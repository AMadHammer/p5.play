<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>__temp_examples/lib/p5.js - p5.play</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/css/lucid.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
	    <img alt="p5.play" src="../../asterisk.png" style="max-height: 65%;" title="p5.play">
            p5.play
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>1.0.0</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/Animation", "classes/Camera", "classes/Group", "classes/p5", "classes/p5.Color", "classes/p5.Element", "classes/p5.Font", "classes/p5.Graphics", "classes/p5.Image", "classes/p5.play", "classes/p5.Renderer", "classes/p5.Table", "classes/p5.TableRow", "classes/p5.Vector", "classes/Sprite", "classes/SpriteSheet", "modules/2D Primitives", "modules/3D Primitives", "modules/Acceleration", "modules/Array Functions", "modules/Attributes", "modules/Calculation", "modules/Camera", "modules/Color", "modules/Constants", "modules/Conversion", "modules/Creating & Reading", "modules/Curves", "modules/Data", "modules/DOM", "modules/Environment", "modules/Events", "modules/Font", "modules/Image", "modules/Input", "modules/IO", "modules/Keyboard", "modules/Lights", "modules/Lights, Camera", "modules/Loading & Displaying", "modules/Material", "modules/Math", "modules/Mouse", "modules/Noise", "modules/Output", "modules/p5.play", "modules/Pixels", "modules/Random", "modules/Rendering", "modules/Setting", "modules/Shape", "modules/String Functions", "modules/Structure", "modules/Table", "modules/Time & Date", "modules/Touch", "modules/Transform", "modules/Trigonometry", "modules/Typography", "modules/Vertex"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
	    <div>
	        <div id="sidebar">
	        <div id="classes">
	            <ul id="api-classes" class="nav nav-list">
	                    <li><a href="../classes/Animation.html">Animation</a></li>
	                    <li><a href="../classes/Camera.html">Camera</a></li>
	                    <li><a href="../classes/Group.html">Group</a></li>
	                    <li><a href="../classes/p5.html">p5</a></li>
	                    <li><a href="../classes/p5.Color.html">p5.Color</a></li>
	                    <li><a href="../classes/p5.Element.html">p5.Element</a></li>
	                    <li><a href="../classes/p5.Font.html">p5.Font</a></li>
	                    <li><a href="../classes/p5.Graphics.html">p5.Graphics</a></li>
	                    <li><a href="../classes/p5.Image.html">p5.Image</a></li>
	                    <li><a href="../classes/p5.play.html">p5.play</a></li>
	                    <li><a href="../classes/p5.Renderer.html">p5.Renderer</a></li>
	                    <li><a href="../classes/p5.Table.html">p5.Table</a></li>
	                    <li><a href="../classes/p5.TableRow.html">p5.TableRow</a></li>
	                    <li><a href="../classes/p5.Vector.html">p5.Vector</a></li>
	                    <li><a href="../classes/Sprite.html">Sprite</a></li>
	                    <li><a href="../classes/SpriteSheet.html">SpriteSheet</a></li>
	            </ul>
	        </div>
	        </div>
	    </div>
        </div>
        <div class="span9">
                <form id="options-form" class="form-inline pull-right">
                    Show:
                    <label for="api-show-inherited" class="checkbox">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected" class="checkbox">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private" class="checkbox">
                        <input type="checkbox" id="api-show-private" checked>
                        Private
                    </label>
                    <label for="api-show-deprecated" class="checkbox">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </form>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <div class="page-header">
                            <h1>__temp_examples/lib/p5.js <small>File</small></h1>
                        </div>
                        
                        <div class="file">
                            <pre class="prettyprint linenums">
                        /*! p5.js v0.4.21 January 22, 2016 */
                        (function(f){if(typeof exports===&quot;object&quot;&amp;&amp;typeof module!==&quot;undefined&quot;){module.exports=f()}else if(typeof define===&quot;function&quot;&amp;&amp;define.amd){define([],f)}else{var g;if(typeof window!==&quot;undefined&quot;){g=window}else if(typeof global!==&quot;undefined&quot;){g=global}else if(typeof self!==&quot;undefined&quot;){g=self}else{g=this}g.p5 = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==&quot;function&quot;&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);var f=new Error(&quot;Cannot find module &#x27;&quot;+o+&quot;&#x27;&quot;);throw f.code=&quot;MODULE_NOT_FOUND&quot;,f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==&quot;function&quot;&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
                        
                        },{}],2:[function(_dereq_,module,exports){
                        // Run-time checking of preconditions.
                        
                        &#x27;use strict&#x27;;
                        
                        // Precondition function that checks if the given predicate is true.
                        // If not, it will throw an error.
                        exports.argument = function(predicate, message) {
                            if (!predicate) {
                                throw new Error(message);
                            }
                        };
                        
                        // Precondition function that checks if the given assertion is true.
                        // If not, it will throw an error.
                        exports.assert = exports.argument;
                        
                        },{}],3:[function(_dereq_,module,exports){
                        // Drawing utility functions.
                        
                        &#x27;use strict&#x27;;
                        
                        // Draw a line on the given context from point &#x60;x1,y1&#x60; to point &#x60;x2,y2&#x60;.
                        function line(ctx, x1, y1, x2, y2) {
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        }
                        
                        exports.line = line;
                        
                        },{}],4:[function(_dereq_,module,exports){
                        // Glyph encoding
                        
                        &#x27;use strict&#x27;;
                        
                        var cffStandardStrings = [
                            &#x27;.notdef&#x27;, &#x27;space&#x27;, &#x27;exclam&#x27;, &#x27;quotedbl&#x27;, &#x27;numbersign&#x27;, &#x27;dollar&#x27;, &#x27;percent&#x27;, &#x27;ampersand&#x27;, &#x27;quoteright&#x27;,
                            &#x27;parenleft&#x27;, &#x27;parenright&#x27;, &#x27;asterisk&#x27;, &#x27;plus&#x27;, &#x27;comma&#x27;, &#x27;hyphen&#x27;, &#x27;period&#x27;, &#x27;slash&#x27;, &#x27;zero&#x27;, &#x27;one&#x27;, &#x27;two&#x27;,
                            &#x27;three&#x27;, &#x27;four&#x27;, &#x27;five&#x27;, &#x27;six&#x27;, &#x27;seven&#x27;, &#x27;eight&#x27;, &#x27;nine&#x27;, &#x27;colon&#x27;, &#x27;semicolon&#x27;, &#x27;less&#x27;, &#x27;equal&#x27;, &#x27;greater&#x27;,
                            &#x27;question&#x27;, &#x27;at&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;,
                            &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;bracketleft&#x27;, &#x27;backslash&#x27;, &#x27;bracketright&#x27;, &#x27;asciicircum&#x27;, &#x27;underscore&#x27;,
                            &#x27;quoteleft&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;,
                            &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;braceleft&#x27;, &#x27;bar&#x27;, &#x27;braceright&#x27;, &#x27;asciitilde&#x27;, &#x27;exclamdown&#x27;, &#x27;cent&#x27;, &#x27;sterling&#x27;,
                            &#x27;fraction&#x27;, &#x27;yen&#x27;, &#x27;florin&#x27;, &#x27;section&#x27;, &#x27;currency&#x27;, &#x27;quotesingle&#x27;, &#x27;quotedblleft&#x27;, &#x27;guillemotleft&#x27;,
                            &#x27;guilsinglleft&#x27;, &#x27;guilsinglright&#x27;, &#x27;fi&#x27;, &#x27;fl&#x27;, &#x27;endash&#x27;, &#x27;dagger&#x27;, &#x27;daggerdbl&#x27;, &#x27;periodcentered&#x27;, &#x27;paragraph&#x27;,
                            &#x27;bullet&#x27;, &#x27;quotesinglbase&#x27;, &#x27;quotedblbase&#x27;, &#x27;quotedblright&#x27;, &#x27;guillemotright&#x27;, &#x27;ellipsis&#x27;, &#x27;perthousand&#x27;,
                            &#x27;questiondown&#x27;, &#x27;grave&#x27;, &#x27;acute&#x27;, &#x27;circumflex&#x27;, &#x27;tilde&#x27;, &#x27;macron&#x27;, &#x27;breve&#x27;, &#x27;dotaccent&#x27;, &#x27;dieresis&#x27;, &#x27;ring&#x27;,
                            &#x27;cedilla&#x27;, &#x27;hungarumlaut&#x27;, &#x27;ogonek&#x27;, &#x27;caron&#x27;, &#x27;emdash&#x27;, &#x27;AE&#x27;, &#x27;ordfeminine&#x27;, &#x27;Lslash&#x27;, &#x27;Oslash&#x27;, &#x27;OE&#x27;,
                            &#x27;ordmasculine&#x27;, &#x27;ae&#x27;, &#x27;dotlessi&#x27;, &#x27;lslash&#x27;, &#x27;oslash&#x27;, &#x27;oe&#x27;, &#x27;germandbls&#x27;, &#x27;onesuperior&#x27;, &#x27;logicalnot&#x27;, &#x27;mu&#x27;,
                            &#x27;trademark&#x27;, &#x27;Eth&#x27;, &#x27;onehalf&#x27;, &#x27;plusminus&#x27;, &#x27;Thorn&#x27;, &#x27;onequarter&#x27;, &#x27;divide&#x27;, &#x27;brokenbar&#x27;, &#x27;degree&#x27;, &#x27;thorn&#x27;,
                            &#x27;threequarters&#x27;, &#x27;twosuperior&#x27;, &#x27;registered&#x27;, &#x27;minus&#x27;, &#x27;eth&#x27;, &#x27;multiply&#x27;, &#x27;threesuperior&#x27;, &#x27;copyright&#x27;,
                            &#x27;Aacute&#x27;, &#x27;Acircumflex&#x27;, &#x27;Adieresis&#x27;, &#x27;Agrave&#x27;, &#x27;Aring&#x27;, &#x27;Atilde&#x27;, &#x27;Ccedilla&#x27;, &#x27;Eacute&#x27;, &#x27;Ecircumflex&#x27;,
                            &#x27;Edieresis&#x27;, &#x27;Egrave&#x27;, &#x27;Iacute&#x27;, &#x27;Icircumflex&#x27;, &#x27;Idieresis&#x27;, &#x27;Igrave&#x27;, &#x27;Ntilde&#x27;, &#x27;Oacute&#x27;, &#x27;Ocircumflex&#x27;,
                            &#x27;Odieresis&#x27;, &#x27;Ograve&#x27;, &#x27;Otilde&#x27;, &#x27;Scaron&#x27;, &#x27;Uacute&#x27;, &#x27;Ucircumflex&#x27;, &#x27;Udieresis&#x27;, &#x27;Ugrave&#x27;, &#x27;Yacute&#x27;,
                            &#x27;Ydieresis&#x27;, &#x27;Zcaron&#x27;, &#x27;aacute&#x27;, &#x27;acircumflex&#x27;, &#x27;adieresis&#x27;, &#x27;agrave&#x27;, &#x27;aring&#x27;, &#x27;atilde&#x27;, &#x27;ccedilla&#x27;, &#x27;eacute&#x27;,
                            &#x27;ecircumflex&#x27;, &#x27;edieresis&#x27;, &#x27;egrave&#x27;, &#x27;iacute&#x27;, &#x27;icircumflex&#x27;, &#x27;idieresis&#x27;, &#x27;igrave&#x27;, &#x27;ntilde&#x27;, &#x27;oacute&#x27;,
                            &#x27;ocircumflex&#x27;, &#x27;odieresis&#x27;, &#x27;ograve&#x27;, &#x27;otilde&#x27;, &#x27;scaron&#x27;, &#x27;uacute&#x27;, &#x27;ucircumflex&#x27;, &#x27;udieresis&#x27;, &#x27;ugrave&#x27;,
                            &#x27;yacute&#x27;, &#x27;ydieresis&#x27;, &#x27;zcaron&#x27;, &#x27;exclamsmall&#x27;, &#x27;Hungarumlautsmall&#x27;, &#x27;dollaroldstyle&#x27;, &#x27;dollarsuperior&#x27;,
                            &#x27;ampersandsmall&#x27;, &#x27;Acutesmall&#x27;, &#x27;parenleftsuperior&#x27;, &#x27;parenrightsuperior&#x27;, &#x27;266 ff&#x27;, &#x27;onedotenleader&#x27;,
                            &#x27;zerooldstyle&#x27;, &#x27;oneoldstyle&#x27;, &#x27;twooldstyle&#x27;, &#x27;threeoldstyle&#x27;, &#x27;fouroldstyle&#x27;, &#x27;fiveoldstyle&#x27;, &#x27;sixoldstyle&#x27;,
                            &#x27;sevenoldstyle&#x27;, &#x27;eightoldstyle&#x27;, &#x27;nineoldstyle&#x27;, &#x27;commasuperior&#x27;, &#x27;threequartersemdash&#x27;, &#x27;periodsuperior&#x27;,
                            &#x27;questionsmall&#x27;, &#x27;asuperior&#x27;, &#x27;bsuperior&#x27;, &#x27;centsuperior&#x27;, &#x27;dsuperior&#x27;, &#x27;esuperior&#x27;, &#x27;isuperior&#x27;, &#x27;lsuperior&#x27;,
                            &#x27;msuperior&#x27;, &#x27;nsuperior&#x27;, &#x27;osuperior&#x27;, &#x27;rsuperior&#x27;, &#x27;ssuperior&#x27;, &#x27;tsuperior&#x27;, &#x27;ff&#x27;, &#x27;ffi&#x27;, &#x27;ffl&#x27;,
                            &#x27;parenleftinferior&#x27;, &#x27;parenrightinferior&#x27;, &#x27;Circumflexsmall&#x27;, &#x27;hyphensuperior&#x27;, &#x27;Gravesmall&#x27;, &#x27;Asmall&#x27;,
                            &#x27;Bsmall&#x27;, &#x27;Csmall&#x27;, &#x27;Dsmall&#x27;, &#x27;Esmall&#x27;, &#x27;Fsmall&#x27;, &#x27;Gsmall&#x27;, &#x27;Hsmall&#x27;, &#x27;Ismall&#x27;, &#x27;Jsmall&#x27;, &#x27;Ksmall&#x27;, &#x27;Lsmall&#x27;,
                            &#x27;Msmall&#x27;, &#x27;Nsmall&#x27;, &#x27;Osmall&#x27;, &#x27;Psmall&#x27;, &#x27;Qsmall&#x27;, &#x27;Rsmall&#x27;, &#x27;Ssmall&#x27;, &#x27;Tsmall&#x27;, &#x27;Usmall&#x27;, &#x27;Vsmall&#x27;, &#x27;Wsmall&#x27;,
                            &#x27;Xsmall&#x27;, &#x27;Ysmall&#x27;, &#x27;Zsmall&#x27;, &#x27;colonmonetary&#x27;, &#x27;onefitted&#x27;, &#x27;rupiah&#x27;, &#x27;Tildesmall&#x27;, &#x27;exclamdownsmall&#x27;,
                            &#x27;centoldstyle&#x27;, &#x27;Lslashsmall&#x27;, &#x27;Scaronsmall&#x27;, &#x27;Zcaronsmall&#x27;, &#x27;Dieresissmall&#x27;, &#x27;Brevesmall&#x27;, &#x27;Caronsmall&#x27;,
                            &#x27;Dotaccentsmall&#x27;, &#x27;Macronsmall&#x27;, &#x27;figuredash&#x27;, &#x27;hypheninferior&#x27;, &#x27;Ogoneksmall&#x27;, &#x27;Ringsmall&#x27;, &#x27;Cedillasmall&#x27;,
                            &#x27;questiondownsmall&#x27;, &#x27;oneeighth&#x27;, &#x27;threeeighths&#x27;, &#x27;fiveeighths&#x27;, &#x27;seveneighths&#x27;, &#x27;onethird&#x27;, &#x27;twothirds&#x27;,
                            &#x27;zerosuperior&#x27;, &#x27;foursuperior&#x27;, &#x27;fivesuperior&#x27;, &#x27;sixsuperior&#x27;, &#x27;sevensuperior&#x27;, &#x27;eightsuperior&#x27;, &#x27;ninesuperior&#x27;,
                            &#x27;zeroinferior&#x27;, &#x27;oneinferior&#x27;, &#x27;twoinferior&#x27;, &#x27;threeinferior&#x27;, &#x27;fourinferior&#x27;, &#x27;fiveinferior&#x27;, &#x27;sixinferior&#x27;,
                            &#x27;seveninferior&#x27;, &#x27;eightinferior&#x27;, &#x27;nineinferior&#x27;, &#x27;centinferior&#x27;, &#x27;dollarinferior&#x27;, &#x27;periodinferior&#x27;,
                            &#x27;commainferior&#x27;, &#x27;Agravesmall&#x27;, &#x27;Aacutesmall&#x27;, &#x27;Acircumflexsmall&#x27;, &#x27;Atildesmall&#x27;, &#x27;Adieresissmall&#x27;,
                            &#x27;Aringsmall&#x27;, &#x27;AEsmall&#x27;, &#x27;Ccedillasmall&#x27;, &#x27;Egravesmall&#x27;, &#x27;Eacutesmall&#x27;, &#x27;Ecircumflexsmall&#x27;, &#x27;Edieresissmall&#x27;,
                            &#x27;Igravesmall&#x27;, &#x27;Iacutesmall&#x27;, &#x27;Icircumflexsmall&#x27;, &#x27;Idieresissmall&#x27;, &#x27;Ethsmall&#x27;, &#x27;Ntildesmall&#x27;, &#x27;Ogravesmall&#x27;,
                            &#x27;Oacutesmall&#x27;, &#x27;Ocircumflexsmall&#x27;, &#x27;Otildesmall&#x27;, &#x27;Odieresissmall&#x27;, &#x27;OEsmall&#x27;, &#x27;Oslashsmall&#x27;, &#x27;Ugravesmall&#x27;,
                            &#x27;Uacutesmall&#x27;, &#x27;Ucircumflexsmall&#x27;, &#x27;Udieresissmall&#x27;, &#x27;Yacutesmall&#x27;, &#x27;Thornsmall&#x27;, &#x27;Ydieresissmall&#x27;, &#x27;001.000&#x27;,
                            &#x27;001.001&#x27;, &#x27;001.002&#x27;, &#x27;001.003&#x27;, &#x27;Black&#x27;, &#x27;Bold&#x27;, &#x27;Book&#x27;, &#x27;Light&#x27;, &#x27;Medium&#x27;, &#x27;Regular&#x27;, &#x27;Roman&#x27;, &#x27;Semibold&#x27;];
                        
                        var cffStandardEncoding = [
                            &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
                            &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;space&#x27;, &#x27;exclam&#x27;, &#x27;quotedbl&#x27;, &#x27;numbersign&#x27;, &#x27;dollar&#x27;, &#x27;percent&#x27;, &#x27;ampersand&#x27;, &#x27;quoteright&#x27;,
                            &#x27;parenleft&#x27;, &#x27;parenright&#x27;, &#x27;asterisk&#x27;, &#x27;plus&#x27;, &#x27;comma&#x27;, &#x27;hyphen&#x27;, &#x27;period&#x27;, &#x27;slash&#x27;, &#x27;zero&#x27;, &#x27;one&#x27;, &#x27;two&#x27;,
                            &#x27;three&#x27;, &#x27;four&#x27;, &#x27;five&#x27;, &#x27;six&#x27;, &#x27;seven&#x27;, &#x27;eight&#x27;, &#x27;nine&#x27;, &#x27;colon&#x27;, &#x27;semicolon&#x27;, &#x27;less&#x27;, &#x27;equal&#x27;, &#x27;greater&#x27;,
                            &#x27;question&#x27;, &#x27;at&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;,
                            &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;bracketleft&#x27;, &#x27;backslash&#x27;, &#x27;bracketright&#x27;, &#x27;asciicircum&#x27;, &#x27;underscore&#x27;,
                            &#x27;quoteleft&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;,
                            &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;braceleft&#x27;, &#x27;bar&#x27;, &#x27;braceright&#x27;, &#x27;asciitilde&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
                            &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
                            &#x27;exclamdown&#x27;, &#x27;cent&#x27;, &#x27;sterling&#x27;, &#x27;fraction&#x27;, &#x27;yen&#x27;, &#x27;florin&#x27;, &#x27;section&#x27;, &#x27;currency&#x27;, &#x27;quotesingle&#x27;,
                            &#x27;quotedblleft&#x27;, &#x27;guillemotleft&#x27;, &#x27;guilsinglleft&#x27;, &#x27;guilsinglright&#x27;, &#x27;fi&#x27;, &#x27;fl&#x27;, &#x27;&#x27;, &#x27;endash&#x27;, &#x27;dagger&#x27;,
                            &#x27;daggerdbl&#x27;, &#x27;periodcentered&#x27;, &#x27;&#x27;, &#x27;paragraph&#x27;, &#x27;bullet&#x27;, &#x27;quotesinglbase&#x27;, &#x27;quotedblbase&#x27;, &#x27;quotedblright&#x27;,
                            &#x27;guillemotright&#x27;, &#x27;ellipsis&#x27;, &#x27;perthousand&#x27;, &#x27;&#x27;, &#x27;questiondown&#x27;, &#x27;&#x27;, &#x27;grave&#x27;, &#x27;acute&#x27;, &#x27;circumflex&#x27;, &#x27;tilde&#x27;,
                            &#x27;macron&#x27;, &#x27;breve&#x27;, &#x27;dotaccent&#x27;, &#x27;dieresis&#x27;, &#x27;&#x27;, &#x27;ring&#x27;, &#x27;cedilla&#x27;, &#x27;&#x27;, &#x27;hungarumlaut&#x27;, &#x27;ogonek&#x27;, &#x27;caron&#x27;,
                            &#x27;emdash&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;AE&#x27;, &#x27;&#x27;, &#x27;ordfeminine&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
                            &#x27;&#x27;, &#x27;Lslash&#x27;, &#x27;Oslash&#x27;, &#x27;OE&#x27;, &#x27;ordmasculine&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;ae&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;dotlessi&#x27;, &#x27;&#x27;, &#x27;&#x27;,
                            &#x27;lslash&#x27;, &#x27;oslash&#x27;, &#x27;oe&#x27;, &#x27;germandbls&#x27;];
                        
                        var cffExpertEncoding = [
                            &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
                            &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;space&#x27;, &#x27;exclamsmall&#x27;, &#x27;Hungarumlautsmall&#x27;, &#x27;&#x27;, &#x27;dollaroldstyle&#x27;, &#x27;dollarsuperior&#x27;,
                            &#x27;ampersandsmall&#x27;, &#x27;Acutesmall&#x27;, &#x27;parenleftsuperior&#x27;, &#x27;parenrightsuperior&#x27;, &#x27;twodotenleader&#x27;, &#x27;onedotenleader&#x27;,
                            &#x27;comma&#x27;, &#x27;hyphen&#x27;, &#x27;period&#x27;, &#x27;fraction&#x27;, &#x27;zerooldstyle&#x27;, &#x27;oneoldstyle&#x27;, &#x27;twooldstyle&#x27;, &#x27;threeoldstyle&#x27;,
                            &#x27;fouroldstyle&#x27;, &#x27;fiveoldstyle&#x27;, &#x27;sixoldstyle&#x27;, &#x27;sevenoldstyle&#x27;, &#x27;eightoldstyle&#x27;, &#x27;nineoldstyle&#x27;, &#x27;colon&#x27;,
                            &#x27;semicolon&#x27;, &#x27;commasuperior&#x27;, &#x27;threequartersemdash&#x27;, &#x27;periodsuperior&#x27;, &#x27;questionsmall&#x27;, &#x27;&#x27;, &#x27;asuperior&#x27;,
                            &#x27;bsuperior&#x27;, &#x27;centsuperior&#x27;, &#x27;dsuperior&#x27;, &#x27;esuperior&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;isuperior&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;lsuperior&#x27;, &#x27;msuperior&#x27;,
                            &#x27;nsuperior&#x27;, &#x27;osuperior&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;rsuperior&#x27;, &#x27;ssuperior&#x27;, &#x27;tsuperior&#x27;, &#x27;&#x27;, &#x27;ff&#x27;, &#x27;fi&#x27;, &#x27;fl&#x27;, &#x27;ffi&#x27;, &#x27;ffl&#x27;,
                            &#x27;parenleftinferior&#x27;, &#x27;&#x27;, &#x27;parenrightinferior&#x27;, &#x27;Circumflexsmall&#x27;, &#x27;hyphensuperior&#x27;, &#x27;Gravesmall&#x27;, &#x27;Asmall&#x27;,
                            &#x27;Bsmall&#x27;, &#x27;Csmall&#x27;, &#x27;Dsmall&#x27;, &#x27;Esmall&#x27;, &#x27;Fsmall&#x27;, &#x27;Gsmall&#x27;, &#x27;Hsmall&#x27;, &#x27;Ismall&#x27;, &#x27;Jsmall&#x27;, &#x27;Ksmall&#x27;, &#x27;Lsmall&#x27;,
                            &#x27;Msmall&#x27;, &#x27;Nsmall&#x27;, &#x27;Osmall&#x27;, &#x27;Psmall&#x27;, &#x27;Qsmall&#x27;, &#x27;Rsmall&#x27;, &#x27;Ssmall&#x27;, &#x27;Tsmall&#x27;, &#x27;Usmall&#x27;, &#x27;Vsmall&#x27;, &#x27;Wsmall&#x27;,
                            &#x27;Xsmall&#x27;, &#x27;Ysmall&#x27;, &#x27;Zsmall&#x27;, &#x27;colonmonetary&#x27;, &#x27;onefitted&#x27;, &#x27;rupiah&#x27;, &#x27;Tildesmall&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
                            &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
                            &#x27;exclamdownsmall&#x27;, &#x27;centoldstyle&#x27;, &#x27;Lslashsmall&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;Scaronsmall&#x27;, &#x27;Zcaronsmall&#x27;, &#x27;Dieresissmall&#x27;,
                            &#x27;Brevesmall&#x27;, &#x27;Caronsmall&#x27;, &#x27;&#x27;, &#x27;Dotaccentsmall&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;Macronsmall&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;figuredash&#x27;, &#x27;hypheninferior&#x27;,
                            &#x27;&#x27;, &#x27;&#x27;, &#x27;Ogoneksmall&#x27;, &#x27;Ringsmall&#x27;, &#x27;Cedillasmall&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;onequarter&#x27;, &#x27;onehalf&#x27;, &#x27;threequarters&#x27;,
                            &#x27;questiondownsmall&#x27;, &#x27;oneeighth&#x27;, &#x27;threeeighths&#x27;, &#x27;fiveeighths&#x27;, &#x27;seveneighths&#x27;, &#x27;onethird&#x27;, &#x27;twothirds&#x27;, &#x27;&#x27;,
                            &#x27;&#x27;, &#x27;zerosuperior&#x27;, &#x27;onesuperior&#x27;, &#x27;twosuperior&#x27;, &#x27;threesuperior&#x27;, &#x27;foursuperior&#x27;, &#x27;fivesuperior&#x27;,
                            &#x27;sixsuperior&#x27;, &#x27;sevensuperior&#x27;, &#x27;eightsuperior&#x27;, &#x27;ninesuperior&#x27;, &#x27;zeroinferior&#x27;, &#x27;oneinferior&#x27;, &#x27;twoinferior&#x27;,
                            &#x27;threeinferior&#x27;, &#x27;fourinferior&#x27;, &#x27;fiveinferior&#x27;, &#x27;sixinferior&#x27;, &#x27;seveninferior&#x27;, &#x27;eightinferior&#x27;,
                            &#x27;nineinferior&#x27;, &#x27;centinferior&#x27;, &#x27;dollarinferior&#x27;, &#x27;periodinferior&#x27;, &#x27;commainferior&#x27;, &#x27;Agravesmall&#x27;,
                            &#x27;Aacutesmall&#x27;, &#x27;Acircumflexsmall&#x27;, &#x27;Atildesmall&#x27;, &#x27;Adieresissmall&#x27;, &#x27;Aringsmall&#x27;, &#x27;AEsmall&#x27;, &#x27;Ccedillasmall&#x27;,
                            &#x27;Egravesmall&#x27;, &#x27;Eacutesmall&#x27;, &#x27;Ecircumflexsmall&#x27;, &#x27;Edieresissmall&#x27;, &#x27;Igravesmall&#x27;, &#x27;Iacutesmall&#x27;,
                            &#x27;Icircumflexsmall&#x27;, &#x27;Idieresissmall&#x27;, &#x27;Ethsmall&#x27;, &#x27;Ntildesmall&#x27;, &#x27;Ogravesmall&#x27;, &#x27;Oacutesmall&#x27;,
                            &#x27;Ocircumflexsmall&#x27;, &#x27;Otildesmall&#x27;, &#x27;Odieresissmall&#x27;, &#x27;OEsmall&#x27;, &#x27;Oslashsmall&#x27;, &#x27;Ugravesmall&#x27;, &#x27;Uacutesmall&#x27;,
                            &#x27;Ucircumflexsmall&#x27;, &#x27;Udieresissmall&#x27;, &#x27;Yacutesmall&#x27;, &#x27;Thornsmall&#x27;, &#x27;Ydieresissmall&#x27;];
                        
                        var standardNames = [
                            &#x27;.notdef&#x27;, &#x27;.null&#x27;, &#x27;nonmarkingreturn&#x27;, &#x27;space&#x27;, &#x27;exclam&#x27;, &#x27;quotedbl&#x27;, &#x27;numbersign&#x27;, &#x27;dollar&#x27;, &#x27;percent&#x27;,
                            &#x27;ampersand&#x27;, &#x27;quotesingle&#x27;, &#x27;parenleft&#x27;, &#x27;parenright&#x27;, &#x27;asterisk&#x27;, &#x27;plus&#x27;, &#x27;comma&#x27;, &#x27;hyphen&#x27;, &#x27;period&#x27;, &#x27;slash&#x27;,
                            &#x27;zero&#x27;, &#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;, &#x27;five&#x27;, &#x27;six&#x27;, &#x27;seven&#x27;, &#x27;eight&#x27;, &#x27;nine&#x27;, &#x27;colon&#x27;, &#x27;semicolon&#x27;, &#x27;less&#x27;,
                            &#x27;equal&#x27;, &#x27;greater&#x27;, &#x27;question&#x27;, &#x27;at&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;,
                            &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;bracketleft&#x27;, &#x27;backslash&#x27;, &#x27;bracketright&#x27;,
                            &#x27;asciicircum&#x27;, &#x27;underscore&#x27;, &#x27;grave&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;,
                            &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;braceleft&#x27;, &#x27;bar&#x27;, &#x27;braceright&#x27;, &#x27;asciitilde&#x27;,
                            &#x27;Adieresis&#x27;, &#x27;Aring&#x27;, &#x27;Ccedilla&#x27;, &#x27;Eacute&#x27;, &#x27;Ntilde&#x27;, &#x27;Odieresis&#x27;, &#x27;Udieresis&#x27;, &#x27;aacute&#x27;, &#x27;agrave&#x27;,
                            &#x27;acircumflex&#x27;, &#x27;adieresis&#x27;, &#x27;atilde&#x27;, &#x27;aring&#x27;, &#x27;ccedilla&#x27;, &#x27;eacute&#x27;, &#x27;egrave&#x27;, &#x27;ecircumflex&#x27;, &#x27;edieresis&#x27;,
                            &#x27;iacute&#x27;, &#x27;igrave&#x27;, &#x27;icircumflex&#x27;, &#x27;idieresis&#x27;, &#x27;ntilde&#x27;, &#x27;oacute&#x27;, &#x27;ograve&#x27;, &#x27;ocircumflex&#x27;, &#x27;odieresis&#x27;,
                            &#x27;otilde&#x27;, &#x27;uacute&#x27;, &#x27;ugrave&#x27;, &#x27;ucircumflex&#x27;, &#x27;udieresis&#x27;, &#x27;dagger&#x27;, &#x27;degree&#x27;, &#x27;cent&#x27;, &#x27;sterling&#x27;, &#x27;section&#x27;,
                            &#x27;bullet&#x27;, &#x27;paragraph&#x27;, &#x27;germandbls&#x27;, &#x27;registered&#x27;, &#x27;copyright&#x27;, &#x27;trademark&#x27;, &#x27;acute&#x27;, &#x27;dieresis&#x27;, &#x27;notequal&#x27;,
                            &#x27;AE&#x27;, &#x27;Oslash&#x27;, &#x27;infinity&#x27;, &#x27;plusminus&#x27;, &#x27;lessequal&#x27;, &#x27;greaterequal&#x27;, &#x27;yen&#x27;, &#x27;mu&#x27;, &#x27;partialdiff&#x27;, &#x27;summation&#x27;,
                            &#x27;product&#x27;, &#x27;pi&#x27;, &#x27;integral&#x27;, &#x27;ordfeminine&#x27;, &#x27;ordmasculine&#x27;, &#x27;Omega&#x27;, &#x27;ae&#x27;, &#x27;oslash&#x27;, &#x27;questiondown&#x27;,
                            &#x27;exclamdown&#x27;, &#x27;logicalnot&#x27;, &#x27;radical&#x27;, &#x27;florin&#x27;, &#x27;approxequal&#x27;, &#x27;Delta&#x27;, &#x27;guillemotleft&#x27;, &#x27;guillemotright&#x27;,
                            &#x27;ellipsis&#x27;, &#x27;nonbreakingspace&#x27;, &#x27;Agrave&#x27;, &#x27;Atilde&#x27;, &#x27;Otilde&#x27;, &#x27;OE&#x27;, &#x27;oe&#x27;, &#x27;endash&#x27;, &#x27;emdash&#x27;, &#x27;quotedblleft&#x27;,
                            &#x27;quotedblright&#x27;, &#x27;quoteleft&#x27;, &#x27;quoteright&#x27;, &#x27;divide&#x27;, &#x27;lozenge&#x27;, &#x27;ydieresis&#x27;, &#x27;Ydieresis&#x27;, &#x27;fraction&#x27;,
                            &#x27;currency&#x27;, &#x27;guilsinglleft&#x27;, &#x27;guilsinglright&#x27;, &#x27;fi&#x27;, &#x27;fl&#x27;, &#x27;daggerdbl&#x27;, &#x27;periodcentered&#x27;, &#x27;quotesinglbase&#x27;,
                            &#x27;quotedblbase&#x27;, &#x27;perthousand&#x27;, &#x27;Acircumflex&#x27;, &#x27;Ecircumflex&#x27;, &#x27;Aacute&#x27;, &#x27;Edieresis&#x27;, &#x27;Egrave&#x27;, &#x27;Iacute&#x27;,
                            &#x27;Icircumflex&#x27;, &#x27;Idieresis&#x27;, &#x27;Igrave&#x27;, &#x27;Oacute&#x27;, &#x27;Ocircumflex&#x27;, &#x27;apple&#x27;, &#x27;Ograve&#x27;, &#x27;Uacute&#x27;, &#x27;Ucircumflex&#x27;,
                            &#x27;Ugrave&#x27;, &#x27;dotlessi&#x27;, &#x27;circumflex&#x27;, &#x27;tilde&#x27;, &#x27;macron&#x27;, &#x27;breve&#x27;, &#x27;dotaccent&#x27;, &#x27;ring&#x27;, &#x27;cedilla&#x27;, &#x27;hungarumlaut&#x27;,
                            &#x27;ogonek&#x27;, &#x27;caron&#x27;, &#x27;Lslash&#x27;, &#x27;lslash&#x27;, &#x27;Scaron&#x27;, &#x27;scaron&#x27;, &#x27;Zcaron&#x27;, &#x27;zcaron&#x27;, &#x27;brokenbar&#x27;, &#x27;Eth&#x27;, &#x27;eth&#x27;,
                            &#x27;Yacute&#x27;, &#x27;yacute&#x27;, &#x27;Thorn&#x27;, &#x27;thorn&#x27;, &#x27;minus&#x27;, &#x27;multiply&#x27;, &#x27;onesuperior&#x27;, &#x27;twosuperior&#x27;, &#x27;threesuperior&#x27;,
                            &#x27;onehalf&#x27;, &#x27;onequarter&#x27;, &#x27;threequarters&#x27;, &#x27;franc&#x27;, &#x27;Gbreve&#x27;, &#x27;gbreve&#x27;, &#x27;Idotaccent&#x27;, &#x27;Scedilla&#x27;, &#x27;scedilla&#x27;,
                            &#x27;Cacute&#x27;, &#x27;cacute&#x27;, &#x27;Ccaron&#x27;, &#x27;ccaron&#x27;, &#x27;dcroat&#x27;];
                        
                        // This is the encoding used for fonts created from scratch.
                        // It loops through all glyphs and finds the appropriate unicode value.
                        // Since it&#x27;s linear time, other encodings will be faster.
                        function DefaultEncoding(font) {
                            this.font = font;
                        }
                        
                        DefaultEncoding.prototype.charToGlyphIndex = function(c) {
                            var code = c.charCodeAt(0);
                            var glyphs = this.font.glyphs;
                            if (glyphs) {
                                for (var i = 0; i &lt; glyphs.length; i += 1) {
                                    var glyph = glyphs.get(i);
                                    for (var j = 0; j &lt; glyph.unicodes.length; j += 1) {
                                        if (glyph.unicodes[j] === code) {
                                            return i;
                                        }
                                    }
                                }
                            } else {
                                return null;
                            }
                        };
                        
                        function CmapEncoding(cmap) {
                            this.cmap = cmap;
                        }
                        
                        CmapEncoding.prototype.charToGlyphIndex = function(c) {
                            return this.cmap.glyphIndexMap[c.charCodeAt(0)] || 0;
                        };
                        
                        function CffEncoding(encoding, charset) {
                            this.encoding = encoding;
                            this.charset = charset;
                        }
                        
                        CffEncoding.prototype.charToGlyphIndex = function(s) {
                            var code = s.charCodeAt(0);
                            var charName = this.encoding[code];
                            return this.charset.indexOf(charName);
                        };
                        
                        function GlyphNames(post) {
                            var i;
                            switch (post.version) {
                            case 1:
                                this.names = exports.standardNames.slice();
                                break;
                            case 2:
                                this.names = new Array(post.numberOfGlyphs);
                                for (i = 0; i &lt; post.numberOfGlyphs; i++) {
                                    if (post.glyphNameIndex[i] &lt; exports.standardNames.length) {
                                        this.names[i] = exports.standardNames[post.glyphNameIndex[i]];
                                    } else {
                                        this.names[i] = post.names[post.glyphNameIndex[i] - exports.standardNames.length];
                                    }
                                }
                        
                                break;
                            case 2.5:
                                this.names = new Array(post.numberOfGlyphs);
                                for (i = 0; i &lt; post.numberOfGlyphs; i++) {
                                    this.names[i] = exports.standardNames[i + post.glyphNameIndex[i]];
                                }
                        
                                break;
                            case 3:
                                this.names = [];
                                break;
                            }
                        }
                        
                        GlyphNames.prototype.nameToGlyphIndex = function(name) {
                            return this.names.indexOf(name);
                        };
                        
                        GlyphNames.prototype.glyphIndexToName = function(gid) {
                            return this.names[gid];
                        };
                        
                        function addGlyphNames(font) {
                            var glyph;
                            var glyphIndexMap = font.tables.cmap.glyphIndexMap;
                            var charCodes = Object.keys(glyphIndexMap);
                        
                            for (var i = 0; i &lt; charCodes.length; i += 1) {
                                var c = charCodes[i];
                                var glyphIndex = glyphIndexMap[c];
                                glyph = font.glyphs.get(glyphIndex);
                                glyph.addUnicode(parseInt(c));
                            }
                        
                            for (i = 0; i &lt; font.glyphs.length; i += 1) {
                                glyph = font.glyphs.get(i);
                                if (font.cffEncoding) {
                                    glyph.name = font.cffEncoding.charset[i];
                                } else {
                                    glyph.name = font.glyphNames.glyphIndexToName(i);
                                }
                            }
                        }
                        
                        exports.cffStandardStrings = cffStandardStrings;
                        exports.cffStandardEncoding = cffStandardEncoding;
                        exports.cffExpertEncoding = cffExpertEncoding;
                        exports.standardNames = standardNames;
                        exports.DefaultEncoding = DefaultEncoding;
                        exports.CmapEncoding = CmapEncoding;
                        exports.CffEncoding = CffEncoding;
                        exports.GlyphNames = GlyphNames;
                        exports.addGlyphNames = addGlyphNames;
                        
                        },{}],5:[function(_dereq_,module,exports){
                        // The Font object
                        
                        &#x27;use strict&#x27;;
                        
                        var path = _dereq_(&#x27;./path&#x27;);
                        var sfnt = _dereq_(&#x27;./tables/sfnt&#x27;);
                        var encoding = _dereq_(&#x27;./encoding&#x27;);
                        var glyphset = _dereq_(&#x27;./glyphset&#x27;);
                        
                        // A Font represents a loaded OpenType font file.
                        // It contains a set of glyphs and methods to draw text on a drawing context,
                        // or to get a path representing the text.
                        function Font(options) {
                            options = options || {};
                        
                            // OS X will complain if the names are empty, so we put a single space everywhere by default.
                            this.familyName = options.familyName || &#x27; &#x27;;
                            this.styleName = options.styleName || &#x27; &#x27;;
                            this.designer = options.designer || &#x27; &#x27;;
                            this.designerURL = options.designerURL || &#x27; &#x27;;
                            this.manufacturer = options.manufacturer || &#x27; &#x27;;
                            this.manufacturerURL = options.manufacturerURL || &#x27; &#x27;;
                            this.license = options.license || &#x27; &#x27;;
                            this.licenseURL = options.licenseURL || &#x27; &#x27;;
                            this.version = options.version || &#x27;Version 0.1&#x27;;
                            this.description = options.description || &#x27; &#x27;;
                            this.copyright = options.copyright || &#x27; &#x27;;
                            this.trademark = options.trademark || &#x27; &#x27;;
                            this.unitsPerEm = options.unitsPerEm || 1000;
                            this.ascender = options.ascender;
                            this.descender = options.descender;
                            this.supported = true;
                            this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);
                            this.encoding = new encoding.DefaultEncoding(this);
                            this.tables = {};
                        }
                        
                        // Check if the font has a glyph for the given character.
                        Font.prototype.hasChar = function(c) {
                            return this.encoding.charToGlyphIndex(c) !== null;
                        };
                        
                        // Convert the given character to a single glyph index.
                        // Note that this function assumes that there is a one-to-one mapping between
                        // the given character and a glyph; for complex scripts this might not be the case.
                        Font.prototype.charToGlyphIndex = function(s) {
                            return this.encoding.charToGlyphIndex(s);
                        };
                        
                        // Convert the given character to a single Glyph object.
                        // Note that this function assumes that there is a one-to-one mapping between
                        // the given character and a glyph; for complex scripts this might not be the case.
                        Font.prototype.charToGlyph = function(c) {
                            var glyphIndex = this.charToGlyphIndex(c);
                            var glyph = this.glyphs.get(glyphIndex);
                            if (!glyph) {
                                // .notdef
                                glyph = this.glyphs.get(0);
                            }
                        
                            return glyph;
                        };
                        
                        // Convert the given text to a list of Glyph objects.
                        // Note that there is no strict one-to-one mapping between characters and
                        // glyphs, so the list of returned glyphs can be larger or smaller than the
                        // length of the given string.
                        Font.prototype.stringToGlyphs = function(s) {
                            var glyphs = [];
                            for (var i = 0; i &lt; s.length; i += 1) {
                                var c = s[i];
                                glyphs.push(this.charToGlyph(c));
                            }
                        
                            return glyphs;
                        };
                        
                        Font.prototype.nameToGlyphIndex = function(name) {
                            return this.glyphNames.nameToGlyphIndex(name);
                        };
                        
                        Font.prototype.nameToGlyph = function(name) {
                            var glyphIndex = this.nametoGlyphIndex(name);
                            var glyph = this.glyphs.get(glyphIndex);
                            if (!glyph) {
                                // .notdef
                                glyph = this.glyphs.get(0);
                            }
                        
                            return glyph;
                        };
                        
                        Font.prototype.glyphIndexToName = function(gid) {
                            if (!this.glyphNames.glyphIndexToName) {
                                return &#x27;&#x27;;
                            }
                        
                            return this.glyphNames.glyphIndexToName(gid);
                        };
                        
                        // Retrieve the value of the kerning pair between the left glyph (or its index)
                        // and the right glyph (or its index). If no kerning pair is found, return 0.
                        // The kerning value gets added to the advance width when calculating the spacing
                        // between glyphs.
                        Font.prototype.getKerningValue = function(leftGlyph, rightGlyph) {
                            leftGlyph = leftGlyph.index || leftGlyph;
                            rightGlyph = rightGlyph.index || rightGlyph;
                            var gposKerning = this.getGposKerningValue;
                            return gposKerning ? gposKerning(leftGlyph, rightGlyph) :
                                (this.kerningPairs[leftGlyph + &#x27;,&#x27; + rightGlyph] || 0);
                        };
                        
                        // Helper function that invokes the given callback for each glyph in the given text.
                        // The callback gets &#x60;(glyph, x, y, fontSize, options)&#x60;.
                        Font.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {
                            if (!this.supported) {
                                return;
                            }
                        
                            x = x !== undefined ? x : 0;
                            y = y !== undefined ? y : 0;
                            fontSize = fontSize !== undefined ? fontSize : 72;
                            options = options || {};
                            var kerning = options.kerning === undefined ? true : options.kerning;
                            var fontScale = 1 / this.unitsPerEm * fontSize;
                            var glyphs = this.stringToGlyphs(text);
                            for (var i = 0; i &lt; glyphs.length; i += 1) {
                                var glyph = glyphs[i];
                                callback(glyph, x, y, fontSize, options);
                                if (glyph.advanceWidth) {
                                    x += glyph.advanceWidth * fontScale;
                                }
                        
                                if (kerning &amp;&amp; i &lt; glyphs.length - 1) {
                                    var kerningValue = this.getKerningValue(glyph, glyphs[i + 1]);
                                    x += kerningValue * fontScale;
                                }
                            }
                        };
                        
                        // Create a Path object that represents the given text.
                        //
                        // text - The text to create.
                        // x - Horizontal position of the beginning of the text. (default: 0)
                        // y - Vertical position of the *baseline* of the text. (default: 0)
                        // fontSize - Font size in pixels. We scale the glyph units by &#x60;1 / unitsPerEm * fontSize&#x60;. (default: 72)
                        // Options is an optional object that contains:
                        // - kerning - Whether to take kerning information into account. (default: true)
                        //
                        // Returns a Path object.
                        Font.prototype.getPath = function(text, x, y, fontSize, options) {
                            var fullPath = new path.Path();
                            this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
                                var glyphPath = glyph.getPath(gX, gY, gFontSize);
                                fullPath.extend(glyphPath);
                            });
                        
                            return fullPath;
                        };
                        
                        // Draw the text on the given drawing context.
                        //
                        // ctx - A 2D drawing context, like Canvas.
                        // text - The text to create.
                        // x - Horizontal position of the beginning of the text. (default: 0)
                        // y - Vertical position of the *baseline* of the text. (default: 0)
                        // fontSize - Font size in pixels. We scale the glyph units by &#x60;1 / unitsPerEm * fontSize&#x60;. (default: 72)
                        // Options is an optional object that contains:
                        // - kerning - Whether to take kerning information into account. (default: true)
                        Font.prototype.draw = function(ctx, text, x, y, fontSize, options) {
                            this.getPath(text, x, y, fontSize, options).draw(ctx);
                        };
                        
                        // Draw the points of all glyphs in the text.
                        // On-curve points will be drawn in blue, off-curve points will be drawn in red.
                        //
                        // ctx - A 2D drawing context, like Canvas.
                        // text - The text to create.
                        // x - Horizontal position of the beginning of the text. (default: 0)
                        // y - Vertical position of the *baseline* of the text. (default: 0)
                        // fontSize - Font size in pixels. We scale the glyph units by &#x60;1 / unitsPerEm * fontSize&#x60;. (default: 72)
                        // Options is an optional object that contains:
                        // - kerning - Whether to take kerning information into account. (default: true)
                        Font.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {
                            this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
                                glyph.drawPoints(ctx, gX, gY, gFontSize);
                            });
                        };
                        
                        // Draw lines indicating important font measurements for all glyphs in the text.
                        // Black lines indicate the origin of the coordinate system (point 0,0).
                        // Blue lines indicate the glyph bounding box.
                        // Green line indicates the advance width of the glyph.
                        //
                        // ctx - A 2D drawing context, like Canvas.
                        // text - The text to create.
                        // x - Horizontal position of the beginning of the text. (default: 0)
                        // y - Vertical position of the *baseline* of the text. (default: 0)
                        // fontSize - Font size in pixels. We scale the glyph units by &#x60;1 / unitsPerEm * fontSize&#x60;. (default: 72)
                        // Options is an optional object that contains:
                        // - kerning - Whether to take kerning information into account. (default: true)
                        Font.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {
                            this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
                                glyph.drawMetrics(ctx, gX, gY, gFontSize);
                            });
                        };
                        
                        // Validate
                        Font.prototype.validate = function() {
                            var warnings = [];
                            var _this = this;
                        
                            function assert(predicate, message) {
                                if (!predicate) {
                                    warnings.push(message);
                                }
                            }
                        
                            function assertStringAttribute(attrName) {
                                assert(_this[attrName] &amp;&amp; _this[attrName].trim().length &gt; 0, &#x27;No &#x27; + attrName + &#x27; specified.&#x27;);
                            }
                        
                            // Identification information
                            assertStringAttribute(&#x27;familyName&#x27;);
                            assertStringAttribute(&#x27;weightName&#x27;);
                            assertStringAttribute(&#x27;manufacturer&#x27;);
                            assertStringAttribute(&#x27;copyright&#x27;);
                            assertStringAttribute(&#x27;version&#x27;);
                        
                            // Dimension information
                            assert(this.unitsPerEm &gt; 0, &#x27;No unitsPerEm specified.&#x27;);
                        };
                        
                        // Convert the font object to a SFNT data structure.
                        // This structure contains all the necessary tables and metadata to create a binary OTF file.
                        Font.prototype.toTables = function() {
                            return sfnt.fontToTable(this);
                        };
                        
                        Font.prototype.toBuffer = function() {
                            var sfntTable = this.toTables();
                            var bytes = sfntTable.encode();
                            var buffer = new ArrayBuffer(bytes.length);
                            var intArray = new Uint8Array(buffer);
                            for (var i = 0; i &lt; bytes.length; i++) {
                                intArray[i] = bytes[i];
                            }
                        
                            return buffer;
                        };
                        
                        // Initiate a download of the OpenType font.
                        Font.prototype.download = function() {
                            var fileName = this.familyName.replace(/\s/g, &#x27;&#x27;) + &#x27;-&#x27; + this.styleName + &#x27;.otf&#x27;;
                            var buffer = this.toBuffer();
                        
                            window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
                            window.requestFileSystem(window.TEMPORARY, buffer.byteLength, function(fs) {
                                fs.root.getFile(fileName, {create: true}, function(fileEntry) {
                                    fileEntry.createWriter(function(writer) {
                                        var dataView = new DataView(buffer);
                                        var blob = new Blob([dataView], {type: &#x27;font/opentype&#x27;});
                                        writer.write(blob);
                        
                                        writer.addEventListener(&#x27;writeend&#x27;, function() {
                                            // Navigating to the file will download it.
                                            location.href = fileEntry.toURL();
                                        }, false);
                                    });
                                });
                            },
                        
                            function(err) {
                                throw err;
                            });
                        };
                        
                        exports.Font = Font;
                        
                        },{&quot;./encoding&quot;:4,&quot;./glyphset&quot;:7,&quot;./path&quot;:10,&quot;./tables/sfnt&quot;:25}],6:[function(_dereq_,module,exports){
                        // The Glyph object
                        
                        &#x27;use strict&#x27;;
                        
                        var check = _dereq_(&#x27;./check&#x27;);
                        var draw = _dereq_(&#x27;./draw&#x27;);
                        var path = _dereq_(&#x27;./path&#x27;);
                        
                        function getPathDefinition(glyph, path) {
                            var _path = path || { commands: [] };
                            return {
                                configurable: true,
                        
                                get: function() {
                                    if (typeof _path === &#x27;function&#x27;) {
                                        _path = _path();
                                    }
                        
                                    return _path;
                                },
                        
                                set: function(p) {
                                    _path = p;
                                }
                            };
                        }
                        
                        // A Glyph is an individual mark that often corresponds to a character.
                        // Some glyphs, such as ligatures, are a combination of many characters.
                        // Glyphs are the basic building blocks of a font.
                        //
                        // The &#x60;Glyph&#x60; class contains utility methods for drawing the path and its points.
                        function Glyph(options) {
                            // By putting all the code on a prototype function (which is only declared once)
                            // we reduce the memory requirements for larger fonts by some 2%
                            this.bindConstructorValues(options);
                        }
                        
                        Glyph.prototype.bindConstructorValues = function(options) {
                            this.index = options.index || 0;
                        
                            // These three values cannnot be deferred for memory optimization:
                            this.name = options.name || null;
                            this.unicode = options.unicode || undefined;
                            this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];
                        
                            // But by binding these values only when necessary, we reduce can
                            // the memory requirements by almost 3% for larger fonts.
                            if (options.xMin) {
                                this.xMin = options.xMin;
                            }
                        
                            if (options.yMin) {
                                this.yMin = options.yMin;
                            }
                        
                            if (options.xMax) {
                                this.xMax = options.xMax;
                            }
                        
                            if (options.yMax) {
                                this.yMax = options.yMax;
                            }
                        
                            if (options.advanceWidth) {
                                this.advanceWidth = options.advanceWidth;
                            }
                        
                            // The path for a glyph is the most memory intensive, and is bound as a value
                            // with a getter/setter to ensure we actually do path parsing only once the
                            // path is actually needed by anything.
                            Object.defineProperty(this, &#x27;path&#x27;, getPathDefinition(this, options.path));
                        };
                        
                        Glyph.prototype.addUnicode = function(unicode) {
                            if (this.unicodes.length === 0) {
                                this.unicode = unicode;
                            }
                        
                            this.unicodes.push(unicode);
                        };
                        
                        // Convert the glyph to a Path we can draw on a drawing context.
                        //
                        // x - Horizontal position of the glyph. (default: 0)
                        // y - Vertical position of the *baseline* of the glyph. (default: 0)
                        // fontSize - Font size, in pixels (default: 72).
                        Glyph.prototype.getPath = function(x, y, fontSize) {
                            x = x !== undefined ? x : 0;
                            y = y !== undefined ? y : 0;
                            fontSize = fontSize !== undefined ? fontSize : 72;
                            var scale = 1 / this.path.unitsPerEm * fontSize;
                            var p = new path.Path();
                            var commands = this.path.commands;
                            for (var i = 0; i &lt; commands.length; i += 1) {
                                var cmd = commands[i];
                                if (cmd.type === &#x27;M&#x27;) {
                                    p.moveTo(x + (cmd.x * scale), y + (-cmd.y * scale));
                                } else if (cmd.type === &#x27;L&#x27;) {
                                    p.lineTo(x + (cmd.x * scale), y + (-cmd.y * scale));
                                } else if (cmd.type === &#x27;Q&#x27;) {
                                    p.quadraticCurveTo(x + (cmd.x1 * scale), y + (-cmd.y1 * scale),
                                                       x + (cmd.x * scale), y + (-cmd.y * scale));
                                } else if (cmd.type === &#x27;C&#x27;) {
                                    p.curveTo(x + (cmd.x1 * scale), y + (-cmd.y1 * scale),
                                              x + (cmd.x2 * scale), y + (-cmd.y2 * scale),
                                              x + (cmd.x * scale), y + (-cmd.y * scale));
                                } else if (cmd.type === &#x27;Z&#x27;) {
                                    p.closePath();
                                }
                            }
                        
                            return p;
                        };
                        
                        // Split the glyph into contours.
                        // This function is here for backwards compatibility, and to
                        // provide raw access to the TrueType glyph outlines.
                        Glyph.prototype.getContours = function() {
                            if (this.points === undefined) {
                                return [];
                            }
                        
                            var contours = [];
                            var currentContour = [];
                            for (var i = 0; i &lt; this.points.length; i += 1) {
                                var pt = this.points[i];
                                currentContour.push(pt);
                                if (pt.lastPointOfContour) {
                                    contours.push(currentContour);
                                    currentContour = [];
                                }
                            }
                        
                            check.argument(currentContour.length === 0, &#x27;There are still points left in the current contour.&#x27;);
                            return contours;
                        };
                        
                        // Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.
                        Glyph.prototype.getMetrics = function() {
                            var commands = this.path.commands;
                            var xCoords = [];
                            var yCoords = [];
                            for (var i = 0; i &lt; commands.length; i += 1) {
                                var cmd = commands[i];
                                if (cmd.type !== &#x27;Z&#x27;) {
                                    xCoords.push(cmd.x);
                                    yCoords.push(cmd.y);
                                }
                        
                                if (cmd.type === &#x27;Q&#x27; || cmd.type === &#x27;C&#x27;) {
                                    xCoords.push(cmd.x1);
                                    yCoords.push(cmd.y1);
                                }
                        
                                if (cmd.type === &#x27;C&#x27;) {
                                    xCoords.push(cmd.x2);
                                    yCoords.push(cmd.y2);
                                }
                            }
                        
                            var metrics = {
                                xMin: Math.min.apply(null, xCoords),
                                yMin: Math.min.apply(null, yCoords),
                                xMax: Math.max.apply(null, xCoords),
                                yMax: Math.max.apply(null, yCoords),
                                leftSideBearing: 0
                            };
                            metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
                            return metrics;
                        };
                        
                        // Draw the glyph on the given context.
                        //
                        // ctx - The drawing context.
                        // x - Horizontal position of the glyph. (default: 0)
                        // y - Vertical position of the *baseline* of the glyph. (default: 0)
                        // fontSize - Font size, in pixels (default: 72).
                        Glyph.prototype.draw = function(ctx, x, y, fontSize) {
                            this.getPath(x, y, fontSize).draw(ctx);
                        };
                        
                        // Draw the points of the glyph.
                        // On-curve points will be drawn in blue, off-curve points will be drawn in red.
                        //
                        // ctx - The drawing context.
                        // x - Horizontal position of the glyph. (default: 0)
                        // y - Vertical position of the *baseline* of the glyph. (default: 0)
                        // fontSize - Font size, in pixels (default: 72).
                        Glyph.prototype.drawPoints = function(ctx, x, y, fontSize) {
                        
                            function drawCircles(l, x, y, scale) {
                                var PI_SQ = Math.PI * 2;
                                ctx.beginPath();
                                for (var j = 0; j &lt; l.length; j += 1) {
                                    ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));
                                    ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, PI_SQ, false);
                                }
                        
                                ctx.closePath();
                                ctx.fill();
                            }
                        
                            x = x !== undefined ? x : 0;
                            y = y !== undefined ? y : 0;
                            fontSize = fontSize !== undefined ? fontSize : 24;
                            var scale = 1 / this.path.unitsPerEm * fontSize;
                        
                            var blueCircles = [];
                            var redCircles = [];
                            var path = this.path;
                            for (var i = 0; i &lt; path.commands.length; i += 1) {
                                var cmd = path.commands[i];
                                if (cmd.x !== undefined) {
                                    blueCircles.push({x: cmd.x, y: -cmd.y});
                                }
                        
                                if (cmd.x1 !== undefined) {
                                    redCircles.push({x: cmd.x1, y: -cmd.y1});
                                }
                        
                                if (cmd.x2 !== undefined) {
                                    redCircles.push({x: cmd.x2, y: -cmd.y2});
                                }
                            }
                        
                            ctx.fillStyle = &#x27;blue&#x27;;
                            drawCircles(blueCircles, x, y, scale);
                            ctx.fillStyle = &#x27;red&#x27;;
                            drawCircles(redCircles, x, y, scale);
                        };
                        
                        // Draw lines indicating important font measurements.
                        // Black lines indicate the origin of the coordinate system (point 0,0).
                        // Blue lines indicate the glyph bounding box.
                        // Green line indicates the advance width of the glyph.
                        //
                        // ctx - The drawing context.
                        // x - Horizontal position of the glyph. (default: 0)
                        // y - Vertical position of the *baseline* of the glyph. (default: 0)
                        // fontSize - Font size, in pixels (default: 72).
                        Glyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {
                            var scale;
                            x = x !== undefined ? x : 0;
                            y = y !== undefined ? y : 0;
                            fontSize = fontSize !== undefined ? fontSize : 24;
                            scale = 1 / this.path.unitsPerEm * fontSize;
                            ctx.lineWidth = 1;
                        
                            // Draw the origin
                            ctx.strokeStyle = &#x27;black&#x27;;
                            draw.line(ctx, x, -10000, x, 10000);
                            draw.line(ctx, -10000, y, 10000, y);
                        
                            // This code is here due to memory optimization: by not using
                            // defaults in the constructor, we save a notable amount of memory.
                            var xMin = this.xMin || 0;
                            var yMin = this.yMin || 0;
                            var xMax = this.xMax || 0;
                            var yMax = this.yMax || 0;
                            var advanceWidth = this.advanceWidth || 0;
                        
                            // Draw the glyph box
                            ctx.strokeStyle = &#x27;blue&#x27;;
                            draw.line(ctx, x + (xMin * scale), -10000, x + (xMin * scale), 10000);
                            draw.line(ctx, x + (xMax * scale), -10000, x + (xMax * scale), 10000);
                            draw.line(ctx, -10000, y + (-yMin * scale), 10000, y + (-yMin * scale));
                            draw.line(ctx, -10000, y + (-yMax * scale), 10000, y + (-yMax * scale));
                        
                            // Draw the advance width
                            ctx.strokeStyle = &#x27;green&#x27;;
                            draw.line(ctx, x + (advanceWidth * scale), -10000, x + (advanceWidth * scale), 10000);
                        };
                        
                        exports.Glyph = Glyph;
                        
                        },{&quot;./check&quot;:2,&quot;./draw&quot;:3,&quot;./path&quot;:10}],7:[function(_dereq_,module,exports){
                        // The GlyphSet object
                        
                        &#x27;use strict&#x27;;
                        
                        var _glyph = _dereq_(&#x27;./glyph&#x27;);
                        
                        // A GlyphSet represents all glyphs available in the font, but modelled using
                        // a deferred glyph loader, for retrieving glyphs only once they are absolutely
                        // necessary, to keep the memory footprint down.
                        function GlyphSet(font, glyphs) {
                            this.font = font;
                            this.glyphs = {};
                            if (Array.isArray(glyphs)) {
                                for (var i = 0; i &lt; glyphs.length; i++) {
                                    this.glyphs[i] = glyphs[i];
                                }
                            }
                        
                            this.length = (glyphs &amp;&amp; glyphs.length) || 0;
                        }
                        
                        GlyphSet.prototype.get = function(index) {
                            if (typeof this.glyphs[index] === &#x27;function&#x27;) {
                                this.glyphs[index] = this.glyphs[index]();
                            }
                        
                            return this.glyphs[index];
                        };
                        
                        GlyphSet.prototype.push = function(index, loader) {
                            this.glyphs[index] = loader;
                            this.length++;
                        };
                        
                        function glyphLoader(font, index) {
                            return new _glyph.Glyph({index: index, font: font});
                        }
                        
                        /**
                         * Generate a stub glyph that can be filled with all metadata *except*
                         * the &quot;points&quot; and &quot;path&quot; properties, which must be loaded only once
                         * the glyph&#x27;s path is actually requested for text shaping.
                         */
                        
                        function ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {
                            return function() {
                                var glyph = new _glyph.Glyph({index: index, font: font});
                        
                                glyph.path = function() {
                                    parseGlyph(glyph, data, position);
                                    var path = buildPath(font.glyphs, glyph);
                                    path.unitsPerEm = font.unitsPerEm;
                                    return path;
                                };
                        
                                return glyph;
                            };
                        }
                        
                        function cffGlyphLoader(font, index, parseCFFCharstring, charstring) {
                            return function() {
                                var glyph = new _glyph.Glyph({index: index, font: font});
                        
                                glyph.path = function() {
                                    var path = parseCFFCharstring(font, glyph, charstring);
                                    path.unitsPerEm = font.unitsPerEm;
                                    return path;
                                };
                        
                                return glyph;
                            };
                        }
                        
                        exports.GlyphSet = GlyphSet;
                        exports.glyphLoader = glyphLoader;
                        exports.ttfGlyphLoader = ttfGlyphLoader;
                        exports.cffGlyphLoader = cffGlyphLoader;
                        
                        },{&quot;./glyph&quot;:6}],8:[function(_dereq_,module,exports){
                        // opentype.js
                        // https://github.com/nodebox/opentype.js
                        // (c) 2015 Frederik De Bleser
                        // opentype.js may be freely distributed under the MIT license.
                        
                        /* global ArrayBuffer, DataView, Uint8Array, XMLHttpRequest  */
                        
                        &#x27;use strict&#x27;;
                        
                        var encoding = _dereq_(&#x27;./encoding&#x27;);
                        var _font = _dereq_(&#x27;./font&#x27;);
                        var glyph = _dereq_(&#x27;./glyph&#x27;);
                        var parse = _dereq_(&#x27;./parse&#x27;);
                        var path = _dereq_(&#x27;./path&#x27;);
                        
                        var cmap = _dereq_(&#x27;./tables/cmap&#x27;);
                        var cff = _dereq_(&#x27;./tables/cff&#x27;);
                        var glyf = _dereq_(&#x27;./tables/glyf&#x27;);
                        var gpos = _dereq_(&#x27;./tables/gpos&#x27;);
                        var head = _dereq_(&#x27;./tables/head&#x27;);
                        var hhea = _dereq_(&#x27;./tables/hhea&#x27;);
                        var hmtx = _dereq_(&#x27;./tables/hmtx&#x27;);
                        var kern = _dereq_(&#x27;./tables/kern&#x27;);
                        var loca = _dereq_(&#x27;./tables/loca&#x27;);
                        var maxp = _dereq_(&#x27;./tables/maxp&#x27;);
                        var _name = _dereq_(&#x27;./tables/name&#x27;);
                        var os2 = _dereq_(&#x27;./tables/os2&#x27;);
                        var post = _dereq_(&#x27;./tables/post&#x27;);
                        
                        // File loaders /////////////////////////////////////////////////////////
                        
                        // Convert a Node.js Buffer to an ArrayBuffer
                        function toArrayBuffer(buffer) {
                            var arrayBuffer = new ArrayBuffer(buffer.length);
                            var data = new Uint8Array(arrayBuffer);
                            for (var i = 0; i &lt; buffer.length; i += 1) {
                                data[i] = buffer[i];
                            }
                        
                            return arrayBuffer;
                        }
                        
                        function loadFromFile(path, callback) {
                            var fs = _dereq_(&#x27;fs&#x27;);
                            fs.readFile(path, function(err, buffer) {
                                if (err) {
                                    return callback(err.message);
                                }
                        
                                callback(null, toArrayBuffer(buffer));
                            });
                        }
                        
                        function loadFromUrl(url, callback) {
                            var request = new XMLHttpRequest();
                            request.open(&#x27;get&#x27;, url, true);
                            request.responseType = &#x27;arraybuffer&#x27;;
                            request.onload = function() {
                                if (request.status !== 200) {
                                    return callback(&#x27;Font could not be loaded: &#x27; + request.statusText);
                                }
                        
                                return callback(null, request.response);
                            };
                        
                            request.send();
                        }
                        
                        // Public API ///////////////////////////////////////////////////////////
                        
                        // Parse the OpenType file data (as an ArrayBuffer) and return a Font object.
                        // If the file could not be parsed (most likely because it contains Postscript outlines)
                        // we return an empty Font object with the &#x60;supported&#x60; flag set to &#x60;false&#x60;.
                        function parseBuffer(buffer) {
                            var indexToLocFormat;
                            var hmtxOffset;
                            var glyfOffset;
                            var locaOffset;
                            var cffOffset;
                            var kernOffset;
                            var gposOffset;
                        
                            // OpenType fonts use big endian byte ordering.
                            // We can&#x27;t rely on typed array view types, because they operate with the endianness of the host computer.
                            // Instead we use DataViews where we can specify endianness.
                        
                            var font = new _font.Font();
                            var data = new DataView(buffer, 0);
                        
                            var version = parse.getFixed(data, 0);
                            if (version === 1.0) {
                                font.outlinesFormat = &#x27;truetype&#x27;;
                            } else {
                                version = parse.getTag(data, 0);
                                if (version === &#x27;OTTO&#x27;) {
                                    font.outlinesFormat = &#x27;cff&#x27;;
                                } else {
                                    throw new Error(&#x27;Unsupported OpenType version &#x27; + version);
                                }
                            }
                        
                            var numTables = parse.getUShort(data, 4);
                        
                            // Offset into the table records.
                            var p = 12;
                            for (var i = 0; i &lt; numTables; i += 1) {
                                var tag = parse.getTag(data, p);
                                var offset = parse.getULong(data, p + 8);
                                switch (tag) {
                                case &#x27;cmap&#x27;:
                                    font.tables.cmap = cmap.parse(data, offset);
                                    font.encoding = new encoding.CmapEncoding(font.tables.cmap);
                                    if (!font.encoding) {
                                        font.supported = false;
                                    }
                        
                                    break;
                                case &#x27;head&#x27;:
                                    font.tables.head = head.parse(data, offset);
                                    font.unitsPerEm = font.tables.head.unitsPerEm;
                                    indexToLocFormat = font.tables.head.indexToLocFormat;
                                    break;
                                case &#x27;hhea&#x27;:
                                    font.tables.hhea = hhea.parse(data, offset);
                                    font.ascender = font.tables.hhea.ascender;
                                    font.descender = font.tables.hhea.descender;
                                    font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;
                                    break;
                                case &#x27;hmtx&#x27;:
                                    hmtxOffset = offset;
                                    break;
                                case &#x27;maxp&#x27;:
                                    font.tables.maxp = maxp.parse(data, offset);
                                    font.numGlyphs = font.tables.maxp.numGlyphs;
                                    break;
                                case &#x27;name&#x27;:
                                    font.tables.name = _name.parse(data, offset);
                                    font.familyName = font.tables.name.fontFamily;
                                    font.styleName = font.tables.name.fontSubfamily;
                                    break;
                                case &#x27;OS/2&#x27;:
                                    font.tables.os2 = os2.parse(data, offset);
                                    break;
                                case &#x27;post&#x27;:
                                    font.tables.post = post.parse(data, offset);
                                    font.glyphNames = new encoding.GlyphNames(font.tables.post);
                                    break;
                                case &#x27;glyf&#x27;:
                                    glyfOffset = offset;
                                    break;
                                case &#x27;loca&#x27;:
                                    locaOffset = offset;
                                    break;
                                case &#x27;CFF &#x27;:
                                    cffOffset = offset;
                                    break;
                                case &#x27;kern&#x27;:
                                    kernOffset = offset;
                                    break;
                                case &#x27;GPOS&#x27;:
                                    gposOffset = offset;
                                    break;
                                }
                                p += 16;
                            }
                        
                            if (glyfOffset &amp;&amp; locaOffset) {
                                var shortVersion = indexToLocFormat === 0;
                                var locaTable = loca.parse(data, locaOffset, font.numGlyphs, shortVersion);
                                font.glyphs = glyf.parse(data, glyfOffset, locaTable, font);
                                hmtx.parse(data, hmtxOffset, font.numberOfHMetrics, font.numGlyphs, font.glyphs);
                                encoding.addGlyphNames(font);
                            } else if (cffOffset) {
                                cff.parse(data, cffOffset, font);
                                encoding.addGlyphNames(font);
                            } else {
                                font.supported = false;
                            }
                        
                            if (font.supported) {
                                if (kernOffset) {
                                    font.kerningPairs = kern.parse(data, kernOffset);
                                } else {
                                    font.kerningPairs = {};
                                }
                        
                                if (gposOffset) {
                                    gpos.parse(data, gposOffset, font);
                                }
                            }
                        
                            return font;
                        }
                        
                        // Asynchronously load the font from a URL or a filesystem. When done, call the callback
                        // with two arguments &#x60;(err, font)&#x60;. The &#x60;err&#x60; will be null on success,
                        // the &#x60;font&#x60; is a Font object.
                        //
                        // We use the node.js callback convention so that
                        // opentype.js can integrate with frameworks like async.js.
                        function load(url, callback) {
                            var isNode = typeof window === &#x27;undefined&#x27;;
                            var loadFn = isNode ? loadFromFile : loadFromUrl;
                            loadFn(url, function(err, arrayBuffer) {
                                if (err) {
                                    return callback(err);
                                }
                        
                                var font = parseBuffer(arrayBuffer);
                                if (!font.supported) {
                                    return callback(&#x27;Font is not supported (is this a Postscript font?)&#x27;);
                                }
                        
                                return callback(null, font);
                            });
                        }
                        
                        exports._parse = parse;
                        exports.Font = _font.Font;
                        exports.Glyph = glyph.Glyph;
                        exports.Path = path.Path;
                        exports.parse = parseBuffer;
                        exports.load = load;
                        
                        },{&quot;./encoding&quot;:4,&quot;./font&quot;:5,&quot;./glyph&quot;:6,&quot;./parse&quot;:9,&quot;./path&quot;:10,&quot;./tables/cff&quot;:12,&quot;./tables/cmap&quot;:13,&quot;./tables/glyf&quot;:14,&quot;./tables/gpos&quot;:15,&quot;./tables/head&quot;:16,&quot;./tables/hhea&quot;:17,&quot;./tables/hmtx&quot;:18,&quot;./tables/kern&quot;:19,&quot;./tables/loca&quot;:20,&quot;./tables/maxp&quot;:21,&quot;./tables/name&quot;:22,&quot;./tables/os2&quot;:23,&quot;./tables/post&quot;:24,&quot;fs&quot;:1}],9:[function(_dereq_,module,exports){
                        // Parsing utility functions
                        
                        &#x27;use strict&#x27;;
                        
                        // Retrieve an unsigned byte from the DataView.
                        exports.getByte = function getByte(dataView, offset) {
                            return dataView.getUint8(offset);
                        };
                        
                        exports.getCard8 = exports.getByte;
                        
                        // Retrieve an unsigned 16-bit short from the DataView.
                        // The value is stored in big endian.
                        exports.getUShort = function(dataView, offset) {
                            return dataView.getUint16(offset, false);
                        };
                        
                        exports.getCard16 = exports.getUShort;
                        
                        // Retrieve a signed 16-bit short from the DataView.
                        // The value is stored in big endian.
                        exports.getShort = function(dataView, offset) {
                            return dataView.getInt16(offset, false);
                        };
                        
                        // Retrieve an unsigned 32-bit long from the DataView.
                        // The value is stored in big endian.
                        exports.getULong = function(dataView, offset) {
                            return dataView.getUint32(offset, false);
                        };
                        
                        // Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.
                        // The value is stored in big endian.
                        exports.getFixed = function(dataView, offset) {
                            var decimal = dataView.getInt16(offset, false);
                            var fraction = dataView.getUint16(offset + 2, false);
                            return decimal + fraction / 65535;
                        };
                        
                        // Retrieve a 4-character tag from the DataView.
                        // Tags are used to identify tables.
                        exports.getTag = function(dataView, offset) {
                            var tag = &#x27;&#x27;;
                            for (var i = offset; i &lt; offset + 4; i += 1) {
                                tag += String.fromCharCode(dataView.getInt8(i));
                            }
                        
                            return tag;
                        };
                        
                        // Retrieve an offset from the DataView.
                        // Offsets are 1 to 4 bytes in length, depending on the offSize argument.
                        exports.getOffset = function(dataView, offset, offSize) {
                            var v = 0;
                            for (var i = 0; i &lt; offSize; i += 1) {
                                v &lt;&lt;= 8;
                                v += dataView.getUint8(offset + i);
                            }
                        
                            return v;
                        };
                        
                        // Retrieve a number of bytes from start offset to the end offset from the DataView.
                        exports.getBytes = function(dataView, startOffset, endOffset) {
                            var bytes = [];
                            for (var i = startOffset; i &lt; endOffset; i += 1) {
                                bytes.push(dataView.getUint8(i));
                            }
                        
                            return bytes;
                        };
                        
                        // Convert the list of bytes to a string.
                        exports.bytesToString = function(bytes) {
                            var s = &#x27;&#x27;;
                            for (var i = 0; i &lt; bytes.length; i += 1) {
                                s += String.fromCharCode(bytes[i]);
                            }
                        
                            return s;
                        };
                        
                        var typeOffsets = {
                            byte: 1,
                            uShort: 2,
                            short: 2,
                            uLong: 4,
                            fixed: 4,
                            longDateTime: 8,
                            tag: 4
                        };
                        
                        // A stateful parser that changes the offset whenever a value is retrieved.
                        // The data is a DataView.
                        function Parser(data, offset) {
                            this.data = data;
                            this.offset = offset;
                            this.relativeOffset = 0;
                        }
                        
                        Parser.prototype.parseByte = function() {
                            var v = this.data.getUint8(this.offset + this.relativeOffset);
                            this.relativeOffset += 1;
                            return v;
                        };
                        
                        Parser.prototype.parseChar = function() {
                            var v = this.data.getInt8(this.offset + this.relativeOffset);
                            this.relativeOffset += 1;
                            return v;
                        };
                        
                        Parser.prototype.parseCard8 = Parser.prototype.parseByte;
                        
                        Parser.prototype.parseUShort = function() {
                            var v = this.data.getUint16(this.offset + this.relativeOffset);
                            this.relativeOffset += 2;
                            return v;
                        };
                        
                        Parser.prototype.parseCard16 = Parser.prototype.parseUShort;
                        Parser.prototype.parseSID = Parser.prototype.parseUShort;
                        Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;
                        
                        Parser.prototype.parseShort = function() {
                            var v = this.data.getInt16(this.offset + this.relativeOffset);
                            this.relativeOffset += 2;
                            return v;
                        };
                        
                        Parser.prototype.parseF2Dot14 = function() {
                            var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
                            this.relativeOffset += 2;
                            return v;
                        };
                        
                        Parser.prototype.parseULong = function() {
                            var v = exports.getULong(this.data, this.offset + this.relativeOffset);
                            this.relativeOffset += 4;
                            return v;
                        };
                        
                        Parser.prototype.parseFixed = function() {
                            var v = exports.getFixed(this.data, this.offset + this.relativeOffset);
                            this.relativeOffset += 4;
                            return v;
                        };
                        
                        Parser.prototype.parseOffset16List =
                        Parser.prototype.parseUShortList = function(count) {
                            var offsets = new Array(count);
                            var dataView = this.data;
                            var offset = this.offset + this.relativeOffset;
                            for (var i = 0; i &lt; count; i++) {
                                offsets[i] = exports.getUShort(dataView, offset);
                                offset += 2;
                            }
                        
                            this.relativeOffset += count * 2;
                            return offsets;
                        };
                        
                        Parser.prototype.parseString = function(length) {
                            var dataView = this.data;
                            var offset = this.offset + this.relativeOffset;
                            var string = &#x27;&#x27;;
                            this.relativeOffset += length;
                            for (var i = 0; i &lt; length; i++) {
                                string += String.fromCharCode(dataView.getUint8(offset + i));
                            }
                        
                            return string;
                        };
                        
                        Parser.prototype.parseTag = function() {
                            return this.parseString(4);
                        };
                        
                        // LONGDATETIME is a 64-bit integer.
                        // JavaScript and unix timestamps traditionally use 32 bits, so we
                        // only take the last 32 bits.
                        Parser.prototype.parseLongDateTime = function() {
                            var v = exports.getULong(this.data, this.offset + this.relativeOffset + 4);
                            this.relativeOffset += 8;
                            return v;
                        };
                        
                        Parser.prototype.parseFixed = function() {
                            var v = exports.getULong(this.data, this.offset + this.relativeOffset);
                            this.relativeOffset += 4;
                            return v / 65536;
                        };
                        
                        Parser.prototype.parseVersion = function() {
                            var major = exports.getUShort(this.data, this.offset + this.relativeOffset);
                        
                            // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1
                            // This returns the correct number if minor = 0xN000 where N is 0-9
                            var minor = exports.getUShort(this.data, this.offset + this.relativeOffset + 2);
                            this.relativeOffset += 4;
                            return major + minor / 0x1000 / 10;
                        };
                        
                        Parser.prototype.skip = function(type, amount) {
                            if (amount === undefined) {
                                amount = 1;
                            }
                        
                            this.relativeOffset += typeOffsets[type] * amount;
                        };
                        
                        exports.Parser = Parser;
                        
                        },{}],10:[function(_dereq_,module,exports){
                        // Geometric objects
                        
                        &#x27;use strict&#x27;;
                        
                        // A bézier path containing a set of path commands similar to a SVG path.
                        // Paths can be drawn on a context using &#x60;draw&#x60;.
                        function Path() {
                            this.commands = [];
                            this.fill = &#x27;black&#x27;;
                            this.stroke = null;
                            this.strokeWidth = 1;
                        }
                        
                        Path.prototype.moveTo = function(x, y) {
                            this.commands.push({
                                type: &#x27;M&#x27;,
                                x: x,
                                y: y
                            });
                        };
                        
                        Path.prototype.lineTo = function(x, y) {
                            this.commands.push({
                                type: &#x27;L&#x27;,
                                x: x,
                                y: y
                            });
                        };
                        
                        Path.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {
                            this.commands.push({
                                type: &#x27;C&#x27;,
                                x1: x1,
                                y1: y1,
                                x2: x2,
                                y2: y2,
                                x: x,
                                y: y
                            });
                        };
                        
                        Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {
                            this.commands.push({
                                type: &#x27;Q&#x27;,
                                x1: x1,
                                y1: y1,
                                x: x,
                                y: y
                            });
                        };
                        
                        Path.prototype.close = Path.prototype.closePath = function() {
                            this.commands.push({
                                type: &#x27;Z&#x27;
                            });
                        };
                        
                        // Add the given path or list of commands to the commands of this path.
                        Path.prototype.extend = function(pathOrCommands) {
                            if (pathOrCommands.commands) {
                                pathOrCommands = pathOrCommands.commands;
                            }
                        
                            Array.prototype.push.apply(this.commands, pathOrCommands);
                        };
                        
                        // Draw the path to a 2D context.
                        Path.prototype.draw = function(ctx) {
                            ctx.beginPath();
                            for (var i = 0; i &lt; this.commands.length; i += 1) {
                                var cmd = this.commands[i];
                                if (cmd.type === &#x27;M&#x27;) {
                                    ctx.moveTo(cmd.x, cmd.y);
                                } else if (cmd.type === &#x27;L&#x27;) {
                                    ctx.lineTo(cmd.x, cmd.y);
                                } else if (cmd.type === &#x27;C&#x27;) {
                                    ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                                } else if (cmd.type === &#x27;Q&#x27;) {
                                    ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
                                } else if (cmd.type === &#x27;Z&#x27;) {
                                    ctx.closePath();
                                }
                            }
                        
                            if (this.fill) {
                                ctx.fillStyle = this.fill;
                                ctx.fill();
                            }
                        
                            if (this.stroke) {
                                ctx.strokeStyle = this.stroke;
                                ctx.lineWidth = this.strokeWidth;
                                ctx.stroke();
                            }
                        };
                        
                        // Convert the Path to a string of path data instructions
                        // See http://www.w3.org/TR/SVG/paths.html#PathData
                        // Parameters:
                        // - decimalPlaces: The amount of decimal places for floating-point values (default: 2)
                        Path.prototype.toPathData = function(decimalPlaces) {
                            decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;
                        
                            function floatToString(v) {
                                if (Math.round(v) === v) {
                                    return &#x27;&#x27; + Math.round(v);
                                } else {
                                    return v.toFixed(decimalPlaces);
                                }
                            }
                        
                            function packValues() {
                                var s = &#x27;&#x27;;
                                for (var i = 0; i &lt; arguments.length; i += 1) {
                                    var v = arguments[i];
                                    if (v &gt;= 0 &amp;&amp; i &gt; 0) {
                                        s += &#x27; &#x27;;
                                    }
                        
                                    s += floatToString(v);
                                }
                        
                                return s;
                            }
                        
                            var d = &#x27;&#x27;;
                            for (var i = 0; i &lt; this.commands.length; i += 1) {
                                var cmd = this.commands[i];
                                if (cmd.type === &#x27;M&#x27;) {
                                    d += &#x27;M&#x27; + packValues(cmd.x, cmd.y);
                                } else if (cmd.type === &#x27;L&#x27;) {
                                    d += &#x27;L&#x27; + packValues(cmd.x, cmd.y);
                                } else if (cmd.type === &#x27;C&#x27;) {
                                    d += &#x27;C&#x27; + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                                } else if (cmd.type === &#x27;Q&#x27;) {
                                    d += &#x27;Q&#x27; + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);
                                } else if (cmd.type === &#x27;Z&#x27;) {
                                    d += &#x27;Z&#x27;;
                                }
                            }
                        
                            return d;
                        };
                        
                        // Convert the path to a SVG &lt;path&gt; element, as a string.
                        // Parameters:
                        // - decimalPlaces: The amount of decimal places for floating-point values (default: 2)
                        Path.prototype.toSVG = function(decimalPlaces) {
                            var svg = &#x27;&lt;path d=&quot;&#x27;;
                            svg += this.toPathData(decimalPlaces);
                            svg += &#x27;&quot;&#x27;;
                            if (this.fill &amp; this.fill !== &#x27;black&#x27;) {
                                if (this.fill === null) {
                                    svg += &#x27; fill=&quot;none&quot;&#x27;;
                                } else {
                                    svg += &#x27; fill=&quot;&#x27; + this.fill + &#x27;&quot;&#x27;;
                                }
                            }
                        
                            if (this.stroke) {
                                svg += &#x27; stroke=&quot;&#x27; + this.stroke + &#x27;&quot; stroke-width=&quot;&#x27; + this.strokeWidth + &#x27;&quot;&#x27;;
                            }
                        
                            svg += &#x27;/&gt;&#x27;;
                            return svg;
                        };
                        
                        exports.Path = Path;
                        
                        },{}],11:[function(_dereq_,module,exports){
                        // Table metadata
                        
                        &#x27;use strict&#x27;;
                        
                        var check = _dereq_(&#x27;./check&#x27;);
                        var encode = _dereq_(&#x27;./types&#x27;).encode;
                        var sizeOf = _dereq_(&#x27;./types&#x27;).sizeOf;
                        
                        function Table(tableName, fields, options) {
                            var i;
                            for (i = 0; i &lt; fields.length; i += 1) {
                                var field = fields[i];
                                this[field.name] = field.value;
                            }
                        
                            this.tableName = tableName;
                            this.fields = fields;
                            if (options) {
                                var optionKeys = Object.keys(options);
                                for (i = 0; i &lt; optionKeys.length; i += 1) {
                                    var k = optionKeys[i];
                                    var v = options[k];
                                    if (this[k] !== undefined) {
                                        this[k] = v;
                                    }
                                }
                            }
                        }
                        
                        Table.prototype.sizeOf = function() {
                            var v = 0;
                            for (var i = 0; i &lt; this.fields.length; i += 1) {
                                var field = this.fields[i];
                                var value = this[field.name];
                                if (value === undefined) {
                                    value = field.value;
                                }
                        
                                if (typeof value.sizeOf === &#x27;function&#x27;) {
                                    v += value.sizeOf();
                                } else {
                                    var sizeOfFunction = sizeOf[field.type];
                                    check.assert(typeof sizeOfFunction === &#x27;function&#x27;, &#x27;Could not find sizeOf function for field&#x27; + field.name);
                                    v += sizeOfFunction(value);
                                }
                            }
                        
                            return v;
                        };
                        
                        Table.prototype.encode = function() {
                            return encode.TABLE(this);
                        };
                        
                        exports.Table = Table;
                        
                        },{&quot;./check&quot;:2,&quot;./types&quot;:26}],12:[function(_dereq_,module,exports){
                        // The &#x60;CFF&#x60; table contains the glyph outlines in PostScript format.
                        // https://www.microsoft.com/typography/OTSPEC/cff.htm
                        // http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/cff.pdf
                        // http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/type2.pdf
                        
                        &#x27;use strict&#x27;;
                        
                        var encoding = _dereq_(&#x27;../encoding&#x27;);
                        var glyphset = _dereq_(&#x27;../glyphset&#x27;);
                        var parse = _dereq_(&#x27;../parse&#x27;);
                        var path = _dereq_(&#x27;../path&#x27;);
                        var table = _dereq_(&#x27;../table&#x27;);
                        
                        // Custom equals function that can also check lists.
                        function equals(a, b) {
                            if (a === b) {
                                return true;
                            } else if (Array.isArray(a) &amp;&amp; Array.isArray(b)) {
                                if (a.length !== b.length) {
                                    return false;
                                }
                        
                                for (var i = 0; i &lt; a.length; i += 1) {
                                    if (!equals(a[i], b[i])) {
                                        return false;
                                    }
                                }
                        
                                return true;
                            } else {
                                return false;
                            }
                        }
                        
                        // Parse a &#x60;CFF&#x60; INDEX array.
                        // An index array consists of a list of offsets, then a list of objects at those offsets.
                        function parseCFFIndex(data, start, conversionFn) {
                            //var i, objectOffset, endOffset;
                            var offsets = [];
                            var objects = [];
                            var count = parse.getCard16(data, start);
                            var i;
                            var objectOffset;
                            var endOffset;
                            if (count !== 0) {
                                var offsetSize = parse.getByte(data, start + 2);
                                objectOffset = start + ((count + 1) * offsetSize) + 2;
                                var pos = start + 3;
                                for (i = 0; i &lt; count + 1; i += 1) {
                                    offsets.push(parse.getOffset(data, pos, offsetSize));
                                    pos += offsetSize;
                                }
                        
                                // The total size of the index array is 4 header bytes + the value of the last offset.
                                endOffset = objectOffset + offsets[count];
                            } else {
                                endOffset = start + 2;
                            }
                        
                            for (i = 0; i &lt; offsets.length - 1; i += 1) {
                                var value = parse.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);
                                if (conversionFn) {
                                    value = conversionFn(value);
                                }
                        
                                objects.push(value);
                            }
                        
                            return {objects: objects, startOffset: start, endOffset: endOffset};
                        }
                        
                        // Parse a &#x60;CFF&#x60; DICT real value.
                        function parseFloatOperand(parser) {
                            var s = &#x27;&#x27;;
                            var eof = 15;
                            var lookup = [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;.&#x27;, &#x27;E&#x27;, &#x27;E-&#x27;, null, &#x27;-&#x27;];
                            while (true) {
                                var b = parser.parseByte();
                                var n1 = b &gt;&gt; 4;
                                var n2 = b &amp; 15;
                        
                                if (n1 === eof) {
                                    break;
                                }
                        
                                s += lookup[n1];
                        
                                if (n2 === eof) {
                                    break;
                                }
                        
                                s += lookup[n2];
                            }
                        
                            return parseFloat(s);
                        }
                        
                        // Parse a &#x60;CFF&#x60; DICT operand.
                        function parseOperand(parser, b0) {
                            var b1;
                            var b2;
                            var b3;
                            var b4;
                            if (b0 === 28) {
                                b1 = parser.parseByte();
                                b2 = parser.parseByte();
                                return b1 &lt;&lt; 8 | b2;
                            }
                        
                            if (b0 === 29) {
                                b1 = parser.parseByte();
                                b2 = parser.parseByte();
                                b3 = parser.parseByte();
                                b4 = parser.parseByte();
                                return b1 &lt;&lt; 24 | b2 &lt;&lt; 16 | b3 &lt;&lt; 8 | b4;
                            }
                        
                            if (b0 === 30) {
                                return parseFloatOperand(parser);
                            }
                        
                            if (b0 &gt;= 32 &amp;&amp; b0 &lt;= 246) {
                                return b0 - 139;
                            }
                        
                            if (b0 &gt;= 247 &amp;&amp; b0 &lt;= 250) {
                                b1 = parser.parseByte();
                                return (b0 - 247) * 256 + b1 + 108;
                            }
                        
                            if (b0 &gt;= 251 &amp;&amp; b0 &lt;= 254) {
                                b1 = parser.parseByte();
                                return -(b0 - 251) * 256 - b1 - 108;
                            }
                        
                            throw new Error(&#x27;Invalid b0 &#x27; + b0);
                        }
                        
                        // Convert the entries returned by &#x60;parseDict&#x60; to a proper dictionary.
                        // If a value is a list of one, it is unpacked.
                        function entriesToObject(entries) {
                            var o = {};
                            for (var i = 0; i &lt; entries.length; i += 1) {
                                var key = entries[i][0];
                                var values = entries[i][1];
                                var value;
                                if (values.length === 1) {
                                    value = values[0];
                                } else {
                                    value = values;
                                }
                        
                                if (o.hasOwnProperty(key)) {
                                    throw new Error(&#x27;Object &#x27; + o + &#x27; already has key &#x27; + key);
                                }
                        
                                o[key] = value;
                            }
                        
                            return o;
                        }
                        
                        // Parse a &#x60;CFF&#x60; DICT object.
                        // A dictionary contains key-value pairs in a compact tokenized format.
                        function parseCFFDict(data, start, size) {
                            start = start !== undefined ? start : 0;
                            var parser = new parse.Parser(data, start);
                            var entries = [];
                            var operands = [];
                            size = size !== undefined ? size : data.length;
                        
                            while (parser.relativeOffset &lt; size) {
                                var op = parser.parseByte();
                        
                                // The first byte for each dict item distinguishes between operator (key) and operand (value).
                                // Values &lt;= 21 are operators.
                                if (op &lt;= 21) {
                                    // Two-byte operators have an initial escape byte of 12.
                                    if (op === 12) {
                                        op = 1200 + parser.parseByte();
                                    }
                        
                                    entries.push([op, operands]);
                                    operands = [];
                                } else {
                                    // Since the operands (values) come before the operators (keys), we store all operands in a list
                                    // until we encounter an operator.
                                    operands.push(parseOperand(parser, op));
                                }
                            }
                        
                            return entriesToObject(entries);
                        }
                        
                        // Given a String Index (SID), return the value of the string.
                        // Strings below index 392 are standard CFF strings and are not encoded in the font.
                        function getCFFString(strings, index) {
                            if (index &lt;= 390) {
                                index = encoding.cffStandardStrings[index];
                            } else {
                                index = strings[index - 391];
                            }
                        
                            return index;
                        }
                        
                        // Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.
                        // This function takes &#x60;meta&#x60; which is a list of objects containing &#x60;operand&#x60;, &#x60;name&#x60; and &#x60;default&#x60;.
                        function interpretDict(dict, meta, strings) {
                            var newDict = {};
                        
                            // Because we also want to include missing values, we start out from the meta list
                            // and lookup values in the dict.
                            for (var i = 0; i &lt; meta.length; i += 1) {
                                var m = meta[i];
                                var value = dict[m.op];
                                if (value === undefined) {
                                    value = m.value !== undefined ? m.value : null;
                                }
                        
                                if (m.type === &#x27;SID&#x27;) {
                                    value = getCFFString(strings, value);
                                }
                        
                                newDict[m.name] = value;
                            }
                        
                            return newDict;
                        }
                        
                        // Parse the CFF header.
                        function parseCFFHeader(data, start) {
                            var header = {};
                            header.formatMajor = parse.getCard8(data, start);
                            header.formatMinor = parse.getCard8(data, start + 1);
                            header.size = parse.getCard8(data, start + 2);
                            header.offsetSize = parse.getCard8(data, start + 3);
                            header.startOffset = start;
                            header.endOffset = start + 4;
                            return header;
                        }
                        
                        var TOP_DICT_META = [
                            {name: &#x27;version&#x27;, op: 0, type: &#x27;SID&#x27;},
                            {name: &#x27;notice&#x27;, op: 1, type: &#x27;SID&#x27;},
                            {name: &#x27;copyright&#x27;, op: 1200, type: &#x27;SID&#x27;},
                            {name: &#x27;fullName&#x27;, op: 2, type: &#x27;SID&#x27;},
                            {name: &#x27;familyName&#x27;, op: 3, type: &#x27;SID&#x27;},
                            {name: &#x27;weight&#x27;, op: 4, type: &#x27;SID&#x27;},
                            {name: &#x27;isFixedPitch&#x27;, op: 1201, type: &#x27;number&#x27;, value: 0},
                            {name: &#x27;italicAngle&#x27;, op: 1202, type: &#x27;number&#x27;, value: 0},
                            {name: &#x27;underlinePosition&#x27;, op: 1203, type: &#x27;number&#x27;, value: -100},
                            {name: &#x27;underlineThickness&#x27;, op: 1204, type: &#x27;number&#x27;, value: 50},
                            {name: &#x27;paintType&#x27;, op: 1205, type: &#x27;number&#x27;, value: 0},
                            {name: &#x27;charstringType&#x27;, op: 1206, type: &#x27;number&#x27;, value: 2},
                            {name: &#x27;fontMatrix&#x27;, op: 1207, type: [&#x27;real&#x27;, &#x27;real&#x27;, &#x27;real&#x27;, &#x27;real&#x27;, &#x27;real&#x27;, &#x27;real&#x27;], value: [0.001, 0, 0, 0.001, 0, 0]},
                            {name: &#x27;uniqueId&#x27;, op: 13, type: &#x27;number&#x27;},
                            {name: &#x27;fontBBox&#x27;, op: 5, type: [&#x27;number&#x27;, &#x27;number&#x27;, &#x27;number&#x27;, &#x27;number&#x27;], value: [0, 0, 0, 0]},
                            {name: &#x27;strokeWidth&#x27;, op: 1208, type: &#x27;number&#x27;, value: 0},
                            {name: &#x27;xuid&#x27;, op: 14, type: [], value: null},
                            {name: &#x27;charset&#x27;, op: 15, type: &#x27;offset&#x27;, value: 0},
                            {name: &#x27;encoding&#x27;, op: 16, type: &#x27;offset&#x27;, value: 0},
                            {name: &#x27;charStrings&#x27;, op: 17, type: &#x27;offset&#x27;, value: 0},
                            {name: &#x27;private&#x27;, op: 18, type: [&#x27;number&#x27;, &#x27;offset&#x27;], value: [0, 0]}
                        ];
                        
                        var PRIVATE_DICT_META = [
                            {name: &#x27;subrs&#x27;, op: 19, type: &#x27;offset&#x27;, value: 0},
                            {name: &#x27;defaultWidthX&#x27;, op: 20, type: &#x27;number&#x27;, value: 0},
                            {name: &#x27;nominalWidthX&#x27;, op: 21, type: &#x27;number&#x27;, value: 0}
                        ];
                        
                        // Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.
                        // The top dictionary contains the essential metadata for the font, together with the private dictionary.
                        function parseCFFTopDict(data, strings) {
                            var dict = parseCFFDict(data, 0, data.byteLength);
                            return interpretDict(dict, TOP_DICT_META, strings);
                        }
                        
                        // Parse the CFF private dictionary. We don&#x27;t fully parse out all the values, only the ones we need.
                        function parseCFFPrivateDict(data, start, size, strings) {
                            var dict = parseCFFDict(data, start, size);
                            return interpretDict(dict, PRIVATE_DICT_META, strings);
                        }
                        
                        // Parse the CFF charset table, which contains internal names for all the glyphs.
                        // This function will return a list of glyph names.
                        // See Adobe TN #5176 chapter 13, &quot;Charsets&quot;.
                        function parseCFFCharset(data, start, nGlyphs, strings) {
                            var i;
                            var sid;
                            var count;
                            var parser = new parse.Parser(data, start);
                        
                            // The .notdef glyph is not included, so subtract 1.
                            nGlyphs -= 1;
                            var charset = [&#x27;.notdef&#x27;];
                        
                            var format = parser.parseCard8();
                            if (format === 0) {
                                for (i = 0; i &lt; nGlyphs; i += 1) {
                                    sid = parser.parseSID();
                                    charset.push(getCFFString(strings, sid));
                                }
                            } else if (format === 1) {
                                while (charset.length &lt;= nGlyphs) {
                                    sid = parser.parseSID();
                                    count = parser.parseCard8();
                                    for (i = 0; i &lt;= count; i += 1) {
                                        charset.push(getCFFString(strings, sid));
                                        sid += 1;
                                    }
                                }
                            } else if (format === 2) {
                                while (charset.length &lt;= nGlyphs) {
                                    sid = parser.parseSID();
                                    count = parser.parseCard16();
                                    for (i = 0; i &lt;= count; i += 1) {
                                        charset.push(getCFFString(strings, sid));
                                        sid += 1;
                                    }
                                }
                            } else {
                                throw new Error(&#x27;Unknown charset format &#x27; + format);
                            }
                        
                            return charset;
                        }
                        
                        // Parse the CFF encoding data. Only one encoding can be specified per font.
                        // See Adobe TN #5176 chapter 12, &quot;Encodings&quot;.
                        function parseCFFEncoding(data, start, charset) {
                            var i;
                            var code;
                            var enc = {};
                            var parser = new parse.Parser(data, start);
                            var format = parser.parseCard8();
                            if (format === 0) {
                                var nCodes = parser.parseCard8();
                                for (i = 0; i &lt; nCodes; i += 1) {
                                    code = parser.parseCard8();
                                    enc[code] = i;
                                }
                            } else if (format === 1) {
                                var nRanges = parser.parseCard8();
                                code = 1;
                                for (i = 0; i &lt; nRanges; i += 1) {
                                    var first = parser.parseCard8();
                                    var nLeft = parser.parseCard8();
                                    for (var j = first; j &lt;= first + nLeft; j += 1) {
                                        enc[j] = code;
                                        code += 1;
                                    }
                                }
                            } else {
                                throw new Error(&#x27;Unknown encoding format &#x27; + format);
                            }
                        
                            return new encoding.CffEncoding(enc, charset);
                        }
                        
                        // Take in charstring code and return a Glyph object.
                        // The encoding is described in the Type 2 Charstring Format
                        // https://www.microsoft.com/typography/OTSPEC/charstr2.htm
                        function parseCFFCharstring(font, glyph, code) {
                            var c1x;
                            var c1y;
                            var c2x;
                            var c2y;
                            var p = new path.Path();
                            var stack = [];
                            var nStems = 0;
                            var haveWidth = false;
                            var width = font.defaultWidthX;
                            var open = false;
                            var x = 0;
                            var y = 0;
                        
                            function newContour(x, y) {
                                if (open) {
                                    p.closePath();
                                }
                        
                                p.moveTo(x, y);
                                open = true;
                            }
                        
                            function parseStems() {
                                var hasWidthArg;
                        
                                // The number of stem operators on the stack is always even.
                                // If the value is uneven, that means a width is specified.
                                hasWidthArg = stack.length % 2 !== 0;
                                if (hasWidthArg &amp;&amp; !haveWidth) {
                                    width = stack.shift() + font.nominalWidthX;
                                }
                        
                                nStems += stack.length &gt;&gt; 1;
                                stack.length = 0;
                                haveWidth = true;
                            }
                        
                            function parse(code) {
                                var b1;
                                var b2;
                                var b3;
                                var b4;
                                var codeIndex;
                                var subrCode;
                                var jpx;
                                var jpy;
                                var c3x;
                                var c3y;
                                var c4x;
                                var c4y;
                        
                                var i = 0;
                                while (i &lt; code.length) {
                                    var v = code[i];
                                    i += 1;
                                    switch (v) {
                                    case 1: // hstem
                                        parseStems();
                                        break;
                                    case 3: // vstem
                                        parseStems();
                                        break;
                                    case 4: // vmoveto
                                        if (stack.length &gt; 1 &amp;&amp; !haveWidth) {
                                            width = stack.shift() + font.nominalWidthX;
                                            haveWidth = true;
                                        }
                        
                                        y += stack.pop();
                                        newContour(x, y);
                                        break;
                                    case 5: // rlineto
                                        while (stack.length &gt; 0) {
                                            x += stack.shift();
                                            y += stack.shift();
                                            p.lineTo(x, y);
                                        }
                        
                                        break;
                                    case 6: // hlineto
                                        while (stack.length &gt; 0) {
                                            x += stack.shift();
                                            p.lineTo(x, y);
                                            if (stack.length === 0) {
                                                break;
                                            }
                        
                                            y += stack.shift();
                                            p.lineTo(x, y);
                                        }
                        
                                        break;
                                    case 7: // vlineto
                                        while (stack.length &gt; 0) {
                                            y += stack.shift();
                                            p.lineTo(x, y);
                                            if (stack.length === 0) {
                                                break;
                                            }
                        
                                            x += stack.shift();
                                            p.lineTo(x, y);
                                        }
                        
                                        break;
                                    case 8: // rrcurveto
                                        while (stack.length &gt; 0) {
                                            c1x = x + stack.shift();
                                            c1y = y + stack.shift();
                                            c2x = c1x + stack.shift();
                                            c2y = c1y + stack.shift();
                                            x = c2x + stack.shift();
                                            y = c2y + stack.shift();
                                            p.curveTo(c1x, c1y, c2x, c2y, x, y);
                                        }
                        
                                        break;
                                    case 10: // callsubr
                                        codeIndex = stack.pop() + font.subrsBias;
                                        subrCode = font.subrs[codeIndex];
                                        if (subrCode) {
                                            parse(subrCode);
                                        }
                        
                                        break;
                                    case 11: // return
                                        return;
                                    case 12: // flex operators
                                        v = code[i];
                                        i += 1;
                                        switch (v) {
                                        case 35: // flex
                                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-
                                            c1x = x   + stack.shift();    // dx1
                                            c1y = y   + stack.shift();    // dy1
                                            c2x = c1x + stack.shift();    // dx2
                                            c2y = c1y + stack.shift();    // dy2
                                            jpx = c2x + stack.shift();    // dx3
                                            jpy = c2y + stack.shift();    // dy3
                                            c3x = jpx + stack.shift();    // dx4
                                            c3y = jpy + stack.shift();    // dy4
                                            c4x = c3x + stack.shift();    // dx5
                                            c4y = c3y + stack.shift();    // dy5
                                            x = c4x + stack.shift();      // dx6
                                            y = c4y + stack.shift();      // dy6
                                            stack.shift();                // flex depth
                                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                                            break;
                                        case 34: // hflex
                                            // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-
                                            c1x = x   + stack.shift();    // dx1
                                            c1y = y;                      // dy1
                                            c2x = c1x + stack.shift();    // dx2
                                            c2y = c1y + stack.shift();    // dy2
                                            jpx = c2x + stack.shift();    // dx3
                                            jpy = c2y;                    // dy3
                                            c3x = jpx + stack.shift();    // dx4
                                            c3y = c2y;                    // dy4
                                            c4x = c3x + stack.shift();    // dx5
                                            c4y = y;                      // dy5
                                            x = c4x + stack.shift();      // dx6
                                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                                            break;
                                        case 36: // hflex1
                                            // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-
                                            c1x = x   + stack.shift();    // dx1
                                            c1y = y   + stack.shift();    // dy1
                                            c2x = c1x + stack.shift();    // dx2
                                            c2y = c1y + stack.shift();    // dy2
                                            jpx = c2x + stack.shift();    // dx3
                                            jpy = c2y;                    // dy3
                                            c3x = jpx + stack.shift();    // dx4
                                            c3y = c2y;                    // dy4
                                            c4x = c3x + stack.shift();    // dx5
                                            c4y = c3y + stack.shift();    // dy5
                                            x = c4x + stack.shift();      // dx6
                                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                                            break;
                                        case 37: // flex1
                                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-
                                            c1x = x   + stack.shift();    // dx1
                                            c1y = y   + stack.shift();    // dy1
                                            c2x = c1x + stack.shift();    // dx2
                                            c2y = c1y + stack.shift();    // dy2
                                            jpx = c2x + stack.shift();    // dx3
                                            jpy = c2y + stack.shift();    // dy3
                                            c3x = jpx + stack.shift();    // dx4
                                            c3y = jpy + stack.shift();    // dy4
                                            c4x = c3x + stack.shift();    // dx5
                                            c4y = c3y + stack.shift();    // dy5
                                            if (Math.abs(c4x - x) &gt; Math.abs(c4y - y)) {
                                                x = c4x + stack.shift();
                                            } else {
                                                y = c4y + stack.shift();
                                            }
                        
                                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                                            break;
                                        default:
                                            console.log(&#x27;Glyph &#x27; + glyph.index + &#x27;: unknown operator &#x27; + 1200 + v);
                                            stack.length = 0;
                                        }
                                        break;
                                    case 14: // endchar
                                        if (stack.length &gt; 0 &amp;&amp; !haveWidth) {
                                            width = stack.shift() + font.nominalWidthX;
                                            haveWidth = true;
                                        }
                        
                                        if (open) {
                                            p.closePath();
                                            open = false;
                                        }
                        
                                        break;
                                    case 18: // hstemhm
                                        parseStems();
                                        break;
                                    case 19: // hintmask
                                    case 20: // cntrmask
                                        parseStems();
                                        i += (nStems + 7) &gt;&gt; 3;
                                        break;
                                    case 21: // rmoveto
                                        if (stack.length &gt; 2 &amp;&amp; !haveWidth) {
                                            width = stack.shift() + font.nominalWidthX;
                                            haveWidth = true;
                                        }
                        
                                        y += stack.pop();
                                        x += stack.pop();
                                        newContour(x, y);
                                        break;
                                    case 22: // hmoveto
                                        if (stack.length &gt; 1 &amp;&amp; !haveWidth) {
                                            width = stack.shift() + font.nominalWidthX;
                                            haveWidth = true;
                                        }
                        
                                        x += stack.pop();
                                        newContour(x, y);
                                        break;
                                    case 23: // vstemhm
                                        parseStems();
                                        break;
                                    case 24: // rcurveline
                                        while (stack.length &gt; 2) {
                                            c1x = x + stack.shift();
                                            c1y = y + stack.shift();
                                            c2x = c1x + stack.shift();
                                            c2y = c1y + stack.shift();
                                            x = c2x + stack.shift();
                                            y = c2y + stack.shift();
                                            p.curveTo(c1x, c1y, c2x, c2y, x, y);
                                        }
                        
                                        x += stack.shift();
                                        y += stack.shift();
                                        p.lineTo(x, y);
                                        break;
                                    case 25: // rlinecurve
                                        while (stack.length &gt; 6) {
                                            x += stack.shift();
                                            y += stack.shift();
                                            p.lineTo(x, y);
                                        }
                        
                                        c1x = x + stack.shift();
                                        c1y = y + stack.shift();
                                        c2x = c1x + stack.shift();
                                        c2y = c1y + stack.shift();
                                        x = c2x + stack.shift();
                                        y = c2y + stack.shift();
                                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                                        break;
                                    case 26: // vvcurveto
                                        if (stack.length % 2) {
                                            x += stack.shift();
                                        }
                        
                                        while (stack.length &gt; 0) {
                                            c1x = x;
                                            c1y = y + stack.shift();
                                            c2x = c1x + stack.shift();
                                            c2y = c1y + stack.shift();
                                            x = c2x;
                                            y = c2y + stack.shift();
                                            p.curveTo(c1x, c1y, c2x, c2y, x, y);
                                        }
                        
                                        break;
                                    case 27: // hhcurveto
                                        if (stack.length % 2) {
                                            y += stack.shift();
                                        }
                        
                                        while (stack.length &gt; 0) {
                                            c1x = x + stack.shift();
                                            c1y = y;
                                            c2x = c1x + stack.shift();
                                            c2y = c1y + stack.shift();
                                            x = c2x + stack.shift();
                                            y = c2y;
                                            p.curveTo(c1x, c1y, c2x, c2y, x, y);
                                        }
                        
                                        break;
                                    case 28: // shortint
                                        b1 = code[i];
                                        b2 = code[i + 1];
                                        stack.push(((b1 &lt;&lt; 24) | (b2 &lt;&lt; 16)) &gt;&gt; 16);
                                        i += 2;
                                        break;
                                    case 29: // callgsubr
                                        codeIndex = stack.pop() + font.gsubrsBias;
                                        subrCode = font.gsubrs[codeIndex];
                                        if (subrCode) {
                                            parse(subrCode);
                                        }
                        
                                        break;
                                    case 30: // vhcurveto
                                        while (stack.length &gt; 0) {
                                            c1x = x;
                                            c1y = y + stack.shift();
                                            c2x = c1x + stack.shift();
                                            c2y = c1y + stack.shift();
                                            x = c2x + stack.shift();
                                            y = c2y + (stack.length === 1 ? stack.shift() : 0);
                                            p.curveTo(c1x, c1y, c2x, c2y, x, y);
                                            if (stack.length === 0) {
                                                break;
                                            }
                        
                                            c1x = x + stack.shift();
                                            c1y = y;
                                            c2x = c1x + stack.shift();
                                            c2y = c1y + stack.shift();
                                            y = c2y + stack.shift();
                                            x = c2x + (stack.length === 1 ? stack.shift() : 0);
                                            p.curveTo(c1x, c1y, c2x, c2y, x, y);
                                        }
                        
                                        break;
                                    case 31: // hvcurveto
                                        while (stack.length &gt; 0) {
                                            c1x = x + stack.shift();
                                            c1y = y;
                                            c2x = c1x + stack.shift();
                                            c2y = c1y + stack.shift();
                                            y = c2y + stack.shift();
                                            x = c2x + (stack.length === 1 ? stack.shift() : 0);
                                            p.curveTo(c1x, c1y, c2x, c2y, x, y);
                                            if (stack.length === 0) {
                                                break;
                                            }
                        
                                            c1x = x;
                                            c1y = y + stack.shift();
                                            c2x = c1x + stack.shift();
                                            c2y = c1y + stack.shift();
                                            x = c2x + stack.shift();
                                            y = c2y + (stack.length === 1 ? stack.shift() : 0);
                                            p.curveTo(c1x, c1y, c2x, c2y, x, y);
                                        }
                        
                                        break;
                                    default:
                                        if (v &lt; 32) {
                                            console.log(&#x27;Glyph &#x27; + glyph.index + &#x27;: unknown operator &#x27; + v);
                                        } else if (v &lt; 247) {
                                            stack.push(v - 139);
                                        } else if (v &lt; 251) {
                                            b1 = code[i];
                                            i += 1;
                                            stack.push((v - 247) * 256 + b1 + 108);
                                        } else if (v &lt; 255) {
                                            b1 = code[i];
                                            i += 1;
                                            stack.push(-(v - 251) * 256 - b1 - 108);
                                        } else {
                                            b1 = code[i];
                                            b2 = code[i + 1];
                                            b3 = code[i + 2];
                                            b4 = code[i + 3];
                                            i += 4;
                                            stack.push(((b1 &lt;&lt; 24) | (b2 &lt;&lt; 16) | (b3 &lt;&lt; 8) | b4) / 65536);
                                        }
                                    }
                                }
                            }
                        
                            parse(code);
                        
                            glyph.advanceWidth = width;
                            return p;
                        }
                        
                        // Subroutines are encoded using the negative half of the number space.
                        // See type 2 chapter 4.7 &quot;Subroutine operators&quot;.
                        function calcCFFSubroutineBias(subrs) {
                            var bias;
                            if (subrs.length &lt; 1240) {
                                bias = 107;
                            } else if (subrs.length &lt; 33900) {
                                bias = 1131;
                            } else {
                                bias = 32768;
                            }
                        
                            return bias;
                        }
                        
                        // Parse the &#x60;CFF&#x60; table, which contains the glyph outlines in PostScript format.
                        function parseCFFTable(data, start, font) {
                            font.tables.cff = {};
                            var header = parseCFFHeader(data, start);
                            var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);
                            var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);
                            var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);
                            var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);
                            font.gsubrs = globalSubrIndex.objects;
                            font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);
                        
                            var topDictData = new DataView(new Uint8Array(topDictIndex.objects[0]).buffer);
                            var topDict = parseCFFTopDict(topDictData, stringIndex.objects);
                            font.tables.cff.topDict = topDict;
                        
                            var privateDictOffset = start + topDict[&#x27;private&#x27;][1];
                            var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict[&#x27;private&#x27;][0], stringIndex.objects);
                            font.defaultWidthX = privateDict.defaultWidthX;
                            font.nominalWidthX = privateDict.nominalWidthX;
                        
                            if (privateDict.subrs !== 0) {
                                var subrOffset = privateDictOffset + privateDict.subrs;
                                var subrIndex = parseCFFIndex(data, subrOffset);
                                font.subrs = subrIndex.objects;
                                font.subrsBias = calcCFFSubroutineBias(font.subrs);
                            } else {
                                font.subrs = [];
                                font.subrsBias = 0;
                            }
                        
                            // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.
                            var charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);
                            font.nGlyphs = charStringsIndex.objects.length;
                        
                            var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);
                            if (topDict.encoding === 0) { // Standard encoding
                                font.cffEncoding = new encoding.CffEncoding(encoding.cffStandardEncoding, charset);
                            } else if (topDict.encoding === 1) { // Expert encoding
                                font.cffEncoding = new encoding.CffEncoding(encoding.cffExpertEncoding, charset);
                            } else {
                                font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);
                            }
                        
                            // Prefer the CMAP encoding to the CFF encoding.
                            font.encoding = font.encoding || font.cffEncoding;
                        
                            font.glyphs = new glyphset.GlyphSet(font);
                            for (var i = 0; i &lt; font.nGlyphs; i += 1) {
                                var charString = charStringsIndex.objects[i];
                                font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));
                            }
                        }
                        
                        // Convert a string to a String ID (SID).
                        // The list of strings is modified in place.
                        function encodeString(s, strings) {
                            var sid;
                        
                            // Is the string in the CFF standard strings?
                            var i = encoding.cffStandardStrings.indexOf(s);
                            if (i &gt;= 0) {
                                sid = i;
                            }
                        
                            // Is the string already in the string index?
                            i = strings.indexOf(s);
                            if (i &gt;= 0) {
                                sid = i + encoding.cffStandardStrings.length;
                            } else {
                                sid = encoding.cffStandardStrings.length + strings.length;
                                strings.push(s);
                            }
                        
                            return sid;
                        }
                        
                        function makeHeader() {
                            return new table.Table(&#x27;Header&#x27;, [
                                {name: &#x27;major&#x27;, type: &#x27;Card8&#x27;, value: 1},
                                {name: &#x27;minor&#x27;, type: &#x27;Card8&#x27;, value: 0},
                                {name: &#x27;hdrSize&#x27;, type: &#x27;Card8&#x27;, value: 4},
                                {name: &#x27;major&#x27;, type: &#x27;Card8&#x27;, value: 1}
                            ]);
                        }
                        
                        function makeNameIndex(fontNames) {
                            var t = new table.Table(&#x27;Name INDEX&#x27;, [
                                {name: &#x27;names&#x27;, type: &#x27;INDEX&#x27;, value: []}
                            ]);
                            t.names = [];
                            for (var i = 0; i &lt; fontNames.length; i += 1) {
                                t.names.push({name: &#x27;name_&#x27; + i, type: &#x27;NAME&#x27;, value: fontNames[i]});
                            }
                        
                            return t;
                        }
                        
                        // Given a dictionary&#x27;s metadata, create a DICT structure.
                        function makeDict(meta, attrs, strings) {
                            var m = {};
                            for (var i = 0; i &lt; meta.length; i += 1) {
                                var entry = meta[i];
                                var value = attrs[entry.name];
                                if (value !== undefined &amp;&amp; !equals(value, entry.value)) {
                                    if (entry.type === &#x27;SID&#x27;) {
                                        value = encodeString(value, strings);
                                    }
                        
                                    m[entry.op] = {name: entry.name, type: entry.type, value: value};
                                }
                            }
                        
                            return m;
                        }
                        
                        // The Top DICT houses the global font attributes.
                        function makeTopDict(attrs, strings) {
                            var t = new table.Table(&#x27;Top DICT&#x27;, [
                                {name: &#x27;dict&#x27;, type: &#x27;DICT&#x27;, value: {}}
                            ]);
                            t.dict = makeDict(TOP_DICT_META, attrs, strings);
                            return t;
                        }
                        
                        function makeTopDictIndex(topDict) {
                            var t = new table.Table(&#x27;Top DICT INDEX&#x27;, [
                                {name: &#x27;topDicts&#x27;, type: &#x27;INDEX&#x27;, value: []}
                            ]);
                            t.topDicts = [{name: &#x27;topDict_0&#x27;, type: &#x27;TABLE&#x27;, value: topDict}];
                            return t;
                        }
                        
                        function makeStringIndex(strings) {
                            var t = new table.Table(&#x27;String INDEX&#x27;, [
                                {name: &#x27;strings&#x27;, type: &#x27;INDEX&#x27;, value: []}
                            ]);
                            t.strings = [];
                            for (var i = 0; i &lt; strings.length; i += 1) {
                                t.strings.push({name: &#x27;string_&#x27; + i, type: &#x27;STRING&#x27;, value: strings[i]});
                            }
                        
                            return t;
                        }
                        
                        function makeGlobalSubrIndex() {
                            // Currently we don&#x27;t use subroutines.
                            return new table.Table(&#x27;Global Subr INDEX&#x27;, [
                                {name: &#x27;subrs&#x27;, type: &#x27;INDEX&#x27;, value: []}
                            ]);
                        }
                        
                        function makeCharsets(glyphNames, strings) {
                            var t = new table.Table(&#x27;Charsets&#x27;, [
                                {name: &#x27;format&#x27;, type: &#x27;Card8&#x27;, value: 0}
                            ]);
                            for (var i = 0; i &lt; glyphNames.length; i += 1) {
                                var glyphName = glyphNames[i];
                                var glyphSID = encodeString(glyphName, strings);
                                t.fields.push({name: &#x27;glyph_&#x27; + i, type: &#x27;SID&#x27;, value: glyphSID});
                            }
                        
                            return t;
                        }
                        
                        function glyphToOps(glyph) {
                            var ops = [];
                            var path = glyph.path;
                            ops.push({name: &#x27;width&#x27;, type: &#x27;NUMBER&#x27;, value: glyph.advanceWidth});
                            var x = 0;
                            var y = 0;
                            for (var i = 0; i &lt; path.commands.length; i += 1) {
                                var dx;
                                var dy;
                                var cmd = path.commands[i];
                                if (cmd.type === &#x27;Q&#x27;) {
                                    // CFF only supports bézier curves, so convert the quad to a bézier.
                                    var _13 = 1 / 3;
                                    var _23 = 2 / 3;
                        
                                    // We&#x27;re going to create a new command so we don&#x27;t change the original path.
                                    cmd = {
                                        type: &#x27;C&#x27;,
                                        x: cmd.x,
                                        y: cmd.y,
                                        x1: _13 * x + _23 * cmd.x1,
                                        y1: _13 * y + _23 * cmd.y1,
                                        x2: _13 * cmd.x + _23 * cmd.x1,
                                        y2: _13 * cmd.y + _23 * cmd.y1
                                    };
                                }
                        
                                if (cmd.type === &#x27;M&#x27;) {
                                    dx = Math.round(cmd.x - x);
                                    dy = Math.round(cmd.y - y);
                                    ops.push({name: &#x27;dx&#x27;, type: &#x27;NUMBER&#x27;, value: dx});
                                    ops.push({name: &#x27;dy&#x27;, type: &#x27;NUMBER&#x27;, value: dy});
                                    ops.push({name: &#x27;rmoveto&#x27;, type: &#x27;OP&#x27;, value: 21});
                                    x = Math.round(cmd.x);
                                    y = Math.round(cmd.y);
                                } else if (cmd.type === &#x27;L&#x27;) {
                                    dx = Math.round(cmd.x - x);
                                    dy = Math.round(cmd.y - y);
                                    ops.push({name: &#x27;dx&#x27;, type: &#x27;NUMBER&#x27;, value: dx});
                                    ops.push({name: &#x27;dy&#x27;, type: &#x27;NUMBER&#x27;, value: dy});
                                    ops.push({name: &#x27;rlineto&#x27;, type: &#x27;OP&#x27;, value: 5});
                                    x = Math.round(cmd.x);
                                    y = Math.round(cmd.y);
                                } else if (cmd.type === &#x27;C&#x27;) {
                                    var dx1 = Math.round(cmd.x1 - x);
                                    var dy1 = Math.round(cmd.y1 - y);
                                    var dx2 = Math.round(cmd.x2 - cmd.x1);
                                    var dy2 = Math.round(cmd.y2 - cmd.y1);
                                    dx = Math.round(cmd.x - cmd.x2);
                                    dy = Math.round(cmd.y - cmd.y2);
                                    ops.push({name: &#x27;dx1&#x27;, type: &#x27;NUMBER&#x27;, value: dx1});
                                    ops.push({name: &#x27;dy1&#x27;, type: &#x27;NUMBER&#x27;, value: dy1});
                                    ops.push({name: &#x27;dx2&#x27;, type: &#x27;NUMBER&#x27;, value: dx2});
                                    ops.push({name: &#x27;dy2&#x27;, type: &#x27;NUMBER&#x27;, value: dy2});
                                    ops.push({name: &#x27;dx&#x27;, type: &#x27;NUMBER&#x27;, value: dx});
                                    ops.push({name: &#x27;dy&#x27;, type: &#x27;NUMBER&#x27;, value: dy});
                                    ops.push({name: &#x27;rrcurveto&#x27;, type: &#x27;OP&#x27;, value: 8});
                                    x = Math.round(cmd.x);
                                    y = Math.round(cmd.y);
                                }
                        
                                // Contours are closed automatically.
                        
                            }
                        
                            ops.push({name: &#x27;endchar&#x27;, type: &#x27;OP&#x27;, value: 14});
                            return ops;
                        }
                        
                        function makeCharStringsIndex(glyphs) {
                            var t = new table.Table(&#x27;CharStrings INDEX&#x27;, [
                                {name: &#x27;charStrings&#x27;, type: &#x27;INDEX&#x27;, value: []}
                            ]);
                        
                            for (var i = 0; i &lt; glyphs.length; i += 1) {
                                var glyph = glyphs.get(i);
                                var ops = glyphToOps(glyph);
                                t.charStrings.push({name: glyph.name, type: &#x27;CHARSTRING&#x27;, value: ops});
                            }
                        
                            return t;
                        }
                        
                        function makePrivateDict(attrs, strings) {
                            var t = new table.Table(&#x27;Private DICT&#x27;, [
                                {name: &#x27;dict&#x27;, type: &#x27;DICT&#x27;, value: {}}
                            ]);
                            t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
                            return t;
                        }
                        
                        function makePrivateDictIndex(privateDict) {
                            var t = new table.Table(&#x27;Private DICT INDEX&#x27;, [
                                {name: &#x27;privateDicts&#x27;, type: &#x27;INDEX&#x27;, value: []}
                            ]);
                            t.privateDicts = [{name: &#x27;privateDict_0&#x27;, type: &#x27;TABLE&#x27;, value: privateDict}];
                            return t;
                        }
                        
                        function makeCFFTable(glyphs, options) {
                            var t = new table.Table(&#x27;CFF &#x27;, [
                                {name: &#x27;header&#x27;, type: &#x27;TABLE&#x27;},
                                {name: &#x27;nameIndex&#x27;, type: &#x27;TABLE&#x27;},
                                {name: &#x27;topDictIndex&#x27;, type: &#x27;TABLE&#x27;},
                                {name: &#x27;stringIndex&#x27;, type: &#x27;TABLE&#x27;},
                                {name: &#x27;globalSubrIndex&#x27;, type: &#x27;TABLE&#x27;},
                                {name: &#x27;charsets&#x27;, type: &#x27;TABLE&#x27;},
                                {name: &#x27;charStringsIndex&#x27;, type: &#x27;TABLE&#x27;},
                                {name: &#x27;privateDictIndex&#x27;, type: &#x27;TABLE&#x27;}
                            ]);
                        
                            var fontScale = 1 / options.unitsPerEm;
                            // We use non-zero values for the offsets so that the DICT encodes them.
                            // This is important because the size of the Top DICT plays a role in offset calculation,
                            // and the size shouldn&#x27;t change after we&#x27;ve written correct offsets.
                            var attrs = {
                                version: options.version,
                                fullName: options.fullName,
                                familyName: options.familyName,
                                weight: options.weightName,
                                fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],
                                charset: 999,
                                encoding: 0,
                                charStrings: 999,
                                private: [0, 999]
                            };
                        
                            var privateAttrs = {};
                        
                            var glyphNames = [];
                            var glyph;
                        
                            // Skip first glyph (.notdef)
                            for (var i = 1; i &lt; glyphs.length; i += 1) {
                                glyph = glyphs.get(i);
                                glyphNames.push(glyph.name);
                            }
                        
                            var strings = [];
                        
                            t.header = makeHeader();
                            t.nameIndex = makeNameIndex([options.postScriptName]);
                            var topDict = makeTopDict(attrs, strings);
                            t.topDictIndex = makeTopDictIndex(topDict);
                            t.globalSubrIndex = makeGlobalSubrIndex();
                            t.charsets = makeCharsets(glyphNames, strings);
                            t.charStringsIndex = makeCharStringsIndex(glyphs);
                            var privateDict = makePrivateDict(privateAttrs, strings);
                            t.privateDictIndex = makePrivateDictIndex(privateDict);
                        
                            // Needs to come at the end, to encode all custom strings used in the font.
                            t.stringIndex = makeStringIndex(strings);
                        
                            var startOffset = t.header.sizeOf() +
                                t.nameIndex.sizeOf() +
                                t.topDictIndex.sizeOf() +
                                t.stringIndex.sizeOf() +
                                t.globalSubrIndex.sizeOf();
                            attrs.charset = startOffset;
                        
                            // We use the CFF standard encoding; proper encoding will be handled in cmap.
                            attrs.encoding = 0;
                            attrs.charStrings = attrs.charset + t.charsets.sizeOf();
                            attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();
                        
                            // Recreate the Top DICT INDEX with the correct offsets.
                            topDict = makeTopDict(attrs, strings);
                            t.topDictIndex = makeTopDictIndex(topDict);
                        
                            return t;
                        }
                        
                        exports.parse = parseCFFTable;
                        exports.make = makeCFFTable;
                        
                        },{&quot;../encoding&quot;:4,&quot;../glyphset&quot;:7,&quot;../parse&quot;:9,&quot;../path&quot;:10,&quot;../table&quot;:11}],13:[function(_dereq_,module,exports){
                        // The &#x60;cmap&#x60; table stores the mappings from characters to glyphs.
                        // https://www.microsoft.com/typography/OTSPEC/cmap.htm
                        
                        &#x27;use strict&#x27;;
                        
                        var check = _dereq_(&#x27;../check&#x27;);
                        var parse = _dereq_(&#x27;../parse&#x27;);
                        var table = _dereq_(&#x27;../table&#x27;);
                        
                        // Parse the &#x60;cmap&#x60; table. This table stores the mappings from characters to glyphs.
                        // There are many available formats, but we only support the Windows format 4.
                        // This function returns a &#x60;CmapEncoding&#x60; object or null if no supported format could be found.
                        function parseCmapTable(data, start) {
                            var i;
                            var cmap = {};
                            cmap.version = parse.getUShort(data, start);
                            check.argument(cmap.version === 0, &#x27;cmap table version should be 0.&#x27;);
                        
                            // The cmap table can contain many sub-tables, each with their own format.
                            // We&#x27;re only interested in a &quot;platform 3&quot; table. This is a Windows format.
                            cmap.numTables = parse.getUShort(data, start + 2);
                            var offset = -1;
                            for (i = 0; i &lt; cmap.numTables; i += 1) {
                                var platformId = parse.getUShort(data, start + 4 + (i * 8));
                                var encodingId = parse.getUShort(data, start + 4 + (i * 8) + 2);
                                if (platformId === 3 &amp;&amp; (encodingId === 1 || encodingId === 0)) {
                                    offset = parse.getULong(data, start + 4 + (i * 8) + 4);
                                    break;
                                }
                            }
                        
                            if (offset === -1) {
                                // There is no cmap table in the font that we support, so return null.
                                // This font will be marked as unsupported.
                                return null;
                            }
                        
                            var p = new parse.Parser(data, start + offset);
                            cmap.format = p.parseUShort();
                            check.argument(cmap.format === 4, &#x27;Only format 4 cmap tables are supported.&#x27;);
                        
                            // Length in bytes of the sub-tables.
                            cmap.length = p.parseUShort();
                            cmap.language = p.parseUShort();
                        
                            // segCount is stored x 2.
                            var segCount;
                            cmap.segCount = segCount = p.parseUShort() &gt;&gt; 1;
                        
                            // Skip searchRange, entrySelector, rangeShift.
                            p.skip(&#x27;uShort&#x27;, 3);
                        
                            // The &quot;unrolled&quot; mapping from character codes to glyph indices.
                            cmap.glyphIndexMap = {};
                        
                            var endCountParser = new parse.Parser(data, start + offset + 14);
                            var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);
                            var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);
                            var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);
                            var glyphIndexOffset = start + offset + 16 + segCount * 8;
                            for (i = 0; i &lt; segCount - 1; i += 1) {
                                var glyphIndex;
                                var endCount = endCountParser.parseUShort();
                                var startCount = startCountParser.parseUShort();
                                var idDelta = idDeltaParser.parseShort();
                                var idRangeOffset = idRangeOffsetParser.parseUShort();
                                for (var c = startCount; c &lt;= endCount; c += 1) {
                                    if (idRangeOffset !== 0) {
                                        // The idRangeOffset is relative to the current position in the idRangeOffset array.
                                        // Take the current offset in the idRangeOffset array.
                                        glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);
                        
                                        // Add the value of the idRangeOffset, which will move us into the glyphIndex array.
                                        glyphIndexOffset += idRangeOffset;
                        
                                        // Then add the character index of the current segment, multiplied by 2 for USHORTs.
                                        glyphIndexOffset += (c - startCount) * 2;
                                        glyphIndex = parse.getUShort(data, glyphIndexOffset);
                                        if (glyphIndex !== 0) {
                                            glyphIndex = (glyphIndex + idDelta) &amp; 0xFFFF;
                                        }
                                    } else {
                                        glyphIndex = (c + idDelta) &amp; 0xFFFF;
                                    }
                        
                                    cmap.glyphIndexMap[c] = glyphIndex;
                                }
                            }
                        
                            return cmap;
                        }
                        
                        function addSegment(t, code, glyphIndex) {
                            t.segments.push({
                                end: code,
                                start: code,
                                delta: -(code - glyphIndex),
                                offset: 0
                            });
                        }
                        
                        function addTerminatorSegment(t) {
                            t.segments.push({
                                end: 0xFFFF,
                                start: 0xFFFF,
                                delta: 1,
                                offset: 0
                            });
                        }
                        
                        function makeCmapTable(glyphs) {
                            var i;
                            var t = new table.Table(&#x27;cmap&#x27;, [
                                {name: &#x27;version&#x27;, type: &#x27;USHORT&#x27;, value: 0},
                                {name: &#x27;numTables&#x27;, type: &#x27;USHORT&#x27;, value: 1},
                                {name: &#x27;platformID&#x27;, type: &#x27;USHORT&#x27;, value: 3},
                                {name: &#x27;encodingID&#x27;, type: &#x27;USHORT&#x27;, value: 1},
                                {name: &#x27;offset&#x27;, type: &#x27;ULONG&#x27;, value: 12},
                                {name: &#x27;format&#x27;, type: &#x27;USHORT&#x27;, value: 4},
                                {name: &#x27;length&#x27;, type: &#x27;USHORT&#x27;, value: 0},
                                {name: &#x27;language&#x27;, type: &#x27;USHORT&#x27;, value: 0},
                                {name: &#x27;segCountX2&#x27;, type: &#x27;USHORT&#x27;, value: 0},
                                {name: &#x27;searchRange&#x27;, type: &#x27;USHORT&#x27;, value: 0},
                                {name: &#x27;entrySelector&#x27;, type: &#x27;USHORT&#x27;, value: 0},
                                {name: &#x27;rangeShift&#x27;, type: &#x27;USHORT&#x27;, value: 0}
                            ]);
                        
                            t.segments = [];
                            for (i = 0; i &lt; glyphs.length; i += 1) {
                                var glyph = glyphs.get(i);
                                for (var j = 0; j &lt; glyph.unicodes.length; j += 1) {
                                    addSegment(t, glyph.unicodes[j], i);
                                }
                        
                                t.segments = t.segments.sort(function(a, b) {
                                    return a.start - b.start;
                                });
                            }
                        
                            addTerminatorSegment(t);
                        
                            var segCount;
                            segCount = t.segments.length;
                            t.segCountX2 = segCount * 2;
                            t.searchRange = Math.pow(2, Math.floor(Math.log(segCount) / Math.log(2))) * 2;
                            t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);
                            t.rangeShift = t.segCountX2 - t.searchRange;
                        
                            // Set up parallel segment arrays.
                            var endCounts = [];
                            var startCounts = [];
                            var idDeltas = [];
                            var idRangeOffsets = [];
                            var glyphIds = [];
                        
                            for (i = 0; i &lt; segCount; i += 1) {
                                var segment = t.segments[i];
                                endCounts = endCounts.concat({name: &#x27;end_&#x27; + i, type: &#x27;USHORT&#x27;, value: segment.end});
                                startCounts = startCounts.concat({name: &#x27;start_&#x27; + i, type: &#x27;USHORT&#x27;, value: segment.start});
                                idDeltas = idDeltas.concat({name: &#x27;idDelta_&#x27; + i, type: &#x27;SHORT&#x27;, value: segment.delta});
                                idRangeOffsets = idRangeOffsets.concat({name: &#x27;idRangeOffset_&#x27; + i, type: &#x27;USHORT&#x27;, value: segment.offset});
                                if (segment.glyphId !== undefined) {
                                    glyphIds = glyphIds.concat({name: &#x27;glyph_&#x27; + i, type: &#x27;USHORT&#x27;, value: segment.glyphId});
                                }
                            }
                        
                            t.fields = t.fields.concat(endCounts);
                            t.fields.push({name: &#x27;reservedPad&#x27;, type: &#x27;USHORT&#x27;, value: 0});
                            t.fields = t.fields.concat(startCounts);
                            t.fields = t.fields.concat(idDeltas);
                            t.fields = t.fields.concat(idRangeOffsets);
                            t.fields = t.fields.concat(glyphIds);
                        
                            t.length = 14 + // Subtable header
                                endCounts.length * 2 +
                                2 + // reservedPad
                                startCounts.length * 2 +
                                idDeltas.length * 2 +
                                idRangeOffsets.length * 2 +
                                glyphIds.length * 2;
                        
                            return t;
                        }
                        
                        exports.parse = parseCmapTable;
                        exports.make = makeCmapTable;
                        
                        },{&quot;../check&quot;:2,&quot;../parse&quot;:9,&quot;../table&quot;:11}],14:[function(_dereq_,module,exports){
                        // The &#x60;glyf&#x60; table describes the glyphs in TrueType outline format.
                        // http://www.microsoft.com/typography/otspec/glyf.htm
                        
                        &#x27;use strict&#x27;;
                        
                        var check = _dereq_(&#x27;../check&#x27;);
                        var glyphset = _dereq_(&#x27;../glyphset&#x27;);
                        var parse = _dereq_(&#x27;../parse&#x27;);
                        var path = _dereq_(&#x27;../path&#x27;);
                        
                        // Parse the coordinate data for a glyph.
                        function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
                            var v;
                            if ((flag &amp; shortVectorBitMask) &gt; 0) {
                                // The coordinate is 1 byte long.
                                v = p.parseByte();
                                // The &#x60;same&#x60; bit is re-used for short values to signify the sign of the value.
                                if ((flag &amp; sameBitMask) === 0) {
                                    v = -v;
                                }
                        
                                v = previousValue + v;
                            } else {
                                //  The coordinate is 2 bytes long.
                                // If the &#x60;same&#x60; bit is set, the coordinate is the same as the previous coordinate.
                                if ((flag &amp; sameBitMask) &gt; 0) {
                                    v = previousValue;
                                } else {
                                    // Parse the coordinate as a signed 16-bit delta value.
                                    v = previousValue + p.parseShort();
                                }
                            }
                        
                            return v;
                        }
                        
                        // Parse a TrueType glyph.
                        function parseGlyph(glyph, data, start) {
                            var p = new parse.Parser(data, start);
                            glyph.numberOfContours = p.parseShort();
                            glyph.xMin = p.parseShort();
                            glyph.yMin = p.parseShort();
                            glyph.xMax = p.parseShort();
                            glyph.yMax = p.parseShort();
                            var flags;
                            var flag;
                            if (glyph.numberOfContours &gt; 0) {
                                var i;
                                // This glyph is not a composite.
                                var endPointIndices = glyph.endPointIndices = [];
                                for (i = 0; i &lt; glyph.numberOfContours; i += 1) {
                                    endPointIndices.push(p.parseUShort());
                                }
                        
                                glyph.instructionLength = p.parseUShort();
                                glyph.instructions = [];
                                for (i = 0; i &lt; glyph.instructionLength; i += 1) {
                                    glyph.instructions.push(p.parseByte());
                                }
                        
                                var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
                                flags = [];
                                for (i = 0; i &lt; numberOfCoordinates; i += 1) {
                                    flag = p.parseByte();
                                    flags.push(flag);
                                    // If bit 3 is set, we repeat this flag n times, where n is the next byte.
                                    if ((flag &amp; 8) &gt; 0) {
                                        var repeatCount = p.parseByte();
                                        for (var j = 0; j &lt; repeatCount; j += 1) {
                                            flags.push(flag);
                                            i += 1;
                                        }
                                    }
                                }
                        
                                check.argument(flags.length === numberOfCoordinates, &#x27;Bad flags.&#x27;);
                        
                                if (endPointIndices.length &gt; 0) {
                                    var points = [];
                                    var point;
                                    // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.
                                    if (numberOfCoordinates &gt; 0) {
                                        for (i = 0; i &lt; numberOfCoordinates; i += 1) {
                                            flag = flags[i];
                                            point = {};
                                            point.onCurve = !!(flag &amp; 1);
                                            point.lastPointOfContour = endPointIndices.indexOf(i) &gt;= 0;
                                            points.push(point);
                                        }
                        
                                        var px = 0;
                                        for (i = 0; i &lt; numberOfCoordinates; i += 1) {
                                            flag = flags[i];
                                            point = points[i];
                                            point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
                                            px = point.x;
                                        }
                        
                                        var py = 0;
                                        for (i = 0; i &lt; numberOfCoordinates; i += 1) {
                                            flag = flags[i];
                                            point = points[i];
                                            point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
                                            py = point.y;
                                        }
                                    }
                        
                                    glyph.points = points;
                                } else {
                                    glyph.points = [];
                                }
                            } else if (glyph.numberOfContours === 0) {
                                glyph.points = [];
                            } else {
                                glyph.isComposite = true;
                                glyph.points = [];
                                glyph.components = [];
                                var moreComponents = true;
                                while (moreComponents) {
                                    flags = p.parseUShort();
                                    var component = {
                                        glyphIndex: p.parseUShort(),
                                        xScale: 1,
                                        scale01: 0,
                                        scale10: 0,
                                        yScale: 1,
                                        dx: 0,
                                        dy: 0
                                    };
                                    if ((flags &amp; 1) &gt; 0) {
                                        // The arguments are words
                                        component.dx = p.parseShort();
                                        component.dy = p.parseShort();
                                    } else {
                                        // The arguments are bytes
                                        component.dx = p.parseChar();
                                        component.dy = p.parseChar();
                                    }
                        
                                    if ((flags &amp; 8) &gt; 0) {
                                        // We have a scale
                                        component.xScale = component.yScale = p.parseF2Dot14();
                                    } else if ((flags &amp; 64) &gt; 0) {
                                        // We have an X / Y scale
                                        component.xScale = p.parseF2Dot14();
                                        component.yScale = p.parseF2Dot14();
                                    } else if ((flags &amp; 128) &gt; 0) {
                                        // We have a 2x2 transformation
                                        component.xScale = p.parseF2Dot14();
                                        component.scale01 = p.parseF2Dot14();
                                        component.scale10 = p.parseF2Dot14();
                                        component.yScale = p.parseF2Dot14();
                                    }
                        
                                    glyph.components.push(component);
                                    moreComponents = !!(flags &amp; 32);
                                }
                            }
                        }
                        
                        // Transform an array of points and return a new array.
                        function transformPoints(points, transform) {
                            var newPoints = [];
                            for (var i = 0; i &lt; points.length; i += 1) {
                                var pt = points[i];
                                var newPt = {
                                    x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
                                    y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
                                    onCurve: pt.onCurve,
                                    lastPointOfContour: pt.lastPointOfContour
                                };
                                newPoints.push(newPt);
                            }
                        
                            return newPoints;
                        }
                        
                        function getContours(points) {
                            var contours = [];
                            var currentContour = [];
                            for (var i = 0; i &lt; points.length; i += 1) {
                                var pt = points[i];
                                currentContour.push(pt);
                                if (pt.lastPointOfContour) {
                                    contours.push(currentContour);
                                    currentContour = [];
                                }
                            }
                        
                            check.argument(currentContour.length === 0, &#x27;There are still points left in the current contour.&#x27;);
                            return contours;
                        }
                        
                        // Convert the TrueType glyph outline to a Path.
                        function getPath(points) {
                            var p = new path.Path();
                            if (!points) {
                                return p;
                            }
                        
                            var contours = getContours(points);
                            for (var i = 0; i &lt; contours.length; i += 1) {
                                var contour = contours[i];
                                var firstPt = contour[0];
                                var lastPt = contour[contour.length - 1];
                                var curvePt;
                                var realFirstPoint;
                                if (firstPt.onCurve) {
                                    curvePt = null;
                                    // The first point will be consumed by the moveTo command,
                                    // so skip it in the loop.
                                    realFirstPoint = true;
                                } else {
                                    if (lastPt.onCurve) {
                                        // If the first point is off-curve and the last point is on-curve,
                                        // start at the last point.
                                        firstPt = lastPt;
                                    } else {
                                        // If both first and last points are off-curve, start at their middle.
                                        firstPt = { x: (firstPt.x + lastPt.x) / 2, y: (firstPt.y + lastPt.y) / 2 };
                                    }
                        
                                    curvePt = firstPt;
                                    // The first point is synthesized, so don&#x27;t skip the real first point.
                                    realFirstPoint = false;
                                }
                        
                                p.moveTo(firstPt.x, firstPt.y);
                        
                                for (var j = realFirstPoint ? 1 : 0; j &lt; contour.length; j += 1) {
                                    var pt = contour[j];
                                    var prevPt = j === 0 ? firstPt : contour[j - 1];
                                    if (prevPt.onCurve &amp;&amp; pt.onCurve) {
                                        // This is a straight line.
                                        p.lineTo(pt.x, pt.y);
                                    } else if (prevPt.onCurve &amp;&amp; !pt.onCurve) {
                                        curvePt = pt;
                                    } else if (!prevPt.onCurve &amp;&amp; !pt.onCurve) {
                                        var midPt = { x: (prevPt.x + pt.x) / 2, y: (prevPt.y + pt.y) / 2 };
                                        p.quadraticCurveTo(prevPt.x, prevPt.y, midPt.x, midPt.y);
                                        curvePt = pt;
                                    } else if (!prevPt.onCurve &amp;&amp; pt.onCurve) {
                                        // Previous point off-curve, this point on-curve.
                                        p.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);
                                        curvePt = null;
                                    } else {
                                        throw new Error(&#x27;Invalid state.&#x27;);
                                    }
                                }
                        
                                if (firstPt !== lastPt) {
                                    // Connect the last and first points
                                    if (curvePt) {
                                        p.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);
                                    } else {
                                        p.lineTo(firstPt.x, firstPt.y);
                                    }
                                }
                            }
                        
                            p.closePath();
                            return p;
                        }
                        
                        function buildPath(glyphs, glyph) {
                            if (glyph.isComposite) {
                                for (var j = 0; j &lt; glyph.components.length; j += 1) {
                                    var component = glyph.components[j];
                                    var componentGlyph = glyphs.get(component.glyphIndex);
                                    if (componentGlyph.points) {
                                        var transformedPoints = transformPoints(componentGlyph.points, component);
                                        glyph.points = glyph.points.concat(transformedPoints);
                                    }
                                }
                            }
                        
                            return getPath(glyph.points);
                        }
                        
                        // Parse all the glyphs according to the offsets from the &#x60;loca&#x60; table.
                        function parseGlyfTable(data, start, loca, font) {
                            var glyphs = new glyphset.GlyphSet(font);
                            var i;
                        
                            // The last element of the loca table is invalid.
                            for (i = 0; i &lt; loca.length - 1; i += 1) {
                                var offset = loca[i];
                                var nextOffset = loca[i + 1];
                                if (offset !== nextOffset) {
                                    glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));
                                } else {
                                    glyphs.push(i, glyphset.glyphLoader(font, i));
                                }
                            }
                        
                            return glyphs;
                        }
                        
                        exports.parse = parseGlyfTable;
                        
                        },{&quot;../check&quot;:2,&quot;../glyphset&quot;:7,&quot;../parse&quot;:9,&quot;../path&quot;:10}],15:[function(_dereq_,module,exports){
                        // The &#x60;GPOS&#x60; table contains kerning pairs, among other things.
                        // https://www.microsoft.com/typography/OTSPEC/gpos.htm
                        
                        &#x27;use strict&#x27;;
                        
                        var check = _dereq_(&#x27;../check&#x27;);
                        var parse = _dereq_(&#x27;../parse&#x27;);
                        
                        // Parse ScriptList and FeatureList tables of GPOS, GSUB, GDEF, BASE, JSTF tables.
                        // These lists are unused by now, this function is just the basis for a real parsing.
                        function parseTaggedListTable(data, start) {
                            var p = new parse.Parser(data, start);
                            var n = p.parseUShort();
                            var list = [];
                            for (var i = 0; i &lt; n; i++) {
                                list[p.parseTag()] = { offset: p.parseUShort() };
                            }
                        
                            return list;
                        }
                        
                        // Parse a coverage table in a GSUB, GPOS or GDEF table.
                        // Format 1 is a simple list of glyph ids,
                        // Format 2 is a list of ranges. It is expanded in a list of glyphs, maybe not the best idea.
                        function parseCoverageTable(data, start) {
                            var p = new parse.Parser(data, start);
                            var format = p.parseUShort();
                            var count =  p.parseUShort();
                            if (format === 1) {
                                return p.parseUShortList(count);
                            }
                            else if (format === 2) {
                                var coverage = [];
                                for (; count--;) {
                                    var begin = p.parseUShort();
                                    var end = p.parseUShort();
                                    var index = p.parseUShort();
                                    for (var i = begin; i &lt;= end; i++) {
                                        coverage[index++] = i;
                                    }
                                }
                        
                                return coverage;
                            }
                        }
                        
                        // Parse a Class Definition Table in a GSUB, GPOS or GDEF table.
                        // Returns a function that gets a class value from a glyph ID.
                        function parseClassDefTable(data, start) {
                            var p = new parse.Parser(data, start);
                            var format = p.parseUShort();
                            if (format === 1) {
                                // Format 1 specifies a range of consecutive glyph indices, one class per glyph ID.
                                var startGlyph = p.parseUShort();
                                var glyphCount = p.parseUShort();
                                var classes = p.parseUShortList(glyphCount);
                                return function(glyphID) {
                                    return classes[glyphID - startGlyph] || 0;
                                };
                            }
                            else if (format === 2) {
                                // Format 2 defines multiple groups of glyph indices that belong to the same class.
                                var rangeCount = p.parseUShort();
                                var startGlyphs = [];
                                var endGlyphs = [];
                                var classValues = [];
                                for (var i = 0; i &lt; rangeCount; i++) {
                                    startGlyphs[i] = p.parseUShort();
                                    endGlyphs[i] = p.parseUShort();
                                    classValues[i] = p.parseUShort();
                                }
                        
                                return function(glyphID) {
                                    var l = 0;
                                    var r = startGlyphs.length - 1;
                                    while (l &lt; r) {
                                        var c = (l + r + 1) &gt;&gt; 1;
                                        if (glyphID &lt; startGlyphs[c]) {
                                            r = c - 1;
                                        } else {
                                            l = c;
                                        }
                                    }
                        
                                    if (startGlyphs[l] &lt;= glyphID &amp;&amp; glyphID &lt;= endGlyphs[l]) {
                                        return classValues[l] || 0;
                                    }
                        
                                    return 0;
                                };
                            }
                        }
                        
                        // Parse a pair adjustment positioning subtable, format 1 or format 2
                        // The subtable is returned in the form of a lookup function.
                        function parsePairPosSubTable(data, start) {
                            var p = new parse.Parser(data, start);
                            // This part is common to format 1 and format 2 subtables
                            var format = p.parseUShort();
                            var coverageOffset = p.parseUShort();
                            var coverage = parseCoverageTable(data, start + coverageOffset);
                            // valueFormat 4: XAdvance only, 1: XPlacement only, 0: no ValueRecord for second glyph
                            // Only valueFormat1=4 and valueFormat2=0 is supported.
                            var valueFormat1 = p.parseUShort();
                            var valueFormat2 = p.parseUShort();
                            var value1;
                            var value2;
                            if (valueFormat1 !== 4 || valueFormat2 !== 0) return;
                            var sharedPairSets = {};
                            if (format === 1) {
                                // Pair Positioning Adjustment: Format 1
                                var pairSetCount = p.parseUShort();
                                var pairSet = [];
                                // Array of offsets to PairSet tables-from beginning of PairPos subtable-ordered by Coverage Index
                                var pairSetOffsets = p.parseOffset16List(pairSetCount);
                                for (var firstGlyph = 0; firstGlyph &lt; pairSetCount; firstGlyph++) {
                                    var pairSetOffset = pairSetOffsets[firstGlyph];
                                    var sharedPairSet = sharedPairSets[pairSetOffset];
                                    if (!sharedPairSet) {
                                        // Parse a pairset table in a pair adjustment subtable format 1
                                        sharedPairSet = {};
                                        p.relativeOffset = pairSetOffset;
                                        var pairValueCount = p.parseUShort();
                                        for (; pairValueCount--;) {
                                            var secondGlyph = p.parseUShort();
                                            if (valueFormat1) value1 = p.parseShort();
                                            if (valueFormat2) value2 = p.parseShort();
                                            // We only support valueFormat1 = 4 and valueFormat2 = 0,
                                            // so value1 is the XAdvance and value2 is empty.
                                            sharedPairSet[secondGlyph] = value1;
                                        }
                                    }
                        
                                    pairSet[coverage[firstGlyph]] = sharedPairSet;
                                }
                        
                                return function(leftGlyph, rightGlyph) {
                                    var pairs = pairSet[leftGlyph];
                                    if (pairs) return pairs[rightGlyph];
                                };
                            }
                            else if (format === 2) {
                                // Pair Positioning Adjustment: Format 2
                                var classDef1Offset = p.parseUShort();
                                var classDef2Offset = p.parseUShort();
                                var class1Count = p.parseUShort();
                                var class2Count = p.parseUShort();
                                var getClass1 = parseClassDefTable(data, start + classDef1Offset);
                                var getClass2 = parseClassDefTable(data, start + classDef2Offset);
                        
                                // Parse kerning values by class pair.
                                var kerningMatrix = [];
                                for (var i = 0; i &lt; class1Count; i++) {
                                    var kerningRow = kerningMatrix[i] = [];
                                    for (var j = 0; j &lt; class2Count; j++) {
                                        if (valueFormat1) value1 = p.parseShort();
                                        if (valueFormat2) value2 = p.parseShort();
                                        // We only support valueFormat1 = 4 and valueFormat2 = 0,
                                        // so value1 is the XAdvance and value2 is empty.
                                        kerningRow[j] = value1;
                                    }
                                }
                        
                                // Convert coverage list to a hash
                                var covered = {};
                                for (i = 0; i &lt; coverage.length; i++) covered[coverage[i]] = 1;
                        
                                // Get the kerning value for a specific glyph pair.
                                return function(leftGlyph, rightGlyph) {
                                    if (!covered[leftGlyph]) return;
                                    var class1 = getClass1(leftGlyph);
                                    var class2 = getClass2(rightGlyph);
                                    var kerningRow = kerningMatrix[class1];
                        
                                    if (kerningRow) {
                                        return kerningRow[class2];
                                    }
                                };
                            }
                        }
                        
                        // Parse a LookupTable (present in of GPOS, GSUB, GDEF, BASE, JSTF tables).
                        function parseLookupTable(data, start) {
                            var p = new parse.Parser(data, start);
                            var lookupType = p.parseUShort();
                            var lookupFlag = p.parseUShort();
                            var useMarkFilteringSet = lookupFlag &amp; 0x10;
                            var subTableCount = p.parseUShort();
                            var subTableOffsets = p.parseOffset16List(subTableCount);
                            var table = {
                                lookupType: lookupType,
                                lookupFlag: lookupFlag,
                                markFilteringSet: useMarkFilteringSet ? p.parseUShort() : -1
                            };
                            // LookupType 2, Pair adjustment
                            if (lookupType === 2) {
                                var subtables = [];
                                for (var i = 0; i &lt; subTableCount; i++) {
                                    subtables.push(parsePairPosSubTable(data, start + subTableOffsets[i]));
                                }
                                // Return a function which finds the kerning values in the subtables.
                                table.getKerningValue = function(leftGlyph, rightGlyph) {
                                    for (var i = subtables.length; i--;) {
                                        var value = subtables[i](leftGlyph, rightGlyph);
                                        if (value !== undefined) return value;
                                    }
                        
                                    return 0;
                                };
                            }
                        
                            return table;
                        }
                        
                        // Parse the &#x60;GPOS&#x60; table which contains, among other things, kerning pairs.
                        // https://www.microsoft.com/typography/OTSPEC/gpos.htm
                        function parseGposTable(data, start, font) {
                            var p = new parse.Parser(data, start);
                            var tableVersion = p.parseFixed();
                            check.argument(tableVersion === 1, &#x27;Unsupported GPOS table version.&#x27;);
                        
                            // ScriptList and FeatureList - ignored for now
                            parseTaggedListTable(data, start + p.parseUShort());
                            // &#x27;kern&#x27; is the feature we are looking for.
                            parseTaggedListTable(data, start + p.parseUShort());
                        
                            // LookupList
                            var lookupListOffset = p.parseUShort();
                            p.relativeOffset = lookupListOffset;
                            var lookupCount = p.parseUShort();
                            var lookupTableOffsets = p.parseOffset16List(lookupCount);
                            var lookupListAbsoluteOffset = start + lookupListOffset;
                            for (var i = 0; i &lt; lookupCount; i++) {
                                var table = parseLookupTable(data, lookupListAbsoluteOffset + lookupTableOffsets[i]);
                                if (table.lookupType === 2 &amp;&amp; !font.getGposKerningValue) font.getGposKerningValue = table.getKerningValue;
                            }
                        }
                        
                        exports.parse = parseGposTable;
                        
                        },{&quot;../check&quot;:2,&quot;../parse&quot;:9}],16:[function(_dereq_,module,exports){
                        // The &#x60;head&#x60; table contains global information about the font.
                        // https://www.microsoft.com/typography/OTSPEC/head.htm
                        
                        &#x27;use strict&#x27;;
                        
                        var check = _dereq_(&#x27;../check&#x27;);
                        var parse = _dereq_(&#x27;../parse&#x27;);
                        var table = _dereq_(&#x27;../table&#x27;);
                        
                        // Parse the header &#x60;head&#x60; table
                        function parseHeadTable(data, start) {
                            var head = {};
                            var p = new parse.Parser(data, start);
                            head.version = p.parseVersion();
                            head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;
                            head.checkSumAdjustment = p.parseULong();
                            head.magicNumber = p.parseULong();
                            check.argument(head.magicNumber === 0x5F0F3CF5, &#x27;Font header has wrong magic number.&#x27;);
                            head.flags = p.parseUShort();
                            head.unitsPerEm = p.parseUShort();
                            head.created = p.parseLongDateTime();
                            head.modified = p.parseLongDateTime();
                            head.xMin = p.parseShort();
                            head.yMin = p.parseShort();
                            head.xMax = p.parseShort();
                            head.yMax = p.parseShort();
                            head.macStyle = p.parseUShort();
                            head.lowestRecPPEM = p.parseUShort();
                            head.fontDirectionHint = p.parseShort();
                            head.indexToLocFormat = p.parseShort();     // 50
                            head.glyphDataFormat = p.parseShort();
                            return head;
                        }
                        
                        function makeHeadTable(options) {
                            return new table.Table(&#x27;head&#x27;, [
                                {name: &#x27;version&#x27;, type: &#x27;FIXED&#x27;, value: 0x00010000},
                                {name: &#x27;fontRevision&#x27;, type: &#x27;FIXED&#x27;, value: 0x00010000},
                                {name: &#x27;checkSumAdjustment&#x27;, type: &#x27;ULONG&#x27;, value: 0},
                                {name: &#x27;magicNumber&#x27;, type: &#x27;ULONG&#x27;, value: 0x5F0F3CF5},
                                {name: &#x27;flags&#x27;, type: &#x27;USHORT&#x27;, value: 0},
                                {name: &#x27;unitsPerEm&#x27;, type: &#x27;USHORT&#x27;, value: 1000},
                                {name: &#x27;created&#x27;, type: &#x27;LONGDATETIME&#x27;, value: 0},
                                {name: &#x27;modified&#x27;, type: &#x27;LONGDATETIME&#x27;, value: 0},
                                {name: &#x27;xMin&#x27;, type: &#x27;SHORT&#x27;, value: 0},
                                {name: &#x27;yMin&#x27;, type: &#x27;SHORT&#x27;, value: 0},
                                {name: &#x27;xMax&#x27;, type: &#x27;SHORT&#x27;, value: 0},
                                {name: &#x27;yMax&#x27;, type: &#x27;SHORT&#x27;, value: 0},
                                {name: &#x27;macStyle&#x27;, type: &#x27;USHORT&#x27;, value: 0},
                                {name: &#x27;lowestRecPPEM&#x27;, type: &#x27;USHORT&#x27;, value: 0},
                                {name: &#x27;fontDirectionHint&#x27;, type: &#x27;SHORT&#x27;, value: 2},
                                {name: &#x27;indexToLocFormat&#x27;, type: &#x27;SHORT&#x27;, value: 0},
                                {name: &#x27;glyphDataFormat&#x27;, type: &#x27;SHORT&#x27;, value: 0}
                            ], options);
                        }
                        
                        exports.parse = parseHeadTable;
                        exports.make = makeHeadTable;
                        
                        },{&quot;../check&quot;:2,&quot;../parse&quot;:9,&quot;../table&quot;:11}],17:[function(_dereq_,module,exports){
                        // The &#x60;hhea&#x60; table contains information for horizontal layout.
                        // https://www.microsoft.com/typography/OTSPEC/hhea.htm
                        
                        &#x27;use strict&#x27;;
                        
                        var parse = _dereq_(&#x27;../parse&#x27;);
                        var table = _dereq_(&#x27;../table&#x27;);
                        
                        // Parse the horizontal header &#x60;hhea&#x60; table
                        function parseHheaTable(data, start) {
                            var hhea = {};
                            var p = new parse.Parser(data, start);
                            hhea.version = p.parseVersion();
                            hhea.ascender = p.parseShort();
                            hhea.descender = p.parseShort();
                            hhea.lineGap = p.parseShort();
                            hhea.advanceWidthMax = p.parseUShort();
                            hhea.minLeftSideBearing = p.parseShort();
                            hhea.minRightSideBearing = p.parseShort();
                            hhea.xMaxExtent = p.parseShort();
                            hhea.caretSlopeRise = p.parseShort();
                            hhea.caretSlopeRun = p.parseShort();
                            hhea.caretOffset = p.parseShort();
                            p.relativeOffset += 8;
                            hhea.metricDataFormat = p.parseShort();
                            hhea.numberOfHMetrics = p.parseUShort();
                            return hhea;
                        }
                        
                        function makeHheaTable(options) {
                            return new table.Table(&#x27;hhea&#x27;, [
                                {name: &#x27;version&#x27;, type: &#x27;FIXED&#x27;, value: 0x00010000},
                                {name: &#x27;ascender&#x27;, type: &#x27;FWORD&#x27;, value: 0},
                                {name: &#x27;descender&#x27;, type: &#x27;FWORD&#x27;, value: 0},
                                {name: &#x27;lineGap&#x27;, type: &#x27;FWORD&#x27;, value: 0},
                                {name: &#x27;advanceWidthMax&#x27;, type: &#x27;UFWORD&#x27;, value: 0},
                                {name: &#x27;minLeftSideBearing&#x27;, type: &#x27;FWORD&#x27;, value: 0},
                                {name: &#x27;minRightSideBearing&#x27;, type: &#x27;FWORD&#x27;, value: 0},
                                {name: &#x27;xMaxExtent&#x27;, type: &#x27;FWORD&#x27;, value: 0},
                                {name: &#x27;caretSlopeRise&#x27;, type: &#x27;SHORT&#x27;, value: 1},
                                {name: &#x27;caretSlopeRun&#x27;, type: &#x27;SHORT&#x27;, value: 0},
                                {name: &#x27;caretOffset&#x27;, type: &#x27;SHORT&#x27;, value: 0},
                                {name: &#x27;reserved1&#x27;, type: &#x27;SHORT&#x27;, value: 0},
                                {name: &#x27;reserved2&#x27;, type: &#x27;SHORT&#x27;, value: 0},
                                {name: &#x27;reserved3&#x27;, type: &#x27;SHORT&#x27;, value: 0},
                                {name: &#x27;reserved4&#x27;, type: &#x27;SHORT&#x27;, value: 0},
                                {name: &#x27;metricDataFormat&#x27;, type: &#x27;SHORT&#x27;, value: 0},
                                {name: &#x27;numberOfHMetrics&#x27;, type: &#x27;USHORT&#x27;, value: 0}
                            ], options);
                        }
                        
                        exports.parse = parseHheaTable;
                        exports.make = makeHheaTable;
                        
                        },{&quot;../parse&quot;:9,&quot;../table&quot;:11}],18:[function(_dereq_,module,exports){
                        // The &#x60;hmtx&#x60; table contains the horizontal metrics for all glyphs.
                        // https://www.microsoft.com/typography/OTSPEC/hmtx.htm
                        
                        &#x27;use strict&#x27;;
                        
                        var parse = _dereq_(&#x27;../parse&#x27;);
                        var table = _dereq_(&#x27;../table&#x27;);
                        
                        // Parse the &#x60;hmtx&#x60; table, which contains the horizontal metrics for all glyphs.
                        // This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.
                        function parseHmtxTable(data, start, numMetrics, numGlyphs, glyphs) {
                            var advanceWidth;
                            var leftSideBearing;
                            var p = new parse.Parser(data, start);
                            for (var i = 0; i &lt; numGlyphs; i += 1) {
                                // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.
                                if (i &lt; numMetrics) {
                                    advanceWidth = p.parseUShort();
                                    leftSideBearing = p.parseShort();
                                }
                        
                                var glyph = glyphs.get(i);
                                glyph.advanceWidth = advanceWidth;
                                glyph.leftSideBearing = leftSideBearing;
                            }
                        }
                        
                        function makeHmtxTable(glyphs) {
                            var t = new table.Table(&#x27;hmtx&#x27;, []);
                            for (var i = 0; i &lt; glyphs.length; i += 1) {
                                var glyph = glyphs.get(i);
                                var advanceWidth = glyph.advanceWidth || 0;
                                var leftSideBearing = glyph.leftSideBearing || 0;
                                t.fields.push({name: &#x27;advanceWidth_&#x27; + i, type: &#x27;USHORT&#x27;, value: advanceWidth});
                                t.fields.push({name: &#x27;leftSideBearing_&#x27; + i, type: &#x27;SHORT&#x27;, value: leftSideBearing});
                            }
                        
                            return t;
                        }
                        
                        exports.parse = parseHmtxTable;
                        exports.make = makeHmtxTable;
                        
                        },{&quot;../parse&quot;:9,&quot;../table&quot;:11}],19:[function(_dereq_,module,exports){
                        // The &#x60;kern&#x60; table contains kerning pairs.
                        // Note that some fonts use the GPOS OpenType layout table to specify kerning.
                        // https://www.microsoft.com/typography/OTSPEC/kern.htm
                        
                        &#x27;use strict&#x27;;
                        
                        var check = _dereq_(&#x27;../check&#x27;);
                        var parse = _dereq_(&#x27;../parse&#x27;);
                        
                        // Parse the &#x60;kern&#x60; table which contains kerning pairs.
                        function parseKernTable(data, start) {
                            var pairs = {};
                            var p = new parse.Parser(data, start);
                            var tableVersion = p.parseUShort();
                            check.argument(tableVersion === 0, &#x27;Unsupported kern table version.&#x27;);
                            // Skip nTables.
                            p.skip(&#x27;uShort&#x27;, 1);
                            var subTableVersion = p.parseUShort();
                            check.argument(subTableVersion === 0, &#x27;Unsupported kern sub-table version.&#x27;);
                            // Skip subTableLength, subTableCoverage
                            p.skip(&#x27;uShort&#x27;, 2);
                            var nPairs = p.parseUShort();
                            // Skip searchRange, entrySelector, rangeShift.
                            p.skip(&#x27;uShort&#x27;, 3);
                            for (var i = 0; i &lt; nPairs; i += 1) {
                                var leftIndex = p.parseUShort();
                                var rightIndex = p.parseUShort();
                                var value = p.parseShort();
                                pairs[leftIndex + &#x27;,&#x27; + rightIndex] = value;
                            }
                        
                            return pairs;
                        }
                        
                        exports.parse = parseKernTable;
                        
                        },{&quot;../check&quot;:2,&quot;../parse&quot;:9}],20:[function(_dereq_,module,exports){
                        // The &#x60;loca&#x60; table stores the offsets to the locations of the glyphs in the font.
                        // https://www.microsoft.com/typography/OTSPEC/loca.htm
                        
                        &#x27;use strict&#x27;;
                        
                        var parse = _dereq_(&#x27;../parse&#x27;);
                        
                        // Parse the &#x60;loca&#x60; table. This table stores the offsets to the locations of the glyphs in the font,
                        // relative to the beginning of the glyphData table.
                        // The number of glyphs stored in the &#x60;loca&#x60; table is specified in the &#x60;maxp&#x60; table (under numGlyphs)
                        // The loca table has two versions: a short version where offsets are stored as uShorts, and a long
                        // version where offsets are stored as uLongs. The &#x60;head&#x60; table specifies which version to use
                        // (under indexToLocFormat).
                        function parseLocaTable(data, start, numGlyphs, shortVersion) {
                            var p = new parse.Parser(data, start);
                            var parseFn = shortVersion ? p.parseUShort : p.parseULong;
                            // There is an extra entry after the last index element to compute the length of the last glyph.
                            // That&#x27;s why we use numGlyphs + 1.
                            var glyphOffsets = [];
                            for (var i = 0; i &lt; numGlyphs + 1; i += 1) {
                                var glyphOffset = parseFn.call(p);
                                if (shortVersion) {
                                    // The short table version stores the actual offset divided by 2.
                                    glyphOffset *= 2;
                                }
                        
                                glyphOffsets.push(glyphOffset);
                            }
                        
                            return glyphOffsets;
                        }
                        
                        exports.parse = parseLocaTable;
                        
                        },{&quot;../parse&quot;:9}],21:[function(_dereq_,module,exports){
                        // The &#x60;maxp&#x60; table establishes the memory requirements for the font.
                        // We need it just to get the number of glyphs in the font.
                        // https://www.microsoft.com/typography/OTSPEC/maxp.htm
                        
                        &#x27;use strict&#x27;;
                        
                        var parse = _dereq_(&#x27;../parse&#x27;);
                        var table = _dereq_(&#x27;../table&#x27;);
                        
                        // Parse the maximum profile &#x60;maxp&#x60; table.
                        function parseMaxpTable(data, start) {
                            var maxp = {};
                            var p = new parse.Parser(data, start);
                            maxp.version = p.parseVersion();
                            maxp.numGlyphs = p.parseUShort();
                            if (maxp.version === 1.0) {
                                maxp.maxPoints = p.parseUShort();
                                maxp.maxContours = p.parseUShort();
                                maxp.maxCompositePoints = p.parseUShort();
                                maxp.maxCompositeContours = p.parseUShort();
                                maxp.maxZones = p.parseUShort();
                                maxp.maxTwilightPoints = p.parseUShort();
                                maxp.maxStorage = p.parseUShort();
                                maxp.maxFunctionDefs = p.parseUShort();
                                maxp.maxInstructionDefs = p.parseUShort();
                                maxp.maxStackElements = p.parseUShort();
                                maxp.maxSizeOfInstructions = p.parseUShort();
                                maxp.maxComponentElements = p.parseUShort();
                                maxp.maxComponentDepth = p.parseUShort();
                            }
                        
                            return maxp;
                        }
                        
                        function makeMaxpTable(numGlyphs) {
                            return new table.Table(&#x27;maxp&#x27;, [
                                {name: &#x27;version&#x27;, type: &#x27;FIXED&#x27;, value: 0x00005000},
                                {name: &#x27;numGlyphs&#x27;, type: &#x27;USHORT&#x27;, value: numGlyphs}
                            ]);
                        }
                        
                        exports.parse = parseMaxpTable;
                        exports.make = makeMaxpTable;
                        
                        },{&quot;../parse&quot;:9,&quot;../table&quot;:11}],22:[function(_dereq_,module,exports){
                        // The &#x60;name&#x60; naming table.
                        // https://www.microsoft.com/typography/OTSPEC/name.htm
                        
                        &#x27;use strict&#x27;;
                        
                        var encode = _dereq_(&#x27;../types&#x27;).encode;
                        var parse = _dereq_(&#x27;../parse&#x27;);
                        var table = _dereq_(&#x27;../table&#x27;);
                        
                        // NameIDs for the name table.
                        var nameTableNames = [
                            &#x27;copyright&#x27;,              // 0
                            &#x27;fontFamily&#x27;,             // 1
                            &#x27;fontSubfamily&#x27;,          // 2
                            &#x27;uniqueID&#x27;,               // 3
                            &#x27;fullName&#x27;,               // 4
                            &#x27;version&#x27;,                // 5
                            &#x27;postScriptName&#x27;,         // 6
                            &#x27;trademark&#x27;,              // 7
                            &#x27;manufacturer&#x27;,           // 8
                            &#x27;designer&#x27;,               // 9
                            &#x27;description&#x27;,            // 10
                            &#x27;manufacturerURL&#x27;,        // 11
                            &#x27;designerURL&#x27;,            // 12
                            &#x27;licence&#x27;,                // 13
                            &#x27;licenceURL&#x27;,             // 14
                            &#x27;reserved&#x27;,               // 15
                            &#x27;preferredFamily&#x27;,        // 16
                            &#x27;preferredSubfamily&#x27;,     // 17
                            &#x27;compatibleFullName&#x27;,     // 18
                            &#x27;sampleText&#x27;,             // 19
                            &#x27;postScriptFindFontName&#x27;, // 20
                            &#x27;wwsFamily&#x27;,              // 21
                            &#x27;wwsSubfamily&#x27;            // 22
                        ];
                        
                        // Parse the naming &#x60;name&#x60; table
                        // Only Windows Unicode English names are supported.
                        // Format 1 additional fields are not supported
                        function parseNameTable(data, start) {
                            var name = {};
                            var p = new parse.Parser(data, start);
                            name.format = p.parseUShort();
                            var count = p.parseUShort();
                            var stringOffset = p.offset + p.parseUShort();
                            var unknownCount = 0;
                            for (var i = 0; i &lt; count; i++) {
                                var platformID = p.parseUShort();
                                var encodingID = p.parseUShort();
                                var languageID = p.parseUShort();
                                var nameID = p.parseUShort();
                                var property = nameTableNames[nameID];
                                var byteLength = p.parseUShort();
                                var offset = p.parseUShort();
                                // platformID - encodingID - languageID standard combinations :
                                // 1 - 0 - 0 : Macintosh, Roman, English
                                // 3 - 1 - 0x409 : Windows, Unicode BMP (UCS-2), en-US
                                if (platformID === 3 &amp;&amp; encodingID === 1 &amp;&amp; languageID === 0x409) {
                                    var codePoints = [];
                                    var length = byteLength / 2;
                                    for (var j = 0; j &lt; length; j++, offset += 2) {
                                        codePoints[j] = parse.getShort(data, stringOffset + offset);
                                    }
                        
                                    var str = String.fromCharCode.apply(null, codePoints);
                                    if (property) {
                                        name[property] = str;
                                    }
                                    else {
                                        unknownCount++;
                                        name[&#x27;unknown&#x27; + unknownCount] = str;
                                    }
                                }
                        
                            }
                        
                            if (name.format === 1) {
                                name.langTagCount = p.parseUShort();
                            }
                        
                            return name;
                        }
                        
                        function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {
                            return new table.Table(&#x27;NameRecord&#x27;, [
                                {name: &#x27;platformID&#x27;, type: &#x27;USHORT&#x27;, value: platformID},
                                {name: &#x27;encodingID&#x27;, type: &#x27;USHORT&#x27;, value: encodingID},
                                {name: &#x27;languageID&#x27;, type: &#x27;USHORT&#x27;, value: languageID},
                                {name: &#x27;nameID&#x27;, type: &#x27;USHORT&#x27;, value: nameID},
                                {name: &#x27;length&#x27;, type: &#x27;USHORT&#x27;, value: length},
                                {name: &#x27;offset&#x27;, type: &#x27;USHORT&#x27;, value: offset}
                            ]);
                        }
                        
                        function addMacintoshNameRecord(t, recordID, s, offset) {
                            // Macintosh, Roman, English
                            var stringBytes = encode.STRING(s);
                            t.records.push(makeNameRecord(1, 0, 0, recordID, stringBytes.length, offset));
                            t.strings.push(stringBytes);
                            offset += stringBytes.length;
                            return offset;
                        }
                        
                        function addWindowsNameRecord(t, recordID, s, offset) {
                            // Windows, Unicode BMP (UCS-2), US English
                            var utf16Bytes = encode.UTF16(s);
                            t.records.push(makeNameRecord(3, 1, 0x0409, recordID, utf16Bytes.length, offset));
                            t.strings.push(utf16Bytes);
                            offset += utf16Bytes.length;
                            return offset;
                        }
                        
                        function makeNameTable(options) {
                            var t = new table.Table(&#x27;name&#x27;, [
                                {name: &#x27;format&#x27;, type: &#x27;USHORT&#x27;, value: 0},
                                {name: &#x27;count&#x27;, type: &#x27;USHORT&#x27;, value: 0},
                                {name: &#x27;stringOffset&#x27;, type: &#x27;USHORT&#x27;, value: 0}
                            ]);
                            t.records = [];
                            t.strings = [];
                            var offset = 0;
                            var i;
                            var s;
                            // Add Macintosh records first
                            for (i = 0; i &lt; nameTableNames.length; i += 1) {
                                if (options[nameTableNames[i]] !== undefined) {
                                    s = options[nameTableNames[i]];
                                    offset = addMacintoshNameRecord(t, i, s, offset);
                                }
                            }
                            // Then add Windows records
                            for (i = 0; i &lt; nameTableNames.length; i += 1) {
                                if (options[nameTableNames[i]] !== undefined) {
                                    s = options[nameTableNames[i]];
                                    offset = addWindowsNameRecord(t, i, s, offset);
                                }
                            }
                        
                            t.count = t.records.length;
                            t.stringOffset = 6 + t.count * 12;
                            for (i = 0; i &lt; t.records.length; i += 1) {
                                t.fields.push({name: &#x27;record_&#x27; + i, type: &#x27;TABLE&#x27;, value: t.records[i]});
                            }
                        
                            for (i = 0; i &lt; t.strings.length; i += 1) {
                                t.fields.push({name: &#x27;string_&#x27; + i, type: &#x27;LITERAL&#x27;, value: t.strings[i]});
                            }
                        
                            return t;
                        }
                        
                        exports.parse = parseNameTable;
                        exports.make = makeNameTable;
                        
                        },{&quot;../parse&quot;:9,&quot;../table&quot;:11,&quot;../types&quot;:26}],23:[function(_dereq_,module,exports){
                        // The &#x60;OS/2&#x60; table contains metrics required in OpenType fonts.
                        // https://www.microsoft.com/typography/OTSPEC/os2.htm
                        
                        &#x27;use strict&#x27;;
                        
                        var parse = _dereq_(&#x27;../parse&#x27;);
                        var table = _dereq_(&#x27;../table&#x27;);
                        
                        var unicodeRanges = [
                            {begin: 0x0000, end: 0x007F}, // Basic Latin
                            {begin: 0x0080, end: 0x00FF}, // Latin-1 Supplement
                            {begin: 0x0100, end: 0x017F}, // Latin Extended-A
                            {begin: 0x0180, end: 0x024F}, // Latin Extended-B
                            {begin: 0x0250, end: 0x02AF}, // IPA Extensions
                            {begin: 0x02B0, end: 0x02FF}, // Spacing Modifier Letters
                            {begin: 0x0300, end: 0x036F}, // Combining Diacritical Marks
                            {begin: 0x0370, end: 0x03FF}, // Greek and Coptic
                            {begin: 0x2C80, end: 0x2CFF}, // Coptic
                            {begin: 0x0400, end: 0x04FF}, // Cyrillic
                            {begin: 0x0530, end: 0x058F}, // Armenian
                            {begin: 0x0590, end: 0x05FF}, // Hebrew
                            {begin: 0xA500, end: 0xA63F}, // Vai
                            {begin: 0x0600, end: 0x06FF}, // Arabic
                            {begin: 0x07C0, end: 0x07FF}, // NKo
                            {begin: 0x0900, end: 0x097F}, // Devanagari
                            {begin: 0x0980, end: 0x09FF}, // Bengali
                            {begin: 0x0A00, end: 0x0A7F}, // Gurmukhi
                            {begin: 0x0A80, end: 0x0AFF}, // Gujarati
                            {begin: 0x0B00, end: 0x0B7F}, // Oriya
                            {begin: 0x0B80, end: 0x0BFF}, // Tamil
                            {begin: 0x0C00, end: 0x0C7F}, // Telugu
                            {begin: 0x0C80, end: 0x0CFF}, // Kannada
                            {begin: 0x0D00, end: 0x0D7F}, // Malayalam
                            {begin: 0x0E00, end: 0x0E7F}, // Thai
                            {begin: 0x0E80, end: 0x0EFF}, // Lao
                            {begin: 0x10A0, end: 0x10FF}, // Georgian
                            {begin: 0x1B00, end: 0x1B7F}, // Balinese
                            {begin: 0x1100, end: 0x11FF}, // Hangul Jamo
                            {begin: 0x1E00, end: 0x1EFF}, // Latin Extended Additional
                            {begin: 0x1F00, end: 0x1FFF}, // Greek Extended
                            {begin: 0x2000, end: 0x206F}, // General Punctuation
                            {begin: 0x2070, end: 0x209F}, // Superscripts And Subscripts
                            {begin: 0x20A0, end: 0x20CF}, // Currency Symbol
                            {begin: 0x20D0, end: 0x20FF}, // Combining Diacritical Marks For Symbols
                            {begin: 0x2100, end: 0x214F}, // Letterlike Symbols
                            {begin: 0x2150, end: 0x218F}, // Number Forms
                            {begin: 0x2190, end: 0x21FF}, // Arrows
                            {begin: 0x2200, end: 0x22FF}, // Mathematical Operators
                            {begin: 0x2300, end: 0x23FF}, // Miscellaneous Technical
                            {begin: 0x2400, end: 0x243F}, // Control Pictures
                            {begin: 0x2440, end: 0x245F}, // Optical Character Recognition
                            {begin: 0x2460, end: 0x24FF}, // Enclosed Alphanumerics
                            {begin: 0x2500, end: 0x257F}, // Box Drawing
                            {begin: 0x2580, end: 0x259F}, // Block Elements
                            {begin: 0x25A0, end: 0x25FF}, // Geometric Shapes
                            {begin: 0x2600, end: 0x26FF}, // Miscellaneous Symbols
                            {begin: 0x2700, end: 0x27BF}, // Dingbats
                            {begin: 0x3000, end: 0x303F}, // CJK Symbols And Punctuation
                            {begin: 0x3040, end: 0x309F}, // Hiragana
                            {begin: 0x30A0, end: 0x30FF}, // Katakana
                            {begin: 0x3100, end: 0x312F}, // Bopomofo
                            {begin: 0x3130, end: 0x318F}, // Hangul Compatibility Jamo
                            {begin: 0xA840, end: 0xA87F}, // Phags-pa
                            {begin: 0x3200, end: 0x32FF}, // Enclosed CJK Letters And Months
                            {begin: 0x3300, end: 0x33FF}, // CJK Compatibility
                            {begin: 0xAC00, end: 0xD7AF}, // Hangul Syllables
                            {begin: 0xD800, end: 0xDFFF}, // Non-Plane 0 *
                            {begin: 0x10900, end: 0x1091F}, // Phoenicia
                            {begin: 0x4E00, end: 0x9FFF}, // CJK Unified Ideographs
                            {begin: 0xE000, end: 0xF8FF}, // Private Use Area (plane 0)
                            {begin: 0x31C0, end: 0x31EF}, // CJK Strokes
                            {begin: 0xFB00, end: 0xFB4F}, // Alphabetic Presentation Forms
                            {begin: 0xFB50, end: 0xFDFF}, // Arabic Presentation Forms-A
                            {begin: 0xFE20, end: 0xFE2F}, // Combining Half Marks
                            {begin: 0xFE10, end: 0xFE1F}, // Vertical Forms
                            {begin: 0xFE50, end: 0xFE6F}, // Small Form Variants
                            {begin: 0xFE70, end: 0xFEFF}, // Arabic Presentation Forms-B
                            {begin: 0xFF00, end: 0xFFEF}, // Halfwidth And Fullwidth Forms
                            {begin: 0xFFF0, end: 0xFFFF}, // Specials
                            {begin: 0x0F00, end: 0x0FFF}, // Tibetan
                            {begin: 0x0700, end: 0x074F}, // Syriac
                            {begin: 0x0780, end: 0x07BF}, // Thaana
                            {begin: 0x0D80, end: 0x0DFF}, // Sinhala
                            {begin: 0x1000, end: 0x109F}, // Myanmar
                            {begin: 0x1200, end: 0x137F}, // Ethiopic
                            {begin: 0x13A0, end: 0x13FF}, // Cherokee
                            {begin: 0x1400, end: 0x167F}, // Unified Canadian Aboriginal Syllabics
                            {begin: 0x1680, end: 0x169F}, // Ogham
                            {begin: 0x16A0, end: 0x16FF}, // Runic
                            {begin: 0x1780, end: 0x17FF}, // Khmer
                            {begin: 0x1800, end: 0x18AF}, // Mongolian
                            {begin: 0x2800, end: 0x28FF}, // Braille Patterns
                            {begin: 0xA000, end: 0xA48F}, // Yi Syllables
                            {begin: 0x1700, end: 0x171F}, // Tagalog
                            {begin: 0x10300, end: 0x1032F}, // Old Italic
                            {begin: 0x10330, end: 0x1034F}, // Gothic
                            {begin: 0x10400, end: 0x1044F}, // Deseret
                            {begin: 0x1D000, end: 0x1D0FF}, // Byzantine Musical Symbols
                            {begin: 0x1D400, end: 0x1D7FF}, // Mathematical Alphanumeric Symbols
                            {begin: 0xFF000, end: 0xFFFFD}, // Private Use (plane 15)
                            {begin: 0xFE00, end: 0xFE0F}, // Variation Selectors
                            {begin: 0xE0000, end: 0xE007F}, // Tags
                            {begin: 0x1900, end: 0x194F}, // Limbu
                            {begin: 0x1950, end: 0x197F}, // Tai Le
                            {begin: 0x1980, end: 0x19DF}, // New Tai Lue
                            {begin: 0x1A00, end: 0x1A1F}, // Buginese
                            {begin: 0x2C00, end: 0x2C5F}, // Glagolitic
                            {begin: 0x2D30, end: 0x2D7F}, // Tifinagh
                            {begin: 0x4DC0, end: 0x4DFF}, // Yijing Hexagram Symbols
                            {begin: 0xA800, end: 0xA82F}, // Syloti Nagri
                            {begin: 0x10000, end: 0x1007F}, // Linear B Syllabary
                            {begin: 0x10140, end: 0x1018F}, // Ancient Greek Numbers
                            {begin: 0x10380, end: 0x1039F}, // Ugaritic
                            {begin: 0x103A0, end: 0x103DF}, // Old Persian
                            {begin: 0x10450, end: 0x1047F}, // Shavian
                            {begin: 0x10480, end: 0x104AF}, // Osmanya
                            {begin: 0x10800, end: 0x1083F}, // Cypriot Syllabary
                            {begin: 0x10A00, end: 0x10A5F}, // Kharoshthi
                            {begin: 0x1D300, end: 0x1D35F}, // Tai Xuan Jing Symbols
                            {begin: 0x12000, end: 0x123FF}, // Cuneiform
                            {begin: 0x1D360, end: 0x1D37F}, // Counting Rod Numerals
                            {begin: 0x1B80, end: 0x1BBF}, // Sundanese
                            {begin: 0x1C00, end: 0x1C4F}, // Lepcha
                            {begin: 0x1C50, end: 0x1C7F}, // Ol Chiki
                            {begin: 0xA880, end: 0xA8DF}, // Saurashtra
                            {begin: 0xA900, end: 0xA92F}, // Kayah Li
                            {begin: 0xA930, end: 0xA95F}, // Rejang
                            {begin: 0xAA00, end: 0xAA5F}, // Cham
                            {begin: 0x10190, end: 0x101CF}, // Ancient Symbols
                            {begin: 0x101D0, end: 0x101FF}, // Phaistos Disc
                            {begin: 0x102A0, end: 0x102DF}, // Carian
                            {begin: 0x1F030, end: 0x1F09F}  // Domino Tiles
                        ];
                        
                        function getUnicodeRange(unicode) {
                            for (var i = 0; i &lt; unicodeRanges.length; i += 1) {
                                var range = unicodeRanges[i];
                                if (unicode &gt;= range.begin &amp;&amp; unicode &lt; range.end) {
                                    return i;
                                }
                            }
                        
                            return -1;
                        }
                        
                        // Parse the OS/2 and Windows metrics &#x60;OS/2&#x60; table
                        function parseOS2Table(data, start) {
                            var os2 = {};
                            var p = new parse.Parser(data, start);
                            os2.version = p.parseUShort();
                            os2.xAvgCharWidth = p.parseShort();
                            os2.usWeightClass = p.parseUShort();
                            os2.usWidthClass = p.parseUShort();
                            os2.fsType = p.parseUShort();
                            os2.ySubscriptXSize = p.parseShort();
                            os2.ySubscriptYSize = p.parseShort();
                            os2.ySubscriptXOffset = p.parseShort();
                            os2.ySubscriptYOffset = p.parseShort();
                            os2.ySuperscriptXSize = p.parseShort();
                            os2.ySuperscriptYSize = p.parseShort();
                            os2.ySuperscriptXOffset = p.parseShort();
                            os2.ySuperscriptYOffset = p.parseShort();
                            os2.yStrikeoutSize = p.parseShort();
                            os2.yStrikeoutPosition = p.parseShort();
                            os2.sFamilyClass = p.parseShort();
                            os2.panose = [];
                            for (var i = 0; i &lt; 10; i++) {
                                os2.panose[i] = p.parseByte();
                            }
                        
                            os2.ulUnicodeRange1 = p.parseULong();
                            os2.ulUnicodeRange2 = p.parseULong();
                            os2.ulUnicodeRange3 = p.parseULong();
                            os2.ulUnicodeRange4 = p.parseULong();
                            os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
                            os2.fsSelection = p.parseUShort();
                            os2.usFirstCharIndex = p.parseUShort();
                            os2.usLastCharIndex = p.parseUShort();
                            os2.sTypoAscender = p.parseShort();
                            os2.sTypoDescender = p.parseShort();
                            os2.sTypoLineGap = p.parseShort();
                            os2.usWinAscent = p.parseUShort();
                            os2.usWinDescent = p.parseUShort();
                            if (os2.version &gt;= 1) {
                                os2.ulCodePageRange1 = p.parseULong();
                                os2.ulCodePageRange2 = p.parseULong();
                            }
                        
                            if (os2.version &gt;= 2) {
                                os2.sxHeight = p.parseShort();
                                os2.sCapHeight = p.parseShort();
                                os2.usDefaultChar = p.parseUShort();
                                os2.usBreakChar = p.parseUShort();
                                os2.usMaxContent = p.parseUShort();
                            }
                        
                            return os2;
                        }
                        
                        function makeOS2Table(options) {
                            return new table.Table(&#x27;OS/2&#x27;, [
                                {name: &#x27;version&#x27;, type: &#x27;USHORT&#x27;, value: 0x0003},
                                {name: &#x27;xAvgCharWidth&#x27;, type: &#x27;SHORT&#x27;, value: 0},
                                {name: &#x27;usWeightClass&#x27;, type: &#x27;USHORT&#x27;, value: 0},
                                {name: &#x27;usWidthClass&#x27;, type: &#x27;USHORT&#x27;, value: 0},
                                {name: &#x27;fsType&#x27;, type: &#x27;USHORT&#x27;, value: 0},
                                {name: &#x27;ySubscriptXSize&#x27;, type: &#x27;SHORT&#x27;, value: 650},
                                {name: &#x27;ySubscriptYSize&#x27;, type: &#x27;SHORT&#x27;, value: 699},
                                {name: &#x27;ySubscriptXOffset&#x27;, type: &#x27;SHORT&#x27;, value: 0},
                                {name: &#x27;ySubscriptYOffset&#x27;, type: &#x27;SHORT&#x27;, value: 140},
                                {name: &#x27;ySuperscriptXSize&#x27;, type: &#x27;SHORT&#x27;, value: 650},
                                {name: &#x27;ySuperscriptYSize&#x27;, type: &#x27;SHORT&#x27;, value: 699},
                                {name: &#x27;ySuperscriptXOffset&#x27;, type: &#x27;SHORT&#x27;, value: 0},
                                {name: &#x27;ySuperscriptYOffset&#x27;, type: &#x27;SHORT&#x27;, value: 479},
                                {name: &#x27;yStrikeoutSize&#x27;, type: &#x27;SHORT&#x27;, value: 49},
                                {name: &#x27;yStrikeoutPosition&#x27;, type: &#x27;SHORT&#x27;, value: 258},
                                {name: &#x27;sFamilyClass&#x27;, type: &#x27;SHORT&#x27;, value: 0},
                                {name: &#x27;bFamilyType&#x27;, type: &#x27;BYTE&#x27;, value: 0},
                                {name: &#x27;bSerifStyle&#x27;, type: &#x27;BYTE&#x27;, value: 0},
                                {name: &#x27;bWeight&#x27;, type: &#x27;BYTE&#x27;, value: 0},
                                {name: &#x27;bProportion&#x27;, type: &#x27;BYTE&#x27;, value: 0},
                                {name: &#x27;bContrast&#x27;, type: &#x27;BYTE&#x27;, value: 0},
                                {name: &#x27;bStrokeVariation&#x27;, type: &#x27;BYTE&#x27;, value: 0},
                                {name: &#x27;bArmStyle&#x27;, type: &#x27;BYTE&#x27;, value: 0},
                                {name: &#x27;bLetterform&#x27;, type: &#x27;BYTE&#x27;, value: 0},
                                {name: &#x27;bMidline&#x27;, type: &#x27;BYTE&#x27;, value: 0},
                                {name: &#x27;bXHeight&#x27;, type: &#x27;BYTE&#x27;, value: 0},
                                {name: &#x27;ulUnicodeRange1&#x27;, type: &#x27;ULONG&#x27;, value: 0},
                                {name: &#x27;ulUnicodeRange2&#x27;, type: &#x27;ULONG&#x27;, value: 0},
                                {name: &#x27;ulUnicodeRange3&#x27;, type: &#x27;ULONG&#x27;, value: 0},
                                {name: &#x27;ulUnicodeRange4&#x27;, type: &#x27;ULONG&#x27;, value: 0},
                                {name: &#x27;achVendID&#x27;, type: &#x27;CHARARRAY&#x27;, value: &#x27;XXXX&#x27;},
                                {name: &#x27;fsSelection&#x27;, type: &#x27;USHORT&#x27;, value: 0},
                                {name: &#x27;usFirstCharIndex&#x27;, type: &#x27;USHORT&#x27;, value: 0},
                                {name: &#x27;usLastCharIndex&#x27;, type: &#x27;USHORT&#x27;, value: 0},
                                {name: &#x27;sTypoAscender&#x27;, type: &#x27;SHORT&#x27;, value: 0},
                                {name: &#x27;sTypoDescender&#x27;, type: &#x27;SHORT&#x27;, value: 0},
                                {name: &#x27;sTypoLineGap&#x27;, type: &#x27;SHORT&#x27;, value: 0},
                                {name: &#x27;usWinAscent&#x27;, type: &#x27;USHORT&#x27;, value: 0},
                                {name: &#x27;usWinDescent&#x27;, type: &#x27;USHORT&#x27;, value: 0},
                                {name: &#x27;ulCodePageRange1&#x27;, type: &#x27;ULONG&#x27;, value: 0},
                                {name: &#x27;ulCodePageRange2&#x27;, type: &#x27;ULONG&#x27;, value: 0},
                                {name: &#x27;sxHeight&#x27;, type: &#x27;SHORT&#x27;, value: 0},
                                {name: &#x27;sCapHeight&#x27;, type: &#x27;SHORT&#x27;, value: 0},
                                {name: &#x27;usDefaultChar&#x27;, type: &#x27;USHORT&#x27;, value: 0},
                                {name: &#x27;usBreakChar&#x27;, type: &#x27;USHORT&#x27;, value: 0},
                                {name: &#x27;usMaxContext&#x27;, type: &#x27;USHORT&#x27;, value: 0}
                            ], options);
                        }
                        
                        exports.unicodeRanges = unicodeRanges;
                        exports.getUnicodeRange = getUnicodeRange;
                        exports.parse = parseOS2Table;
                        exports.make = makeOS2Table;
                        
                        },{&quot;../parse&quot;:9,&quot;../table&quot;:11}],24:[function(_dereq_,module,exports){
                        // The &#x60;post&#x60; table stores additional PostScript information, such as glyph names.
                        // https://www.microsoft.com/typography/OTSPEC/post.htm
                        
                        &#x27;use strict&#x27;;
                        
                        var encoding = _dereq_(&#x27;../encoding&#x27;);
                        var parse = _dereq_(&#x27;../parse&#x27;);
                        var table = _dereq_(&#x27;../table&#x27;);
                        
                        // Parse the PostScript &#x60;post&#x60; table
                        function parsePostTable(data, start) {
                            var post = {};
                            var p = new parse.Parser(data, start);
                            var i;
                            post.version = p.parseVersion();
                            post.italicAngle = p.parseFixed();
                            post.underlinePosition = p.parseShort();
                            post.underlineThickness = p.parseShort();
                            post.isFixedPitch = p.parseULong();
                            post.minMemType42 = p.parseULong();
                            post.maxMemType42 = p.parseULong();
                            post.minMemType1 = p.parseULong();
                            post.maxMemType1 = p.parseULong();
                            switch (post.version) {
                            case 1:
                                post.names = encoding.standardNames.slice();
                                break;
                            case 2:
                                post.numberOfGlyphs = p.parseUShort();
                                post.glyphNameIndex = new Array(post.numberOfGlyphs);
                                for (i = 0; i &lt; post.numberOfGlyphs; i++) {
                                    post.glyphNameIndex[i] = p.parseUShort();
                                }
                        
                                post.names = [];
                                for (i = 0; i &lt; post.numberOfGlyphs; i++) {
                                    if (post.glyphNameIndex[i] &gt;= encoding.standardNames.length) {
                                        var nameLength = p.parseChar();
                                        post.names.push(p.parseString(nameLength));
                                    }
                                }
                        
                                break;
                            case 2.5:
                                post.numberOfGlyphs = p.parseUShort();
                                post.offset = new Array(post.numberOfGlyphs);
                                for (i = 0; i &lt; post.numberOfGlyphs; i++) {
                                    post.offset[i] = p.parseChar();
                                }
                        
                                break;
                            }
                            return post;
                        }
                        
                        function makePostTable() {
                            return new table.Table(&#x27;post&#x27;, [
                                {name: &#x27;version&#x27;, type: &#x27;FIXED&#x27;, value: 0x00030000},
                                {name: &#x27;italicAngle&#x27;, type: &#x27;FIXED&#x27;, value: 0},
                                {name: &#x27;underlinePosition&#x27;, type: &#x27;FWORD&#x27;, value: 0},
                                {name: &#x27;underlineThickness&#x27;, type: &#x27;FWORD&#x27;, value: 0},
                                {name: &#x27;isFixedPitch&#x27;, type: &#x27;ULONG&#x27;, value: 0},
                                {name: &#x27;minMemType42&#x27;, type: &#x27;ULONG&#x27;, value: 0},
                                {name: &#x27;maxMemType42&#x27;, type: &#x27;ULONG&#x27;, value: 0},
                                {name: &#x27;minMemType1&#x27;, type: &#x27;ULONG&#x27;, value: 0},
                                {name: &#x27;maxMemType1&#x27;, type: &#x27;ULONG&#x27;, value: 0}
                            ]);
                        }
                        
                        exports.parse = parsePostTable;
                        exports.make = makePostTable;
                        
                        },{&quot;../encoding&quot;:4,&quot;../parse&quot;:9,&quot;../table&quot;:11}],25:[function(_dereq_,module,exports){
                        // The &#x60;sfnt&#x60; wrapper provides organization for the tables in the font.
                        // It is the top-level data structure in a font.
                        // https://www.microsoft.com/typography/OTSPEC/otff.htm
                        // Recommendations for creating OpenType Fonts:
                        // http://www.microsoft.com/typography/otspec140/recom.htm
                        
                        &#x27;use strict&#x27;;
                        
                        var check = _dereq_(&#x27;../check&#x27;);
                        var table = _dereq_(&#x27;../table&#x27;);
                        
                        var cmap = _dereq_(&#x27;./cmap&#x27;);
                        var cff = _dereq_(&#x27;./cff&#x27;);
                        var head = _dereq_(&#x27;./head&#x27;);
                        var hhea = _dereq_(&#x27;./hhea&#x27;);
                        var hmtx = _dereq_(&#x27;./hmtx&#x27;);
                        var maxp = _dereq_(&#x27;./maxp&#x27;);
                        var _name = _dereq_(&#x27;./name&#x27;);
                        var os2 = _dereq_(&#x27;./os2&#x27;);
                        var post = _dereq_(&#x27;./post&#x27;);
                        
                        function log2(v) {
                            return Math.log(v) / Math.log(2) | 0;
                        }
                        
                        function computeCheckSum(bytes) {
                            while (bytes.length % 4 !== 0) {
                                bytes.push(0);
                            }
                        
                            var sum = 0;
                            for (var i = 0; i &lt; bytes.length; i += 4) {
                                sum += (bytes[i] &lt;&lt; 24) +
                                    (bytes[i + 1] &lt;&lt; 16) +
                                    (bytes[i + 2] &lt;&lt; 8) +
                                    (bytes[i + 3]);
                            }
                        
                            sum %= Math.pow(2, 32);
                            return sum;
                        }
                        
                        function makeTableRecord(tag, checkSum, offset, length) {
                            return new table.Table(&#x27;Table Record&#x27;, [
                                {name: &#x27;tag&#x27;, type: &#x27;TAG&#x27;, value: tag !== undefined ? tag : &#x27;&#x27;},
                                {name: &#x27;checkSum&#x27;, type: &#x27;ULONG&#x27;, value: checkSum !== undefined ? checkSum : 0},
                                {name: &#x27;offset&#x27;, type: &#x27;ULONG&#x27;, value: offset !== undefined ? offset : 0},
                                {name: &#x27;length&#x27;, type: &#x27;ULONG&#x27;, value: length !== undefined ? length : 0}
                            ]);
                        }
                        
                        function makeSfntTable(tables) {
                            var sfnt = new table.Table(&#x27;sfnt&#x27;, [
                                {name: &#x27;version&#x27;, type: &#x27;TAG&#x27;, value: &#x27;OTTO&#x27;},
                                {name: &#x27;numTables&#x27;, type: &#x27;USHORT&#x27;, value: 0},
                                {name: &#x27;searchRange&#x27;, type: &#x27;USHORT&#x27;, value: 0},
                                {name: &#x27;entrySelector&#x27;, type: &#x27;USHORT&#x27;, value: 0},
                                {name: &#x27;rangeShift&#x27;, type: &#x27;USHORT&#x27;, value: 0}
                            ]);
                            sfnt.tables = tables;
                            sfnt.numTables = tables.length;
                            var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));
                            sfnt.searchRange = 16 * highestPowerOf2;
                            sfnt.entrySelector = log2(highestPowerOf2);
                            sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;
                        
                            var recordFields = [];
                            var tableFields = [];
                        
                            var offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);
                            while (offset % 4 !== 0) {
                                offset += 1;
                                tableFields.push({name: &#x27;padding&#x27;, type: &#x27;BYTE&#x27;, value: 0});
                            }
                        
                            for (var i = 0; i &lt; tables.length; i += 1) {
                                var t = tables[i];
                                check.argument(t.tableName.length === 4, &#x27;Table name&#x27; + t.tableName + &#x27; is invalid.&#x27;);
                                var tableLength = t.sizeOf();
                                var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);
                                recordFields.push({name: tableRecord.tag + &#x27; Table Record&#x27;, type: &#x27;TABLE&#x27;, value: tableRecord});
                                tableFields.push({name: t.tableName + &#x27; table&#x27;, type: &#x27;TABLE&#x27;, value: t});
                                offset += tableLength;
                                check.argument(!isNaN(offset), &#x27;Something went wrong calculating the offset.&#x27;);
                                while (offset % 4 !== 0) {
                                    offset += 1;
                                    tableFields.push({name: &#x27;padding&#x27;, type: &#x27;BYTE&#x27;, value: 0});
                                }
                            }
                        
                            // Table records need to be sorted alphabetically.
                            recordFields.sort(function(r1, r2) {
                                if (r1.value.tag &gt; r2.value.tag) {
                                    return 1;
                                } else {
                                    return -1;
                                }
                            });
                        
                            sfnt.fields = sfnt.fields.concat(recordFields);
                            sfnt.fields = sfnt.fields.concat(tableFields);
                            return sfnt;
                        }
                        
                        // Get the metrics for a character. If the string has more than one character
                        // this function returns metrics for the first available character.
                        // You can provide optional fallback metrics if no characters are available.
                        function metricsForChar(font, chars, notFoundMetrics) {
                            for (var i = 0; i &lt; chars.length; i += 1) {
                                var glyphIndex = font.charToGlyphIndex(chars[i]);
                                if (glyphIndex &gt; 0) {
                                    var glyph = font.glyphs.get(glyphIndex);
                                    return glyph.getMetrics();
                                }
                            }
                        
                            return notFoundMetrics;
                        }
                        
                        function average(vs) {
                            var sum = 0;
                            for (var i = 0; i &lt; vs.length; i += 1) {
                                sum += vs[i];
                            }
                        
                            return sum / vs.length;
                        }
                        
                        // Convert the font object to a SFNT data structure.
                        // This structure contains all the necessary tables and metadata to create a binary OTF file.
                        function fontToSfntTable(font) {
                            var xMins = [];
                            var yMins = [];
                            var xMaxs = [];
                            var yMaxs = [];
                            var advanceWidths = [];
                            var leftSideBearings = [];
                            var rightSideBearings = [];
                            var firstCharIndex;
                            var lastCharIndex = 0;
                            var ulUnicodeRange1 = 0;
                            var ulUnicodeRange2 = 0;
                            var ulUnicodeRange3 = 0;
                            var ulUnicodeRange4 = 0;
                        
                            for (var i = 0; i &lt; font.glyphs.length; i += 1) {
                                var glyph = font.glyphs.get(i);
                                var unicode = glyph.unicode | 0;
                                if (firstCharIndex &gt; unicode || firstCharIndex === null) {
                                    firstCharIndex = unicode;
                                }
                        
                                if (lastCharIndex &lt; unicode) {
                                    lastCharIndex = unicode;
                                }
                        
                                var position = os2.getUnicodeRange(unicode);
                                if (position &lt; 32) {
                                    ulUnicodeRange1 |= 1 &lt;&lt; position;
                                } else if (position &lt; 64) {
                                    ulUnicodeRange2 |= 1 &lt;&lt; position - 32;
                                } else if (position &lt; 96) {
                                    ulUnicodeRange3 |= 1 &lt;&lt; position - 64;
                                } else if (position &lt; 123) {
                                    ulUnicodeRange4 |= 1 &lt;&lt; position - 96;
                                } else {
                                    throw new Error(&#x27;Unicode ranges bits &gt; 123 are reserved for internal usage&#x27;);
                                }
                                // Skip non-important characters.
                                if (glyph.name === &#x27;.notdef&#x27;) continue;
                                var metrics = glyph.getMetrics();
                                xMins.push(metrics.xMin);
                                yMins.push(metrics.yMin);
                                xMaxs.push(metrics.xMax);
                                yMaxs.push(metrics.yMax);
                                leftSideBearings.push(metrics.leftSideBearing);
                                rightSideBearings.push(metrics.rightSideBearing);
                                advanceWidths.push(glyph.advanceWidth);
                            }
                        
                            var globals = {
                                xMin: Math.min.apply(null, xMins),
                                yMin: Math.min.apply(null, yMins),
                                xMax: Math.max.apply(null, xMaxs),
                                yMax: Math.max.apply(null, yMaxs),
                                advanceWidthMax: Math.max.apply(null, advanceWidths),
                                advanceWidthAvg: average(advanceWidths),
                                minLeftSideBearing: Math.min.apply(null, leftSideBearings),
                                maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
                                minRightSideBearing: Math.min.apply(null, rightSideBearings)
                            };
                            globals.ascender = font.ascender !== undefined ? font.ascender : globals.yMax;
                            globals.descender = font.descender !== undefined ? font.descender : globals.yMin;
                        
                            var headTable = head.make({
                                unitsPerEm: font.unitsPerEm,
                                xMin: globals.xMin,
                                yMin: globals.yMin,
                                xMax: globals.xMax,
                                yMax: globals.yMax
                            });
                        
                            var hheaTable = hhea.make({
                                ascender: globals.ascender,
                                descender: globals.descender,
                                advanceWidthMax: globals.advanceWidthMax,
                                minLeftSideBearing: globals.minLeftSideBearing,
                                minRightSideBearing: globals.minRightSideBearing,
                                xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
                                numberOfHMetrics: font.glyphs.length
                            });
                        
                            var maxpTable = maxp.make(font.glyphs.length);
                        
                            var os2Table = os2.make({
                                xAvgCharWidth: Math.round(globals.advanceWidthAvg),
                                usWeightClass: 500, // Medium FIXME Make this configurable
                                usWidthClass: 5, // Medium (normal) FIXME Make this configurable
                                usFirstCharIndex: firstCharIndex,
                                usLastCharIndex: lastCharIndex,
                                ulUnicodeRange1: ulUnicodeRange1,
                                ulUnicodeRange2: ulUnicodeRange2,
                                ulUnicodeRange3: ulUnicodeRange3,
                                ulUnicodeRange4: ulUnicodeRange4,
                                // See http://typophile.com/node/13081 for more info on vertical metrics.
                                // We get metrics for typical characters (such as &quot;x&quot; for xHeight).
                                // We provide some fallback characters if characters are unavailable: their
                                // ordering was chosen experimentally.
                                sTypoAscender: globals.ascender,
                                sTypoDescender: globals.descender,
                                sTypoLineGap: 0,
                                usWinAscent: globals.ascender,
                                usWinDescent: -globals.descender,
                                sxHeight: metricsForChar(font, &#x27;xyvw&#x27;, {yMax: 0}).yMax,
                                sCapHeight: metricsForChar(font, &#x27;HIKLEFJMNTZBDPRAGOQSUVWXY&#x27;, globals).yMax,
                                usBreakChar: font.hasChar(&#x27; &#x27;) ? 32 : 0 // Use space as the break character, if available.
                            });
                        
                            var hmtxTable = hmtx.make(font.glyphs);
                            var cmapTable = cmap.make(font.glyphs);
                        
                            var fullName = font.familyName + &#x27; &#x27; + font.styleName;
                            var postScriptName = font.familyName.replace(/\s/g, &#x27;&#x27;) + &#x27;-&#x27; + font.styleName;
                            var nameTable = _name.make({
                                copyright: font.copyright,
                                fontFamily: font.familyName,
                                fontSubfamily: font.styleName,
                                uniqueID: font.manufacturer + &#x27;:&#x27; + fullName,
                                fullName: fullName,
                                version: font.version,
                                postScriptName: postScriptName,
                                trademark: font.trademark,
                                manufacturer: font.manufacturer,
                                designer: font.designer,
                                description: font.description,
                                manufacturerURL: font.manufacturerURL,
                                designerURL: font.designerURL,
                                license: font.license,
                                licenseURL: font.licenseURL,
                                preferredFamily: font.familyName,
                                preferredSubfamily: font.styleName
                            });
                            var postTable = post.make();
                            var cffTable = cff.make(font.glyphs, {
                                version: font.version,
                                fullName: fullName,
                                familyName: font.familyName,
                                weightName: font.styleName,
                                postScriptName: postScriptName,
                                unitsPerEm: font.unitsPerEm
                            });
                            // Order the tables according to the the OpenType specification 1.4.
                            var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];
                        
                            var sfntTable = makeSfntTable(tables);
                        
                            // Compute the font&#x27;s checkSum and store it in head.checkSumAdjustment.
                            var bytes = sfntTable.encode();
                            var checkSum = computeCheckSum(bytes);
                            var tableFields = sfntTable.fields;
                            var checkSumAdjusted = false;
                            for (i = 0; i &lt; tableFields.length; i += 1) {
                                if (tableFields[i].name === &#x27;head table&#x27;) {
                                    tableFields[i].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;
                                    checkSumAdjusted = true;
                                    break;
                                }
                            }
                        
                            if (!checkSumAdjusted) {
                                throw new Error(&#x27;Could not find head table with checkSum to adjust.&#x27;);
                            }
                        
                            return sfntTable;
                        }
                        
                        exports.computeCheckSum = computeCheckSum;
                        exports.make = makeSfntTable;
                        exports.fontToTable = fontToSfntTable;
                        
                        },{&quot;../check&quot;:2,&quot;../table&quot;:11,&quot;./cff&quot;:12,&quot;./cmap&quot;:13,&quot;./head&quot;:16,&quot;./hhea&quot;:17,&quot;./hmtx&quot;:18,&quot;./maxp&quot;:21,&quot;./name&quot;:22,&quot;./os2&quot;:23,&quot;./post&quot;:24}],26:[function(_dereq_,module,exports){
                        // Data types used in the OpenType font file.
                        // All OpenType fonts use Motorola-style byte ordering (Big Endian)
                        
                        /* global WeakMap */
                        
                        &#x27;use strict&#x27;;
                        
                        var check = _dereq_(&#x27;./check&#x27;);
                        
                        var LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15
                        var LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31
                        
                        var decode = {};
                        var encode = {};
                        var sizeOf = {};
                        
                        // Return a function that always returns the same value.
                        function constant(v) {
                            return function() {
                                return v;
                            };
                        }
                        
                        // OpenType data types //////////////////////////////////////////////////////
                        
                        // Convert an 8-bit unsigned integer to a list of 1 byte.
                        encode.BYTE = function(v) {
                            check.argument(v &gt;= 0 &amp;&amp; v &lt;= 255, &#x27;Byte value should be between 0 and 255.&#x27;);
                            return [v];
                        };
                        
                        sizeOf.BYTE = constant(1);
                        
                        // Convert a 8-bit signed integer to a list of 1 byte.
                        encode.CHAR = function(v) {
                            return [v.charCodeAt(0)];
                        };
                        
                        sizeOf.BYTE = constant(1);
                        
                        // Convert an ASCII string to a list of bytes.
                        encode.CHARARRAY = function(v) {
                            var b = [];
                            for (var i = 0; i &lt; v.length; i += 1) {
                                b.push(v.charCodeAt(i));
                            }
                        
                            return b;
                        };
                        
                        sizeOf.CHARARRAY = function(v) {
                            return v.length;
                        };
                        
                        // Convert a 16-bit unsigned integer to a list of 2 bytes.
                        encode.USHORT = function(v) {
                            return [(v &gt;&gt; 8) &amp; 0xFF, v &amp; 0xFF];
                        };
                        
                        sizeOf.USHORT = constant(2);
                        
                        // Convert a 16-bit signed integer to a list of 2 bytes.
                        encode.SHORT = function(v) {
                            // Two&#x27;s complement
                            if (v &gt;= LIMIT16) {
                                v = -(2 * LIMIT16 - v);
                            }
                        
                            return [(v &gt;&gt; 8) &amp; 0xFF, v &amp; 0xFF];
                        };
                        
                        sizeOf.SHORT = constant(2);
                        
                        // Convert a 24-bit unsigned integer to a list of 3 bytes.
                        encode.UINT24 = function(v) {
                            return [(v &gt;&gt; 16) &amp; 0xFF, (v &gt;&gt; 8) &amp; 0xFF, v &amp; 0xFF];
                        };
                        
                        sizeOf.UINT24 = constant(3);
                        
                        // Convert a 32-bit unsigned integer to a list of 4 bytes.
                        encode.ULONG = function(v) {
                            return [(v &gt;&gt; 24) &amp; 0xFF, (v &gt;&gt; 16) &amp; 0xFF, (v &gt;&gt; 8) &amp; 0xFF, v &amp; 0xFF];
                        };
                        
                        sizeOf.ULONG = constant(4);
                        
                        // Convert a 32-bit unsigned integer to a list of 4 bytes.
                        encode.LONG = function(v) {
                            // Two&#x27;s complement
                            if (v &gt;= LIMIT32) {
                                v = -(2 * LIMIT32 - v);
                            }
                        
                            return [(v &gt;&gt; 24) &amp; 0xFF, (v &gt;&gt; 16) &amp; 0xFF, (v &gt;&gt; 8) &amp; 0xFF, v &amp; 0xFF];
                        };
                        
                        sizeOf.LONG = constant(4);
                        
                        encode.FIXED = encode.ULONG;
                        sizeOf.FIXED = sizeOf.ULONG;
                        
                        encode.FWORD = encode.SHORT;
                        sizeOf.FWORD = sizeOf.SHORT;
                        
                        encode.UFWORD = encode.USHORT;
                        sizeOf.UFWORD = sizeOf.USHORT;
                        
                        // FIXME Implement LONGDATETIME
                        encode.LONGDATETIME = function() {
                            return [0, 0, 0, 0, 0, 0, 0, 0];
                        };
                        
                        sizeOf.LONGDATETIME = constant(8);
                        
                        // Convert a 4-char tag to a list of 4 bytes.
                        encode.TAG = function(v) {
                            check.argument(v.length === 4, &#x27;Tag should be exactly 4 ASCII characters.&#x27;);
                            return [v.charCodeAt(0),
                                    v.charCodeAt(1),
                                    v.charCodeAt(2),
                                    v.charCodeAt(3)];
                        };
                        
                        sizeOf.TAG = constant(4);
                        
                        // CFF data types ///////////////////////////////////////////////////////////
                        
                        encode.Card8 = encode.BYTE;
                        sizeOf.Card8 = sizeOf.BYTE;
                        
                        encode.Card16 = encode.USHORT;
                        sizeOf.Card16 = sizeOf.USHORT;
                        
                        encode.OffSize = encode.BYTE;
                        sizeOf.OffSize = sizeOf.BYTE;
                        
                        encode.SID = encode.USHORT;
                        sizeOf.SID = sizeOf.USHORT;
                        
                        // Convert a numeric operand or charstring number to a variable-size list of bytes.
                        encode.NUMBER = function(v) {
                            if (v &gt;= -107 &amp;&amp; v &lt;= 107) {
                                return [v + 139];
                            } else if (v &gt;= 108 &amp;&amp; v &lt;= 1131) {
                                v = v - 108;
                                return [(v &gt;&gt; 8) + 247, v &amp; 0xFF];
                            } else if (v &gt;= -1131 &amp;&amp; v &lt;= -108) {
                                v = -v - 108;
                                return [(v &gt;&gt; 8) + 251, v &amp; 0xFF];
                            } else if (v &gt;= -32768 &amp;&amp; v &lt;= 32767) {
                                return encode.NUMBER16(v);
                            } else {
                                return encode.NUMBER32(v);
                            }
                        };
                        
                        sizeOf.NUMBER = function(v) {
                            return encode.NUMBER(v).length;
                        };
                        
                        // Convert a signed number between -32768 and +32767 to a three-byte value.
                        // This ensures we always use three bytes, but is not the most compact format.
                        encode.NUMBER16 = function(v) {
                            return [28, (v &gt;&gt; 8) &amp; 0xFF, v &amp; 0xFF];
                        };
                        
                        sizeOf.NUMBER16 = constant(2);
                        
                        // Convert a signed number between -(2^31) and +(2^31-1) to a four-byte value.
                        // This is useful if you want to be sure you always use four bytes,
                        // at the expense of wasting a few bytes for smaller numbers.
                        encode.NUMBER32 = function(v) {
                            return [29, (v &gt;&gt; 24) &amp; 0xFF, (v &gt;&gt; 16) &amp; 0xFF, (v &gt;&gt; 8) &amp; 0xFF, v &amp; 0xFF];
                        };
                        
                        sizeOf.NUMBER32 = constant(4);
                        
                        encode.REAL = function(v) {
                            var value = v.toString();
                        
                            // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)
                            // This code converts it back to a number without the epsilon.
                            var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
                            if (m) {
                                var epsilon = parseFloat(&#x27;1e&#x27; + ((m[2] ? +m[2] : 0) + m[1].length));
                                value = (Math.round(v * epsilon) / epsilon).toString();
                            }
                        
                            var nibbles = &#x27;&#x27;;
                            var i;
                            var ii;
                            for (i = 0, ii = value.length; i &lt; ii; i += 1) {
                                var c = value[i];
                                if (c === &#x27;e&#x27;) {
                                    nibbles += value[++i] === &#x27;-&#x27; ? &#x27;c&#x27; : &#x27;b&#x27;;
                                } else if (c === &#x27;.&#x27;) {
                                    nibbles += &#x27;a&#x27;;
                                } else if (c === &#x27;-&#x27;) {
                                    nibbles += &#x27;e&#x27;;
                                } else {
                                    nibbles += c;
                                }
                            }
                        
                            nibbles += (nibbles.length &amp; 1) ? &#x27;f&#x27; : &#x27;ff&#x27;;
                            var out = [30];
                            for (i = 0, ii = nibbles.length; i &lt; ii; i += 2) {
                                out.push(parseInt(nibbles.substr(i, 2), 16));
                            }
                        
                            return out;
                        };
                        
                        sizeOf.REAL = function(v) {
                            return encode.REAL(v).length;
                        };
                        
                        encode.NAME = encode.CHARARRAY;
                        sizeOf.NAME = sizeOf.CHARARRAY;
                        
                        encode.STRING = encode.CHARARRAY;
                        sizeOf.STRING = sizeOf.CHARARRAY;
                        
                        // Convert a ASCII string to a list of UTF16 bytes.
                        encode.UTF16 = function(v) {
                            var b = [];
                            for (var i = 0; i &lt; v.length; i += 1) {
                                b.push(0);
                                b.push(v.charCodeAt(i));
                            }
                        
                            return b;
                        };
                        
                        sizeOf.UTF16 = function(v) {
                            return v.length * 2;
                        };
                        
                        // Convert a list of values to a CFF INDEX structure.
                        // The values should be objects containing name / type / value.
                        encode.INDEX = function(l) {
                            var i;
                            //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,
                            //    dataSize, i, v;
                            // Because we have to know which data type to use to encode the offsets,
                            // we have to go through the values twice: once to encode the data and
                            // calculate the offets, then again to encode the offsets using the fitting data type.
                            var offset = 1; // First offset is always 1.
                            var offsets = [offset];
                            var data = [];
                            var dataSize = 0;
                            for (i = 0; i &lt; l.length; i += 1) {
                                var v = encode.OBJECT(l[i]);
                                Array.prototype.push.apply(data, v);
                                dataSize += v.length;
                                offset += v.length;
                                offsets.push(offset);
                            }
                        
                            if (data.length === 0) {
                                return [0, 0];
                            }
                        
                            var encodedOffsets = [];
                            var offSize = (1 + Math.floor(Math.log(dataSize) / Math.log(2)) / 8) | 0;
                            var offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];
                            for (i = 0; i &lt; offsets.length; i += 1) {
                                var encodedOffset = offsetEncoder(offsets[i]);
                                Array.prototype.push.apply(encodedOffsets, encodedOffset);
                            }
                        
                            return Array.prototype.concat(encode.Card16(l.length),
                                                   encode.OffSize(offSize),
                                                   encodedOffsets,
                                                   data);
                        };
                        
                        sizeOf.INDEX = function(v) {
                            return encode.INDEX(v).length;
                        };
                        
                        // Convert an object to a CFF DICT structure.
                        // The keys should be numeric.
                        // The values should be objects containing name / type / value.
                        encode.DICT = function(m) {
                            var d = [];
                            var keys = Object.keys(m);
                            var length = keys.length;
                        
                            for (var i = 0; i &lt; length; i += 1) {
                                // Object.keys() return string keys, but our keys are always numeric.
                                var k = parseInt(keys[i], 0);
                                var v = m[k];
                                // Value comes before the key.
                                d = d.concat(encode.OPERAND(v.value, v.type));
                                d = d.concat(encode.OPERATOR(k));
                            }
                        
                            return d;
                        };
                        
                        sizeOf.DICT = function(m) {
                            return encode.DICT(m).length;
                        };
                        
                        encode.OPERATOR = function(v) {
                            if (v &lt; 1200) {
                                return [v];
                            } else {
                                return [12, v - 1200];
                            }
                        };
                        
                        encode.OPERAND = function(v, type) {
                            var d = [];
                            if (Array.isArray(type)) {
                                for (var i = 0; i &lt; type.length; i += 1) {
                                    check.argument(v.length === type.length, &#x27;Not enough arguments given for type&#x27; + type);
                                    d = d.concat(encode.OPERAND(v[i], type[i]));
                                }
                            } else {
                                if (type === &#x27;SID&#x27;) {
                                    d = d.concat(encode.NUMBER(v));
                                } else if (type === &#x27;offset&#x27;) {
                                    // We make it easy for ourselves and always encode offsets as
                                    // 4 bytes. This makes offset calculation for the top dict easier.
                                    d = d.concat(encode.NUMBER32(v));
                                } else if (type === &#x27;number&#x27;) {
                                    d = d.concat(encode.NUMBER(v));
                                } else if (type === &#x27;real&#x27;) {
                                    d = d.concat(encode.REAL(v));
                                } else {
                                    throw new Error(&#x27;Unknown operand type &#x27; + type);
                                    // FIXME Add support for booleans
                                }
                            }
                        
                            return d;
                        };
                        
                        encode.OP = encode.BYTE;
                        sizeOf.OP = sizeOf.BYTE;
                        
                        // memoize charstring encoding using WeakMap if available
                        var wmm = typeof WeakMap === &#x27;function&#x27; &amp;&amp; new WeakMap();
                        // Convert a list of CharString operations to bytes.
                        encode.CHARSTRING = function(ops) {
                            if (wmm &amp;&amp; wmm.has(ops)) {
                                return wmm.get(ops);
                            }
                        
                            var d = [];
                            var length = ops.length;
                        
                            for (var i = 0; i &lt; length; i += 1) {
                                var op = ops[i];
                                d = d.concat(encode[op.type](op.value));
                            }
                        
                            if (wmm) {
                                wmm.set(ops, d);
                            }
                        
                            return d;
                        };
                        
                        sizeOf.CHARSTRING = function(ops) {
                            return encode.CHARSTRING(ops).length;
                        };
                        
                        // Utility functions ////////////////////////////////////////////////////////
                        
                        // Convert an object containing name / type / value to bytes.
                        encode.OBJECT = function(v) {
                            var encodingFunction = encode[v.type];
                            check.argument(encodingFunction !== undefined, &#x27;No encoding function for type &#x27; + v.type);
                            return encodingFunction(v.value);
                        };
                        
                        // Convert a table object to bytes.
                        // A table contains a list of fields containing the metadata (name, type and default value).
                        // The table itself has the field values set as attributes.
                        encode.TABLE = function(table) {
                            var d = [];
                            var length = table.fields.length;
                        
                            for (var i = 0; i &lt; length; i += 1) {
                                var field = table.fields[i];
                                var encodingFunction = encode[field.type];
                                check.argument(encodingFunction !== undefined, &#x27;No encoding function for field type &#x27; + field.type);
                                var value = table[field.name];
                                if (value === undefined) {
                                    value = field.value;
                                }
                        
                                var bytes = encodingFunction(value);
                                d = d.concat(bytes);
                            }
                        
                            return d;
                        };
                        
                        // Merge in a list of bytes.
                        encode.LITERAL = function(v) {
                            return v;
                        };
                        
                        sizeOf.LITERAL = function(v) {
                            return v.length;
                        };
                        
                        exports.decode = decode;
                        exports.encode = encode;
                        exports.sizeOf = sizeOf;
                        
                        },{&quot;./check&quot;:2}],27:[function(_dereq_,module,exports){
                        /*!
                          * Reqwest! A general purpose XHR connection manager
                          * license MIT (c) Dustin Diaz 2014
                          * https://github.com/ded/reqwest
                          */
                        
                        !function (name, context, definition) {
                          if (typeof module != &#x27;undefined&#x27; &amp;&amp; module.exports) module.exports = definition()
                          else if (typeof define == &#x27;function&#x27; &amp;&amp; define.amd) define(definition)
                          else context[name] = definition()
                        }(&#x27;reqwest&#x27;, this, function () {
                        
                          var win = window
                            , doc = document
                            , httpsRe = /^http/
                            , protocolRe = /(^\w+):\/\//
                            , twoHundo = /^(20\d|1223)$/ //http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
                            , byTag = &#x27;getElementsByTagName&#x27;
                            , readyState = &#x27;readyState&#x27;
                            , contentType = &#x27;Content-Type&#x27;
                            , requestedWith = &#x27;X-Requested-With&#x27;
                            , head = doc[byTag](&#x27;head&#x27;)[0]
                            , uniqid = 0
                            , callbackPrefix = &#x27;reqwest_&#x27; + (+new Date())
                            , lastValue // data stored by the most recent JSONP callback
                            , xmlHttpRequest = &#x27;XMLHttpRequest&#x27;
                            , xDomainRequest = &#x27;XDomainRequest&#x27;
                            , noop = function () {}
                        
                            , isArray = typeof Array.isArray == &#x27;function&#x27;
                                ? Array.isArray
                                : function (a) {
                                    return a instanceof Array
                                  }
                        
                            , defaultHeaders = {
                                  &#x27;contentType&#x27;: &#x27;application/x-www-form-urlencoded&#x27;
                                , &#x27;requestedWith&#x27;: xmlHttpRequest
                                , &#x27;accept&#x27;: {
                                      &#x27;*&#x27;:  &#x27;text/javascript, text/html, application/xml, text/xml, */*&#x27;
                                    , &#x27;xml&#x27;:  &#x27;application/xml, text/xml&#x27;
                                    , &#x27;html&#x27;: &#x27;text/html&#x27;
                                    , &#x27;text&#x27;: &#x27;text/plain&#x27;
                                    , &#x27;json&#x27;: &#x27;application/json, text/javascript&#x27;
                                    , &#x27;js&#x27;:   &#x27;application/javascript, text/javascript&#x27;
                                  }
                              }
                        
                            , xhr = function(o) {
                                // is it x-domain
                                if (o[&#x27;crossOrigin&#x27;] === true) {
                                  var xhr = win[xmlHttpRequest] ? new XMLHttpRequest() : null
                                  if (xhr &amp;&amp; &#x27;withCredentials&#x27; in xhr) {
                                    return xhr
                                  } else if (win[xDomainRequest]) {
                                    return new XDomainRequest()
                                  } else {
                                    throw new Error(&#x27;Browser does not support cross-origin requests&#x27;)
                                  }
                                } else if (win[xmlHttpRequest]) {
                                  return new XMLHttpRequest()
                                } else {
                                  return new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;)
                                }
                              }
                            , globalSetupOptions = {
                                dataFilter: function (data) {
                                  return data
                                }
                              }
                        
                          function succeed(r) {
                            var protocol = protocolRe.exec(r.url);
                            protocol = (protocol &amp;&amp; protocol[1]) || window.location.protocol;
                            return httpsRe.test(protocol) ? twoHundo.test(r.request.status) : !!r.request.response;
                          }
                        
                          function handleReadyState(r, success, error) {
                            return function () {
                              // use _aborted to mitigate against IE err c00c023f
                              // (can&#x27;t read props on aborted request objects)
                              if (r._aborted) return error(r.request)
                              if (r._timedOut) return error(r.request, &#x27;Request is aborted: timeout&#x27;)
                              if (r.request &amp;&amp; r.request[readyState] == 4) {
                                r.request.onreadystatechange = noop
                                if (succeed(r)) success(r.request)
                                else
                                  error(r.request)
                              }
                            }
                          }
                        
                          function setHeaders(http, o) {
                            var headers = o[&#x27;headers&#x27;] || {}
                              , h
                        
                            headers[&#x27;Accept&#x27;] = headers[&#x27;Accept&#x27;]
                              || defaultHeaders[&#x27;accept&#x27;][o[&#x27;type&#x27;]]
                              || defaultHeaders[&#x27;accept&#x27;][&#x27;*&#x27;]
                        
                            var isAFormData = typeof FormData === &#x27;function&#x27; &amp;&amp; (o[&#x27;data&#x27;] instanceof FormData);
                            // breaks cross-origin requests with legacy browsers
                            if (!o[&#x27;crossOrigin&#x27;] &amp;&amp; !headers[requestedWith]) headers[requestedWith] = defaultHeaders[&#x27;requestedWith&#x27;]
                            if (!headers[contentType] &amp;&amp; !isAFormData) headers[contentType] = o[&#x27;contentType&#x27;] || defaultHeaders[&#x27;contentType&#x27;]
                            for (h in headers)
                              headers.hasOwnProperty(h) &amp;&amp; &#x27;setRequestHeader&#x27; in http &amp;&amp; http.setRequestHeader(h, headers[h])
                          }
                        
                          function setCredentials(http, o) {
                            if (typeof o[&#x27;withCredentials&#x27;] !== &#x27;undefined&#x27; &amp;&amp; typeof http.withCredentials !== &#x27;undefined&#x27;) {
                              http.withCredentials = !!o[&#x27;withCredentials&#x27;]
                            }
                          }
                        
                          function generalCallback(data) {
                            lastValue = data
                          }
                        
                          function urlappend (url, s) {
                            return url + (/\?/.test(url) ? &#x27;&amp;&#x27; : &#x27;?&#x27;) + s
                          }
                        
                          function handleJsonp(o, fn, err, url) {
                            var reqId = uniqid++
                              , cbkey = o[&#x27;jsonpCallback&#x27;] || &#x27;callback&#x27; // the &#x27;callback&#x27; key
                              , cbval = o[&#x27;jsonpCallbackName&#x27;] || reqwest.getcallbackPrefix(reqId)
                              , cbreg = new RegExp(&#x27;((^|\\?|&amp;)&#x27; + cbkey + &#x27;)=([^&amp;]+)&#x27;)
                              , match = url.match(cbreg)
                              , script = doc.createElement(&#x27;script&#x27;)
                              , loaded = 0
                              , isIE10 = navigator.userAgent.indexOf(&#x27;MSIE 10.0&#x27;) !== -1
                        
                            if (match) {
                              if (match[3] === &#x27;?&#x27;) {
                                url = url.replace(cbreg, &#x27;$1=&#x27; + cbval) // wildcard callback func name
                              } else {
                                cbval = match[3] // provided callback func name
                              }
                            } else {
                              url = urlappend(url, cbkey + &#x27;=&#x27; + cbval) // no callback details, add &#x27;em
                            }
                        
                            win[cbval] = generalCallback
                        
                            script.type = &#x27;text/javascript&#x27;
                            script.src = url
                            script.async = true
                            if (typeof script.onreadystatechange !== &#x27;undefined&#x27; &amp;&amp; !isIE10) {
                              // need this for IE due to out-of-order onreadystatechange(), binding script
                              // execution to an event listener gives us control over when the script
                              // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
                              script.htmlFor = script.id = &#x27;_reqwest_&#x27; + reqId
                            }
                        
                            script.onload = script.onreadystatechange = function () {
                              if ((script[readyState] &amp;&amp; script[readyState] !== &#x27;complete&#x27; &amp;&amp; script[readyState] !== &#x27;loaded&#x27;) || loaded) {
                                return false
                              }
                              script.onload = script.onreadystatechange = null
                              script.onclick &amp;&amp; script.onclick()
                              // Call the user callback with the last value stored and clean up values and scripts.
                              fn(lastValue)
                              lastValue = undefined
                              head.removeChild(script)
                              loaded = 1
                            }
                        
                            // Add the script to the DOM head
                            head.appendChild(script)
                        
                            // Enable JSONP timeout
                            return {
                              abort: function () {
                                script.onload = script.onreadystatechange = null
                                err({}, &#x27;Request is aborted: timeout&#x27;, {})
                                lastValue = undefined
                                head.removeChild(script)
                                loaded = 1
                              }
                            }
                          }
                        
                          function getRequest(fn, err) {
                            var o = this.o
                              , method = (o[&#x27;method&#x27;] || &#x27;GET&#x27;).toUpperCase()
                              , url = typeof o === &#x27;string&#x27; ? o : o[&#x27;url&#x27;]
                              // convert non-string objects to query-string form unless o[&#x27;processData&#x27;] is false
                              , data = (o[&#x27;processData&#x27;] !== false &amp;&amp; o[&#x27;data&#x27;] &amp;&amp; typeof o[&#x27;data&#x27;] !== &#x27;string&#x27;)
                                ? reqwest.toQueryString(o[&#x27;data&#x27;])
                                : (o[&#x27;data&#x27;] || null)
                              , http
                              , sendWait = false
                        
                            // if we&#x27;re working on a GET request and we have data then we should append
                            // query string to end of URL and not post data
                            if ((o[&#x27;type&#x27;] == &#x27;jsonp&#x27; || method == &#x27;GET&#x27;) &amp;&amp; data) {
                              url = urlappend(url, data)
                              data = null
                            }
                        
                            if (o[&#x27;type&#x27;] == &#x27;jsonp&#x27;) return handleJsonp(o, fn, err, url)
                        
                            // get the xhr from the factory if passed
                            // if the factory returns null, fall-back to ours
                            http = (o.xhr &amp;&amp; o.xhr(o)) || xhr(o)
                        
                            http.open(method, url, o[&#x27;async&#x27;] === false ? false : true)
                            setHeaders(http, o)
                            setCredentials(http, o)
                            if (win[xDomainRequest] &amp;&amp; http instanceof win[xDomainRequest]) {
                                http.onload = fn
                                http.onerror = err
                                // NOTE: see
                                // http://social.msdn.microsoft.com/Forums/en-US/iewebdevelopment/thread/30ef3add-767c-4436-b8a9-f1ca19b4812e
                                http.onprogress = function() {}
                                sendWait = true
                            } else {
                              http.onreadystatechange = handleReadyState(this, fn, err)
                            }
                            o[&#x27;before&#x27;] &amp;&amp; o[&#x27;before&#x27;](http)
                            if (sendWait) {
                              setTimeout(function () {
                                http.send(data)
                              }, 200)
                            } else {
                              http.send(data)
                            }
                            return http
                          }
                        
                          function Reqwest(o, fn) {
                            this.o = o
                            this.fn = fn
                        
                            init.apply(this, arguments)
                          }
                        
                          function setType(header) {
                            // json, javascript, text/plain, text/html, xml
                            if (header.match(&#x27;json&#x27;)) return &#x27;json&#x27;
                            if (header.match(&#x27;javascript&#x27;)) return &#x27;js&#x27;
                            if (header.match(&#x27;text&#x27;)) return &#x27;html&#x27;
                            if (header.match(&#x27;xml&#x27;)) return &#x27;xml&#x27;
                          }
                        
                          function init(o, fn) {
                        
                            this.url = typeof o == &#x27;string&#x27; ? o : o[&#x27;url&#x27;]
                            this.timeout = null
                        
                            // whether request has been fulfilled for purpose
                            // of tracking the Promises
                            this._fulfilled = false
                            // success handlers
                            this._successHandler = function(){}
                            this._fulfillmentHandlers = []
                            // error handlers
                            this._errorHandlers = []
                            // complete (both success and fail) handlers
                            this._completeHandlers = []
                            this._erred = false
                            this._responseArgs = {}
                        
                            var self = this
                        
                            fn = fn || function () {}
                        
                            if (o[&#x27;timeout&#x27;]) {
                              this.timeout = setTimeout(function () {
                                timedOut()
                              }, o[&#x27;timeout&#x27;])
                            }
                        
                            if (o[&#x27;success&#x27;]) {
                              this._successHandler = function () {
                                o[&#x27;success&#x27;].apply(o, arguments)
                              }
                            }
                        
                            if (o[&#x27;error&#x27;]) {
                              this._errorHandlers.push(function () {
                                o[&#x27;error&#x27;].apply(o, arguments)
                              })
                            }
                        
                            if (o[&#x27;complete&#x27;]) {
                              this._completeHandlers.push(function () {
                                o[&#x27;complete&#x27;].apply(o, arguments)
                              })
                            }
                        
                            function complete (resp) {
                              o[&#x27;timeout&#x27;] &amp;&amp; clearTimeout(self.timeout)
                              self.timeout = null
                              while (self._completeHandlers.length &gt; 0) {
                                self._completeHandlers.shift()(resp)
                              }
                            }
                        
                            function success (resp) {
                              var type = o[&#x27;type&#x27;] || resp &amp;&amp; setType(resp.getResponseHeader(&#x27;Content-Type&#x27;)) // resp can be undefined in IE
                              resp = (type !== &#x27;jsonp&#x27;) ? self.request : resp
                              // use global data filter on response text
                              var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type)
                                , r = filteredResponse
                              try {
                                resp.responseText = r
                              } catch (e) {
                                // can&#x27;t assign this in IE&lt;=8, just ignore
                              }
                              if (r) {
                                switch (type) {
                                case &#x27;json&#x27;:
                                  try {
                                    resp = win.JSON ? win.JSON.parse(r) : eval(&#x27;(&#x27; + r + &#x27;)&#x27;)
                                  } catch (err) {
                                    return error(resp, &#x27;Could not parse JSON in response&#x27;, err)
                                  }
                                  break
                                case &#x27;js&#x27;:
                                  resp = eval(r)
                                  break
                                case &#x27;html&#x27;:
                                  resp = r
                                  break
                                case &#x27;xml&#x27;:
                                  resp = resp.responseXML
                                      &amp;&amp; resp.responseXML.parseError // IE trololo
                                      &amp;&amp; resp.responseXML.parseError.errorCode
                                      &amp;&amp; resp.responseXML.parseError.reason
                                    ? null
                                    : resp.responseXML
                                  break
                                }
                              }
                        
                              self._responseArgs.resp = resp
                              self._fulfilled = true
                              fn(resp)
                              self._successHandler(resp)
                              while (self._fulfillmentHandlers.length &gt; 0) {
                                resp = self._fulfillmentHandlers.shift()(resp)
                              }
                        
                              complete(resp)
                            }
                        
                            function timedOut() {
                              self._timedOut = true
                              self.request.abort()      
                            }
                        
                            function error(resp, msg, t) {
                              resp = self.request
                              self._responseArgs.resp = resp
                              self._responseArgs.msg = msg
                              self._responseArgs.t = t
                              self._erred = true
                              while (self._errorHandlers.length &gt; 0) {
                                self._errorHandlers.shift()(resp, msg, t)
                              }
                              complete(resp)
                            }
                        
                            this.request = getRequest.call(this, success, error)
                          }
                        
                          Reqwest.prototype = {
                            abort: function () {
                              this._aborted = true
                              this.request.abort()
                            }
                        
                          , retry: function () {
                              init.call(this, this.o, this.fn)
                            }
                        
                            /**
                             * Small deviation from the Promises A CommonJs specification
                             * http://wiki.commonjs.org/wiki/Promises/A
                             */
                        
                            /**
                             * &#x60;then&#x60; will execute upon successful requests
                             */
                          , then: function (success, fail) {
                              success = success || function () {}
                              fail = fail || function () {}
                              if (this._fulfilled) {
                                this._responseArgs.resp = success(this._responseArgs.resp)
                              } else if (this._erred) {
                                fail(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
                              } else {
                                this._fulfillmentHandlers.push(success)
                                this._errorHandlers.push(fail)
                              }
                              return this
                            }
                        
                            /**
                             * &#x60;always&#x60; will execute whether the request succeeds or fails
                             */
                          , always: function (fn) {
                              if (this._fulfilled || this._erred) {
                                fn(this._responseArgs.resp)
                              } else {
                                this._completeHandlers.push(fn)
                              }
                              return this
                            }
                        
                            /**
                             * &#x60;fail&#x60; will execute when the request fails
                             */
                          , fail: function (fn) {
                              if (this._erred) {
                                fn(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
                              } else {
                                this._errorHandlers.push(fn)
                              }
                              return this
                            }
                          , &#x27;catch&#x27;: function (fn) {
                              return this.fail(fn)
                            }
                          }
                        
                          function reqwest(o, fn) {
                            return new Reqwest(o, fn)
                          }
                        
                          // normalize newline variants according to spec -&gt; CRLF
                          function normalize(s) {
                            return s ? s.replace(/\r?\n/g, &#x27;\r\n&#x27;) : &#x27;&#x27;
                          }
                        
                          function serial(el, cb) {
                            var n = el.name
                              , t = el.tagName.toLowerCase()
                              , optCb = function (o) {
                                  // IE gives value=&quot;&quot; even where there is no value attribute
                                  // &#x27;specified&#x27; ref: http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-862529273
                                  if (o &amp;&amp; !o[&#x27;disabled&#x27;])
                                    cb(n, normalize(o[&#x27;attributes&#x27;][&#x27;value&#x27;] &amp;&amp; o[&#x27;attributes&#x27;][&#x27;value&#x27;][&#x27;specified&#x27;] ? o[&#x27;value&#x27;] : o[&#x27;text&#x27;]))
                                }
                              , ch, ra, val, i
                        
                            // don&#x27;t serialize elements that are disabled or without a name
                            if (el.disabled || !n) return
                        
                            switch (t) {
                            case &#x27;input&#x27;:
                              if (!/reset|button|image|file/i.test(el.type)) {
                                ch = /checkbox/i.test(el.type)
                                ra = /radio/i.test(el.type)
                                val = el.value
                                // WebKit gives us &quot;&quot; instead of &quot;on&quot; if a checkbox has no value, so correct it here
                                ;(!(ch || ra) || el.checked) &amp;&amp; cb(n, normalize(ch &amp;&amp; val === &#x27;&#x27; ? &#x27;on&#x27; : val))
                              }
                              break
                            case &#x27;textarea&#x27;:
                              cb(n, normalize(el.value))
                              break
                            case &#x27;select&#x27;:
                              if (el.type.toLowerCase() === &#x27;select-one&#x27;) {
                                optCb(el.selectedIndex &gt;= 0 ? el.options[el.selectedIndex] : null)
                              } else {
                                for (i = 0; el.length &amp;&amp; i &lt; el.length; i++) {
                                  el.options[i].selected &amp;&amp; optCb(el.options[i])
                                }
                              }
                              break
                            }
                          }
                        
                          // collect up all form elements found from the passed argument elements all
                          // the way down to child elements; pass a &#x27;&lt;form&gt;&#x27; or form fields.
                          // called with &#x27;this&#x27;=callback to use for serial() on each element
                          function eachFormElement() {
                            var cb = this
                              , e, i
                              , serializeSubtags = function (e, tags) {
                                  var i, j, fa
                                  for (i = 0; i &lt; tags.length; i++) {
                                    fa = e[byTag](tags[i])
                                    for (j = 0; j &lt; fa.length; j++) serial(fa[j], cb)
                                  }
                                }
                        
                            for (i = 0; i &lt; arguments.length; i++) {
                              e = arguments[i]
                              if (/input|select|textarea/i.test(e.tagName)) serial(e, cb)
                              serializeSubtags(e, [ &#x27;input&#x27;, &#x27;select&#x27;, &#x27;textarea&#x27; ])
                            }
                          }
                        
                          // standard query string style serialization
                          function serializeQueryString() {
                            return reqwest.toQueryString(reqwest.serializeArray.apply(null, arguments))
                          }
                        
                          // { &#x27;name&#x27;: &#x27;value&#x27;, ... } style serialization
                          function serializeHash() {
                            var hash = {}
                            eachFormElement.apply(function (name, value) {
                              if (name in hash) {
                                hash[name] &amp;&amp; !isArray(hash[name]) &amp;&amp; (hash[name] = [hash[name]])
                                hash[name].push(value)
                              } else hash[name] = value
                            }, arguments)
                            return hash
                          }
                        
                          // [ { name: &#x27;name&#x27;, value: &#x27;value&#x27; }, ... ] style serialization
                          reqwest.serializeArray = function () {
                            var arr = []
                            eachFormElement.apply(function (name, value) {
                              arr.push({name: name, value: value})
                            }, arguments)
                            return arr
                          }
                        
                          reqwest.serialize = function () {
                            if (arguments.length === 0) return &#x27;&#x27;
                            var opt, fn
                              , args = Array.prototype.slice.call(arguments, 0)
                        
                            opt = args.pop()
                            opt &amp;&amp; opt.nodeType &amp;&amp; args.push(opt) &amp;&amp; (opt = null)
                            opt &amp;&amp; (opt = opt.type)
                        
                            if (opt == &#x27;map&#x27;) fn = serializeHash
                            else if (opt == &#x27;array&#x27;) fn = reqwest.serializeArray
                            else fn = serializeQueryString
                        
                            return fn.apply(null, args)
                          }
                        
                          reqwest.toQueryString = function (o, trad) {
                            var prefix, i
                              , traditional = trad || false
                              , s = []
                              , enc = encodeURIComponent
                              , add = function (key, value) {
                                  // If value is a function, invoke it and return its value
                                  value = (&#x27;function&#x27; === typeof value) ? value() : (value == null ? &#x27;&#x27; : value)
                                  s[s.length] = enc(key) + &#x27;=&#x27; + enc(value)
                                }
                            // If an array was passed in, assume that it is an array of form elements.
                            if (isArray(o)) {
                              for (i = 0; o &amp;&amp; i &lt; o.length; i++) add(o[i][&#x27;name&#x27;], o[i][&#x27;value&#x27;])
                            } else {
                              // If traditional, encode the &quot;old&quot; way (the way 1.3.2 or older
                              // did it), otherwise encode params recursively.
                              for (prefix in o) {
                                if (o.hasOwnProperty(prefix)) buildParams(prefix, o[prefix], traditional, add)
                              }
                            }
                        
                            // spaces should be + according to spec
                            return s.join(&#x27;&amp;&#x27;).replace(/%20/g, &#x27;+&#x27;)
                          }
                        
                          function buildParams(prefix, obj, traditional, add) {
                            var name, i, v
                              , rbracket = /\[\]$/
                        
                            if (isArray(obj)) {
                              // Serialize array item.
                              for (i = 0; obj &amp;&amp; i &lt; obj.length; i++) {
                                v = obj[i]
                                if (traditional || rbracket.test(prefix)) {
                                  // Treat each array item as a scalar.
                                  add(prefix, v)
                                } else {
                                  buildParams(prefix + &#x27;[&#x27; + (typeof v === &#x27;object&#x27; ? i : &#x27;&#x27;) + &#x27;]&#x27;, v, traditional, add)
                                }
                              }
                            } else if (obj &amp;&amp; obj.toString() === &#x27;[object Object]&#x27;) {
                              // Serialize object item.
                              for (name in obj) {
                                buildParams(prefix + &#x27;[&#x27; + name + &#x27;]&#x27;, obj[name], traditional, add)
                              }
                        
                            } else {
                              // Serialize scalar item.
                              add(prefix, obj)
                            }
                          }
                        
                          reqwest.getcallbackPrefix = function () {
                            return callbackPrefix
                          }
                        
                          // jQuery and Zepto compatibility, differences can be remapped here so you can call
                          // .ajax.compat(options, callback)
                          reqwest.compat = function (o, fn) {
                            if (o) {
                              o[&#x27;type&#x27;] &amp;&amp; (o[&#x27;method&#x27;] = o[&#x27;type&#x27;]) &amp;&amp; delete o[&#x27;type&#x27;]
                              o[&#x27;dataType&#x27;] &amp;&amp; (o[&#x27;type&#x27;] = o[&#x27;dataType&#x27;])
                              o[&#x27;jsonpCallback&#x27;] &amp;&amp; (o[&#x27;jsonpCallbackName&#x27;] = o[&#x27;jsonpCallback&#x27;]) &amp;&amp; delete o[&#x27;jsonpCallback&#x27;]
                              o[&#x27;jsonp&#x27;] &amp;&amp; (o[&#x27;jsonpCallback&#x27;] = o[&#x27;jsonp&#x27;])
                            }
                            return new Reqwest(o, fn)
                          }
                        
                          reqwest.ajaxSetup = function (options) {
                            options = options || {}
                            for (var k in options) {
                              globalSetupOptions[k] = options[k]
                            }
                          }
                        
                          return reqwest
                        });
                        
                        },{}],28:[function(_dereq_,module,exports){
                        /**
                         * @module Shape
                         * @submodule 3D Primitives
                         * @for p5
                         * @requires core
                         * @requires p5.Geometry3D
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        _dereq_(&#x27;./p5.Geometry3D&#x27;);
                        
                        /**
                         * Draw a plane with given a width and height
                         * @method plane
                         * @param  {Number} width      width of the plane
                         * @param  {Number} height     height of the plane
                         * @return {p5}                the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * //draw a plane with width 200 and height 200
                         * function setup(){
                         *   createCanvas(100, 100, WEBGL);
                         * }
                         *
                         * function draw(){
                         *   background(200);
                         *   plane(200, 200);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.plane = function(width, height){
                        
                          width = width || 50;
                          height = height || 50;
                        
                          //details for plane are highly optional
                          var detailX = typeof arguments[2] === Number ? arguments[2] : 1;
                          var detailY = typeof arguments[3] === Number ? arguments[3] : 1;
                        
                          var gId = &#x27;plane|&#x27;+width+&#x27;|&#x27;+height+&#x27;|&#x27;+detailX+&#x27;|&#x27;+detailY;
                        
                          if(!this._renderer.geometryInHash(gId)){
                        
                            var geometry3d = new p5.Geometry3D();
                        
                            var createPlane = function(u, v){
                              var x = 2 * width * u - width;
                              var y = 2 * height * v - height;
                              var z = 0;
                              return new p5.Vector(x, y, z);
                            };
                        
                            geometry3d.parametricGeometry(createPlane, detailX, detailY);
                        
                            var obj = geometry3d.generateObj();
                        
                            this._renderer.initBuffer(gId, [obj]);
                        
                          }
                        
                          this._renderer.drawBuffer(gId);
                        
                        };
                        
                        /**
                         * Draw a sphere with given raduis
                         * @method sphere
                         * @param  {Number} radius            radius of circle
                         * @param  {Number} [detail]          number of segments,
                         *                                    the more segments the smoother geometry
                         *                                    default is 24. Avoid detail number above
                         *                                    150, it may crash the browser.
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // draw a sphere with radius 200
                         * function setup(){
                         *   createCanvas(100, 100, WEBGL);
                         * }
                         *
                         * function draw(){
                         *   background(200);
                         *   sphere(200);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.sphere = function(radius, detail){
                        
                          radius = radius || 50;
                        
                          var detailX = detail || 24;
                          var detailY = detail || 16;
                        
                          var gId = &#x27;sphere|&#x27;+radius+&#x27;|&#x27;+detailX+&#x27;|&#x27;+detailY;
                        
                          if(!this._renderer.geometryInHash(gId)){
                        
                            var geometry3d = new p5.Geometry3D();
                        
                            var createSphere = function(u, v){
                              var theta = 2 * Math.PI * u;
                              var phi = Math.PI * v - Math.PI / 2;
                              var x = radius * Math.cos(phi) * Math.sin(theta);
                              var y = radius * Math.sin(phi);
                              var z = radius * Math.cos(phi) * Math.cos(theta);
                              return new p5.Vector(x, y, z);
                            };
                        
                            geometry3d.parametricGeometry(createSphere, detailX, detailY);
                        
                            var obj = geometry3d.generateObj(true, true);
                        
                            this._renderer.initBuffer(gId, [obj]);
                          }
                        
                          this._renderer.drawBuffer(gId);
                        
                          return this;
                        };
                        
                        /**
                         * Draw an ellipsoid with given raduis
                         * @method ellipsoid
                         * @param  {Number} radiusx           xradius of circle
                         * @param  {Number} radiusy           yradius of circle
                         * @param  {Number} radiusz           zradius of circle
                         * @param  {Number} [detail]          number of segments,
                         *                                    the more segments the smoother geometry
                         *                                    default is 24. Avoid detail number above
                         *                                    150. It may crash the browser.
                         * @return {p5}                       the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // draw an ellipsoid with radius 200, 300 and 400 .
                         * function setup(){
                         *   createCanvas(100, 100, WEBGL);
                         * }
                         *
                         * function draw(){
                         *   background(200);
                         *   ellipsoid(200,300,400);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.ellipsoid = function(radiusx, radiusy, radiusz, detail){
                        
                          radiusx = radiusx || 50;
                          radiusy = radiusy || 50;
                          radiusz = radiusz || 50;
                        
                          var detailX = detail || 24;
                          var detailY = detail || 24;
                        
                          var gId = &#x27;ellipsoid|&#x27;+radiusx+&#x27;|&#x27;+radiusy+
                          &#x27;|&#x27;+radiusz+&#x27;|&#x27;+detailX+&#x27;|&#x27;+detailY;
                        
                        
                          if(!this._renderer.geometryInHash(gId)){
                        
                            var geometry3d = new p5.Geometry3D();
                        
                            var createEllipsoid = function(u, v){
                              var theta = 2 * Math.PI * u;
                              var phi = Math.PI * v - Math.PI / 2;
                              var x = radiusx * Math.cos(phi) * Math.sin(theta);
                              var y = radiusy * Math.sin(phi);
                              var z = radiusz * Math.cos(phi) * Math.cos(theta);
                              return new p5.Vector(x, y, z);
                            };
                        
                            geometry3d.parametricGeometry(createEllipsoid, detailX, detailY);
                        
                            var obj = geometry3d.generateObj(true, true);
                        
                            this._renderer.initBuffer(gId, [obj]);
                          }
                        
                          this._renderer.drawBuffer(gId);
                        
                          return this;
                        };
                        
                        /**
                         * Draw a cylinder with given radius and height
                         * @method  cylinder
                         * @param  {Number} radius            radius of the surface
                         * @param  {Number} height            height of the cylinder
                         * @param  {Number} [detail]          number of segments,
                         *                                    the more segments the smoother geometry
                         *                                    default is 24. Avoid detail number above
                         *                                    150. It may crash the browser.
                         * @return {p5}                       the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * //draw a spining sylinder with radius 200 and height 200
                         * function setup(){
                         *   createCanvas(100, 100, WEBGL);
                         * }
                         *
                         * function draw(){
                         *   background(200);
                         *   rotateX(frameCount * 0.01);
                         *   rotateZ(frameCount * 0.01);
                         *   cylinder(200, 200);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.cylinder = function(radius, height, detail){
                        
                          radius = radius || 50;
                          height = height || 50;
                        
                          var detailX = detail || 24;
                          var detailY = detail || 16;
                        
                          var gId = &#x27;cylinder|&#x27;+radius+&#x27;|&#x27;+height+&#x27;|&#x27;+detailX+&#x27;|&#x27;+detailY;
                        
                          if(!this._renderer.geometryInHash(gId)){
                        
                            var geometry3d = new p5.Geometry3D();
                        
                            var createCylinder = function(u, v){
                              var theta = 2 * Math.PI * u;
                              var x = radius * Math.sin(theta);
                              var y = 2 * height * v - height;
                              var z = radius * Math.cos(theta);
                              return new p5.Vector(x, y, z);
                            };
                        
                            geometry3d.parametricGeometry(createCylinder, detailX, detailY);
                            var obj = geometry3d.generateObj(true);
                        
                            var createTop = function(u, v){
                              var theta = 2 * Math.PI * u;
                              var x = radius * Math.sin(-theta);
                              var y = height;
                              var z = radius * Math.cos(theta);
                              if(v === 0){
                                return new p5.Vector(0, height, 0);
                              }
                              else{
                                return new p5.Vector(x, y, z);
                              }
                            };
                        
                            var geometry3d1 = new p5.Geometry3D();
                            geometry3d1.parametricGeometry(
                              createTop, detailX, 1);
                            var obj1 = geometry3d1.generateObj();
                        
                            var createBottom = function(u, v){
                              var theta = 2 * Math.PI * u;
                              var x = radius * Math.sin(theta);
                              var y = -height;
                              var z = radius * Math.cos(theta);
                              if(v === 0){
                                return new p5.Vector(0, -height, 0);
                              }else{
                                return new p5.Vector(x, y, z);
                              }
                            };
                        
                            var geometry3d2 = new p5.Geometry3D();
                            geometry3d2.parametricGeometry(
                              createBottom, detailX, 1);
                            var obj2 = geometry3d2.generateObj();
                        
                        
                            this._renderer.initBuffer(gId, [obj, obj1, obj2]);
                          }
                        
                          this._renderer.drawBuffer(gId);
                        
                          return this;
                        };
                        
                        
                        /**
                         * Draw a cone with given radius and height
                         * @method cone
                         * @param  {Number} radius            radius of the bottom surface
                         * @param  {Number} height            height of the cone
                         * @param  {Number} [detail]          number of segments,
                         *                                    the more segments the smoother geometry
                         *                                    default is 24. Avoid detail number above
                         *                                    150. It may crash the browser.
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * //draw a spining cone with radius 200 and height 200
                         * function setup(){
                         *   createCanvas(100, 100, WEBGL);
                         * }
                         *
                         * function draw(){
                         *   background(200);
                         *   rotateX(frameCount * 0.01);
                         *   rotateZ(frameCount * 0.01);
                         *   cone(200, 200);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.cone = function(radius, height, detail){
                        
                          radius = radius || 50;
                          height = height || 50;
                        
                          var detailX = detail || 24;
                          var detailY = detail || 16;
                        
                          var gId = &#x27;cone|&#x27;+radius+&#x27;|&#x27;+height+&#x27;|&#x27;+detailX+&#x27;|&#x27;+detailY;
                        
                          if(!this._renderer.geometryInHash(gId)){
                        
                            var geometry3d = new p5.Geometry3D();
                        
                            var createCone = function(u, v){
                              var theta = 2 * Math.PI * u;
                              var x = radius * (1 - v) * Math.sin(theta);
                              var y = 2 * height * v - height;
                              var z = radius * (1 - v) * Math.cos(theta);
                              return new p5.Vector(x, y, z);
                            };
                        
                            geometry3d.parametricGeometry(createCone, detailX, detailY);
                            var obj = geometry3d.generateObj(true);
                        
                            var geometry3d1 = new p5.Geometry3D();
                            var createBottom = function(u, v){
                              var theta = 2 * Math.PI * u;
                              var x = radius * (1 - v) * Math.sin(-theta);
                              var y = -height;
                              var z = radius * (1 - v) * Math.cos(theta);
                              return new p5.Vector(x, y, z);
                            };
                        
                            geometry3d1.parametricGeometry(
                              createBottom, detailX, 1);
                            var obj1 = geometry3d1.generateObj();
                        
                            this._renderer.initBuffer(gId, [obj, obj1]);
                          }
                        
                          this._renderer.drawBuffer(gId);
                        
                          return this;
                        };
                        
                        
                        /**
                         * Draw a torus with given radius and tube radius
                         * @method torus
                         * @param  {Number} radius            radius of the whole ring
                         * @param  {Number} tubeRadius        radius of the tube
                         * @param  {Number} [detail]          number of segments,
                         *                                    the more segments the smoother geometry
                         *                                    default is 24. Avoid detail number above
                         *                                    150. It may crash the browser.
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * //draw a spining torus with radius 200 and tube radius 60
                         * function setup(){
                         *   createCanvas(100, 100, WEBGL);
                         * }
                         *
                         * function draw(){
                         *   background(200);
                         *   rotateX(frameCount * 0.01);
                         *   rotateY(frameCount * 0.01);
                         *   torus(200, 60);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.torus = function(radius, tubeRadius, detail){
                        
                          radius = radius || 50;
                          tubeRadius = tubeRadius || 10;
                        
                          var detailX = detail || 24;
                          var detailY = detail || 16;
                        
                          var gId = &#x27;torus|&#x27;+radius+&#x27;|&#x27;+tubeRadius+&#x27;|&#x27;+detailX+&#x27;|&#x27;+detailY;
                        
                          if(!this._renderer.geometryInHash(gId)){
                        
                            var geometry3d = new p5.Geometry3D();
                        
                            var createTorus = function(u, v){
                              var theta = 2 * Math.PI * u;
                              var phi = 2 * Math.PI * v;
                              var x = (radius + tubeRadius * Math.cos(phi)) * Math.cos(theta);
                              var y = (radius + tubeRadius * Math.cos(phi)) * Math.sin(theta);
                              var z = tubeRadius * Math.sin(phi);
                              return new p5.Vector(x, y, z);
                            };
                        
                            geometry3d.parametricGeometry(createTorus, detailX, detailY);
                        
                            var obj = geometry3d.generateObj(true);
                        
                            this._renderer.initBuffer(gId, [obj]);
                          }
                        
                          this._renderer.drawBuffer(gId);
                        
                          return this;
                        };
                        
                        /**
                         * Draw a box with given width, height and depth
                         * @method  box
                         * @param  {Number} width  width of the box
                         * @param  {Number} height height of the box
                         * @param  {Number} depth  depth of the box
                         * @return {p5}            the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * //draw a spining box with width, height and depth 200
                         * function setup(){
                         *   createCanvas(100, 100, WEBGL);
                         * }
                         *
                         * function draw(){
                         *   background(200);
                         *   rotateX(frameCount * 0.01);
                         *   rotateY(frameCount * 0.01);
                         *   box(200, 200, 200);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.box = function(width, height, depth){
                        
                          width = width || 50;
                          height = height || width;
                          depth = depth || width;
                        
                          //details for box are highly optional
                          var detailX = typeof arguments[3] === Number ? arguments[3] : 1;
                          var detailY = typeof arguments[4] === Number ? arguments[4] : 1;
                        
                          var gId = &#x27;cube|&#x27;+width+&#x27;|&#x27;+height+&#x27;|&#x27;+depth+&#x27;|&#x27;+detailX+&#x27;|&#x27;+detailY;
                        
                          if(!this._renderer.geometryInHash(gId)){
                        
                            var geometry3d = new p5.Geometry3D();
                        
                            var createPlane1 = function(u, v){
                              var x = 2 * width * u - width;
                              var y = 2 * height * v - height;
                              var z = depth;
                              return new p5.Vector(x, y, z);
                            };
                            var createPlane2 = function(u, v){
                              var x = 2 * width * ( 1 - u ) - width;
                              var y = 2 * height * v - height;
                              var z = -depth;
                              return new p5.Vector(x, y, z);
                            };
                            var createPlane3 = function(u, v){
                              var x = 2 * width * ( 1 - u ) - width;
                              var y = height;
                              var z = 2 * depth * v - depth;
                              return new p5.Vector(x, y, z);
                            };
                            var createPlane4 = function(u, v){
                              var x = 2 * width * u - width;
                              var y = -height;
                              var z = 2 * depth * v - depth;
                              return new p5.Vector(x, y, z);
                            };
                            var createPlane5 = function(u, v){
                              var x = width;
                              var y = 2 * height * u - height;
                              var z = 2 * depth * v - depth;
                              return new p5.Vector(x, y, z);
                            };
                            var createPlane6 = function(u, v){
                              var x = -width;
                              var y = 2 * height * ( 1 - u ) - height;
                              var z = 2 * depth * v - depth;
                              return new p5.Vector(x, y, z);
                            };
                        
                            geometry3d.parametricGeometry(
                              createPlane1, detailX, detailY, geometry3d.vertices.length);
                            geometry3d.parametricGeometry(
                              createPlane2, detailX, detailY, geometry3d.vertices.length);
                            geometry3d.parametricGeometry(
                              createPlane3, detailX, detailY, geometry3d.vertices.length);
                            geometry3d.parametricGeometry(
                              createPlane4, detailX, detailY, geometry3d.vertices.length);
                            geometry3d.parametricGeometry(
                              createPlane5, detailX, detailY, geometry3d.vertices.length);
                            geometry3d.parametricGeometry(
                              createPlane6, detailX, detailY, geometry3d.vertices.length);
                        
                            var obj = geometry3d.generateObj();
                        
                            this._renderer.initBuffer(gId, [obj]);
                          }
                        
                          this._renderer.drawBuffer(gId);
                        
                          return this;
                        
                        };
                        
                        module.exports = p5;
                        },{&quot;../core/core&quot;:48,&quot;./p5.Geometry3D&quot;:34}],29:[function(_dereq_,module,exports){
                        /**
                         * @module Lights, Camera
                         * @submodule Camera
                         * @for p5
                         * @requires core
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        
                        /**
                         * Sets camera position
                         * @method camera
                         * @param  {Number} x  camera postion value on x axis
                         * @param  {Number} y  camera postion value on y axis
                         * @param  {Number} z  camera postion value on z axis
                         * @return {p5}        the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * function setup(){
                         *   createCanvas(100, 100, WEBGL);
                         * }
                         * function draw(){
                         *  //move the camera away from the plane by a sin wave
                         *  camera(0, 0, sin(frameCount * 0.01) * 100);
                         *  plane(120, 120);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.camera = function(x, y, z){
                          var args = new Array(arguments.length);
                          for (var i = 0; i &lt; args.length; ++i) {
                            args[i] = arguments[i];
                          }
                          this._validateParameters(
                            &#x27;camera&#x27;,
                            args,
                            [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;]
                          );
                          //what it manipulates is the model view matrix
                          this._renderer.translate(-x, -y, -z);
                        };
                        
                        /**
                         * Sets perspective camera
                         * @method  perspective
                         * @param  {Number} fovy   camera frustum vertical field of view,
                         *                         from bottom to top of view, in degrees
                         * @param  {Number} aspect camera frustum aspect ratio
                         * @param  {Number} near   frustum near plane length
                         * @param  {Number} far    frustum far plane length
                         * @return {p5}            the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * //drag mouse to toggle the world!
                         * //you will see there&#x27;s a vanish point
                         * function setup(){
                         *   createCanvas(100, 100, WEBGL);
                         *   perspective(60 / 180 * PI, width/height, 0.1, 100);
                         * }
                         * function draw(){
                         *  background(200);
                         *  orbitControl();
                         *  for(var i = -1; i &lt; 2; i++){
                         *     for(var j = -2; j &lt; 3; j++){
                         *       push();
                         *       translate(i*160, 0, j*160);
                         *       box(40, 40, 40);
                         *       pop();
                         *     }
                         *   }
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.perspective = function(fovy,aspect,near,far) {
                          var args = new Array(arguments.length);
                          for (var i = 0; i &lt; args.length; ++i) {
                            args[i] = arguments[i];
                          }
                          this._validateParameters(
                            &#x27;perspective&#x27;,
                            args,
                            [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;]
                          );
                          this._renderer.uPMatrix = p5.Matrix.identity();
                          this._renderer.uPMatrix.perspective(fovy,aspect,near,far);
                          this._renderer._setCamera = true;
                        };
                        
                        /**
                         * Setup ortho camera
                         * @method  ortho
                         * @param  {Number} left   camera frustum left plane
                         * @param  {Number} right  camera frustum right plane
                         * @param  {Number} bottom camera frustum bottom plane
                         * @param  {Number} top    camera frustum top plane
                         * @param  {Number} near   camera frustum near plane
                         * @param  {Number} far    camera frustum far plane
                         * @return {p5}            the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * //drag mouse to toggle the world!
                         * //there&#x27;s no vanish point
                         * function setup(){
                         *   createCanvas(100, 100, WEBGL);
                         *   ortho(-width/2, width/2, height/2, -height/2, 0.1, 100);
                         * }
                         * function draw(){
                         *  background(200);
                         *  orbitControl();
                         *  for(var i = -1; i &lt; 2; i++){
                         *     for(var j = -2; j &lt; 3; j++){
                         *       push();
                         *       translate(i*160, 0, j*160);
                         *       box(40, 40, 40);
                         *       pop();
                         *     }
                         *   }
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.ortho = function(left,right,bottom,top,near,far) {
                          var args = new Array(arguments.length);
                          for (var i = 0; i &lt; args.length; ++i) {
                            args[i] = arguments[i];
                          }
                          this._validateParameters(
                            &#x27;ortho&#x27;,
                            args,
                              [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;]
                          );
                          left /= this.width;
                          right /= this.width;
                          top /= this.height;
                          bottom /= this.height;
                          this._renderer.uPMatrix = p5.Matrix.identity();
                          this._renderer.uPMatrix.ortho(left,right,bottom,top,near,far);
                          this._renderer._setCamera = true;
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;../core/core&quot;:48}],30:[function(_dereq_,module,exports){
                        //@TODO: documentation of immediate mode
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        
                        //////////////////////////////////////////////
                        // _primitives2D in 3D space
                        //////////////////////////////////////////////
                        
                        p5.Renderer3D.prototype._primitives2D = function(arr){
                          this._setDefaultCamera();
                          var gl = this.GL;
                          var shaderProgram = this._getColorVertexShader();
                        
                          //create vertice buffer
                          var vertexPositionBuffer = this.verticeBuffer;
                          gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
                        
                          gl.bufferData(
                            gl.ARRAY_BUFFER, new Float32Array(arr), gl.STATIC_DRAW);
                          gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute,
                            3, gl.FLOAT, false, 0, 0);
                        
                          //create vertexcolor buffer
                          var vertexColorBuffer = this.colorBuffer;
                          gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer);
                          var color = this._getCurColor();
                          var colors = [];
                          for(var i = 0; i &lt; arr.length / 3; i++){
                            colors = colors.concat(color);
                          }
                        
                          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
                          gl.vertexAttribPointer(shaderProgram.vertexColorAttribute,
                            4, gl.FLOAT, false, 0, 0);
                        
                          //matrix
                          var mId = &#x27;vertexColorVert|vertexColorFrag&#x27;;
                          this.setMatrixUniforms(mId);
                        };
                        
                        p5.Renderer3D.prototype.point = function(x, y, z){
                          var gl = this.GL;
                          this._primitives2D([x, y, z]);
                          gl.drawArrays(gl.POINTS, 0, 1);
                          return this;
                        };
                        
                        p5.Renderer3D.prototype.line = function(x1, y1, z1, x2, y2, z2){
                          var gl = this.GL;
                          this._primitives2D([x1, y1, z1, x2, y2, z2]);
                          gl.drawArrays(gl.LINES, 0, 2);
                          return this;
                        };
                        
                        p5.Renderer3D.prototype.triangle = function
                        (x1, y1, z1, x2, y2, z2, x3, y3, z3){
                          var gl = this.GL;
                          this._primitives2D([x1, y1, z1, x2, y2, z2, x3, y3, z3]);
                          this._strokeCheck();
                          gl.drawArrays(gl.TRIANGLES, 0, 3);
                          return this;
                        };
                        
                        //@TODO: how to define the order of 4 points
                        p5.Renderer3D.prototype.quad = function
                        (x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4){
                          var gl = this.GL;
                          this._primitives2D(
                            [x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4]);
                          this._strokeCheck();
                          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                          return this;
                        };
                        
                        p5.Renderer3D.prototype.beginShape = function(mode){
                          this.shapeMode = mode;
                          this.verticeStack = [];
                          return this;
                        };
                        
                        p5.Renderer3D.prototype.vertex = function(x, y, z){
                          this.verticeStack.push(x, y, z);
                          return this;
                        };
                        
                        p5.Renderer3D.prototype.endShape = function(){
                          var gl = this.GL;
                          this._primitives2D(this.verticeStack);
                          this.verticeStack = [];
                        
                          switch(this.shapeMode){
                            case &#x27;POINTS&#x27;:
                              gl.drawArrays(gl.POINTS, 0, 1);
                              break;
                            case &#x27;LINES&#x27;:
                              gl.drawArrays(gl.LINES, 0, 2);
                              break;
                            case &#x27;TRIANGLES&#x27;:
                              this._strokeCheck();
                              gl.drawArrays(gl.TRIANGLES, 0, 3);
                              break;
                            case &#x27;TRIANGLE_STRIP&#x27;:
                              this._strokeCheck();
                              gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                              break;
                            default:
                              this._strokeCheck();
                              gl.drawArrays(gl.TRIANGLES, 0, 3);
                              break;
                          }
                          return this;
                        };
                        
                        //@TODO: figure out how to actually do stroke on shapes in 3D
                        p5.Renderer3D.prototype._strokeCheck = function(){
                          if(this.drawMode === &#x27;stroke&#x27;){
                            throw new Error(
                              &#x27;stroke for shapes in 3D not yet implemented, use fill for now :(&#x27;
                            );
                          }
                        };
                        
                        //@TODO
                        p5.Renderer3D.prototype.strokeWeight = function() {
                          throw new Error(&#x27;strokeWeight for 3d not yet implemented&#x27;);
                        };
                        
                        //////////////////////////////////////////////
                        // COLOR
                        //////////////////////////////////////////////
                        
                        p5.Renderer3D.prototype.fill = function(r, g, b, a) {
                          var color = this._pInst.color.apply(this._pInst, arguments);
                          var colorNormalized = color._array;
                          this.curColor = colorNormalized;
                          this.drawMode = &#x27;fill&#x27;;
                          return this;
                        };
                        
                        p5.Renderer3D.prototype.stroke = function(r, g, b, a) {
                          var color = this._pInst.color.apply(this._pInst, arguments);
                          var colorNormalized = color._array;
                          this.curColor = colorNormalized;
                          this.drawMode = &#x27;stroke&#x27;;
                          return this;
                        };
                        
                        p5.Renderer3D.prototype._getColorVertexShader = function(){
                          var gl = this.GL;
                          var mId = &#x27;vertexColorVert|vertexColorFrag&#x27;;
                          var shaderProgram;
                        
                          if(!this.materialInHash(mId)){
                            shaderProgram =
                              this.initShaders(&#x27;vertexColorVert&#x27;, &#x27;vertexColorFrag&#x27;, true);
                            this.mHash[mId] = shaderProgram;
                            shaderProgram.vertexColorAttribute =
                            gl.getAttribLocation(shaderProgram, &#x27;aVertexColor&#x27;);
                            gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);
                          }else{
                            shaderProgram = this.mHash[mId];
                          }
                          return shaderProgram;
                        };
                        
                        module.exports = p5.Renderer3D;
                        
                        },{&quot;../core/core&quot;:48}],31:[function(_dereq_,module,exports){
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        
                        //@TODO: implement full orbit controls including
                        //pan, zoom, quaternion rotation, etc.
                        p5.prototype.orbitControl = function(){
                          if(this.mouseIsPressed){
                            this.rotateY((this.mouseX - this.width / 2) / (this.width / 2));
                            this.rotateX((this.mouseY - this.height / 2) / (this.width / 2));
                          }
                          return this;
                        };
                        
                        module.exports = p5;
                        },{&quot;../core/core&quot;:48}],32:[function(_dereq_,module,exports){
                        /**
                         * @module Lights, Camera
                         * @submodule Lights
                         * @for p5
                         * @requires core
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        
                        /**
                         * Creates an ambient light with a color
                         * @method  ambientLight
                         * @param  {Number|Array|String|p5.Color} v1  gray value,
                         * red or hue value (depending on the current color mode),
                         * or color Array, or CSS color string
                         * @param  {Number}            [v2] optional: green or saturation value
                         * @param  {Number}            [v3] optional: blue or brightness value
                         * @param  {Number}            [a]  optional: opacity
                         * @return {p5}                the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * function setup(){
                         *   createCanvas(100, 100, WEBGL);
                         * }
                         * function draw(){
                         *   background(0);
                         *   ambientLight(150);
                         *   ambientMaterial(250);
                         *   sphere(200);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.ambientLight = function(v1, v2, v3, a){
                          var gl = this._renderer.GL;
                          var shaderProgram = this._renderer._getShader(
                            &#x27;lightVert&#x27;, &#x27;lightTextureFrag&#x27;);
                        
                          gl.useProgram(shaderProgram);
                          shaderProgram.uAmbientColor = gl.getUniformLocation(
                            shaderProgram,
                            &#x27;uAmbientColor[&#x27; + this._renderer.ambientLightCount + &#x27;]&#x27;);
                        
                          var color = this._renderer._pInst.color.apply(
                            this._renderer._pInst, arguments);
                          var colors = color._array;
                        
                          gl.uniform3f( shaderProgram.uAmbientColor,
                            colors[0], colors[1], colors[2]);
                        
                          //in case there&#x27;s no material color for the geometry
                          shaderProgram.uMaterialColor = gl.getUniformLocation(
                            shaderProgram, &#x27;uMaterialColor&#x27; );
                          gl.uniform4f( shaderProgram.uMaterialColor, 1, 1, 1, 1);
                        
                          this._renderer.ambientLightCount ++;
                          shaderProgram.uAmbientLightCount =
                            gl.getUniformLocation(shaderProgram, &#x27;uAmbientLightCount&#x27;);
                          gl.uniform1i(shaderProgram.uAmbientLightCount,
                            this._renderer.ambientLightCount);
                        
                          return this;
                        };
                        
                        /**
                         * Creates a directional light with a color and a direction
                         * @method  directionalLight
                         * @param  {Number|Array|String|p5.Color} v1   gray value,
                         * red or hue value (depending on the current color mode),
                         * or color Array, or CSS color string
                         * @param  {Number}          [v2] optional: green or saturation value
                         * @param  {Number}          [v3] optional: blue or brightness value
                         * @param  {Number}          [a]  optional: opacity
                         * @param  {Number|p5.Vector} x   x axis direction or a p5.Vector
                         * @param  {Number}          [y]  optional: y axis direction
                         * @param  {Number}          [z]  optional: z axis direction
                         * @return {p5}              the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * function setup(){
                         *   createCanvas(100, 100, WEBGL);
                         * }
                         * function draw(){
                         *   background(0);
                         *   //move your mouse to change light direction
                         *   var dirX = (mouseX / width - 0.5) *2;
                         *   var dirY = (mouseY / height - 0.5) *(-2);
                         *   directionalLight(250, 250, 250, dirX, dirY, 0.25);
                         *   ambientMaterial(250);
                         *   sphere(200);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.directionalLight = function(v1, v2, v3, a, x, y, z) {
                          // TODO(jgessner): Find an example using this and profile it.
                          // var args = new Array(arguments.length);
                          // for (var i = 0; i &lt; args.length; ++i) {
                          //   args[i] = arguments[i];
                          // }
                          // this._validateParameters(
                          //   &#x27;directionalLight&#x27;,
                          //   args,
                          //   [
                          //     //rgbaxyz
                          //     [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;],
                          //     //rgbxyz
                          //     [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;],
                          //     //caxyz
                          //     [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;],
                          //     //cxyz
                          //     [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;],
                          //     [&#x27;String&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;],
                          //     [&#x27;Array&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;],
                          //     [&#x27;Object&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;],
                          //     //rgbavector
                          //     [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Object&#x27;],
                          //     //rgbvector
                          //     [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Object&#x27;],
                          //     //cavector
                          //     [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Object&#x27;],
                          //     //cvector
                          //     [&#x27;Number&#x27;, &#x27;Object&#x27;],
                          //     [&#x27;String&#x27;, &#x27;Object&#x27;],
                          //     [&#x27;Array&#x27;, &#x27;Object&#x27;],
                          //     [&#x27;Object&#x27;, &#x27;Object&#x27;]
                          //   ]
                          // );
                        
                          var gl = this._renderer.GL;
                          var shaderProgram = this._renderer._getShader(
                            &#x27;lightVert&#x27;, &#x27;lightTextureFrag&#x27;);
                        
                          gl.useProgram(shaderProgram);
                          shaderProgram.uDirectionalColor = gl.getUniformLocation(
                            shaderProgram,
                            &#x27;uDirectionalColor[&#x27; + this._renderer.directionalLightCount + &#x27;]&#x27;);
                        
                          //@TODO: check parameters number
                          var color = this._renderer._pInst.color.apply(
                            this._renderer._pInst, [v1, v2, v3]);
                          var colors = color._array;
                        
                          gl.uniform3f( shaderProgram.uDirectionalColor,
                            colors[0], colors[1], colors[2]);
                        
                          var _x, _y, _z;
                        
                          if(typeof arguments[arguments.length-1] === &#x27;number&#x27;){
                            _x = arguments[arguments.length-3];
                            _y = arguments[arguments.length-2];
                            _z = arguments[arguments.length-1];
                        
                          }else{
                            try{
                              _x = arguments[arguments.length-1].x;
                              _y = arguments[arguments.length-1].y;
                              _z = arguments[arguments.length-1].z;
                            }
                            catch(error){
                              throw error;
                            }
                          }
                        
                          shaderProgram.uLightingDirection = gl.getUniformLocation(
                            shaderProgram,
                            &#x27;uLightingDirection[&#x27; + this._renderer.directionalLightCount + &#x27;]&#x27;);
                          gl.uniform3f( shaderProgram.uLightingDirection, _x, _y, _z);
                        
                          //in case there&#x27;s no material color for the geometry
                          shaderProgram.uMaterialColor = gl.getUniformLocation(
                            shaderProgram, &#x27;uMaterialColor&#x27; );
                          gl.uniform4f( shaderProgram.uMaterialColor, 1, 1, 1, 1);
                        
                          this._renderer.directionalLightCount ++;
                          shaderProgram.uDirectionalLightCount =
                            gl.getUniformLocation(shaderProgram, &#x27;uDirectionalLightCount&#x27;);
                          gl.uniform1i(shaderProgram.uDirectionalLightCount,
                            this._renderer.directionalLightCount);
                        
                          return this;
                        };
                        
                        /**
                         * Creates a point light with a color and a light position
                         * @method  pointLight
                         * @param  {Number|Array|String|p5.Color} v1   gray value,
                         * red or hue value (depending on the current color mode),
                         * or color Array, or CSS color string
                         * @param  {Number}          [v2] optional: green or saturation value
                         * @param  {Number}          [v3] optional: blue or brightness value
                         * @param  {Number}          [a]  optional: opacity
                         * @param  {Number|p5.Vector} x   x axis position or a p5.Vector
                         * @param  {Number}          [y]  optional: y axis position
                         * @param  {Number}          [z]  optional: z axis position
                         * @return {p5}              the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * function setup(){
                         *   createCanvas(100, 100, WEBGL);
                         * }
                         * function draw(){
                         *   background(0);
                         *   //move your mouse to change light position
                         *   var locY = (mouseY / height - 0.5) *(-2);
                         *   var locX = (mouseX / width - 0.5) *2;
                         *   //to set the light position,
                         *   //think of the world&#x27;s coordinate as:
                         *   // -1,1 -------- 1,1
                         *   //   |            |
                         *   //   |            |
                         *   //   |            |
                         *   // -1,-1---------1,-1
                         *   pointLight(250, 250, 250, locX, locY, 0);
                         *   ambientMaterial(250);
                         *   sphere(200);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.pointLight = function(v1, v2, v3, a, x, y, z) {
                          // TODO(jgessner): Find an example using this and profile it.
                          // var args = new Array(arguments.length);
                          // for (var i = 0; i &lt; args.length; ++i) {
                          //   args[i] = arguments[i];
                          // }
                          // this._validateParameters(
                          //   &#x27;pointLight&#x27;,
                          //   arguments,
                          //   [
                          //     //rgbaxyz
                          //     [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;],
                          //     //rgbxyz
                          //     [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;],
                          //     //caxyz
                          //     [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;],
                          //     //cxyz
                          //     [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;],
                          //     [&#x27;String&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;],
                          //     [&#x27;Array&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;],
                          //     [&#x27;Object&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;],
                          //     //rgbavector
                          //     [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Object&#x27;],
                          //     //rgbvector
                          //     [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Object&#x27;],
                          //     //cavector
                          //     [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Object&#x27;],
                          //     //cvector
                          //     [&#x27;Number&#x27;, &#x27;Object&#x27;],
                          //     [&#x27;String&#x27;, &#x27;Object&#x27;],
                          //     [&#x27;Array&#x27;, &#x27;Object&#x27;],
                          //     [&#x27;Object&#x27;, &#x27;Object&#x27;]
                          //   ]
                          // );
                        
                          var gl = this._renderer.GL;
                          var shaderProgram = this._renderer._getShader(
                            &#x27;lightVert&#x27;, &#x27;lightTextureFrag&#x27;);
                        
                          gl.useProgram(shaderProgram);
                          shaderProgram.uPointLightColor = gl.getUniformLocation(
                            shaderProgram,
                            &#x27;uPointLightColor[&#x27; + this._renderer.pointLightCount + &#x27;]&#x27;);
                        
                          //@TODO: check parameters number
                          var color = this._renderer._pInst.color.apply(
                            this._renderer._pInst, [v1, v2, v3]);
                          var colors = color._array;
                        
                          gl.uniform3f( shaderProgram.uPointLightColor,
                            colors[0], colors[1], colors[2]);
                        
                          var _x, _y, _z;
                        
                          if(typeof arguments[arguments.length-1] === &#x27;number&#x27;){
                            _x = arguments[arguments.length-3];
                            _y = arguments[arguments.length-2];
                            _z = arguments[arguments.length-1];
                        
                          }else{
                            try{
                              _x = arguments[arguments.length-1].x;
                              _y = arguments[arguments.length-1].y;
                              _z = arguments[arguments.length-1].z;
                            }
                            catch(error){
                              throw error;
                            }
                          }
                        
                          shaderProgram.uPointLightLocation = gl.getUniformLocation(
                            shaderProgram,
                            &#x27;uPointLightLocation[&#x27; + this._renderer.pointLightCount + &#x27;]&#x27;);
                          gl.uniform3f( shaderProgram.uPointLightLocation, _x, _y, _z);
                        
                          //in case there&#x27;s no material color for the geometry
                          shaderProgram.uMaterialColor = gl.getUniformLocation(
                            shaderProgram, &#x27;uMaterialColor&#x27; );
                          gl.uniform4f( shaderProgram.uMaterialColor, 1, 1, 1, 1);
                        
                          this._renderer.pointLightCount ++;
                          shaderProgram.uPointLightCount =
                            gl.getUniformLocation(shaderProgram, &#x27;uPointLightCount&#x27;);
                          gl.uniform1i(shaderProgram.uPointLightCount,
                            this._renderer.pointLightCount);
                        
                          return this;
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;../core/core&quot;:48}],33:[function(_dereq_,module,exports){
                        /**
                         * @module Lights, Camera
                         * @submodule Material
                         * @for p5
                         * @requires core
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        //require(&#x27;./p5.Texture&#x27;);
                        
                        /**
                         * Normal material for geometry
                         * @method normalMaterial
                         * @return {p5}                the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * function setup(){
                         *   createCanvas(100, 100, WEBGL);
                         * }
                         *
                         * function draw(){
                         *  background(0);
                         *  normalMaterial();
                         *  sphere(200);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.normalMaterial = function(){
                          this._renderer._getShader(&#x27;normalVert&#x27;, &#x27;normalFrag&#x27;);
                          return this;
                        };
                        
                        /**
                         * Texture for geometry
                         * @method texture
                         * @return {p5}                the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var img;
                         * function setup(){
                         *   createCanvas(100, 100, WEBGL);
                         *   img = loadImage(&quot;assets/laDefense.jpg&quot;);
                         * }
                         *
                         * function draw(){
                         *   background(0);
                         *   rotateZ(frameCount * 0.01);
                         *   rotateX(frameCount * 0.01);
                         *   rotateY(frameCount * 0.01);
                         *   //pass image as texture
                         *   texture(img);
                         *   box(200, 200, 200);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.texture = function(image){
                          var gl = this._renderer.GL;
                          var shaderProgram = this._renderer._getShader(&#x27;lightVert&#x27;,
                            &#x27;lightTextureFrag&#x27;);
                          gl.useProgram(shaderProgram);
                          if (image instanceof p5.Image) {
                            //check if image is already used as texture
                            if(!image.isTexture){
                              //createTexture and set isTexture to true
                              var tex = gl.createTexture();
                              image.createTexture(tex);
                              gl.bindTexture(gl.TEXTURE_2D, tex);
                              gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
                              image._setProperty(&#x27;isTexture&#x27;, true);
                            }
                            //otherwise we&#x27;re good to bind texture without creating
                            //a new one on the gl
                            else {
                              //TODO
                            }
                            image.loadPixels();
                            var data = new Uint8Array(image.pixels);
                            gl.texImage2D(gl.TEXTURE_2D, 0,
                              gl.RGBA, image.width, image.height,
                              0, gl.RGBA, gl.UNSIGNED_BYTE, data);
                          }
                          //if param is a video
                          else if (image instanceof p5.MediaElement){
                            if(!image.loadedmetadata) {return;}
                            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,
                            gl.UNSIGNED_BYTE, image.elt);
                          }
                          else {
                            //@TODO handle following cases:
                            //- 2D canvas (p5 inst)
                          }
                          if (_isPowerOf2(image.width) &amp;&amp; _isPowerOf2(image.height)) {
                            gl.generateMipmap(gl.TEXTURE_2D);
                          } else {
                            //@TODO this is problematic
                            //image.width = _nextHighestPOT(image.width);
                            //image.height = _nextHighestPOT(image.height);
                            gl.texParameteri(gl.TEXTURE_2D,
                            gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                            gl.texParameteri(gl.TEXTURE_2D,
                            gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                            gl.texParameteri(gl.TEXTURE_2D,
                            gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                            gl.texParameteri(gl.TEXTURE_2D,
                            gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                          }
                          //this is where we&#x27;d activate multi textures
                          //eg. gl.activeTexture(gl.TEXTURE0 + (unit || 0));
                          //but for now we just have a single texture.
                          //@TODO need to extend this functionality
                          //gl.activeTexture(gl.TEXTURE0 + 0);
                          //gl.bindTexture(gl.TEXTURE_2D, tex);
                          gl.uniform1i(gl.getUniformLocation(shaderProgram, &#x27;uSampler&#x27;), 0);
                          gl.uniform1i(gl.getUniformLocation(shaderProgram, &#x27;isTexture&#x27;), true);
                          return this;
                        };
                        
                        /**
                         * Helper functions; Checks whether val is a pot
                         * more info on power of 2 here:
                         * https://www.opengl.org/wiki/NPOT_Texture
                         * @param  {Number}  value
                         * @return {Boolean}
                         */
                        function _isPowerOf2 (value){
                          return (value &amp; (value - 1)) === 0;
                        }
                        
                        /**
                         * returns the next highest power of 2 value
                         * @param  {Number} value [description]
                         * @return {Number}       [description]
                         */
                        // function _nextHighestPOT (value){
                        //   --value;
                        //   for (var i = 1; i &lt; 32; i &lt;&lt;= 1) {
                        //     value = value | value &gt;&gt; i;
                        //   }
                        //   return value + 1;
                        // }
                        
                        /**
                         * Basic material for geometry with a given color
                         * @method  basicMaterial
                         * @param  {Number|Array|String|p5.Color} v1  gray value,
                         * red or hue value (depending on the current color mode),
                         * or color Array, or CSS color string
                         * @param  {Number}            [v2] optional: green or saturation value
                         * @param  {Number}            [v3] optional: blue or brightness value
                         * @param  {Number}            [a]  optional: opacity
                         * @return {p5}                the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * function setup(){
                         *   createCanvas(100, 100, WEBGL);
                         * }
                         *
                         * function draw(){
                         *  background(0);
                         *  basicMaterial(250, 0, 0);
                         *  rotateX(frameCount * 0.01);
                         *  rotateY(frameCount * 0.01);
                         *  rotateZ(frameCount * 0.01);
                         *  box(200, 200, 200);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.basicMaterial = function(v1, v2, v3, a){
                          var gl = this._renderer.GL;
                        
                          var shaderProgram = this._renderer._getShader(&#x27;normalVert&#x27;, &#x27;basicFrag&#x27;);
                        
                          gl.useProgram(shaderProgram);
                          shaderProgram.uMaterialColor = gl.getUniformLocation(
                            shaderProgram, &#x27;uMaterialColor&#x27; );
                        
                          var color = this._renderer._pInst.color.apply(
                            this._renderer._pInst, arguments);
                          var colors = color._array;
                        
                          gl.uniform4f( shaderProgram.uMaterialColor,
                            colors[0], colors[1], colors[2], colors[3]);
                        
                          return this;
                        
                        };
                        
                        /**
                         * Ambient material for geometry with a given color
                         * @method  ambientMaterial
                         * @param  {Number|Array|String|p5.Color} v1  gray value,
                         * red or hue value (depending on the current color mode),
                         * or color Array, or CSS color string
                         * @param  {Number}            [v2] optional: green or saturation value
                         * @param  {Number}            [v3] optional: blue or brightness value
                         * @param  {Number}            [a]  optional: opacity
                        * @return {p5}                 the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * function setup(){
                         *   createCanvas(100, 100, WEBGL);
                         * }
                         * function draw(){
                         *  background(0);
                         *  ambientLight(100);
                         *  pointLight(250, 250, 250, 100, 100, 0);
                         *  ambientMaterial(250);
                         *  sphere(200);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.ambientMaterial = function(v1, v2, v3, a) {
                          var gl = this._renderer.GL;
                          var shaderProgram =
                            this._renderer._getShader(&#x27;lightVert&#x27;, &#x27;lightTextureFrag&#x27;);
                        
                          gl.useProgram(shaderProgram);
                          shaderProgram.uMaterialColor = gl.getUniformLocation(
                            shaderProgram, &#x27;uMaterialColor&#x27; );
                        
                          var color = this._renderer._pInst.color.apply(
                            this._renderer._pInst, arguments);
                          var colors = color._array;
                        
                          gl.uniform4f(shaderProgram.uMaterialColor,
                            colors[0], colors[1], colors[2], colors[3]);
                        
                          shaderProgram.uSpecular = gl.getUniformLocation(
                            shaderProgram, &#x27;uSpecular&#x27; );
                          gl.uniform1i(shaderProgram.uSpecular, false);
                        
                          gl.uniform1i(gl.getUniformLocation(shaderProgram, &#x27;isTexture&#x27;), false);
                        
                          return this;
                        };
                        
                        /**
                         * Specular material for geometry with a given color
                         * @method specularMaterial
                         * @param  {Number|Array|String|p5.Color} v1  gray value,
                         * red or hue value (depending on the current color mode),
                         * or color Array, or CSS color string
                         * @param  {Number}            [v2] optional: green or saturation value
                         * @param  {Number}            [v3] optional: blue or brightness value
                         * @param  {Number}            [a]  optional: opacity
                         * @return {p5}                the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * function setup(){
                         *   createCanvas(100, 100, WEBGL);
                         * }
                         * function draw(){
                         *  background(0);
                         *  ambientLight(100);
                         *  pointLight(250, 250, 250, 100, 100, 0);
                         *  specularMaterial(250);
                         *  sphere(200);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.specularMaterial = function(v1, v2, v3, a) {
                          var gl = this._renderer.GL;
                          var shaderProgram =
                            this._renderer._getShader(&#x27;lightVert&#x27;, &#x27;lightTextureFrag&#x27;);
                          gl.uniform1i(gl.getUniformLocation(shaderProgram, &#x27;isTexture&#x27;), false);
                          gl.useProgram(shaderProgram);
                          shaderProgram.uMaterialColor = gl.getUniformLocation(
                            shaderProgram, &#x27;uMaterialColor&#x27; );
                        
                          var color = this._renderer._pInst.color.apply(
                            this._renderer._pInst, arguments);
                          var colors = color._array;
                        
                          gl.uniform4f(shaderProgram.uMaterialColor,
                            colors[0], colors[1], colors[2], colors[3]);
                        
                          shaderProgram.uSpecular = gl.getUniformLocation(
                            shaderProgram, &#x27;uSpecular&#x27; );
                          gl.uniform1i(shaderProgram.uSpecular, true);
                        
                          return this;
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;../core/core&quot;:48}],34:[function(_dereq_,module,exports){
                        //some of the functions are adjusted from Three.js(http://threejs.org)
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        
                        /**
                         * p5 Geometry3D class
                         */
                        p5.Geometry3D = function(){
                          //an array holding every vertice
                          //each vertex is a p5.Vector
                          this.vertices = [];
                          //an array holding each normals for each vertice
                          //each normal is a p5.Vector
                          this.vertexNormals = [];
                          //an array holding each three indecies of vertices that form a face
                          //[[0, 1, 2], [1, 2, 3], ...]
                          this.faces = [];
                          //an array holding every noraml for each face
                          //each faceNormal is a p5.Vector
                          //[[p5.Vector, p5.Vector, p5.Vector],[p5.Vector, p5.Vector, p5.Vector],...]
                          this.faceNormals = [];
                          //an array of array holding uvs (group according to faces)
                          //[[[0, 0], [1, 0], [1, 0]],...]
                          this.uvs = [];
                        };
                        
                        /**
                         * generate geometriy with parametric method
                         * @param  {Function} func  callback function for how to generate geometry
                         * @param  {Number} detailX number of vertices on horizontal surface
                         * @param  {Number} detailY number of vertices on horizontal surface
                         * @param  {Number} offset  offset of vertices index
                         */
                        p5.Geometry3D.prototype.parametricGeometry = function
                        //@TODO: put func as the last parameters
                        (func, detailX, detailY, offset){
                        
                          var i, j, p;
                          var u, v;
                          offset = offset || 0;
                          this.detailX = detailX;
                          this.detailY = detailY;
                        
                          var sliceCount = detailX + 1;
                          for (i = 0; i &lt;= detailY; i++){
                            v = i / detailY;
                            for (j = 0; j &lt;= detailX; j++){
                              u = j / detailX;
                              p = func(u, v);
                              this.vertices.push(p);
                            }
                          }
                        
                          var a, b, c, d;
                          var uva, uvb, uvc, uvd;
                        
                          for (i = 0; i &lt; detailY; i++){
                            for (j = 0; j &lt; detailX; j++){
                              a = i * sliceCount + j + offset;
                              b = i * sliceCount + j + 1 + offset;
                              c = (i + 1)* sliceCount + j + 1 + offset;
                              d = (i + 1)* sliceCount + j + offset;
                        
                              uva = [j/detailX, i/detailY];
                              uvb = [(j + 1)/ detailX, i/detailY];
                              uvc = [(j + 1)/ detailX, (i + 1)/detailY];
                              uvd = [j/detailX, (i + 1)/detailY];
                        
                              this.faces.push([a, b, d]);
                              this.uvs.push([uva, uvb, uvd]);
                        
                              this.faces.push([b, c, d]);
                              this.uvs.push([uvb, uvc, uvd]);
                            }
                          }
                        };
                        
                        /**
                         * compute faceNormals for a geometry
                         */
                        p5.Geometry3D.prototype.computeFaceNormals = function(){
                        
                          var cb = new p5.Vector();
                          var ab = new p5.Vector();
                        
                          for (var f = 0; f &lt; this.faces.length; f++){
                            var face = this.faces[f];
                            var vA = this.vertices[face[0]];
                            var vB = this.vertices[face[1]];
                            var vC = this.vertices[face[2]];
                        
                            p5.Vector.sub(vC, vB, cb);
                            p5.Vector.sub(vA, vB, ab);
                        
                            var normal = p5.Vector.cross(ab, cb);
                            normal.normalize();
                            normal.mult(-1);
                            this.faceNormals[f] = normal;
                          }
                        
                        };
                        
                        /**
                         * compute vertexNormals for a geometry
                         */
                        p5.Geometry3D.prototype.computeVertexNormals = function (){
                        
                          var v, f, face, faceNormal, vertices;
                          var vertexNormals = [];
                        
                          vertices = new Array(this.vertices.length);
                          for (v = 0; v &lt; this.vertices.length; v++) {
                            vertices[v] = new p5.Vector();
                          }
                        
                          for (f = 0; f &lt; this.faces.length; f++) {
                            face = this.faces[f];
                            faceNormal = this.faceNormals[f];
                        
                            vertices[face[0]].add(faceNormal);
                            vertices[face[1]].add(faceNormal);
                            vertices[face[2]].add(faceNormal);
                          }
                        
                          for (v = 0; v &lt; this.vertices.length; v++) {
                            vertices[v].normalize();
                          }
                        
                          for (f = 0; f &lt; this.faces.length; f++) {
                            face = this.faces[f];
                            vertexNormals[f] = [];
                            vertexNormals[f][0]= vertices[face[0]].copy();
                            vertexNormals[f][1]= vertices[face[1]].copy();
                            vertexNormals[f][2]= vertices[face[2]].copy();
                          }
                        
                          for (f = 0; f &lt; this.faces.length; f++){
                            face = this.faces[f];
                            faceNormal = this.faceNormals[f];
                            this.vertexNormals[face[0]] = vertexNormals[f][0];
                            this.vertexNormals[face[1]] = vertexNormals[f][1];
                            this.vertexNormals[face[2]] = vertexNormals[f][2];
                          }
                        
                        };
                        
                        p5.Geometry3D.prototype.averageNormals = function() {
                        
                          for(var i = 0; i &lt;= this.detailY; i++){
                            var offset = this.detailX + 1;
                            var temp = p5.Vector
                              .add(this.vertexNormals[i*offset],
                                this.vertexNormals[i*offset + this.detailX]);
                            temp = p5.Vector.div(temp, 2);
                            this.vertexNormals[i*offset] = temp;
                            this.vertexNormals[i*offset + this.detailX] = temp;
                          }
                        };
                        
                        p5.Geometry3D.prototype.averagePoleNormals = function() {
                        
                          //average the north pole
                          var sum = new p5.Vector(0, 0, 0);
                          for(var i = 0; i &lt; this.detailX; i++){
                            sum.add(this.vertexNormals[i]);
                          }
                          sum = p5.Vector.div(sum, this.detailX);
                        
                          for(i = 0; i &lt; this.detailX; i++){
                            this.vertexNormals[i] = sum;
                          }
                        
                          //average the south pole
                          sum = new p5.Vector(0, 0, 0);
                          for(i = this.vertices.length - 1;
                            i &gt; this.vertices.length - 1 - this.detailX; i--){
                            sum.add(this.vertexNormals[i]);
                          }
                          sum = p5.Vector.div(sum, this.detailX);
                        
                          for(i = this.vertices.length - 1;
                            i &gt; this.vertices.length - 1 - this.detailX; i--){
                            this.vertexNormals[i] = sum;
                          }
                        };
                        
                        /**
                         * [generateUV description]
                         * @param  {Array} faces [description]
                         * @param  {Array} uvs   [description]
                         */
                        p5.Geometry3D.prototype.generateUV = function(faces, uvs){
                        
                          faces = flatten(faces);
                          uvs = flatten(uvs);
                          var arr = [];
                          faces.forEach(function(item, index){
                            arr[item] = uvs[index];
                          });
                          return flatten(arr);
                        };
                        
                        
                        /**
                         * generate an object containing information needed to create buffer
                         */
                        p5.Geometry3D.prototype.generateObj = function(average, sphere){
                        
                          this.computeFaceNormals();
                          this.computeVertexNormals();
                        
                          if(average){
                            this.averageNormals();
                          }
                        
                          if(sphere){
                            this.averagePoleNormals();
                          }
                        
                          var obj = {
                            vertices: turnVectorArrayIntoNumberArray(this.vertices),
                            vertexNormals: turnVectorArrayIntoNumberArray(this.vertexNormals),
                            uvs: this.generateUV(this.faces, this.uvs),
                            faces: flatten(this.faces),
                            len: this.faces.length * 3
                          };
                          return obj;
                        };
                        
                        /**
                         * turn a two dimensional array into one dimensional array
                         * @param  {Array} arr 2-dimensional array
                         * @return {Array}     1-dimensional array
                         * [[1, 2, 3],[4, 5, 6]] -&gt; [1, 2, 3, 4, 5, 6]
                         */
                        function flatten(arr){
                          return arr.reduce(function(a, b){
                            return a.concat(b);
                          });
                        }
                        
                        /**
                         * turn an array of Vector into a one dimensional array of numbers
                         * @param  {Array} arr  an array of p5.Vector
                         * @return {Array]}     a one dimensional array of numbers
                         * [p5.Vector(1, 2, 3), p5.Vector(4, 5, 6)] -&gt;
                         * [1, 2, 3, 4, 5, 6]
                         */
                        function turnVectorArrayIntoNumberArray(arr){
                          return flatten(arr.map(function(item){
                            return [item.x, item.y, item.z];
                          }));
                        }
                        
                        module.exports = p5.Geometry3D;
                        },{&quot;../core/core&quot;:48}],35:[function(_dereq_,module,exports){
                        /**
                        * @requires constants
                        * @todo see methods below needing further implementation.
                        * future consideration: implement SIMD optimizations
                        * when browser compatibility becomes available
                        * https://developer.mozilla.org/en-US/docs/Web/JavaScript/
                        *   Reference/Global_Objects/SIMD
                        */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        var polarGeometry = _dereq_(&#x27;../math/polargeometry&#x27;);
                        var constants = _dereq_(&#x27;../core/constants&#x27;);
                        var GLMAT_ARRAY_TYPE = (
                            typeof Float32Array !== &#x27;undefined&#x27;) ?
                          Float32Array : Array;
                        
                        /**
                         * A class to describe a 4x4 matrix
                         * for model and view matrix manipulation in the p5js webgl renderer.
                         * class p5.Matrix
                         * @constructor
                         * @param {Array} [mat4] array literal of our 4x4 matrix
                         */
                        p5.Matrix = function() {
                          // This is how it comes in with createMatrix()
                          if(arguments[0] instanceof p5) {
                            // save reference to p5 if passed in
                            this.p5 = arguments[0];
                            this.mat4  = arguments[1] || new GLMAT_ARRAY_TYPE([
                              1, 0, 0, 0,
                              0, 1, 0, 0,
                              0, 0, 1, 0,
                              0, 0, 0, 1
                            ]);
                          // This is what we&#x27;ll get with new p5.Matrix()
                          // a mat4 identity matrix
                          } else {
                            this.mat4 = arguments[0] || new GLMAT_ARRAY_TYPE([
                              1, 0, 0, 0,
                              0, 1, 0, 0,
                              0, 0, 1, 0,
                              0, 0, 0, 1
                            ]);
                          }
                          return this;
                        };
                        
                        /**
                         * Sets the x, y, and z component of the vector using two or three separate
                         * variables, the data from a p5.Matrix, or the values from a float array.
                         *
                         * @param {p5.Matrix|Array} [inMatrix] the input p5.Matrix or
                         *                                     an Array of length 16
                         */
                        p5.Matrix.prototype.set = function (inMatrix) {
                          if (inMatrix instanceof p5.Matrix) {
                            this.mat4 = inMatrix.mat4;
                            return this;
                          }
                          else if (inMatrix instanceof GLMAT_ARRAY_TYPE) {
                            this.mat4 = inMatrix;
                            return this;
                          }
                          return this;
                        };
                        
                        /**
                         * Gets a copy of the vector, returns a p5.Matrix object.
                         *
                         * @return {p5.Matrix} the copy of the p5.Matrix object
                         */
                        p5.Matrix.prototype.get = function () {
                          return new p5.Matrix(this.mat4);
                        };
                        
                        /**
                         * return a copy of a matrix
                         * @return {p5.Matrix}   the result matrix
                         */
                        p5.Matrix.prototype.copy = function(){
                          var copied = new p5.Matrix();
                          copied.mat4[0] = this.mat4[0];
                          copied.mat4[1] = this.mat4[1];
                          copied.mat4[2] = this.mat4[2];
                          copied.mat4[3] = this.mat4[3];
                          copied.mat4[4] = this.mat4[4];
                          copied.mat4[5] = this.mat4[5];
                          copied.mat4[6] = this.mat4[6];
                          copied.mat4[7] = this.mat4[7];
                          copied.mat4[8] = this.mat4[8];
                          copied.mat4[9] = this.mat4[9];
                          copied.mat4[10] = this.mat4[10];
                          copied.mat4[11] = this.mat4[11];
                          copied.mat4[12] = this.mat4[12];
                          copied.mat4[13] = this.mat4[13];
                          copied.mat4[14] = this.mat4[14];
                          copied.mat4[15] = this.mat4[15];
                          return copied;
                        };
                        
                        /**
                         * return an identity matrix
                         * @return {p5.Matrix}   the result matrix
                         */
                        p5.Matrix.identity = function(){
                          return new p5.Matrix();
                        };
                        
                        /**
                         * transpose according to a given matrix
                         * @param  {p5.Matrix | Typed Array} a  the matrix to be based on to transpose
                         * @return {p5.Matrix}                  this
                         */
                        p5.Matrix.prototype.transpose = function(a){
                          var a01, a02, a03, a12, a13, a23;
                          if(a instanceof p5.Matrix){
                            a01 = a.mat4[1];
                            a02 = a.mat4[2];
                            a03 = a.mat4[3];
                            a12 = a.mat4[6];
                            a13 = a.mat4[7];
                            a23 = a.mat4[11];
                        
                            this.mat4[0] = a.mat4[0];
                            this.mat4[1] = a.mat4[4];
                            this.mat4[2] = a.mat4[8];
                            this.mat4[3] = a.mat4[12];
                            this.mat4[4] = a01;
                            this.mat4[5] = a.mat4[5];
                            this.mat4[6] = a.mat4[9];
                            this.mat4[7] = a.mat4[13];
                            this.mat4[8] = a02;
                            this.mat4[9] = a12;
                            this.mat4[10] = a.mat4[10];
                            this.mat4[11] = a.mat4[14];
                            this.mat4[12] = a03;
                            this.mat4[13] = a13;
                            this.mat4[14] = a23;
                            this.mat4[15] = a.mat4[15];
                        
                          }else if(a instanceof GLMAT_ARRAY_TYPE){
                            a01 = a[1];
                            a02 = a[2];
                            a03 = a[3];
                            a12 = a[6];
                            a13 = a[7];
                            a23 = a[11];
                        
                            this.mat4[0] = a[0];
                            this.mat4[1] = a[4];
                            this.mat4[2] = a[8];
                            this.mat4[3] = a[12];
                            this.mat4[4] = a01;
                            this.mat4[5] = a[5];
                            this.mat4[6] = a[9];
                            this.mat4[7] = a[13];
                            this.mat4[8] = a02;
                            this.mat4[9] = a12;
                            this.mat4[10] = a[10];
                            this.mat4[11] = a[14];
                            this.mat4[12] = a03;
                            this.mat4[13] = a13;
                            this.mat4[14] = a23;
                            this.mat4[15] = a[15];
                          }
                          return this;
                        };
                        
                        /**
                         * invert  matrix according to a give matrix
                         * @param  {p5.Matrix or Typed Array} a   the matrix to be based on to invert
                         * @return {p5.Matrix}                    this
                         */
                        p5.Matrix.prototype.invert = function(a){
                          var a00, a01, a02, a03, a10, a11, a12, a13,
                          a20, a21, a22, a23, a30, a31, a32, a33;
                          if(a instanceof p5.Matrix){
                            a00 = a.mat4[0];
                            a01 = a.mat4[1];
                            a02 = a.mat4[2];
                            a03 = a.mat4[3];
                            a10 = a.mat4[4];
                            a11 = a.mat4[5];
                            a12 = a.mat4[6];
                            a13 = a.mat4[7];
                            a20 = a.mat4[8];
                            a21 = a.mat4[9];
                            a22 = a.mat4[10];
                            a23 = a.mat4[11];
                            a30 = a.mat4[12];
                            a31 = a.mat4[13];
                            a32 = a.mat4[14];
                            a33 = a.mat4[15];
                          }else if(a instanceof GLMAT_ARRAY_TYPE){
                            a00 = a[0];
                            a01 = a[1];
                            a02 = a[2];
                            a03 = a[3];
                            a10 = a[4];
                            a11 = a[5];
                            a12 = a[6];
                            a13 = a[7];
                            a20 = a[8];
                            a21 = a[9];
                            a22 = a[10];
                            a23 = a[11];
                            a30 = a[12];
                            a31 = a[13];
                            a32 = a[14];
                            a33 = a[15];
                          }
                          var b00 = a00 * a11 - a01 * a10,
                          b01 = a00 * a12 - a02 * a10,
                          b02 = a00 * a13 - a03 * a10,
                          b03 = a01 * a12 - a02 * a11,
                          b04 = a01 * a13 - a03 * a11,
                          b05 = a02 * a13 - a03 * a12,
                          b06 = a20 * a31 - a21 * a30,
                          b07 = a20 * a32 - a22 * a30,
                          b08 = a20 * a33 - a23 * a30,
                          b09 = a21 * a32 - a22 * a31,
                          b10 = a21 * a33 - a23 * a31,
                          b11 = a22 * a33 - a23 * a32,
                        
                          // Calculate the determinant
                          det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 -
                          b04 * b07 + b05 * b06;
                        
                          if (!det) {
                            return null;
                          }
                          det = 1.0 / det;
                        
                          this.mat4[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                          this.mat4[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                          this.mat4[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                          this.mat4[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
                          this.mat4[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                          this.mat4[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                          this.mat4[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                          this.mat4[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
                          this.mat4[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                          this.mat4[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                          this.mat4[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                          this.mat4[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
                          this.mat4[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
                          this.mat4[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
                          this.mat4[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
                          this.mat4[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
                        
                          return this;
                        };
                        
                        /**
                         * inspired by Toji&#x27;s mat4 determinant
                         * @return {Number} Determinant of our 4x4 matrix
                         */
                        p5.Matrix.prototype.determinant = function(){
                          var d00 = (this.mat4[0] * this.mat4[5]) - (this.mat4[1] * this.mat4[4]),
                            d01 = (this.mat4[0] * this.mat4[6]) - (this.mat4[2] * this.mat4[4]),
                            d02 = (this.mat4[0] * this.mat4[7]) - (this.mat4[3] * this.mat4[4]),
                            d03 = (this.mat4[1] * this.mat4[6]) - (this.mat4[2] * this.mat4[5]),
                            d04 = (this.mat4[1] * this.mat4[7]) - (this.mat4[3] * this.mat4[5]),
                            d05 = (this.mat4[2] * this.mat4[7]) - (this.mat4[3] * this.mat4[6]),
                            d06 = (this.mat4[8] * this.mat4[13]) - (this.mat4[9] * this.mat4[12]),
                            d07 = (this.mat4[8] * this.mat4[14]) - (this.mat4[10] * this.mat4[12]),
                            d08 = (this.mat4[8] * this.mat4[15]) - (this.mat4[11] * this.mat4[12]),
                            d09 = (this.mat4[9] * this.mat4[14]) - (this.mat4[10] * this.mat4[13]),
                            d10 = (this.mat4[9] * this.mat4[15]) - (this.mat4[11] * this.mat4[13]),
                            d11 = (this.mat4[10] * this.mat4[15]) - (this.mat4[11] * this.mat4[14]);
                        
                          // Calculate the determinant
                          return d00 * d11 - d01 * d10 + d02 * d09 +
                            d03 * d08 - d04 * d07 + d05 * d06;
                        };
                        
                        /**
                         * multiply two mat4s
                         * @param {p5.Matrix | Array}  multMatrix The matrix we want to multiply by
                         * @return {p5.Matrix}         this
                         */
                        p5.Matrix.prototype.mult = function(multMatrix){
                          var _dest = new GLMAT_ARRAY_TYPE(16);
                          var _src = new GLMAT_ARRAY_TYPE(16);
                        
                          if(multMatrix instanceof p5.Matrix) {
                            _src = multMatrix.mat4;
                          }
                          else if(multMatrix instanceof GLMAT_ARRAY_TYPE){
                            _src = multMatrix;
                          }
                        
                          // each row is used for the multiplier
                          var b0  = this.mat4[0], b1 = this.mat4[1],
                            b2 = this.mat4[2], b3 = this.mat4[3];
                          _dest[0] = b0*_src[0] + b1*_src[4] + b2*_src[8] + b3*_src[12];
                          _dest[1] = b0*_src[1] + b1*_src[5] + b2*_src[9] + b3*_src[13];
                          _dest[2] = b0*_src[2] + b1*_src[6] + b2*_src[10] + b3*_src[14];
                          _dest[3] = b0*_src[3] + b1*_src[7] + b2*_src[11] + b3*_src[15];
                        
                          b0 = this.mat4[4];
                          b1 = this.mat4[5];
                          b2 = this.mat4[6];
                          b3 = this.mat4[7];
                          _dest[4] = b0*_src[0] + b1*_src[4] + b2*_src[8] + b3*_src[12];
                          _dest[5] = b0*_src[1] + b1*_src[5] + b2*_src[9] + b3*_src[13];
                          _dest[6] = b0*_src[2] + b1*_src[6] + b2*_src[10] + b3*_src[14];
                          _dest[7] = b0*_src[3] + b1*_src[7] + b2*_src[11] + b3*_src[15];
                        
                          b0 = this.mat4[8];
                          b1 = this.mat4[9];
                          b2 = this.mat4[10];
                          b3 = this.mat4[11];
                          _dest[8] = b0*_src[0] + b1*_src[4] + b2*_src[8] + b3*_src[12];
                          _dest[9] = b0*_src[1] + b1*_src[5] + b2*_src[9] + b3*_src[13];
                          _dest[10] = b0*_src[2] + b1*_src[6] + b2*_src[10] + b3*_src[14];
                          _dest[11] = b0*_src[3] + b1*_src[7] + b2*_src[11] + b3*_src[15];
                        
                          b0 = this.mat4[12];
                          b1 = this.mat4[13];
                          b2 = this.mat4[14];
                          b3 = this.mat4[15];
                          _dest[12] = b0*_src[0] + b1*_src[4] + b2*_src[8] + b3*_src[12];
                          _dest[13] = b0*_src[1] + b1*_src[5] + b2*_src[9] + b3*_src[13];
                          _dest[14] = b0*_src[2] + b1*_src[6] + b2*_src[10] + b3*_src[14];
                          _dest[15] = b0*_src[3] + b1*_src[7] + b2*_src[11] + b3*_src[15];
                        
                          this.mat4 = _dest;
                        
                          return this;
                        };
                        
                        /**
                         * scales a p5.Matrix by scalars or a vector
                         * @param  {p5.Vector | Array }
                         *                      vector to scale by
                         * @return {p5.Matrix}  this
                         */
                        p5.Matrix.prototype.scale = function() {
                          var x,y,z;
                          var args = new Array(arguments.length);
                          for(var i = 0; i &lt; args.length; i++) {
                            args[i] = arguments[i];
                          }
                          //if our 1st arg is a type p5.Vector
                          if (args[0] instanceof p5.Vector){
                            x = args[0].x;
                            y = args[0].y;
                            z = args[0].z;
                          }
                          //otherwise if it&#x27;s an array
                          else if (args[0] instanceof Array){
                            x = args[0][0];
                            y = args[0][1];
                            z = args[0][2];
                          }
                          var _dest = new GLMAT_ARRAY_TYPE(16);
                          _dest[0] = this.mat4[0] * x;
                          _dest[1] = this.mat4[1] * x;
                          _dest[2] = this.mat4[2] * x;
                          _dest[3] = this.mat4[3] * x;
                          _dest[4] = this.mat4[4] * y;
                          _dest[5] = this.mat4[5] * y;
                          _dest[6] = this.mat4[6] * y;
                          _dest[7] = this.mat4[7] * y;
                          _dest[8] = this.mat4[8] * z;
                          _dest[9] = this.mat4[9] * z;
                          _dest[10] = this.mat4[10] * z;
                          _dest[11] = this.mat4[11] * z;
                          _dest[12] = this.mat4[12];
                          _dest[13] = this.mat4[13];
                          _dest[14] = this.mat4[14];
                          _dest[15] = this.mat4[15];
                        
                          this.mat4 = _dest;
                          return this;
                        };
                        
                        /**
                         * rotate our Matrix around an axis by the given angle.
                         * @param  {Number} a The angle of rotation in radians
                         * @param  {p5.Vector | Array} axis  the axis(es) to rotate around
                         * @return {p5.Matrix}                    this
                         * inspired by Toji&#x27;s gl-matrix lib, mat4 rotation
                         */
                        p5.Matrix.prototype.rotate = function(a, axis){
                          var x, y, z, _a, len;
                        
                          if (this.p5) {
                            if (this.p5._angleMode === constants.DEGREES) {
                              _a = polarGeometry.degreesToRadians(a);
                            }
                          }
                          else {
                            _a = a;
                          }
                          if (axis instanceof p5.Vector) {
                            x = axis.x;
                            y = axis.y;
                            z = axis.z;
                          }
                          else if (axis instanceof Array) {
                            x = axis[0];
                            y = axis[1];
                            z = axis[2];
                          }
                        
                          len = Math.sqrt(x * x + y * y + z * z);
                          x *= (1/len);
                          y *= (1/len);
                          z *= (1/len);
                        
                          var a00 = this.mat4[0];
                          var a01 = this.mat4[1];
                          var a02 = this.mat4[2];
                          var a03 = this.mat4[3];
                          var a10 = this.mat4[4];
                          var a11 = this.mat4[5];
                          var a12 = this.mat4[6];
                          var a13 = this.mat4[7];
                          var a20 = this.mat4[8];
                          var a21 = this.mat4[9];
                          var a22 = this.mat4[10];
                          var a23 = this.mat4[11];
                        
                          //sin,cos, and tan of respective angle
                          var sA = Math.sin(_a);
                          var cA = Math.cos(_a);
                          var tA = 1 - cA;
                          // Construct the elements of the rotation matrix
                          var b00 = x * x * tA + cA;
                          var b01 = y * x * tA + z * sA;
                          var b02 = z * x * tA - y * sA;
                          var b10 = x * y * tA - z * sA;
                          var b11 = y * y * tA + cA;
                          var b12 = z * y * tA + x * sA;
                          var b20 = x * z * tA + y * sA;
                          var b21 = y * z * tA - x * sA;
                          var b22 = z * z * tA + cA;
                        
                          // rotation-specific matrix multiplication
                          this.mat4[0] = a00 * b00 + a10 * b01 + a20 * b02;
                          this.mat4[1] = a01 * b00 + a11 * b01 + a21 * b02;
                          this.mat4[2] = a02 * b00 + a12 * b01 + a22 * b02;
                          this.mat4[3] = a03 * b00 + a13 * b01 + a23 * b02;
                          this.mat4[4] = a00 * b10 + a10 * b11 + a20 * b12;
                          this.mat4[5] = a01 * b10 + a11 * b11 + a21 * b12;
                          this.mat4[6] = a02 * b10 + a12 * b11 + a22 * b12;
                          this.mat4[7] = a03 * b10 + a13 * b11 + a23 * b12;
                          this.mat4[8] = a00 * b20 + a10 * b21 + a20 * b22;
                          this.mat4[9] = a01 * b20 + a11 * b21 + a21 * b22;
                          this.mat4[10] = a02 * b20 + a12 * b21 + a22 * b22;
                          this.mat4[11] = a03 * b20 + a13 * b21 + a23 * b22;
                        
                          return this;
                        };
                        
                        /**
                         * @todo  finish implementing this method!
                         * translates
                         * @param  {Array} v vector to translate by
                         * @return {p5.Matrix}                    this
                         */
                        p5.Matrix.prototype.translate = function(v){
                          var x = v[0],
                            y = v[1],
                            z = v[2] || 0;
                          this.mat4[12] =
                            this.mat4[0] * x +this.mat4[4] * y +this.mat4[8] * z +this.mat4[12];
                          this.mat4[13] =
                            this.mat4[1] * x +this.mat4[5] * y +this.mat4[9] * z +this.mat4[13];
                          this.mat4[14] =
                            this.mat4[2] * x +this.mat4[6] * y +this.mat4[10] * z +this.mat4[14];
                          this.mat4[15] =
                            this.mat4[3] * x +this.mat4[7] * y +this.mat4[11] * z +this.mat4[15];
                        };
                        
                        p5.Matrix.prototype.rotateX = function(a){
                          this.rotate(a, [1,0,0]);
                        };
                        p5.Matrix.prototype.rotateY = function(a){
                          this.rotate(a, [0,1,0]);
                        };
                        p5.Matrix.prototype.rotateZ = function(a){
                          this.rotate(a, [0,0,1]);
                        };
                        
                        /**
                         * sets the perspective matrix
                         * @param  {Number} fovy   [description]
                         * @param  {Number} aspect [description]
                         * @param  {Number} near   near clipping plane
                         * @param  {Number} far    far clipping plane
                         * @return {void}
                         */
                        p5.Matrix.prototype.perspective = function(fovy,aspect,near,far){
                        
                          var f = 1.0 / Math.tan(fovy / 2),
                            nf = 1 / (near - far);
                        
                          this.mat4[0] = f / aspect;
                          this.mat4[1] = 0;
                          this.mat4[2] = 0;
                          this.mat4[3] = 0;
                          this.mat4[4] = 0;
                          this.mat4[5] = f;
                          this.mat4[6] = 0;
                          this.mat4[7] = 0;
                          this.mat4[8] = 0;
                          this.mat4[9] = 0;
                          this.mat4[10] = (far + near) * nf;
                          this.mat4[11] = -1;
                          this.mat4[12] = 0;
                          this.mat4[13] = 0;
                          this.mat4[14] = (2 * far * near) * nf;
                          this.mat4[15] = 0;
                        
                          return this;
                        
                        };
                        
                        /**
                         * sets the ortho matrix
                         * @param  {Number} left   [description]
                         * @param  {Number} right  [description]
                         * @param  {Number} bottom [description]
                         * @param  {Number} top    [description]
                         * @param  {Number} near   near clipping plane
                         * @param  {Number} far    far clipping plane
                         * @return {void}
                         */
                        p5.Matrix.prototype.ortho = function(left,right,bottom,top,near,far){
                        
                          var lr = 1 / (left - right),
                            bt = 1 / (bottom - top),
                            nf = 1 / (near - far);
                          this.mat4[0] = -2 * lr;
                          this.mat4[1] = 0;
                          this.mat4[2] = 0;
                          this.mat4[3] = 0;
                          this.mat4[4] = 0;
                          this.mat4[5] = -2 * bt;
                          this.mat4[6] = 0;
                          this.mat4[7] = 0;
                          this.mat4[8] = 0;
                          this.mat4[9] = 0;
                          this.mat4[10] = 2 * nf;
                          this.mat4[11] = 0;
                          this.mat4[12] = (left + right) * lr;
                          this.mat4[13] = (top + bottom) * bt;
                          this.mat4[14] = (far + near) * nf;
                          this.mat4[15] = 1;
                        
                          return this;
                        };
                        
                        /**
                         * PRIVATE
                         */
                        // matrix methods adapted from:
                        // https://developer.mozilla.org/en-US/docs/Web/WebGL/
                        // gluPerspective
                        //
                        // function _makePerspective(fovy, aspect, znear, zfar){
                        //    var ymax = znear * Math.tan(fovy * Math.PI / 360.0);
                        //    var ymin = -ymax;
                        //    var xmin = ymin * aspect;
                        //    var xmax = ymax * aspect;
                        //    return _makeFrustum(xmin, xmax, ymin, ymax, znear, zfar);
                        //  }
                        
                        ////
                        //// glFrustum
                        ////
                        //function _makeFrustum(left, right, bottom, top, znear, zfar){
                        //  var X = 2*znear/(right-left);
                        //  var Y = 2*znear/(top-bottom);
                        //  var A = (right+left)/(right-left);
                        //  var B = (top+bottom)/(top-bottom);
                        //  var C = -(zfar+znear)/(zfar-znear);
                        //  var D = -2*zfar*znear/(zfar-znear);
                        //  var frustrumMatrix =[
                        //  X, 0, A, 0,
                        //  0, Y, B, 0,
                        //  0, 0, C, D,
                        //  0, 0, -1, 0
                        //];
                        //return frustrumMatrix;
                        // }
                        
                        // function _setMVPMatrices(){
                        ////an identity matrix
                        ////@TODO use the p5.Matrix class to abstract away our MV matrices and
                        ///other math
                        //var _mvMatrix =
                        //[
                        //  1.0,0.0,0.0,0.0,
                        //  0.0,1.0,0.0,0.0,
                        //  0.0,0.0,1.0,0.0,
                        //  0.0,0.0,0.0,1.0
                        //];
                        
                        module.exports = p5.Matrix;
                        },{&quot;../core/constants&quot;:47,&quot;../core/core&quot;:48,&quot;../math/polargeometry&quot;:77}],36:[function(_dereq_,module,exports){
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        var shader = _dereq_(&#x27;./shader&#x27;);
                        _dereq_(&#x27;../core/p5.Renderer&#x27;);
                        _dereq_(&#x27;./p5.Matrix&#x27;);
                        var uMVMatrixStack = [];
                        var RESOLUTION = 1000;
                        
                        //@TODO should probably implement an override for these attributes
                        var attributes = {
                          alpha: true,
                          depth: true,
                          stencil: true,
                          antialias: false,
                          premultipliedAlpha: false,
                          preserveDrawingBuffer: false
                        };
                        
                        /**
                         * 3D graphics class.  Can also be used as an off-screen graphics buffer.
                         * A p5.Renderer3D object can be constructed
                         *
                         */
                        p5.Renderer3D = function(elt, pInst, isMainCanvas) {
                          p5.Renderer.call(this, elt, pInst, isMainCanvas);
                        
                          try {
                            this.drawingContext = this.canvas.getContext(&#x27;webgl&#x27;, attributes) ||
                              this.canvas.getContext(&#x27;experimental-webgl&#x27;, attributes);
                            if (this.drawingContext === null) {
                              throw new Error(&#x27;Error creating webgl context&#x27;);
                            } else {
                              console.log(&#x27;p5.Renderer3D: enabled webgl context&#x27;);
                            }
                          } catch (er) {
                            throw new Error(er);
                          }
                        
                          this.isP3D = true; //lets us know we&#x27;re in 3d mode
                          this.GL = this.drawingContext;
                          var gl = this.GL;
                          gl.clearColor(1.0, 1.0, 1.0, 1.0); //background is initialized white
                          gl.clearDepth(1);
                          gl.enable(gl.DEPTH_TEST);
                          gl.depthFunc(gl.LEQUAL);
                          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                          gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                          this._init();
                          return this;
                        };
                        
                        p5.Renderer3D.prototype = Object.create(p5.Renderer.prototype);
                        
                        p5.Renderer3D.prototype._applyDefaults = function() {
                          return this;
                        };
                        
                        //////////////////////////////////////////////
                        // Setting
                        //////////////////////////////////////////////
                        
                        p5.Renderer3D.prototype._init = function(first_argument) {
                          var gl = this.GL;
                          //for our default matrices
                          this.initMatrix();
                          this.initHash();
                          //for immedidate mode
                          this.verticeStack = [];
                          this.verticeBuffer = gl.createBuffer();
                          this.colorBuffer = gl.createBuffer();
                          //for camera
                          this._setCamera = false;
                          //for counting lights
                          this.ambientLightCount = 0;
                          this.directionalLightCount = 0;
                          this.pointLightCount = 0;
                        };
                        
                        p5.Renderer3D.prototype._update = function() {
                          this.resetMatrix();
                          this.translate(0, 0, -800);
                          this.ambientLightCount = 0;
                          this.directionalLightCount = 0;
                          this.pointLightCount = 0;
                          this.verticeStack = [];
                        };
                        
                        /**
                         * [resize description]
                         * @param  {[type]} w [description]
                         * @param  {[tyoe]} h [description]
                         * @return {[type]}   [description]
                         */
                        p5.Renderer3D.prototype.resize = function(w,h) {
                          var gl = this.GL;
                          p5.Renderer.prototype.resize.call(this, w, h);
                          gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                        };
                        
                        /**
                         * [background description]
                         * @return {[type]} [description]
                         */
                        p5.Renderer3D.prototype.background = function() {
                          var gl = this.GL;
                          var _col = this._pInst.color.apply(this._pInst, arguments);
                          // gl.clearColor(0.0,0.0,0.0,1.0);
                          var _r = (_col.levels[0]) / 255;
                          var _g = (_col.levels[1]) / 255;
                          var _b = (_col.levels[2]) / 255;
                          var _a = (_col.levels[3]) / 255;
                          gl.clearColor(_r, _g, _b, _a);
                          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                        };
                        
                        //@TODO implement this
                        // p5.Renderer3D.prototype.clear = function() {
                        //@TODO
                        // };
                        
                        //////////////////////////////////////////////
                        // SHADER
                        //////////////////////////////////////////////
                        
                        /**
                         * [initShaders description]
                         * @param  {[type]} vertId [description]
                         * @param  {[type]} fragId [description]
                         * @return {[type]}        [description]
                         */
                        p5.Renderer3D.prototype.initShaders = function(vertId, fragId, immediateMode) {
                          var gl = this.GL;
                          //set up our default shaders by:
                          // 1. create the shader,
                          // 2. load the shader source,
                          // 3. compile the shader
                          var _vertShader = gl.createShader(gl.VERTEX_SHADER);
                          //load in our default vertex shader
                          gl.shaderSource(_vertShader, shader[vertId]);
                          gl.compileShader(_vertShader);
                          // if our vertex shader failed compilation?
                          if (!gl.getShaderParameter(_vertShader, gl.COMPILE_STATUS)) {
                            alert(&#x27;Yikes! An error occurred compiling the shaders:&#x27; +
                              gl.getShaderInfoLog(_vertShader));
                            return null;
                          }
                        
                          var _fragShader = gl.createShader(gl.FRAGMENT_SHADER);
                          //load in our material frag shader
                          gl.shaderSource(_fragShader, shader[fragId]);
                          gl.compileShader(_fragShader);
                          // if our frag shader failed compilation?
                          if (!gl.getShaderParameter(_fragShader, gl.COMPILE_STATUS)) {
                            alert(&#x27;Darn! An error occurred compiling the shaders:&#x27; +
                              gl.getShaderInfoLog(_fragShader));
                            return null;
                          }
                        
                          var shaderProgram = gl.createProgram();
                          gl.attachShader(shaderProgram, _vertShader);
                          gl.attachShader(shaderProgram, _fragShader);
                          gl.linkProgram(shaderProgram);
                          if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                            alert(&#x27;Snap! Error linking shader program&#x27;);
                          }
                          //END SHADERS SETUP
                        
                          this._getLocation(shaderProgram, immediateMode);
                        
                          return shaderProgram;
                        };
                        
                        p5.Renderer3D.prototype._getLocation = function(shaderProgram, immediateMode) {
                          var gl = this.GL;
                          gl.useProgram(shaderProgram);
                          shaderProgram.uResolution =
                            gl.getUniformLocation(shaderProgram, &#x27;uResolution&#x27;);
                          gl.uniform1f(shaderProgram.uResolution, RESOLUTION);
                        
                          //vertex position Attribute
                          shaderProgram.vertexPositionAttribute =
                            gl.getAttribLocation(shaderProgram, &#x27;aPosition&#x27;);
                          gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
                        
                          //projection Matrix uniform
                          shaderProgram.uPMatrixUniform =
                            gl.getUniformLocation(shaderProgram, &#x27;uProjectionMatrix&#x27;);
                          //model view Matrix uniform
                          shaderProgram.uMVMatrixUniform =
                            gl.getUniformLocation(shaderProgram, &#x27;uModelViewMatrix&#x27;);
                        
                          //@TODO: figure out a better way instead of if statement
                          if(immediateMode === undefined){
                            //vertex normal Attribute
                            shaderProgram.vertexNormalAttribute =
                              gl.getAttribLocation(shaderProgram, &#x27;aNormal&#x27;);
                            gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);
                        
                            //normal Matrix uniform
                            shaderProgram.uNMatrixUniform =
                            gl.getUniformLocation(shaderProgram, &#x27;uNormalMatrix&#x27;);
                        
                            //texture coordinate Attribute
                            shaderProgram.textureCoordAttribute =
                              gl.getAttribLocation(shaderProgram, &#x27;aTexCoord&#x27;);
                            gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
                        
                            shaderProgram.samplerUniform =
                            gl.getUniformLocation(shaderProgram, &#x27;uSampler&#x27;);
                          }
                        };
                        
                        p5.Renderer3D.prototype.setMatrixUniforms = function(shaderKey) {
                          var gl = this.GL;
                          var shaderProgram = this.mHash[shaderKey];
                        
                          gl.useProgram(shaderProgram);
                        
                          gl.uniformMatrix4fv(
                            shaderProgram.uPMatrixUniform,
                            false, this.uPMatrix.mat4);
                        
                          gl.uniformMatrix4fv(
                            shaderProgram.uMVMatrixUniform,
                            false, this.uMVMatrix.mat4);
                        
                          this.uNMatrix = new p5.Matrix();
                          this.uNMatrix.invert(this.uMVMatrix);
                          this.uNMatrix.transpose(this.uNMatrix);
                        
                          gl.uniformMatrix4fv(
                            shaderProgram.uNMatrixUniform,
                            false, this.uNMatrix.mat4);
                        };
                        //////////////////////////////////////////////
                        // GET CURRENT | for shader and color
                        //////////////////////////////////////////////
                        p5.Renderer3D.prototype._getShader = function(vertId, fragId, immediateMode) {
                          var mId = vertId+ &#x27;|&#x27; + fragId;
                          //create it and put it into hashTable
                          if(!this.materialInHash(mId)){
                            var shaderProgram = this.initShaders(vertId, fragId, immediateMode);
                            this.mHash[mId] = shaderProgram;
                          }
                          this.curShaderId = mId;
                        
                          return this.mHash[this.curShaderId];
                        };
                        
                        p5.Renderer3D.prototype._getCurShaderId = function(){
                          //if it&#x27;s not defined yet
                          if(this.curShaderId === undefined){
                            //default shader: normalMaterial()
                            var mId = &#x27;normalVert|normalFrag&#x27;;
                            var shaderProgram = this.initShaders(&#x27;normalVert&#x27;, &#x27;normalFrag&#x27;);
                            this.mHash[mId] = shaderProgram;
                            this.curShaderId = mId;
                          }
                        
                          return this.curShaderId;
                        };
                        
                        p5.Renderer3D.prototype._getCurColor = function() {
                          //default color: gray
                          if(this.curColor === undefined) {
                            this.curColor = [0.5, 0.5, 0.5, 1.0];
                          }
                          return this.curColor;
                        };
                        
                        //////////////////////////////////////////////
                        // HASH | for material and geometry
                        //////////////////////////////////////////////
                        
                        p5.Renderer3D.prototype.initHash = function(){
                          this.gHash = {};
                          this.mHash = {};
                        };
                        
                        p5.Renderer3D.prototype.geometryInHash = function(gId){
                          return this.gHash[gId] !== undefined;
                        };
                        
                        p5.Renderer3D.prototype.materialInHash = function(mId){
                          return this.mHash[mId] !== undefined;
                        };
                        
                        //////////////////////////////////////////////
                        // MATRIX
                        //////////////////////////////////////////////
                        
                        p5.Renderer3D.prototype.initMatrix = function(){
                          this.uMVMatrix = new p5.Matrix();
                          this.uPMatrix  = new p5.Matrix();
                          this.uNMatrix = new p5.Matrix();
                        };
                        
                        p5.Renderer3D.prototype.resetMatrix = function() {
                          this.uMVMatrix = p5.Matrix.identity();
                          //this.uPMatrix = p5.Matrix.identity();
                        };
                        
                        //detect if user didn&#x27;t set the camera
                        //then call this function below
                        p5.Renderer3D.prototype._setDefaultCamera = function(){
                          if(!this._setCamera){
                            var _w = this.width;
                            var _h = this.height;
                            this.uPMatrix = p5.Matrix.identity();
                            this.uPMatrix.perspective(60 / 180 * Math.PI, _w / _h, 0.1, 100);
                            this._setCamera = true;
                          }
                        };
                        
                        /**
                         * [translate description]
                         * @param  {[type]} x [description]
                         * @param  {[type]} y [description]
                         * @param  {[type]} z [description]
                         * @return {[type]}   [description]
                         * @todo implement handle for components or vector as args
                         */
                        p5.Renderer3D.prototype.translate = function(x, y, z) {
                          //@TODO: figure out how to fit the resolution
                          x = x / RESOLUTION;
                          y = -y / RESOLUTION;
                          z = z / RESOLUTION;
                          this.uMVMatrix.translate([x,y,z]);
                          return this;
                        };
                        
                        /**
                         * Scales the Model View Matrix by a vector
                         * @param  {Number | p5.Vector | Array} x [description]
                         * @param  {Number} [y] y-axis scalar
                         * @param  {Number} [z] z-axis scalar
                         * @return {this}   [description]
                         */
                        p5.Renderer3D.prototype.scale = function(x,y,z) {
                          this.uMVMatrix.scale([x,y,z]);
                          return this;
                        };
                        
                        /**
                         * [rotate description]
                         * @param  {Number} rad  angle in radians
                         * @param  {p5.Vector | Array} axis axis to rotate around
                         * @return {p5.Renderer3D}      [description]
                         */
                        p5.Renderer3D.prototype.rotate = function(rad, axis){
                          this.uMVMatrix.rotate(rad, axis);
                          return this;
                        };
                        
                        /**
                         * [rotateX description]
                         * @param  {Number} rad radians to rotate
                         * @return {[type]}     [description]
                         */
                        p5.Renderer3D.prototype.rotateX = function(rad) {
                          this.uMVMatrix.rotateX(rad);
                          return this;
                        };
                        
                        /**
                         * [rotateY description]
                         * @param  {Number} rad rad radians to rotate
                         * @return {[type]}     [description]
                         */
                        p5.Renderer3D.prototype.rotateY = function(rad) {
                          this.uMVMatrix.rotateY(rad);
                          return this;
                        };
                        
                        /**
                         * [rotateZ description]
                         * @param  {Number} rad rad radians to rotate
                         * @return {[type]}     [description]
                         */
                        p5.Renderer3D.prototype.rotateZ = function(rad) {
                          this.uMVMatrix.rotateZ(rad);
                          return this;
                        };
                        
                        /**
                         * pushes a copy of the model view matrix onto the
                         * MV Matrix stack.
                         * NOTE to self: could probably make this more readable
                         * @return {[type]} [description]
                         */
                        p5.Renderer3D.prototype.push = function() {
                          uMVMatrixStack.push(this.uMVMatrix.copy());
                        };
                        
                        /**
                         * [pop description]
                         * @return {[type]} [description]
                         */
                        p5.Renderer3D.prototype.pop = function() {
                          if (uMVMatrixStack.length === 0) {
                            throw new Error(&#x27;Invalid popMatrix!&#x27;);
                          }
                          this.uMVMatrix = uMVMatrixStack.pop();
                        };
                        
                        module.exports = p5.Renderer3D;
                        
                        },{&quot;../core/core&quot;:48,&quot;../core/p5.Renderer&quot;:54,&quot;./p5.Matrix&quot;:35,&quot;./shader&quot;:38}],37:[function(_dereq_,module,exports){
                        //retained mode is used by rendering 3d_primitives
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        var hashCount = 0;
                        
                        /**
                         * createBuffer
                         * @param  {String} gId  key of the geometry object
                         * @param  {Array}  arr  array holding bject containing geometry information
                         */
                        p5.Renderer3D.prototype.createBuffer = function(gId, arr) {
                        
                          hashCount ++;
                          if(hashCount &gt; 1000){
                            var key = Object.keys(this.gHash)[0];
                            delete this.gHash[key];
                            hashCount --;
                          }
                        
                          var gl = this.GL;
                          this.gHash[gId] = {};
                          this.gHash[gId].len = [];
                          this.gHash[gId].vertexBuffer = [];
                          this.gHash[gId].normalBuffer = [];
                          this.gHash[gId].uvBuffer = [];
                          this.gHash[gId].indexBuffer =[];
                        
                          arr.forEach(function(obj){
                            this.gHash[gId].len.push(obj.len);
                            this.gHash[gId].vertexBuffer.push(gl.createBuffer());
                            this.gHash[gId].normalBuffer.push(gl.createBuffer());
                            this.gHash[gId].uvBuffer.push(gl.createBuffer());
                            this.gHash[gId].indexBuffer.push(gl.createBuffer());
                          }.bind(this));
                        };
                        
                        /**
                         * initBuffer description
                         * @param  {String} gId    key of the geometry object
                         * @param  {Array}  arr    array holding bject containing geometry information
                         */
                        p5.Renderer3D.prototype.initBuffer = function(gId, arr) {
                          this._setDefaultCamera();
                          var gl = this.GL;
                          this.createBuffer(gId, arr);
                        
                          var shaderProgram = this.mHash[this._getCurShaderId()];
                        
                          arr.forEach(function(obj, i){
                            gl.bindBuffer(gl.ARRAY_BUFFER, this.gHash[gId].vertexBuffer[i]);
                            gl.bufferData(
                              gl.ARRAY_BUFFER, new Float32Array(obj.vertices), gl.STATIC_DRAW);
                            gl.vertexAttribPointer(
                              shaderProgram.vertexPositionAttribute,
                              3, gl.FLOAT, false, 0, 0);
                        
                            gl.bindBuffer(gl.ARRAY_BUFFER, this.gHash[gId].normalBuffer[i]);
                            gl.bufferData(
                              gl.ARRAY_BUFFER, new Float32Array(obj.vertexNormals), gl.STATIC_DRAW);
                            gl.vertexAttribPointer(
                              shaderProgram.vertexNormalAttribute,
                              3, gl.FLOAT, false, 0, 0);
                        
                            gl.bindBuffer(gl.ARRAY_BUFFER, this.gHash[gId].uvBuffer[i]);
                            gl.bufferData(
                              gl.ARRAY_BUFFER, new Float32Array(obj.uvs), gl.STATIC_DRAW);
                            gl.vertexAttribPointer(
                              shaderProgram.textureCoordAttribute,
                              2, gl.FLOAT, false, 0, 0);
                        
                            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.gHash[gId].indexBuffer[i]);
                            gl.bufferData
                             (gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(obj.faces), gl.STATIC_DRAW);
                          }.bind(this));
                        };
                        
                        /**
                         * drawBuffer
                         * @param  {String} gId     key of the geometery object
                         */
                        p5.Renderer3D.prototype.drawBuffer = function(gId) {
                          this._setDefaultCamera();
                          var gl = this.GL;
                          var shaderKey = this._getCurShaderId();
                          var shaderProgram = this.mHash[shaderKey];
                        
                          this.gHash[gId].len.forEach(function(d, i){
                            gl.bindBuffer(gl.ARRAY_BUFFER, this.gHash[gId].vertexBuffer[i]);
                            gl.vertexAttribPointer(
                              shaderProgram.vertexPositionAttribute,
                              3, gl.FLOAT, false, 0, 0);
                        
                            gl.bindBuffer(gl.ARRAY_BUFFER, this.gHash[gId].normalBuffer[i]);
                            gl.vertexAttribPointer(
                              shaderProgram.vertexNormalAttribute,
                              3, gl.FLOAT, false, 0, 0);
                        
                            gl.bindBuffer(gl.ARRAY_BUFFER, this.gHash[gId].uvBuffer[i]);
                            gl.vertexAttribPointer(
                              shaderProgram.textureCoordAttribute,
                              2, gl.FLOAT, false, 0, 0);
                        
                            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.gHash[gId].indexBuffer[i]);
                        
                            this.setMatrixUniforms(shaderKey);
                        
                            gl.drawElements(
                              gl.TRIANGLES, this.gHash[gId].len[i],
                               gl.UNSIGNED_SHORT, 0);
                          }.bind(this));
                        };
                        
                        module.exports = p5.Renderer3D;
                        },{&quot;../core/core&quot;:48}],38:[function(_dereq_,module,exports){
                        
                        
                        module.exports = {
                          vertexColorVert:
                            &quot;attribute vec3 aPosition;\nattribute vec4 aVertexColor;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform float uResolution;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  vec4 positionVec4 = vec4(aPosition / uResolution * vec3(1.0, -1.0, 1.0), 1.0);\n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n  vColor = aVertexColor;\n}&quot;,
                          vertexColorFrag:
                            &quot;precision mediump float;\nvarying vec4 vColor;\nvoid main(void) {\n  gl_FragColor = vColor;\n}&quot;,
                          normalVert:
                            &quot;attribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aTexCoord;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat4 uNormalMatrix;\nuniform float uResolution;\n\nvarying vec3 vVertexNormal;\nvarying highp vec2 vVertTexCoord;\n\nvoid main(void) {\n  vec4 positionVec4 = vec4(aPosition / uResolution, 1.0);\n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n  vVertexNormal = vec3( uNormalMatrix * vec4( aNormal, 1.0 ) );\n  vVertTexCoord = aTexCoord;\n}&quot;,
                          normalFrag:
                            &quot;precision mediump float;\nvarying vec3 vVertexNormal;\nvoid main(void) {\n  gl_FragColor = vec4(vVertexNormal, 1.0);\n}&quot;,
                          basicFrag:
                            &quot;precision mediump float;\nvarying vec3 vVertexNormal;\nuniform vec4 uMaterialColor;\nvoid main(void) {\n  gl_FragColor = uMaterialColor;\n}&quot;,
                          lightVert:
                            &quot;attribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aTexCoord;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat4 uNormalMatrix;\nuniform float uResolution;\nuniform int uAmbientLightCount;\nuniform int uDirectionalLightCount;\nuniform int uPointLightCount;\n\nuniform vec3 uAmbientColor[8];\nuniform vec3 uLightingDirection[8];\nuniform vec3 uDirectionalColor[8];\nuniform vec3 uPointLightLocation[8];\nuniform vec3 uPointLightColor[8];\nuniform bool uSpecular;\n\nvarying vec3 vVertexNormal;\nvarying vec2 vVertTexCoord;\nvarying vec3 vLightWeighting;\n\nvec3 ambientLightFactor = vec3(0.0, 0.0, 0.0);\nvec3 directionalLightFactor = vec3(0.0, 0.0, 0.0);\nvec3 pointLightFactor = vec3(0.0, 0.0, 0.0);\nvec3 pointLightFactor2 = vec3(0.0, 0.0, 0.0);\n\nvoid main(void){\n\n  vec4 positionVec4 = vec4(aPosition / uResolution, 1.0);\n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n\n  vec3 vertexNormal = vec3( uNormalMatrix * vec4( aNormal, 1.0 ) );\n  vVertexNormal = vertexNormal;\n  vVertTexCoord = aTexCoord;\n\n  vec4 mvPosition = uModelViewMatrix * vec4(aPosition / uResolution, 1.0);\n  vec3 eyeDirection = normalize(-mvPosition.xyz);\n\n  float shininess = 32.0;\n  float specularFactor = 2.0;\n  float diffuseFactor = 0.3;\n\n  for(int i = 0; i &lt; 8; i++){\n    if(uAmbientLightCount == i) break;\n    ambientLightFactor += uAmbientColor[i];\n  }\n\n  for(int j = 0; j &lt; 8; j++){\n    if(uDirectionalLightCount == j) break;\n    vec3 dir = uLightingDirection[j];\n    float directionalLightWeighting = max(dot(vertexNormal, dir), 0.0);\n    directionalLightFactor += uDirectionalColor[j] * directionalLightWeighting;\n  }\n\n  for(int k = 0; k &lt; 8; k++){\n    if(uPointLightCount == k) break;\n    vec3 loc = uPointLightLocation[k];\n    //loc = loc / uResolution;\n    vec3 lightDirection = normalize(loc - mvPosition.xyz);\n\n    float directionalLightWeighting = max(dot(vertexNormal, lightDirection), 0.0);\n    pointLightFactor += uPointLightColor[k] * directionalLightWeighting;\n\n    //factor2 for specular\n    vec3 reflectionDirection = reflect(-lightDirection, vertexNormal);\n    float specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), shininess);\n\n    pointLightFactor2 += uPointLightColor[k] * (specularFactor * specularLightWeighting\n      +  directionalLightWeighting * diffuseFactor);\n  }\n  \n  if(!uSpecular){\n    vLightWeighting =  ambientLightFactor + directionalLightFactor + pointLightFactor;\n  }else{\n    vLightWeighting = ambientLightFactor + directionalLightFactor + pointLightFactor2;\n  }\n\n}&quot;,
                          lightTextureFrag:
                            &quot;precision mediump float;\n\nuniform vec4 uMaterialColor;\nuniform sampler2D uSampler;\nuniform bool isTexture;\n\nvarying vec3 vLightWeighting;\nvarying highp vec2 vVertTexCoord;\n\nvoid main(void) {\n  if(!isTexture){\n    gl_FragColor = vec4(vec3(uMaterialColor.rgb * vLightWeighting), uMaterialColor.a);\n  }else{\n    vec4 textureColor = texture2D(uSampler, vVertTexCoord);\n    if(vLightWeighting == vec3(0., 0., 0.)){\n      gl_FragColor = textureColor;\n    }else{\n      gl_FragColor = vec4(vec3(textureColor.rgb * vLightWeighting), textureColor.a); \n    }\n  }\n}&quot;
                        };
                        },{}],39:[function(_dereq_,module,exports){
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;./core/core&#x27;);
                        _dereq_(&#x27;./color/p5.Color&#x27;);
                        _dereq_(&#x27;./core/p5.Element&#x27;);
                        _dereq_(&#x27;./typography/p5.Font&#x27;);
                        _dereq_(&#x27;./core/p5.Graphics&#x27;);
                        _dereq_(&#x27;./core/p5.Renderer2D&#x27;);
                        
                        _dereq_(&#x27;./image/p5.Image&#x27;);
                        _dereq_(&#x27;./math/p5.Vector&#x27;);
                        _dereq_(&#x27;./io/p5.TableRow&#x27;);
                        _dereq_(&#x27;./io/p5.Table&#x27;);
                        
                        _dereq_(&#x27;./color/creating_reading&#x27;);
                        _dereq_(&#x27;./color/setting&#x27;);
                        _dereq_(&#x27;./core/constants&#x27;);
                        _dereq_(&#x27;./utilities/conversion&#x27;);
                        _dereq_(&#x27;./utilities/array_functions&#x27;);
                        _dereq_(&#x27;./utilities/string_functions&#x27;);
                        _dereq_(&#x27;./core/environment&#x27;);
                        _dereq_(&#x27;./image/image&#x27;);
                        _dereq_(&#x27;./image/loading_displaying&#x27;);
                        _dereq_(&#x27;./image/pixels&#x27;);
                        _dereq_(&#x27;./io/files&#x27;);
                        _dereq_(&#x27;./events/keyboard&#x27;);
                        _dereq_(&#x27;./events/acceleration&#x27;); //john
                        _dereq_(&#x27;./events/mouse&#x27;);
                        _dereq_(&#x27;./utilities/time_date&#x27;);
                        _dereq_(&#x27;./events/touch&#x27;);
                        _dereq_(&#x27;./math/math&#x27;);
                        _dereq_(&#x27;./math/calculation&#x27;);
                        _dereq_(&#x27;./math/random&#x27;);
                        _dereq_(&#x27;./math/noise&#x27;);
                        _dereq_(&#x27;./math/trigonometry&#x27;);
                        _dereq_(&#x27;./core/rendering&#x27;);
                        _dereq_(&#x27;./core/2d_primitives&#x27;);
                        
                        _dereq_(&#x27;./core/attributes&#x27;);
                        _dereq_(&#x27;./core/curves&#x27;);
                        _dereq_(&#x27;./core/vertex&#x27;);
                        _dereq_(&#x27;./core/structure&#x27;);
                        _dereq_(&#x27;./core/transform&#x27;);
                        _dereq_(&#x27;./typography/attributes&#x27;);
                        _dereq_(&#x27;./typography/loading_displaying&#x27;);
                        
                        _dereq_(&#x27;./3d/p5.Renderer3D&#x27;);
                        _dereq_(&#x27;./3d/p5.Geometry3D&#x27;);
                        _dereq_(&#x27;./3d/retainedMode3D&#x27;);
                        _dereq_(&#x27;./3d/immediateMode3D&#x27;);
                        _dereq_(&#x27;./3d/3d_primitives&#x27;);
                        _dereq_(&#x27;./3d/p5.Matrix&#x27;);
                        _dereq_(&#x27;./3d/material&#x27;);
                        _dereq_(&#x27;./3d/light&#x27;);
                        _dereq_(&#x27;./3d/shader&#x27;);
                        _dereq_(&#x27;./3d/camera&#x27;);
                        _dereq_(&#x27;./3d/interaction&#x27;);
                        
                        /**
                         * _globalInit
                         *
                         * TODO: ???
                         * if sketch is on window
                         * assume &quot;global&quot; mode
                         * and instantiate p5 automatically
                         * otherwise do nothing
                         *
                         * @return {Undefined}
                         */
                        var _globalInit = function() {
                          if (!window.PHANTOMJS &amp;&amp; !window.mocha) {
                            // If there is a setup or draw function on the window
                            // then instantiate p5 in &quot;global&quot; mode
                            if((window.setup &amp;&amp; typeof window.setup === &#x27;function&#x27;) ||
                              (window.draw &amp;&amp; typeof window.draw === &#x27;function&#x27;)) {
                              new p5();
                            }
                          }
                        };
                        
                        // TODO: ???
                        if (document.readyState === &#x27;complete&#x27;) {
                          _globalInit();
                        } else {
                          window.addEventListener(&#x27;load&#x27;, _globalInit , false);
                        }
                        
                        module.exports = p5;
                        },{&quot;./3d/3d_primitives&quot;:28,&quot;./3d/camera&quot;:29,&quot;./3d/immediateMode3D&quot;:30,&quot;./3d/interaction&quot;:31,&quot;./3d/light&quot;:32,&quot;./3d/material&quot;:33,&quot;./3d/p5.Geometry3D&quot;:34,&quot;./3d/p5.Matrix&quot;:35,&quot;./3d/p5.Renderer3D&quot;:36,&quot;./3d/retainedMode3D&quot;:37,&quot;./3d/shader&quot;:38,&quot;./color/creating_reading&quot;:41,&quot;./color/p5.Color&quot;:42,&quot;./color/setting&quot;:43,&quot;./core/2d_primitives&quot;:44,&quot;./core/attributes&quot;:45,&quot;./core/constants&quot;:47,&quot;./core/core&quot;:48,&quot;./core/curves&quot;:49,&quot;./core/environment&quot;:50,&quot;./core/p5.Element&quot;:52,&quot;./core/p5.Graphics&quot;:53,&quot;./core/p5.Renderer2D&quot;:55,&quot;./core/rendering&quot;:56,&quot;./core/structure&quot;:58,&quot;./core/transform&quot;:59,&quot;./core/vertex&quot;:60,&quot;./events/acceleration&quot;:61,&quot;./events/keyboard&quot;:62,&quot;./events/mouse&quot;:63,&quot;./events/touch&quot;:64,&quot;./image/image&quot;:66,&quot;./image/loading_displaying&quot;:67,&quot;./image/p5.Image&quot;:68,&quot;./image/pixels&quot;:69,&quot;./io/files&quot;:70,&quot;./io/p5.Table&quot;:71,&quot;./io/p5.TableRow&quot;:72,&quot;./math/calculation&quot;:73,&quot;./math/math&quot;:74,&quot;./math/noise&quot;:75,&quot;./math/p5.Vector&quot;:76,&quot;./math/random&quot;:78,&quot;./math/trigonometry&quot;:79,&quot;./typography/attributes&quot;:80,&quot;./typography/loading_displaying&quot;:81,&quot;./typography/p5.Font&quot;:82,&quot;./utilities/array_functions&quot;:83,&quot;./utilities/conversion&quot;:84,&quot;./utilities/string_functions&quot;:85,&quot;./utilities/time_date&quot;:86}],40:[function(_dereq_,module,exports){
                        /**
                         * module Conversion
                         * submodule Color Conversion
                         * @for p5
                         * @requires core
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        /**
                         * Conversions adapted from &lt;http://www.easyrgb.com/math.html&gt;.
                         *
                         * In these functions, hue is always in the range [0,1); all other components
                         * are in the range [0,1]. &#x27;Brightness&#x27; and &#x27;value&#x27; are used interchangeably.
                         */
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        p5.ColorConversion = {};
                        
                        /**
                         * Convert an HSBA array to HSLA.
                         */
                        p5.ColorConversion._hsbaToHSLA = function(hsba) {
                          var hue = hsba[0];
                          var sat = hsba[1];
                          var val = hsba[2];
                        
                          // Calculate lightness.
                          var li = (2 - sat) * val / 2;
                        
                          // Convert saturation.
                          if (li !== 0) {
                            if (li === 1) {
                              sat = 0;
                            } else if (li &lt; 0.5) {
                              sat = sat / (2 - sat);
                            } else {
                              sat = sat * val / (2 - li * 2);
                            }
                          }
                        
                          // Hue and alpha stay the same.
                          return [hue, sat, li, hsba[3]];
                        };
                        
                        /**
                         * Convert an HSBA array to RGBA.
                         */
                        p5.ColorConversion._hsbaToRGBA = function(hsba) {
                          var hue = hsba[0] * 6;  // We will split hue into 6 sectors.
                          var sat = hsba[1];
                          var val = hsba[2];
                        
                          var RGBA = [];
                        
                          if (sat === 0) {
                            RGBA = [val, val, val, hsba[3]];  // Return early if grayscale.
                          } else {
                            var sector = Math.floor(hue);
                            var tint1 = val * (1 - sat);
                            var tint2 = val * (1 - sat * (hue - sector));
                            var tint3 = val * (1 - sat * (1 + sector - hue));
                            var red, green, blue;
                            if (sector === 0) {  // Red to yellow.
                              red = val;
                              green = tint3;
                              blue = tint1;
                            } else if (sector === 1) {  // Yellow to green.
                              red = tint2;
                              green = val;
                              blue = tint1;
                            } else if (sector === 2) {  // Green to cyan.
                              red = tint1;
                              green = val;
                              blue = tint3;
                            } else if (sector === 3) {  // Cyan to blue.
                              red = tint1;
                              green = tint2;
                              blue = val;
                            } else if (sector === 4) {  // Blue to magenta.
                              red = tint3;
                              green = tint1;
                              blue = val;
                            } else {  // Magenta to red.
                              red = val;
                              green = tint1;
                              blue = tint2;
                            }
                            RGBA = [red, green, blue, hsba[3]];
                          }
                        
                          return RGBA;
                        };
                        
                        /**
                         * Convert an HSLA array to HSBA.
                         */
                        p5.ColorConversion._hslaToHSBA = function(hsla) {
                          var hue = hsla[0];
                          var sat = hsla[1];
                          var li = hsla[2];
                        
                          // Calculate brightness.
                          var val;
                          if (li &lt; 0.5) {
                            val = (1 + sat) * li;
                          } else {
                            val = li + sat - li * sat;
                          }
                        
                          // Convert saturation.
                          sat = 2 * (val - li) / val;
                        
                          // Hue and alpha stay the same.
                          return [hue, sat, val, hsla[3]];
                        };
                        
                        /**
                         * Convert an HSLA array to RGBA.
                         *
                         * We need to change basis from HSLA to something that can be more easily be
                         * projected onto RGBA. We will choose hue and brightness as our first two
                         * components, and pick a convenient third one (&#x27;zest&#x27;) so that we don&#x27;t need
                         * to calculate formal HSBA saturation.
                         */
                        p5.ColorConversion._hslaToRGBA = function(hsla){
                          var hue = hsla[0] * 6;  // We will split hue into 6 sectors.
                          var sat = hsla[1];
                          var li = hsla[2];
                        
                          var RGBA = [];
                        
                          if (sat === 0) {
                            RGBA = [li, li, li, hsla[3]]; // Return early if grayscale.
                          } else {
                        
                            // Calculate brightness.
                            var val;
                            if (li &lt; 0.5) {
                              val = (1 + sat) * li;
                            } else {
                              val = li + sat - li * sat;
                            }
                        
                            // Define zest.
                            var zest = 2 * li - val;
                        
                            // Implement projection (project onto green by default).
                            var hzvToRGB = function(hue, zest, val) {
                              if (hue &lt; 0) {  // Hue must wrap to allow projection onto red and blue.
                                hue += 6;
                              } else if (hue &gt;= 6) {
                                hue -= 6;
                              }
                              if (hue &lt; 1) {  // Red to yellow (increasing green).
                                return (zest + (val - zest) * hue);
                              } else if (hue &lt; 3) {  // Yellow to cyan (greatest green).
                                return val;
                              } else if (hue &lt; 4) {  // Cyan to blue (decreasing green).
                                return (zest + (val - zest) * (4 - hue));
                              } else {  // Blue to red (least green).
                                return zest;
                              }
                            };
                        
                            // Perform projections, offsetting hue as necessary.
                            RGBA = [hzvToRGB(hue + 2, zest, val),
                                    hzvToRGB(hue    , zest, val),
                                    hzvToRGB(hue - 2, zest, val),
                                    hsla[3]];
                          }
                        
                          return RGBA;
                        };
                        
                        /**
                         * Convert an RGBA array to HSBA.
                         */
                        p5.ColorConversion._rgbaToHSBA = function(rgba) {
                          var red = rgba[0];
                          var green = rgba[1];
                          var blue = rgba[2];
                        
                          var val = Math.max(red, green, blue);
                          var chroma = val - Math.min(red, green, blue);
                        
                          var hue, sat;
                          if (chroma === 0) {  // Return early if grayscale.
                            hue = 0;
                            sat = 0;
                          }
                          else {
                            sat = chroma / val;
                            if (red === val) {  // Magenta to yellow.
                              hue = (green - blue) / chroma;
                            } else if (green === val) { // Yellow to cyan.
                              hue = 2 + (blue - red) / chroma;
                            } else if (blue === val) {  // Cyan to magenta.
                              hue = 4 + (red - green) / chroma;
                            }
                            if (hue &lt; 0) {  // Confine hue to the interval [0, 1).
                              hue += 6;
                            } else if (hue &gt;= 6) {
                              hue -= 6;
                            }
                          }
                        
                          return [hue / 6, sat, val, rgba[3]];
                        };
                        
                        /**
                         * Convert an RGBA array to HSLA.
                         */
                        p5.ColorConversion._rgbaToHSLA = function(rgba) {
                          var red = rgba[0];
                          var green = rgba[1];
                          var blue = rgba[2];
                        
                          var val = Math.max(red, green, blue);
                          var min = Math.min(red, green, blue);
                          var li = val + min;  // We will halve this later.
                          var chroma = val - min;
                        
                          var hue, sat;
                          if (chroma === 0) {  // Return early if grayscale.
                            hue = 0;
                            sat = 0;
                          } else {
                            if (li &lt; 1) {
                              sat = chroma / li;
                            } else {
                              sat = chroma / (2 - chroma);
                            }
                            if (red === val) {  // Magenta to yellow.
                              hue = (green - blue) / chroma;
                            } else if (green === val) {  // Yellow to cyan.
                              hue = 2 + (blue - red) / chroma;
                            } else if (blue === val) {  // Cyan to magenta.
                              hue = 4 + (red - green) / chroma;
                            }
                            if (hue &lt; 0) {  // Confine hue to the interval [0, 1).
                              hue += 6;
                            } else if (hue &gt;= 6) {
                              hue -= 6;
                            }
                          }
                        
                          return [hue / 6, sat, li / 2, rgba[3]];
                        };
                        
                        module.exports = p5.ColorConversion;
                        
                        },{&quot;../core/core&quot;:48}],41:[function(_dereq_,module,exports){
                        /**
                         * @module Color
                         * @submodule Creating &amp; Reading
                         * @for p5
                         * @requires core
                         * @requires constants
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        var constants = _dereq_(&#x27;../core/constants&#x27;);
                        _dereq_(&#x27;./p5.Color&#x27;);
                        
                        /**
                         * Extracts the alpha value from a color or pixel array.
                         *
                         * @method alpha
                         * @param {Object} obj p5.Color object or pixel array
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noStroke();
                         * c = color(0, 126, 255, 102);
                         * fill(c);
                         * rect(15, 15, 35, 70);
                         * value = alpha(c);  // Sets &#x27;value&#x27; to 102
                         * fill(value);
                         * rect(50, 15, 35, 70);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.alpha = function(c) {
                          if (c instanceof p5.Color || c instanceof Array) {
                            return this.color(c)._getAlpha();
                          } else {
                            throw new Error(&#x27;Needs p5.Color or pixel array as argument.&#x27;);
                          }
                        };
                        
                        /**
                         * Extracts the blue value from a color or pixel array.
                         *
                         * @method blue
                         * @param {Object} obj p5.Color object or pixel array
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * c = color(175, 100, 220);  // Define color &#x27;c&#x27;
                         * fill(c);  // Use color variable &#x27;c&#x27; as fill color
                         * rect(15, 20, 35, 60);  // Draw left rectangle
                         *
                         * blueValue = blue(c);  // Get blue in &#x27;c&#x27;
                         * println(blueValue);  // Prints &quot;220.0&quot;
                         * fill(0, 0, blueValue);  // Use &#x27;blueValue&#x27; in new fill
                         * rect(50, 20, 35, 60);  // Draw right rectangle
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.blue = function(c) {
                          if (c instanceof p5.Color || c instanceof Array) {
                            return this.color(c)._getBlue();
                          } else {
                            throw new Error(&#x27;Needs p5.Color or pixel array as argument.&#x27;);
                          }
                        };
                        
                        /**
                         * Extracts the HSB brightness value from a color or pixel array.
                         *
                         * @method brightness
                         * @param {Object} color p5.Color object or pixel array
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noStroke();
                         * colorMode(HSB, 255);
                         * c = color(0, 126, 255);
                         * fill(c);
                         * rect(15, 20, 35, 60);
                         * value = brightness(c);  // Sets &#x27;value&#x27; to 255
                         * fill(value);
                         * rect(50, 20, 35, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.brightness = function(c) {
                          if (c instanceof p5.Color || c instanceof Array) {
                            return this.color(c)._getBrightness();
                          } else {
                            throw new Error(&#x27;Needs p5.Color or pixel array as argument.&#x27;);
                          }
                        };
                        
                        /**
                         * Creates colors for storing in variables of the color datatype. The
                         * parameters are interpreted as RGB or HSB values depending on the
                         * current colorMode(). The default mode is RGB values from 0 to 255
                         * and, therefore, the function call color(255, 204, 0) will return a
                         * bright yellow color.
                         * &lt;br&gt;&lt;br&gt;
                         * Note that if only one value is provided to color(), it will be interpreted
                         * as a grayscale value. Add a second value, and it will be used for alpha
                         * transparency. When three values are specified, they are interpreted as
                         * either RGB or HSB values. Adding a fourth value applies alpha
                         * transparency. If a single string parameter is provided it will be
                         * interpreted as a CSS-compatible color string.
                         *
                         * Colors are stored as Numbers or Arrays.
                         *
                         * @method color
                         * @param  {Number|String} v1      gray value or red or hue value relative to
                         *                                 the current color range, or a color string
                         * @param  {Number}        [v2]    gray value or green or saturation value
                         *                                 relative to the current color range (or
                         *                                 alpha value if first param is gray value)
                         * @param  {Number}        [v3]    gray value or blue or brightness value
                         *                                 relative to the current color range
                         * @param  {Number}        [alpha] alpha value relative to current color range
                         * @return {Array}                 resulting color
                         *
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var c = color(255, 204, 0);  // Define color &#x27;c&#x27;
                         * fill(c);  // Use color variable &#x27;c&#x27; as fill color
                         * noStroke();  // Don&#x27;t draw a stroke around shapes
                         * rect(30, 20, 55, 55);  // Draw rectangle
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var c = color(255, 204, 0);  // Define color &#x27;c&#x27;
                         * fill(c);  // Use color variable &#x27;c&#x27; as fill color
                         * noStroke();  // Don&#x27;t draw a stroke around shapes
                         * ellipse(25, 25, 80, 80);  // Draw left circle
                         *
                         * // Using only one value with color()
                         * // generates a grayscale value.
                         * var c = color(65);  // Update &#x27;c&#x27; with grayscale value
                         * fill(c);  // Use updated &#x27;c&#x27; as fill color
                         * ellipse(75, 75, 80, 80);  // Draw right circle
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Named SVG &amp; CSS colors may be used,
                         * var c = color(&#x27;magenta&#x27;);
                         * fill(c);  // Use &#x27;c&#x27; as fill color
                         * noStroke();  // Don&#x27;t draw a stroke around shapes
                         * rect(20, 20, 60, 60);  // Draw rectangle
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // as can hex color codes:
                         * noStroke();  // Don&#x27;t draw a stroke around shapes
                         * var c = color(&#x27;#0f0&#x27;);
                         * fill(c);  // Use &#x27;c&#x27; as fill color
                         * rect(0, 10, 45, 80);  // Draw rectangle
                         *
                         * c = color(&#x27;#00ff00&#x27;);
                         * fill(c);  // Use updated &#x27;c&#x27; as fill color
                         * rect(55, 10, 45, 80);  // Draw rectangle
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // RGB and RGBA color strings are also supported:
                         * // these all set to the same color (solid blue)
                         * var c;
                         * noStroke();  // Don&#x27;t draw a stroke around shapes
                         * c = color(&#x27;rgb(0,0,255)&#x27;);
                         * fill(c); // Use &#x27;c&#x27; as fill color
                         * rect(10, 10, 35, 35);  // Draw rectangle
                         *
                         * c = color(&#x27;rgb(0%, 0%, 100%)&#x27;);
                         * fill(c); // Use updated &#x27;c&#x27; as fill color
                         * rect(55, 10, 35, 35);  // Draw rectangle
                         *
                         * c = color(&#x27;rgba(0, 0, 255, 1)&#x27;);
                         * fill(c); // Use updated &#x27;c&#x27; as fill color
                         * rect(10, 55, 35, 35);  // Draw rectangle
                         *
                         * c = color(&#x27;rgba(0%, 0%, 100%, 1)&#x27;);
                         * fill(c); // Use updated &#x27;c&#x27; as fill color
                         * rect(55, 55, 35, 35);  // Draw rectangle
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // HSL color is also supported and can be specified
                         * // by value
                         * var c;
                         * noStroke();  // Don&#x27;t draw a stroke around shapes
                         * c = color(&#x27;hsl(160, 100%, 50%)&#x27;);
                         * fill(c);  // Use &#x27;c&#x27; as fill color
                         * rect(0, 10, 45, 80);  // Draw rectangle
                         *
                         * c = color(&#x27;hsla(160, 100%, 50%, 0.5)&#x27;);
                         * fill(c); // Use updated &#x27;c&#x27; as fill color
                         * rect(55, 10, 45, 80);  // Draw rectangle
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // HSB color is also supported and can be specified
                         * // by value
                         * var c;
                         * noStroke();  // Don&#x27;t draw a stroke around shapes
                         * c = color(&#x27;hsb(160, 100%, 50%)&#x27;);
                         * fill(c);  // Use &#x27;c&#x27; as fill color
                         * rect(0, 10, 45, 80);  // Draw rectangle
                         *
                         * c = color(&#x27;hsba(160, 100%, 50%, 0.5)&#x27;);
                         * fill(c); // Use updated &#x27;c&#x27; as fill color
                         * rect(55, 10, 45, 80);  // Draw rectangle
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var c;  // Declare color &#x27;c&#x27;
                         * noStroke();  // Don&#x27;t draw a stroke around shapes
                         *
                         * // If no colorMode is specified, then the
                         * // default of RGB with scale of 0-255 is used.
                         * c = color(50, 55, 100);  // Create a color for &#x27;c&#x27;
                         * fill(c);  // Use color variable &#x27;c&#x27; as fill color
                         * rect(0, 10, 45, 80);  // Draw left rect
                         *
                         * colorMode(HSB, 100);  // Use HSB with scale of 0-100
                         * c = color(50, 55, 100);  // Update &#x27;c&#x27; with new color
                         * fill(c);  // Use updated &#x27;c&#x27; as fill color
                         * rect(55, 10, 45, 80);  // Draw right rect
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.color = function() {
                          if (arguments[0] instanceof p5.Color) {
                            return arguments[0];  // Do nothing if argument is already a color object.
                          } else if (arguments[0] instanceof Array) {
                            return new p5.Color(this, arguments[0]);
                          } else {
                            return new p5.Color(this, arguments);
                          }
                        };
                        
                        /**
                         * Extracts the green value from a color or pixel array.
                         *
                         * @method green
                         * @param {Object} color p5.Color object or pixel array
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * c = color(20, 75, 200);  // Define color &#x27;c&#x27;
                         * fill(c);  // Use color variable &#x27;c&#x27; as fill color
                         * rect(15, 20, 35, 60);  // Draw left rectangle
                         *
                         * greenValue = green(c);  // Get green in &#x27;c&#x27;
                         * println(greenValue);  // Print &quot;75.0&quot;
                         * fill(0, greenValue, 0);  // Use &#x27;greenValue&#x27; in new fill
                         * rect(50, 20, 35, 60);  // Draw right rectangle
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.green = function(c) {
                          if (c instanceof p5.Color || c instanceof Array) {
                            return this.color(c)._getGreen();
                          } else {
                            throw new Error(&#x27;Needs p5.Color or pixel array as argument.&#x27;);
                          }
                        };
                        
                        /**
                         * Extracts the hue value from a color or pixel array.
                         *
                         * Hue exists in both HSB and HSL. This function will return the
                         * HSB-normalized hue when supplied with an HSB color object (or when supplied
                         * with a pixel array while the color mode is HSB), but will default to the
                         * HSL-normalized hue otherwise. (The values will only be different if the
                         * maximum hue setting for each system is different.)
                         *
                         * @method hue
                         * @param {Object} color p5.Color object or pixel array
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noStroke();
                         * colorMode(HSB, 255);
                         * c = color(0, 126, 255);
                         * fill(c);
                         * rect(15, 20, 35, 60);
                         * value = hue(c);  // Sets &#x27;value&#x27; to &quot;0&quot;
                         * fill(value);
                         * rect(50, 20, 35, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.hue = function(c) {
                          if (c instanceof p5.Color || c instanceof Array) {
                            return this.color(c)._getHue();
                          } else {
                            throw new Error(&#x27;Needs p5.Color or pixel array as argument.&#x27;);
                          }
                        };
                        
                        /**
                         * Blends two colors to find a third color somewhere between them. The amt
                         * parameter is the amount to interpolate between the two values where 0.0
                         * equal to the first color, 0.1 is very near the first color, 0.5 is halfway
                         * in between, etc. An amount below 0 will be treated as 0. Likewise, amounts
                         * above 1 will be capped at 1. This is different from the behavior of lerp(),
                         * but necessary because otherwise numbers outside the range will produce
                         * strange and unexpected colors.
                         * &lt;br&gt;&lt;br&gt;
                         * The way that colours are interpolated depends on the current color mode.
                         *
                         * @method lerpColor
                         * @param  {Array/Number} c1  interpolate from this color
                         * @param  {Array/Number} c2  interpolate to this color
                         * @param  {Number}       amt number between 0 and 1
                         * @return {Array/Number}     interpolated color
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * colorMode(RGB);
                         * stroke(255);
                         * background(51);
                         * from = color(218, 165, 32);
                         * to = color(72, 61, 139);
                         * colorMode(RGB);  // Try changing to HSB.
                         * interA = lerpColor(from, to, .33);
                         * interB = lerpColor(from, to, .66);
                         * fill(from);
                         * rect(10, 20, 20, 60);
                         * fill(interA);
                         * rect(30, 20, 20, 60);
                         * fill(interB);
                         * rect(50, 20, 20, 60);
                         * fill(to);
                         * rect(70, 20, 20, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.lerpColor = function(c1, c2, amt) {
                          var mode = this._renderer._colorMode;
                          var maxes = this._renderer._colorMaxes;
                          var l0, l1, l2, l3;
                          var fromArray, toArray;
                        
                          if (mode === constants.RGB) {
                            fromArray = c1.levels.map(function(level) {
                              return level / 255;
                            });
                            toArray = c2.levels.map(function(level) {
                              return level / 255;
                            });
                          } else if (mode === constants.HSB) {
                            c1._getBrightness();  // Cache hsba so it definitely exists.
                            c2._getBrightness();
                            fromArray = c1.hsba;
                            toArray = c2.hsba;
                          } else if (mode === constants.HSL) {
                            c1._getLightness();  // Cache hsla so it definitely exists.
                            c2._getLightness();
                            fromArray = c1.hsla;
                            toArray = c2.hsla;
                          } else {
                            throw new Error (mode + &#x27;cannot be used for interpolation.&#x27;);
                          }
                        
                          // Prevent extrapolation.
                          amt = Math.max(Math.min(amt, 1), 0);
                        
                          // Perform interpolation.
                          l0 = this.lerp(fromArray[0], toArray[0], amt);
                          l1 = this.lerp(fromArray[1], toArray[1], amt);
                          l2 = this.lerp(fromArray[2], toArray[2], amt);
                          l3 = this.lerp(fromArray[3], toArray[3], amt);
                        
                          // Scale components.
                          l0 *= maxes[mode][0];
                          l1 *= maxes[mode][1];
                          l2 *= maxes[mode][2];
                          l3 *= maxes[mode][3];
                        
                          return this.color(l0, l1, l2, l3);
                        };
                        
                        /**
                         * Extracts the HSL lightness value from a color or pixel array.
                         *
                         * @method lightness
                         * @param {Object} color p5.Color object or pixel array
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noStroke();
                         * colorMode(HSL);
                         * c = color(156, 100, 50, 1);
                         * fill(c);
                         * rect(15, 20, 35, 60);
                         * value = lightness(c);  // Sets &#x27;value&#x27; to 50
                         * fill(value);
                         * rect(50, 20, 35, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.lightness = function(c) {
                          if (c instanceof p5.Color || c instanceof Array) {
                            return this.color(c)._getLightness();
                          } else {
                            throw new Error(&#x27;Needs p5.Color or pixel array as argument.&#x27;);
                          }
                        };
                        
                        /**
                         * Extracts the red value from a color or pixel array.
                         *
                         * @method red
                         * @param {Object} obj p5.Color object or pixel array
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * c = color(255, 204, 0);  // Define color &#x27;c&#x27;
                         * fill(c);  // Use color variable &#x27;c&#x27; as fill color
                         * rect(15, 20, 35, 60);  // Draw left rectangle
                         *
                         * redValue = red(c);  // Get red in &#x27;c&#x27;
                         * println(redValue);  // Print &quot;255.0&quot;
                         * fill(redValue, 0, 0);  // Use &#x27;redValue&#x27; in new fill
                         * rect(50, 20, 35, 60);  // Draw right rectangle
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * colorMode(RGB, 255);
                         * var c = color(127, 255, 0);
                         * colorMode(RGB, 1);
                         * var myColor = red(c);
                         * print(myColor);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.red = function(c) {
                          if (c instanceof p5.Color || c instanceof Array) {
                            return this.color(c)._getRed();
                          } else {
                            throw new Error(&#x27;Needs p5.Color or pixel array as argument.&#x27;);
                          }
                        };
                        
                        /**
                         * Extracts the saturation value from a color or pixel array.
                         *
                         * Saturation is scaled differently in HSB and HSL. This function will return
                         * the HSB saturation when supplied with an HSB color object (or when supplied
                         * with a pixel array while the color mode is HSB), but will default to the
                         * HSL saturation otherwise.
                         *
                         * @method saturation
                         * @param {Object} color p5.Color object or pixel array
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noStroke();
                         * colorMode(HSB, 255);
                         * c = color(0, 126, 255);
                         * fill(c);
                         * rect(15, 20, 35, 60);
                         * value = saturation(c);  // Sets &#x27;value&#x27; to 126
                         * fill(value);
                         * rect(50, 20, 35, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.saturation = function(c) {
                          if (c instanceof p5.Color || c instanceof Array) {
                            return this.color(c)._getSaturation();
                          } else {
                            throw new Error(&#x27;Needs p5.Color or pixel array as argument.&#x27;);
                          }
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;../core/constants&quot;:47,&quot;../core/core&quot;:48,&quot;./p5.Color&quot;:42}],42:[function(_dereq_,module,exports){
                        /**
                         * @module Color
                         * @submodule Creating &amp; Reading
                         * @for p5
                         * @requires core
                         * @requires constants
                         * @requires color_conversion
                         */
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        var constants = _dereq_(&#x27;../core/constants&#x27;);
                        var color_conversion = _dereq_(&#x27;./color_conversion&#x27;);
                        
                        /**
                         * We define colors to be immutable objects. Each color stores the color mode
                         * and level maxes that applied at the time of its construction. These are
                         * used to interpret the input arguments and to format the output e.g. when
                         * saturation() is requested.
                         *
                         * Internally we store an array representing the ideal RGBA values in floating
                         * point form, normalized from 0 to 1. From this we calculate the closest
                         * screen color (RGBA levels from 0 to 255) and expose this to the renderer.
                         *
                         * We also cache normalized, floating point components of the color in various
                         * representations as they are calculated. This is done to prevent repeating a
                         * conversion that has already been performed.
                         *
                         * @class p5.Color
                         * @constructor
                         */
                        p5.Color = function(pInst, vals) {
                        
                          // Record color mode and maxes at time of construction.
                          this.mode = pInst._renderer._colorMode;
                          this.maxes = pInst._renderer._colorMaxes;
                        
                          // Calculate normalized RGBA values.
                          if (this.mode !== constants.RGB &amp;&amp;
                              this.mode !== constants.HSL &amp;&amp;
                              this.mode !== constants.HSB) {
                            throw new Error(this.mode + &#x27; is an invalid colorMode.&#x27;);
                          } else {
                            this._array = p5.Color._parseInputs.apply(pInst, vals);
                          }
                        
                          // Expose closest screen color.
                          this.levels = this._array.map(function(level) {
                            return Math.round(level * 255);
                          });
                        
                          return this;
                        };
                        
                        p5.Color.prototype.toString = function() {
                          var a = this.levels;
                          a[3] = this._array[3];  // String representation uses normalized alpha.
                          return &#x27;rgba(&#x27;+a[0]+&#x27;,&#x27;+a[1]+&#x27;,&#x27;+a[2]+&#x27;,&#x27;+ a[3] +&#x27;)&#x27;;
                        };
                        
                        p5.Color.prototype._getAlpha = function() {
                          return this._array[3] * this.maxes[this.mode][3];
                        };
                        
                        p5.Color.prototype._getBlue = function() {
                          return this._array[2] * this.maxes[constants.RGB][2];
                        };
                        
                        p5.Color.prototype._getBrightness = function() {
                          if (!this.hsba) {
                            this.hsba = color_conversion._rgbaToHSBA(this._array);
                          }
                          return this.hsba[2] * this.maxes[constants.HSB][2];
                        };
                        
                        p5.Color.prototype._getGreen = function() {
                          return this._array[1] * this.maxes[constants.RGB][1];
                        };
                        
                        /**
                         * Hue is the same in HSB and HSL, but the maximum value may be different.
                         * This function will return the HSB-normalized saturation when supplied with
                         * an HSB color object, but will default to the HSL-normalized saturation
                         * otherwise.
                         */
                        p5.Color.prototype._getHue = function() {
                          if (this.mode === constants.HSB) {
                            if (!this.hsba) {
                              this.hsba = color_conversion._rgbaToHSBA(this._array);
                            }
                            return this.hsba[0] * this.maxes[constants.HSB][0];
                          } else {
                            if (!this.hsla) {
                              this.hsla = color_conversion._rgbaToHSLA(this._array);
                            }
                            return this.hsla[0] * this.maxes[constants.HSL][0];
                          }
                        };
                        
                        p5.Color.prototype._getLightness = function() {
                          if (!this.hsla) {
                            this.hsla = color_conversion._rgbaToHSLA(this._array);
                          }
                          return this.hsla[2] * this.maxes[constants.HSL][2];
                        };
                        
                        p5.Color.prototype._getRed = function() {
                          return this._array[0] * this.maxes[constants.RGB][0];
                        };
                        
                        /**
                         * Saturation is scaled differently in HSB and HSL. This function will return
                         * the HSB saturation when supplied with an HSB color object, but will default
                         * to the HSL saturation otherwise.
                         */
                        p5.Color.prototype._getSaturation = function() {
                          if (this.mode === constants.HSB) {
                            if (!this.hsba) {
                              this.hsba = color_conversion._rgbaToHSBA(this._array);
                            }
                            return this.hsba[1] * this.maxes[constants.HSB][1];
                          } else {
                            if (!this.hsla) {
                              this.hsla = color_conversion._rgbaToHSLA(this._array);
                            }
                            return this.hsla[1] * this.maxes[constants.HSL][1];
                          }
                        };
                        
                        /**
                         * CSS named colors.
                         */
                        var namedColors = {
                          aliceblue:             &#x27;#f0f8ff&#x27;,
                          antiquewhite:          &#x27;#faebd7&#x27;,
                          aqua:                  &#x27;#00ffff&#x27;,
                          aquamarine:            &#x27;#7fffd4&#x27;,
                          azure:                 &#x27;#f0ffff&#x27;,
                          beige:                 &#x27;#f5f5dc&#x27;,
                          bisque:                &#x27;#ffe4c4&#x27;,
                          black:                 &#x27;#000000&#x27;,
                          blanchedalmond:        &#x27;#ffebcd&#x27;,
                          blue:                  &#x27;#0000ff&#x27;,
                          blueviolet:            &#x27;#8a2be2&#x27;,
                          brown:                 &#x27;#a52a2a&#x27;,
                          burlywood:             &#x27;#deb887&#x27;,
                          cadetblue:             &#x27;#5f9ea0&#x27;,
                          chartreuse:            &#x27;#7fff00&#x27;,
                          chocolate:             &#x27;#d2691e&#x27;,
                          coral:                 &#x27;#ff7f50&#x27;,
                          cornflowerblue:        &#x27;#6495ed&#x27;,
                          cornsilk:              &#x27;#fff8dc&#x27;,
                          crimson:               &#x27;#dc143c&#x27;,
                          cyan:                  &#x27;#00ffff&#x27;,
                          darkblue:              &#x27;#00008b&#x27;,
                          darkcyan:              &#x27;#008b8b&#x27;,
                          darkgoldenrod:         &#x27;#b8860b&#x27;,
                          darkgray:              &#x27;#a9a9a9&#x27;,
                          darkgreen:             &#x27;#006400&#x27;,
                          darkgrey:              &#x27;#a9a9a9&#x27;,
                          darkkhaki:             &#x27;#bdb76b&#x27;,
                          darkmagenta:           &#x27;#8b008b&#x27;,
                          darkolivegreen:        &#x27;#556b2f&#x27;,
                          darkorange:            &#x27;#ff8c00&#x27;,
                          darkorchid:            &#x27;#9932cc&#x27;,
                          darkred:               &#x27;#8b0000&#x27;,
                          darksalmon:            &#x27;#e9967a&#x27;,
                          darkseagreen:          &#x27;#8fbc8f&#x27;,
                          darkslateblue:         &#x27;#483d8b&#x27;,
                          darkslategray:         &#x27;#2f4f4f&#x27;,
                          darkslategrey:         &#x27;#2f4f4f&#x27;,
                          darkturquoise:         &#x27;#00ced1&#x27;,
                          darkviolet:            &#x27;#9400d3&#x27;,
                          deeppink:              &#x27;#ff1493&#x27;,
                          deepskyblue:           &#x27;#00bfff&#x27;,
                          dimgray:               &#x27;#696969&#x27;,
                          dimgrey:               &#x27;#696969&#x27;,
                          dodgerblue:            &#x27;#1e90ff&#x27;,
                          firebrick:             &#x27;#b22222&#x27;,
                          floralwhite:           &#x27;#fffaf0&#x27;,
                          forestgreen:           &#x27;#228b22&#x27;,
                          fuchsia:               &#x27;#ff00ff&#x27;,
                          gainsboro:             &#x27;#dcdcdc&#x27;,
                          ghostwhite:            &#x27;#f8f8ff&#x27;,
                          gold:                  &#x27;#ffd700&#x27;,
                          goldenrod:             &#x27;#daa520&#x27;,
                          gray:                  &#x27;#808080&#x27;,
                          green:                 &#x27;#008000&#x27;,
                          greenyellow:           &#x27;#adff2f&#x27;,
                          grey:                  &#x27;#808080&#x27;,
                          honeydew:              &#x27;#f0fff0&#x27;,
                          hotpink:               &#x27;#ff69b4&#x27;,
                          indianred:             &#x27;#cd5c5c&#x27;,
                          indigo:                &#x27;#4b0082&#x27;,
                          ivory:                 &#x27;#fffff0&#x27;,
                          khaki:                 &#x27;#f0e68c&#x27;,
                          lavender:              &#x27;#e6e6fa&#x27;,
                          lavenderblush:         &#x27;#fff0f5&#x27;,
                          lawngreen:             &#x27;#7cfc00&#x27;,
                          lemonchiffon:          &#x27;#fffacd&#x27;,
                          lightblue:             &#x27;#add8e6&#x27;,
                          lightcoral:            &#x27;#f08080&#x27;,
                          lightcyan:             &#x27;#e0ffff&#x27;,
                          lightgoldenrodyellow:  &#x27;#fafad2&#x27;,
                          lightgray:             &#x27;#d3d3d3&#x27;,
                          lightgreen:            &#x27;#90ee90&#x27;,
                          lightgrey:             &#x27;#d3d3d3&#x27;,
                          lightpink:             &#x27;#ffb6c1&#x27;,
                          lightsalmon:           &#x27;#ffa07a&#x27;,
                          lightseagreen:         &#x27;#20b2aa&#x27;,
                          lightskyblue:          &#x27;#87cefa&#x27;,
                          lightslategray:        &#x27;#778899&#x27;,
                          lightslategrey:        &#x27;#778899&#x27;,
                          lightsteelblue:        &#x27;#b0c4de&#x27;,
                          lightyellow:           &#x27;#ffffe0&#x27;,
                          lime:                  &#x27;#00ff00&#x27;,
                          limegreen:             &#x27;#32cd32&#x27;,
                          linen:                 &#x27;#faf0e6&#x27;,
                          magenta:               &#x27;#ff00ff&#x27;,
                          maroon:                &#x27;#800000&#x27;,
                          mediumaquamarine:      &#x27;#66cdaa&#x27;,
                          mediumblue:            &#x27;#0000cd&#x27;,
                          mediumorchid:          &#x27;#ba55d3&#x27;,
                          mediumpurple:          &#x27;#9370db&#x27;,
                          mediumseagreen:        &#x27;#3cb371&#x27;,
                          mediumslateblue:       &#x27;#7b68ee&#x27;,
                          mediumspringgreen:     &#x27;#00fa9a&#x27;,
                          mediumturquoise:       &#x27;#48d1cc&#x27;,
                          mediumvioletred:       &#x27;#c71585&#x27;,
                          midnightblue:          &#x27;#191970&#x27;,
                          mintcream:             &#x27;#f5fffa&#x27;,
                          mistyrose:             &#x27;#ffe4e1&#x27;,
                          moccasin:              &#x27;#ffe4b5&#x27;,
                          navajowhite:           &#x27;#ffdead&#x27;,
                          navy:                  &#x27;#000080&#x27;,
                          oldlace:               &#x27;#fdf5e6&#x27;,
                          olive:                 &#x27;#808000&#x27;,
                          olivedrab:             &#x27;#6b8e23&#x27;,
                          orange:                &#x27;#ffa500&#x27;,
                          orangered:             &#x27;#ff4500&#x27;,
                          orchid:                &#x27;#da70d6&#x27;,
                          palegoldenrod:         &#x27;#eee8aa&#x27;,
                          palegreen:             &#x27;#98fb98&#x27;,
                          paleturquoise:         &#x27;#afeeee&#x27;,
                          palevioletred:         &#x27;#db7093&#x27;,
                          papayawhip:            &#x27;#ffefd5&#x27;,
                          peachpuff:             &#x27;#ffdab9&#x27;,
                          peru:                  &#x27;#cd853f&#x27;,
                          pink:                  &#x27;#ffc0cb&#x27;,
                          plum:                  &#x27;#dda0dd&#x27;,
                          powderblue:            &#x27;#b0e0e6&#x27;,
                          purple:                &#x27;#800080&#x27;,
                          red:                   &#x27;#ff0000&#x27;,
                          rosybrown:             &#x27;#bc8f8f&#x27;,
                          royalblue:             &#x27;#4169e1&#x27;,
                          saddlebrown:           &#x27;#8b4513&#x27;,
                          salmon:                &#x27;#fa8072&#x27;,
                          sandybrown:            &#x27;#f4a460&#x27;,
                          seagreen:              &#x27;#2e8b57&#x27;,
                          seashell:              &#x27;#fff5ee&#x27;,
                          sienna:                &#x27;#a0522d&#x27;,
                          silver:                &#x27;#c0c0c0&#x27;,
                          skyblue:               &#x27;#87ceeb&#x27;,
                          slateblue:             &#x27;#6a5acd&#x27;,
                          slategray:             &#x27;#708090&#x27;,
                          slategrey:             &#x27;#708090&#x27;,
                          snow:                  &#x27;#fffafa&#x27;,
                          springgreen:           &#x27;#00ff7f&#x27;,
                          steelblue:             &#x27;#4682b4&#x27;,
                          tan:                   &#x27;#d2b48c&#x27;,
                          teal:                  &#x27;#008080&#x27;,
                          thistle:               &#x27;#d8bfd8&#x27;,
                          tomato:                &#x27;#ff6347&#x27;,
                          turquoise:             &#x27;#40e0d0&#x27;,
                          violet:                &#x27;#ee82ee&#x27;,
                          wheat:                 &#x27;#f5deb3&#x27;,
                          white:                 &#x27;#ffffff&#x27;,
                          whitesmoke:            &#x27;#f5f5f5&#x27;,
                          yellow:                &#x27;#ffff00&#x27;,
                          yellowgreen:           &#x27;#9acd32&#x27;
                        };
                        
                        /**
                         * These regular expressions are used to build up the patterns for matching
                         * viable CSS color strings: fragmenting the regexes in this way increases the
                         * legibility and comprehensibility of the code.
                         *
                         * Note that RGB values of .9 are not parsed by IE, but are supported here for
                         * color string consistency.
                         */
                        var WHITESPACE = /\s*/;  // Match zero or more whitespace characters.
                        var INTEGER = /(\d{1,3})/;  // Match integers: 79, 255, etc.
                        var DECIMAL = /((?:\d+(?:\.\d+)?)|(?:\.\d+))/;  // Match 129.6, 79, .9, etc.
                        var PERCENT = new RegExp(DECIMAL.source + &#x27;%&#x27;);  // Match 12.9%, 79%, .9%, etc.
                        
                        /**
                         * Full color string patterns. The capture groups are necessary.
                         */
                        var colorPatterns = {
                          // Match colors in format #XXX, e.g. #416.
                          HEX3: /^#([a-f0-9])([a-f0-9])([a-f0-9])$/i,
                        
                          // Match colors in format #XXXXXX, e.g. #b4d455.
                          HEX6: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i,
                        
                          // Match colors in format rgb(R, G, B), e.g. rgb(255, 0, 128).
                          RGB: new RegExp([
                            &#x27;^rgb\\(&#x27;,
                            INTEGER.source,
                            &#x27;,&#x27;,
                            INTEGER.source,
                            &#x27;,&#x27;,
                            INTEGER.source,
                            &#x27;\\)$&#x27;
                          ].join(WHITESPACE.source), &#x27;i&#x27;),
                        
                          // Match colors in format rgb(R%, G%, B%), e.g. rgb(100%, 0%, 28.9%).
                          RGB_PERCENT: new RegExp([
                            &#x27;^rgb\\(&#x27;,
                            PERCENT.source,
                            &#x27;,&#x27;,
                            PERCENT.source,
                            &#x27;,&#x27;,
                            PERCENT.source,
                            &#x27;\\)$&#x27;
                          ].join(WHITESPACE.source), &#x27;i&#x27;),
                        
                          // Match colors in format rgb(R, G, B, A), e.g. rgb(255, 0, 128, 0.25).
                          RGBA: new RegExp([
                            &#x27;^rgba\\(&#x27;,
                            INTEGER.source,
                            &#x27;,&#x27;,
                            INTEGER.source,
                            &#x27;,&#x27;,
                            INTEGER.source,
                            &#x27;,&#x27;,
                            DECIMAL.source,
                            &#x27;\\)$&#x27;
                          ].join(WHITESPACE.source), &#x27;i&#x27;),
                        
                          // Match colors in format rgb(R%, G%, B%, A), e.g. rgb(100%, 0%, 28.9%, 0.5).
                          RGBA_PERCENT: new RegExp([
                            &#x27;^rgba\\(&#x27;,
                            PERCENT.source,
                            &#x27;,&#x27;,
                            PERCENT.source,
                            &#x27;,&#x27;,
                            PERCENT.source,
                            &#x27;,&#x27;,
                            DECIMAL.source,
                            &#x27;\\)$&#x27;
                          ].join(WHITESPACE.source), &#x27;i&#x27;),
                        
                          // Match colors in format hsla(H, S%, L%), e.g. hsl(100, 40%, 28.9%).
                          HSL: new RegExp([
                            &#x27;^hsl\\(&#x27;,
                            INTEGER.source,
                            &#x27;,&#x27;,
                            PERCENT.source,
                            &#x27;,&#x27;,
                            PERCENT.source,
                            &#x27;\\)$&#x27;
                          ].join(WHITESPACE.source), &#x27;i&#x27;),
                        
                          // Match colors in format hsla(H, S%, L%, A), e.g. hsla(100, 40%, 28.9%, 0.5).
                          HSLA: new RegExp([
                            &#x27;^hsla\\(&#x27;,
                            INTEGER.source,
                            &#x27;,&#x27;,
                            PERCENT.source,
                            &#x27;,&#x27;,
                            PERCENT.source,
                            &#x27;,&#x27;,
                            DECIMAL.source,
                            &#x27;\\)$&#x27;
                          ].join(WHITESPACE.source), &#x27;i&#x27;),
                        
                          // Match colors in format hsb(H, S%, B%), e.g. hsb(100, 40%, 28.9%).
                          HSB: new RegExp([
                            &#x27;^hsb\\(&#x27;,
                            INTEGER.source,
                            &#x27;,&#x27;,
                            PERCENT.source,
                            &#x27;,&#x27;,
                            PERCENT.source,
                            &#x27;\\)$&#x27;
                          ].join(WHITESPACE.source), &#x27;i&#x27;),
                        
                          // Match colors in format hsba(H, S%, B%, A), e.g. hsba(100, 40%, 28.9%, 0.5).
                          HSBA: new RegExp([
                            &#x27;^hsba\\(&#x27;,
                            INTEGER.source,
                            &#x27;,&#x27;,
                            PERCENT.source,
                            &#x27;,&#x27;,
                            PERCENT.source,
                            &#x27;,&#x27;,
                            DECIMAL.source,
                            &#x27;\\)$&#x27;
                          ].join(WHITESPACE.source), &#x27;i&#x27;)
                        };
                        
                        /**
                         * For a number of different inputs, returns a color formatted as [r, g, b, a]
                         * arrays, with each component normalized between 0 and 1.
                         *
                         * @param {Array-like} args An &#x27;array-like&#x27; object that represents a list of
                         *                          arguments
                         * @return {Array}          a color formatted as [r, g, b, a]
                         *                          Example:
                         *                          input        ==&gt; output
                         *                          g            ==&gt; [g, g, g, 255]
                         *                          g,a          ==&gt; [g, g, g, a]
                         *                          r, g, b      ==&gt; [r, g, b, 255]
                         *                          r, g, b, a   ==&gt; [r, g, b, a]
                         *                          [g]          ==&gt; [g, g, g, 255]
                         *                          [g, a]       ==&gt; [g, g, g, a]
                         *                          [r, g, b]    ==&gt; [r, g, b, 255]
                         *                          [r, g, b, a] ==&gt; [r, g, b, a]
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // todo
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.Color._parseInputs = function() {
                          var numArgs = arguments.length;
                          var mode = this._renderer._colorMode;
                          var maxes = this._renderer._colorMaxes;
                          var results = [];
                        
                          if (numArgs &gt;= 3) {  // Argument is a list of component values.
                        
                            results[0] = arguments[0] / maxes[mode][0];
                            results[1] = arguments[1] / maxes[mode][1];
                            results[2] = arguments[2] / maxes[mode][2];
                        
                            // Alpha may be undefined, so default it to 100%.
                            if (typeof arguments[3] === &#x27;number&#x27;) {
                              results[3] = arguments[3] / maxes[mode][3];
                            } else {
                              results[3] = 1;
                            }
                        
                            // Constrain components to the range [0,1].
                            results = results.map(function(value) {
                              return Math.max(Math.min(value, 1), 0);
                            });
                        
                            // Convert to RGBA and return.
                            if (mode === constants.HSL) {
                              return color_conversion._hslaToRGBA(results);
                            } else if (mode === constants.HSB) {
                              return color_conversion._hsbaToRGBA(results);
                            } else {
                              return results;
                            }
                        
                          } else if (numArgs === 1 &amp;&amp; typeof arguments[0] === &#x27;string&#x27;) {
                        
                            var str = arguments[0].trim().toLowerCase();
                        
                            // Return if string is a named colour.
                            if (namedColors[str]) {
                              return p5.Color._parseInputs.apply(this, [namedColors[str]]);
                            }
                        
                            // Try RGBA pattern matching.
                            if (colorPatterns.HEX3.test(str)) {  // #rgb
                              results = colorPatterns.HEX3.exec(str).slice(1).map(function(color) {
                                return parseInt(color + color, 16) / 255;
                              });
                              results[3] = 1;
                              return results;
                            } else if (colorPatterns.HEX6.test(str)) {  // #rrggbb
                              results = colorPatterns.HEX6.exec(str).slice(1).map(function(color) {
                                return parseInt(color, 16) / 255;
                              });
                              results[3] = 1;
                              return results;
                            } else if (colorPatterns.RGB.test(str)) {  // rgb(R,G,B)
                              results = colorPatterns.RGB.exec(str).slice(1).map(function(color) {
                                return color / 255;
                              });
                              results[3] = 1;
                              return results;
                            } else if (colorPatterns.RGB_PERCENT.test(str)) {  // rgb(R%,G%,B%)
                              results = colorPatterns.RGB_PERCENT.exec(str).slice(1)
                                .map(function(color) {
                                  return parseFloat(color) / 100;
                                });
                              results[3] = 1;
                              return results;
                            } else if (colorPatterns.RGBA.test(str)) {  // rgba(R,G,B,A)
                              results = colorPatterns.RGBA.exec(str).slice(1)
                                .map(function(color, idx) {
                                  if (idx === 3) {
                                    return parseFloat(color);
                                  }
                                  return color / 255;
                                });
                              return results;
                            } else if (colorPatterns.RGBA_PERCENT.test(str)) {  // rgba(R%,G%,B%,A%)
                              results = colorPatterns.RGBA_PERCENT.exec(str).slice(1)
                                .map(function(color, idx) {
                                  if (idx === 3) {
                                    return parseFloat(color);
                                  }
                                  return parseFloat(color) / 100;
                                });
                              return results;
                            }
                        
                            // Try HSLA pattern matching.
                            if (colorPatterns.HSL.test(str)) {  // hsl(H,S,L)
                              results = colorPatterns.HSL.exec(str).slice(1)
                                .map(function(color, idx) {
                                if (idx === 0) {
                                  return parseInt(color, 10) / 360;
                                }
                                return parseInt(color, 10) / 100;
                              });
                              results[3] = 1;
                            } else if (colorPatterns.HSLA.test(str)) {  // hsla(H,S,L,A)
                              results = colorPatterns.HSLA.exec(str).slice(1)
                                .map(function(color, idx) {
                                if (idx === 0) {
                                  return parseInt(color, 10) / 360;
                                }
                                else if (idx === 3) {
                                  return parseFloat(color);
                                }
                                return parseInt(color, 10) / 100;
                              });
                            }
                            if (results.length) {
                              return color_conversion._hslaToRGBA(results);
                            }
                        
                            // Try HSBA pattern matching.
                            if (colorPatterns.HSB.test(str)) {  // hsb(H,S,B)
                              results = colorPatterns.HSB.exec(str).slice(1)
                                .map(function(color, idx) {
                                if (idx === 0) {
                                  return parseInt(color, 10) / 360;
                                }
                                return parseInt(color, 10) / 100;
                              });
                              results[3] = 1;
                            } else if (colorPatterns.HSBA.test(str)) {  // hsba(H,S,B,A)
                              results = colorPatterns.HSBA.exec(str).slice(1)
                                .map(function(color, idx) {
                                if (idx === 0) {
                                  return parseInt(color, 10) / 360;
                                }
                                else if (idx === 3) {
                                  return parseFloat(color);
                                }
                                return parseInt(color, 10) / 100;
                              });
                            }
                            if (results.length) {
                              return color_conversion._hsbaToRGBA(results);
                            }
                        
                            // Input did not match any CSS color pattern: default to white.
                            results = [1, 1, 1, 1];
                        
                          } else if ((numArgs === 1 || numArgs === 2) &amp;&amp;
                                      typeof arguments[0] === &#x27;number&#x27;) {  // &#x27;Grayscale&#x27; mode.
                        
                            /**
                             * For HSB and HSL, interpret the gray level as a brightness/lightness
                             * value (they are equivalent when chroma is zero). For RGB, normalize the
                             * gray level according to the blue maximum.
                             */
                            results[0] = arguments[0] / maxes[mode][2];
                            results[1] = arguments[0] / maxes[mode][2];
                            results[2] = arguments[0] / maxes[mode][2];
                        
                            // Alpha may be undefined, so default it to 100%.
                            if (typeof arguments[1] === &#x27;number&#x27;) {
                              results[3] = arguments[1] / maxes[mode][3];
                            } else {
                              results[3] = 1;
                            }
                        
                            // Constrain components to the range [0,1].
                            results = results.map(function(value) {
                              return Math.max(Math.min(value, 1), 0);
                            });
                        
                          } else {
                            throw new Error (arguments + &#x27;is not a valid color representation.&#x27;);
                          }
                        
                          return results;
                        };
                        
                        module.exports = p5.Color;
                        
                        },{&quot;../core/constants&quot;:47,&quot;../core/core&quot;:48,&quot;./color_conversion&quot;:40}],43:[function(_dereq_,module,exports){
                        /**
                         * @module Color
                         * @submodule Setting
                         * @for p5
                         * @requires core
                         * @requires constants
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        var constants = _dereq_(&#x27;../core/constants&#x27;);
                        _dereq_(&#x27;./p5.Color&#x27;);
                        
                        /**
                         * The background() function sets the color used for the background of the
                         * p5.js canvas. The default background is light gray. This function is
                         * typically used within draw() to clear the display window at the beginning
                         * of each frame, but it can be used inside setup() to set the background on
                         * the first frame of animation or if the background need only be set once.
                         *
                         * @method background
                         * @param {Number|String|p5.Color|p5.Image} v1   gray value, red or hue value
                         *                                               (depending on the current
                         *                                               color mode), color string,
                         *                                               p5.Color, or p5.Image
                         * @param {Number}                          [v2] green or saturation value
                         *                                               (depending on the current
                         *                                               color mode)
                         * @param {Number}                          [v3] blue or brightness value
                         *                                               (depending on the current
                         *                                               color mode)
                         * @param {Number}                          [a]  opacity of the background
                         *
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Grayscale integer value
                         * background(51);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // R, G &amp; B integer values
                         * background(255, 204, 0);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // H, S &amp; B integer values
                         * colorMode(HSB);
                         * background(255, 204, 100);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Named SVG/CSS color string
                         * background(&#x27;red&#x27;);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // three-digit hexadecimal RGB notation
                         * background(&#x27;#fae&#x27;);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // six-digit hexadecimal RGB notation
                         * background(&#x27;#222222&#x27;);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // integer RGB notation
                         * background(&#x27;rgb(0,255,0)&#x27;);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // integer RGBA notation
                         * background(&#x27;rgba(0,255,0, 0.25)&#x27;);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // percentage RGB notation
                         * background(&#x27;rgb(100%,0%,10%)&#x27;);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // percentage RGBA notation
                         * background(&#x27;rgba(100%,0%,100%,0.5)&#x27;);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // p5 Color object
                         * background(color(0, 0, 255));
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.background = function() {
                          if (arguments[0] instanceof p5.Image) {
                            this.image(arguments[0], 0, 0, this.width, this.height);
                          } else {
                            this._renderer.background.apply(this._renderer, arguments);
                          }
                          return this;
                        };
                        
                        /**
                         * Clears the pixels within a buffer. This function only works on p5.Canvas
                         * objects created with the createCanvas() function; it won&#x27;t work with the
                         * main display window. Unlike the main graphics context, pixels in
                         * additional graphics areas created with createGraphics() can be entirely
                         * or partially transparent. This function clears everything to make all of
                         * the pixels 100% transparent.
                         *
                         * @method clear
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Clear the screen on mouse press.
                         * function setup() {
                         *   createCanvas(100, 100);
                         * }
                         *
                         * function draw() {
                         *   ellipse(mouseX, mouseY, 20, 20);
                         * }
                         *
                         * function mousePressed() {
                         *   clear();
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.clear = function() {
                          this._renderer.clear();
                          return this;
                        };
                        
                        /**
                         * colorMode() changes the way p5.js interprets color data. By default, the
                         * parameters for fill(), stroke(), background(), and color() are defined by
                         * values between 0 and 255 using the RGB color model. This is equivalent to
                         * setting colorMode(RGB, 255). Setting colorMode(HSB) lets you use the HSB
                         * system instead. By default, this is colorMode(HSB, 360, 100, 100, 1). You
                         * can also use HSL.
                         * &lt;br&gt;&lt;br&gt;
                         * Note: existing color objects remember the mode that they were created in,
                         * so you can change modes as you like without affecting their appearance.
                         *
                         * @method colorMode
                         * @param {Number|Constant} mode   either RGB or HSB, corresponding to
                         *                                 Red/Green/Blue and Hue/Saturation/Brightness
                         *                                 (or Lightness)
                         * @param {Number|Constant} [max1] range for the red or hue depending on the
                         *                                 current color mode, or range for all values
                         * @param {Number|Constant} [max2] range for the green or saturation depending
                         *                                 on the current color mode
                         * @param {Number|Constant} [max3] range for the blue or brightness/lighntess
                         *                                 depending on the current color mode
                         * @param {Number|Constant} [maxA] range for the alpha
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noStroke();
                         * colorMode(RGB, 100);
                         * for (i = 0; i &lt; 100; i++) {
                         *   for (j = 0; j &lt; 100; j++) {
                         *     stroke(i, j, 0);
                         *     point(i, j);
                         *   }
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noStroke();
                         * colorMode(HSB, 100);
                         * for (i = 0; i &lt; 100; i++) {
                         *   for (j = 0; j &lt; 100; j++) {
                         *     stroke(i, j, 100);
                         *     point(i, j);
                         *   }
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * colorMode(RGB, 255);
                         * var c = color(127, 255, 0);
                         *
                         * colorMode(RGB, 1);
                         * var myColor = c._getRed();
                         * text(myColor, 10, 10, 80, 80);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noFill();
                         * colorMode(RGB, 255, 255, 255, 1);
                         * background(255);
                         *
                         * strokeWeight(4);
                         * stroke(255, 0 , 10, 0.3);
                         * ellipse(40, 40, 50, 50);
                         * ellipse(50, 50, 40, 40);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.colorMode = function() {
                          if (arguments[0] === constants.RGB ||
                              arguments[0] === constants.HSB ||
                              arguments[0] === constants.HSL) {
                        
                            // Set color mode.
                            this._renderer._colorMode = arguments[0];
                        
                            // Set color maxes.
                            var maxes = this._renderer._colorMaxes[this._renderer._colorMode];
                            if (arguments.length === 2) {
                              maxes[0] = arguments[1];  // Red
                              maxes[1] = arguments[1];  // Green
                              maxes[2] = arguments[1];  // Blue
                              maxes[3] = arguments[1];  // Alpha
                            } else if (arguments.length === 4) {
                              maxes[0] = arguments[1];  // Red
                              maxes[1] = arguments[2];  // Green
                              maxes[2] = arguments[3];  // Blue
                            } else if (arguments.length === 5) {
                              maxes[0] = arguments[1];  // Red
                              maxes[1] = arguments[2];  // Green
                              maxes[2] = arguments[3];  // Blue
                              maxes[3] = arguments[4];  // Alpha
                            }
                          }
                        
                          return this;
                        };
                        
                        /**
                         * Sets the color used to fill shapes. For example, if you run
                         * fill(204, 102, 0), all subsequent shapes will be filled with orange. This
                         * color is either specified in terms of the RGB or HSB color depending on
                         * the current colorMode(). (The default color space is RGB, with each value
                         * in the range from 0 to 255).
                         * &lt;br&gt;&lt;br&gt;
                         * If a single string argument is provided, RGB, RGBA and Hex CSS color strings
                         * and all named color strings are supported. A p5 Color object can also be
                         * provided to set the fill color.
                         *
                         * @method fill
                         * @param {Number|Array|String|p5.Color} v1   gray value, red or hue value
                         *                                            (depending on the current color
                         *                                            mode), or color Array, or CSS
                         *                                            color string
                         * @param {Number}                       [v2] green or saturation value
                         *                                            (depending on the current
                         *                                            color mode)
                         * @param {Number}                       [v3] blue or brightness value
                         *                                            (depending on the current
                         *                                            color mode)
                         * @param {Number}                       [a]  opacity of the background
                         *
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Grayscale integer value
                         * fill(51);
                         * rect(20, 20, 60, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // R, G &amp; B integer values
                         * fill(255, 204, 0);
                         * rect(20, 20, 60, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // H, S &amp; B integer values
                         * colorMode(HSB);
                         * fill(255, 204, 100);
                         * rect(20, 20, 60, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Named SVG/CSS color string
                         * fill(&#x27;red&#x27;);
                         * rect(20, 20, 60, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // three-digit hexadecimal RGB notation
                         * fill(&#x27;#fae&#x27;);
                         * rect(20, 20, 60, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // six-digit hexadecimal RGB notation
                         * fill(&#x27;#222222&#x27;);
                         * rect(20, 20, 60, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // integer RGB notation
                         * fill(&#x27;rgb(0,255,0)&#x27;);
                         * rect(20, 20, 60, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // integer RGBA notation
                         * fill(&#x27;rgba(0,255,0, 0.25)&#x27;);
                         * rect(20, 20, 60, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // percentage RGB notation
                         * fill(&#x27;rgb(100%,0%,10%)&#x27;);
                         * rect(20, 20, 60, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // percentage RGBA notation
                         * fill(&#x27;rgba(100%,0%,100%,0.5)&#x27;);
                         * rect(20, 20, 60, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // p5 Color object
                         * fill(color(0, 0, 255));
                         * rect(20, 20, 60, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.fill = function() {
                          this._renderer._setProperty(&#x27;_fillSet&#x27;, true);
                          this._renderer._setProperty(&#x27;_doFill&#x27;, true);
                          this._renderer.fill.apply(this._renderer, arguments);
                          return this;
                        };
                        
                        /**
                         * Disables filling geometry. If both noStroke() and noFill() are called,
                         * nothing will be drawn to the screen.
                         *
                         * @method noFill
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * rect(15, 10, 55, 55);
                         * noFill();
                         * rect(20, 20, 60, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.noFill = function() {
                          this._renderer._setProperty(&#x27;_doFill&#x27;, false);
                          return this;
                        };
                        
                        /**
                         * Disables drawing the stroke (outline). If both noStroke() and noFill()
                         * are called, nothing will be drawn to the screen.
                         *
                         * @method noStroke
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noStroke();
                         * rect(20, 20, 60, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.noStroke = function() {
                          this._renderer._setProperty(&#x27;_doStroke&#x27;, false);
                          return this;
                        };
                        
                        /**
                         * Sets the color used to draw lines and borders around shapes. This color
                         * is either specified in terms of the RGB or HSB color depending on the
                         * current colorMode() (the default color space is RGB, with each value in
                         * the range from 0 to 255).
                         * &lt;br&gt;&lt;br&gt;
                         * If a single string argument is provided, RGB, RGBA and Hex CSS color
                         * strings and all named color strings are supported. A p5 Color object
                         * can also be provided to set the stroke color.
                         *
                         * @method stroke
                         * @param {Number|Array|String|p5.Color} v1   gray value, red or hue value
                         *                                            (depending on the current color
                         *                                            mode), or color Array, or CSS
                         *                                            color string
                         * @param {Number}                       [v2] green or saturation value
                         *                                            (depending on the current
                         *                                            color mode)
                         * @param {Number}                       [v3] blue or brightness value
                         *                                            (depending on the current
                         *                                            color mode)
                         * @param {Number}                       [a]  opacity of the background
                         *
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Grayscale integer value
                         * strokeWeight(4);
                         * stroke(51);
                         * rect(20, 20, 60, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // R, G &amp; B integer values
                         * stroke(255, 204, 0);
                         * strokeWeight(4);
                         * rect(20, 20, 60, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // H, S &amp; B integer values
                         * colorMode(HSB);
                         * strokeWeight(4);
                         * stroke(255, 204, 100);
                         * rect(20, 20, 60, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Named SVG/CSS color string
                         * stroke(&#x27;red&#x27;);
                         * strokeWeight(4);
                         * rect(20, 20, 60, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // three-digit hexadecimal RGB notation
                         * stroke(&#x27;#fae&#x27;);
                         * strokeWeight(4);
                         * rect(20, 20, 60, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // six-digit hexadecimal RGB notation
                         * stroke(&#x27;#222222&#x27;);
                         * strokeWeight(4);
                         * rect(20, 20, 60, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // integer RGB notation
                         * stroke(&#x27;rgb(0,255,0)&#x27;);
                         * strokeWeight(4);
                         * rect(20, 20, 60, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // integer RGBA notation
                         * stroke(&#x27;rgba(0,255,0,0.25)&#x27;);
                         * strokeWeight(4);
                         * rect(20, 20, 60, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // percentage RGB notation
                         * stroke(&#x27;rgb(100%,0%,10%)&#x27;);
                         * strokeWeight(4);
                         * rect(20, 20, 60, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // percentage RGBA notation
                         * stroke(&#x27;rgba(100%,0%,100%,0.5)&#x27;);
                         * strokeWeight(4);
                         * rect(20, 20, 60, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // p5 Color object
                         * stroke(color(0, 0, 255));
                         * strokeWeight(4);
                         * rect(20, 20, 60, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.stroke = function() {
                          this._renderer._setProperty(&#x27;_strokeSet&#x27;, true);
                          this._renderer._setProperty(&#x27;_doStroke&#x27;, true);
                          this._renderer.stroke.apply(this._renderer, arguments);
                          return this;
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;../core/constants&quot;:47,&quot;../core/core&quot;:48,&quot;./p5.Color&quot;:42}],44:[function(_dereq_,module,exports){
                        /**
                         * @module Shape
                         * @submodule 2D Primitives
                         * @for p5
                         * @requires core
                         * @requires constants
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;./core&#x27;);
                        var constants = _dereq_(&#x27;./constants&#x27;);
                        
                        _dereq_(&#x27;./error_helpers&#x27;);
                        
                        /**
                         * Draw an arc to the screen. If called with only a, b, c, d, start, and
                         * stop, the arc will be drawn as an open pie. If mode is provided, the arc
                         * will be drawn either open, as a chord, or as a pie as specified. The
                         * origin may be changed with the ellipseMode() function.&lt;br&gt;&lt;br&gt;
                         * Note that drawing a full circle (ex: 0 to TWO_PI) will appear blank
                         * because 0 and TWO_PI are the same position on the unit circle. The
                         * best way to handle this is by using the ellipse() function instead
                         * to create a closed ellipse, and to use the arc() function
                         * only to draw parts of an ellipse.
                         *
                         * @method arc
                         * @param  {Number} a      x-coordinate of the arc&#x27;s ellipse
                         * @param  {Number} b      y-coordinate of the arc&#x27;s ellipse
                         * @param  {Number} c      width of the arc&#x27;s ellipse by default
                         * @param  {Number} d      height of the arc&#x27;s ellipse by default
                         * @param  {Number} start  angle to start the arc, specified in radians
                         * @param  {Number} stop   angle to stop the arc, specified in radians
                         * @param  {String} [mode] optional parameter to determine the way of drawing
                         *                         the arc
                         * @return {Object}        the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * arc(50, 55, 50, 50, 0, HALF_PI);
                         * noFill();
                         * arc(50, 55, 60, 60, HALF_PI, PI);
                         * arc(50, 55, 70, 70, PI, PI+QUARTER_PI);
                         * arc(50, 55, 80, 80, PI+QUARTER_PI, TWO_PI);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * arc(50, 50, 80, 80, 0, PI+QUARTER_PI, OPEN);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * arc(50, 50, 80, 80, 0, PI+QUARTER_PI, CHORD);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * arc(50, 50, 80, 80, 0, PI+QUARTER_PI, PIE);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.arc = function(x, y, w, h, start, stop, mode) {
                          var args = new Array(arguments.length);
                          for (var i = 0; i &lt; args.length; ++i) {
                            args[i] = arguments[i];
                          }
                          this._validateParameters(
                            &#x27;arc&#x27;,
                            args,
                            [
                              [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;],
                              [ &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;,
                                &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;String&#x27; ]
                            ]
                          );
                        
                          if (!this._renderer._doStroke &amp;&amp; !this._renderer._doFill) {
                            return this;
                          }
                          if (this._angleMode === constants.DEGREES) {
                            start = this.radians(start);
                            stop = this.radians(stop);
                          }
                        
                          // Make all angles positive...
                          while (start &lt; 0) {
                            start += constants.TWO_PI;
                          }
                          while (stop &lt; 0) {
                            stop += constants.TWO_PI;
                          }
                          // ...and confine them to the interval [0,TWO_PI).
                          start %= constants.TWO_PI;
                          stop %= constants.TWO_PI;
                        
                          // Adjust angles to counter linear scaling.
                          if (start &lt;= constants.HALF_PI) {
                            start = Math.atan(w / h * Math.tan(start));
                          } else  if (start &gt; constants.HALF_PI &amp;&amp; start &lt;= 3 * constants.HALF_PI) {
                            start = Math.atan(w / h * Math.tan(start)) + constants.PI;
                          } else {
                            start = Math.atan(w / h * Math.tan(start)) + constants.TWO_PI;
                          }
                          if (stop &lt;= constants.HALF_PI) {
                            stop = Math.atan(w / h * Math.tan(stop));
                          } else  if (stop &gt; constants.HALF_PI &amp;&amp; stop &lt;= 3 * constants.HALF_PI) {
                            stop = Math.atan(w / h * Math.tan(stop)) + constants.PI;
                          } else {
                            stop = Math.atan(w / h * Math.tan(stop)) + constants.TWO_PI;
                          }
                        
                          // Exceed the interval if necessary in order to preserve the size and
                          // orientation of the arc.
                          if (start &gt; stop) {
                            stop += constants.TWO_PI;
                          }
                          // p5 supports negative width and heights for ellipses
                          w = Math.abs(w);
                          h = Math.abs(h);
                          this._renderer.arc(x, y, w, h, start, stop, mode);
                          return this;
                        };
                        
                        /**
                         * Draws an ellipse (oval) to the screen. An ellipse with equal width and
                         * height is a circle. By default, the first two parameters set the location,
                         * and the third and fourth parameters set the shape&#x27;s width and height. The
                         * origin may be changed with the ellipseMode() function.
                         *
                         * @method ellipse
                         * @param  {Number} a x-coordinate of the ellipse.
                         * @param  {Number} b y-coordinate of the ellipse.
                         * @param  {Number} c width of the ellipse.
                         * @param  {Number} d height of the ellipse.
                         * @return {p5}       the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * ellipse(56, 46, 55, 55);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.ellipse = function(x, y, w, h) {
                          var args = new Array(arguments.length);
                          for (var i = 0; i &lt; args.length; ++i) {
                            args[i] = arguments[i];
                          }
                          this._validateParameters(
                            &#x27;ellipse&#x27;,
                            args,
                            [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;]
                          );
                        
                          if (!this._renderer._doStroke &amp;&amp; !this._renderer._doFill) {
                            return this;
                          }
                          // p5 supports negative width and heights for ellipses
                          w = Math.abs(w);
                          h = Math.abs(h);
                          //@TODO add catch block here if this._renderer
                          //doesn&#x27;t have the method implemented yet
                          this._renderer.ellipse(x, y, w, h);
                          return this;
                        };
                        /**
                         * Draws a line (a direct path between two points) to the screen. The version
                         * of line() with four parameters draws the line in 2D. To color a line, use
                         * the stroke() function. A line cannot be filled, therefore the fill()
                         * function will not affect the color of a line. 2D lines are drawn with a
                         * width of one pixel by default, but this can be changed with the
                         * strokeWeight() function.
                         *
                         * @method line
                         * @param  {Number} x1 the x-coordinate of the first point
                         * @param  {Number} y1 the y-coordinate of the first point
                         * @param  {Number} x2 the x-coordinate of the second point
                         * @param  {Number} y2 the y-coordinate of the second point
                         * @return {p5}        the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * line(30, 20, 85, 75);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * line(30, 20, 85, 20);
                         * stroke(126);
                         * line(85, 20, 85, 75);
                         * stroke(255);
                         * line(85, 75, 30, 75);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        ////commented out original
                        // p5.prototype.line = function(x1, y1, x2, y2) {
                        //   if (!this._renderer._doStroke) {
                        //     return this;
                        //   }
                        //   if(this._renderer.isP3D){
                        //   } else {
                        //     this._renderer.line(x1, y1, x2, y2);
                        //   }
                        // };
                        p5.prototype.line = function() {
                          if (!this._renderer._doStroke) {
                            return this;
                          }
                          var args = new Array(arguments.length);
                          for (var i = 0; i &lt; args.length; ++i) {
                            args[i] = arguments[i];
                          }
                          //check whether we should draw a 3d line or 2d
                          if(this._renderer.isP3D){
                            this._validateParameters(
                              &#x27;line&#x27;,
                              args,
                              [
                                [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;]
                              ]
                            );
                            this._renderer.line(
                              args[0],
                              args[1],
                              args[2],
                              args[3],
                              args[4],
                              args[5]);
                          } else {
                            this._validateParameters(
                              &#x27;line&#x27;,
                              args,
                              [
                                [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;],
                              ]
                            );
                            this._renderer.line(
                              args[0],
                              args[1],
                              args[2],
                              args[3]);
                          }
                          return this;
                        };
                        
                        /**
                         * Draws a point, a coordinate in space at the dimension of one pixel.
                         * The first parameter is the horizontal value for the point, the second
                         * value is the vertical value for the point. The color of the point is
                         * determined by the current stroke.
                         *
                         * @method point
                         * @param  {Number} x the x-coordinate
                         * @param  {Number} y the y-coordinate
                         * @return {p5}       the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * point(30, 20);
                         * point(85, 20);
                         * point(85, 75);
                         * point(30, 75);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.point = function() {
                          if (!this._renderer._doStroke) {
                            return this;
                          }
                          var args = new Array(arguments.length);
                          for (var i = 0; i &lt; args.length; ++i) {
                            args[i] = arguments[i];
                          }
                          //check whether we should draw a 3d line or 2d
                          if(this._renderer.isP3D){
                            this._validateParameters(
                              &#x27;point&#x27;,
                              args,
                              [
                                [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;]
                              ]
                            );
                            this._renderer.point(
                              args[0],
                              args[1],
                              args[2]
                              );
                          } else {
                            this._validateParameters(
                              &#x27;point&#x27;,
                              args,
                              [
                                [&#x27;Number&#x27;, &#x27;Number&#x27;]
                              ]
                            );
                            this._renderer.point(
                              args[0],
                              args[1]
                            );
                          }
                          return this;
                        };
                        
                        
                        /**
                         * Draw a quad. A quad is a quadrilateral, a four sided polygon. It is
                         * similar to a rectangle, but the angles between its edges are not
                         * constrained to ninety degrees. The first pair of parameters (x1,y1)
                         * sets the first vertex and the subsequent pairs should proceed
                         * clockwise or counter-clockwise around the defined shape.
                         *
                         * @method quad
                         * @param {type} x1 the x-coordinate of the first point
                         * @param {type} y1 the y-coordinate of the first point
                         * @param {type} x2 the x-coordinate of the second point
                         * @param {type} y2 the y-coordinate of the second point
                         * @param {type} x3 the x-coordinate of the third point
                         * @param {type} y3 the y-coordinate of the third point
                         * @param {type} x4 the x-coordinate of the fourth point
                         * @param {type} y4 the y-coordinate of the fourth point
                         * @return {p5}     the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * quad(38, 31, 86, 20, 69, 63, 30, 76);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.quad = function() {
                          if (!this._renderer._doStroke &amp;&amp; !this._renderer._doFill) {
                            return this;
                          }
                          var args = new Array(arguments.length);
                          for (var i = 0; i &lt; args.length; ++i) {
                            args[i] = arguments[i];
                          }
                          if(this._renderer.isP3D){
                            this._validateParameters(
                              &#x27;quad&#x27;,
                              args,
                              [
                                [ &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;,
                                  &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;,
                                  &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;,
                                  &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;]
                              ]
                            );
                            this._renderer.quad(
                              args[0],
                              args[1],
                              args[2],
                              args[3],
                              args[4],
                              args[5],
                              args[6],
                              args[7],
                              args[8],
                              args[9],
                              args[10],
                              args[11]
                              );
                          } else {
                            this._validateParameters(
                              &#x27;quad&#x27;,
                              args,
                              [
                                [ &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;,
                                  &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27; ]
                              ]
                            );
                            this._renderer.quad(
                             args[0],
                             args[1],
                             args[2],
                             args[3],
                             args[4],
                             args[5],
                             args[6],
                            args[7]
                            );
                          }
                          return this;
                        };
                        
                        /**
                        * Draws a rectangle to the screen. A rectangle is a four-sided shape with
                        * every angle at ninety degrees. By default, the first two parameters set
                        * the location of the upper-left corner, the third sets the width, and the
                        * fourth sets the height. The way these parameters are interpreted, however,
                        * may be changed with the rectMode() function.
                        * &lt;br&gt;&lt;br&gt;
                        * The fifth, sixth, seventh and eighth parameters, if specified,
                        * determine corner radius for the top-right, top-left, lower-right and
                        * lower-left corners, respectively. An omitted corner radius parameter is set
                        * to the value of the previously specified radius value in the parameter list.
                        *
                        * @method rect
                        * @param  {Number} x  x-coordinate of the rectangle.
                        * @param  {Number} y  y-coordinate of the rectangle.
                        * @param  {Number} w  width of the rectangle.
                        * @param  {Number} h  height of the rectangle.
                        * @param  {Number} [tl] optional radius of top-left corner.
                        * @param  {Number} [tr] optional radius of top-right corner.
                        * @param  {Number} [br] optional radius of bottom-right corner.
                        * @param  {Number} [bl] optional radius of bottom-left corner.
                        * @return {p5}          the p5 object.
                        * @example
                        * &lt;div&gt;
                        * &lt;code&gt;
                        * // Draw a rectangle at location (30, 20) with a width and height of 55.
                        * rect(30, 20, 55, 55);
                        * &lt;/code&gt;
                        * &lt;/div&gt;
                        *
                        * &lt;div&gt;
                        * &lt;code&gt;
                        * // Draw a rectangle with rounded corners, each having a radius of 20.
                        * rect(30, 20, 55, 55, 20);
                        * &lt;/code&gt;
                        * &lt;/div&gt;
                        *
                        * &lt;div&gt;
                        * &lt;code&gt;
                        * // Draw a rectangle with rounded corners having the following radii:
                        * // top-left = 20, top-right = 15, bottom-right = 10, bottom-left = 5.
                        * rect(30, 20, 55, 55, 20, 15, 10, 5)
                        * &lt;/code&gt;
                        * &lt;/div&gt;
                        */
                        p5.prototype.rect = function (x, y, w, h, tl, tr, br, bl) {
                          var args = new Array(arguments.length);
                          for (var i = 0; i &lt; args.length; ++i) {
                            args[i] = arguments[i];
                          }
                          this._validateParameters(
                            &#x27;rect&#x27;,
                            args,
                            [
                              [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;],
                              [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;],
                              [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;,
                               &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;]
                            ]
                          );
                        
                          if (!this._renderer._doStroke &amp;&amp; !this._renderer._doFill) {
                            return;
                          }
                          this._renderer.rect(x, y, w, h, tl, tr, br, bl);
                          return this;
                        };
                        
                        /**
                        * A triangle is a plane created by connecting three points. The first two
                        * arguments specify the first point, the middle two arguments specify the
                        * second point, and the last two arguments specify the third point.
                        *
                        * @method triangle
                        * @param  {Number} x1 x-coordinate of the first point
                        * @param  {Number} y1 y-coordinate of the first point
                        * @param  {Number} x2 x-coordinate of the second point
                        * @param  {Number} y2 y-coordinate of the second point
                        * @param  {Number} x3 x-coordinate of the third point
                        * @param  {Number} y3 y-coordinate of the third point
                        * @return {p5}        the p5 object
                        * @example
                        * &lt;div&gt;
                        * &lt;code&gt;
                        * triangle(30, 75, 58, 20, 86, 75);
                        * &lt;/code&gt;
                        * &lt;/div&gt;
                        */
                        p5.prototype.triangle = function() {
                        
                          if (!this._renderer._doStroke &amp;&amp; !this._renderer._doFill) {
                            return this;
                          }
                          var args = new Array(arguments.length);
                          for (var i = 0; i &lt; args.length; ++i) {
                            args[i] = arguments[i];
                          }
                          if(this._renderer.isP3D){
                            this._validateParameters(
                              &#x27;triangle&#x27;,
                              args,
                              [
                                [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;,
                                 &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;]
                              ]
                            );
                            this._renderer.triangle(
                              args[0],
                              args[1],
                              args[2],
                              args[3],
                              args[4],
                              args[5],
                              args[6],
                              args[7],
                              args[8]
                              );
                          } else {
                            this._validateParameters(
                              &#x27;triangle&#x27;,
                              args,
                              [
                                [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;]
                              ]
                            );
                            this._renderer.triangle(
                             args[0],
                             args[1],
                             args[2],
                             args[3],
                             args[4],
                             args[5]
                            );
                          }
                          return this;
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;./constants&quot;:47,&quot;./core&quot;:48,&quot;./error_helpers&quot;:51}],45:[function(_dereq_,module,exports){
                        /**
                         * @module Shape
                         * @submodule Attributes
                         * @for p5
                         * @requires core
                         * @requires constants
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;./core&#x27;);
                        var constants = _dereq_(&#x27;./constants&#x27;);
                        
                        /**
                         * Modifies the location from which ellipses are drawn by changing the way
                         * in which parameters given to ellipse() are interpreted.
                         * &lt;br&gt;&lt;br&gt;
                         * The default mode is ellipseMode(CENTER), which interprets the first two
                         * parameters of ellipse() as the shape&#x27;s center point, while the third and
                         * fourth parameters are its width and height.
                         * &lt;br&gt;&lt;br&gt;
                         * ellipseMode(RADIUS) also uses the first two parameters of ellipse() as
                         * the shape&#x27;s center point, but uses the third and fourth parameters to
                         * specify half of the shapes&#x27;s width and height.
                         * &lt;br&gt;&lt;br&gt;
                         * ellipseMode(CORNER) interprets the first two parameters of ellipse() as
                         * the upper-left corner of the shape, while the third and fourth parameters
                         * are its width and height.
                         * &lt;br&gt;&lt;br&gt;
                         * ellipseMode(CORNERS) interprets the first two parameters of ellipse() as
                         * the location of one corner of the ellipse&#x27;s bounding box, and the third
                         * and fourth parameters as the location of the opposite corner.
                         * &lt;br&gt;&lt;br&gt;
                         * The parameter must be written in ALL CAPS because Javascript is a
                         * case-sensitive language.
                         *
                         * @method ellipseMode
                         * @param  {Number/Constant} mode either CENTER, RADIUS, CORNER, or CORNERS
                         * @return {p5}                   the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * ellipseMode(RADIUS);  // Set ellipseMode to RADIUS
                         * fill(255);  // Set fill to white
                         * ellipse(50, 50, 30, 30);  // Draw white ellipse using RADIUS mode
                         *
                         * ellipseMode(CENTER);  // Set ellipseMode to CENTER
                         * fill(100);  // Set fill to gray
                         * ellipse(50, 50, 30, 30);  // Draw gray ellipse using CENTER mode
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * ellipseMode(CORNER);  // Set ellipseMode is CORNER
                         * fill(255);  // Set fill to white
                         * ellipse(25, 25, 50, 50);  // Draw white ellipse using CORNER mode
                         *
                         * ellipseMode(CORNERS);  // Set ellipseMode to CORNERS
                         * fill(100);  // Set fill to gray
                         * ellipse(25, 25, 50, 50);  // Draw gray ellipse using CORNERS mode
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.ellipseMode = function(m) {
                          if (m === constants.CORNER ||
                            m === constants.CORNERS ||
                            m === constants.RADIUS ||
                            m === constants.CENTER) {
                            this._renderer._ellipseMode = m;
                          }
                          return this;
                        };
                        
                        /**
                         * Draws all geometry with jagged (aliased) edges. Note that smooth() is
                         * active by default, so it is necessary to call noSmooth() to disable
                         * smoothing of geometry, images, and fonts.
                         *
                         * @method noSmooth
                         * @return {p5} the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * background(0);
                         * noStroke();
                         * smooth();
                         * ellipse(30, 48, 36, 36);
                         * noSmooth();
                         * ellipse(70, 48, 36, 36);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.noSmooth = function() {
                          this._renderer.noSmooth();
                          return this;
                        };
                        
                        /**
                         * Modifies the location from which rectangles are drawn by changing the way
                         * in which parameters given to rect() are interpreted.
                         * &lt;br&gt;&lt;br&gt;
                         * The default mode is rectMode(CORNER), which interprets the first two
                         * parameters of rect() as the upper-left corner of the shape, while the
                         * third and fourth parameters are its width and height.
                         * &lt;br&gt;&lt;br&gt;
                         * rectMode(CORNERS) interprets the first two parameters of rect() as the
                         * location of one corner, and the third and fourth parameters as the
                         * location of the opposite corner.
                         * &lt;br&gt;&lt;br&gt;
                         * rectMode(CENTER) interprets the first two parameters of rect() as the
                         * shape&#x27;s center point, while the third and fourth parameters are its
                         * width and height.
                         * &lt;br&gt;&lt;br&gt;
                         * rectMode(RADIUS) also uses the first two parameters of rect() as the
                         * shape&#x27;s center point, but uses the third and fourth parameters to specify
                         * half of the shapes&#x27;s width and height.
                         * &lt;br&gt;&lt;br&gt;
                         * The parameter must be written in ALL CAPS because Javascript is a
                         * case-sensitive language.
                         *
                         * @method rectMode
                         * @param  {Number/Constant} mode either CORNER, CORNERS, CENTER, or RADIUS
                         * @return {p5}                   the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * rectMode(CORNER);  // Default rectMode is CORNER
                         * fill(255);  // Set fill to white
                         * rect(25, 25, 50, 50);  // Draw white rect using CORNER mode
                         *
                         * rectMode(CORNERS);  // Set rectMode to CORNERS
                         * fill(100);  // Set fill to gray
                         * rect(25, 25, 50, 50);  // Draw gray rect using CORNERS mode
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * rectMode(RADIUS);  // Set rectMode to RADIUS
                         * fill(255);  // Set fill to white
                         * rect(50, 50, 30, 30);  // Draw white rect using RADIUS mode
                         *
                         * rectMode(CENTER);  // Set rectMode to CENTER
                         * fill(100);  // Set fill to gray
                         * rect(50, 50, 30, 30);  // Draw gray rect using CENTER mode
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.rectMode = function(m) {
                          if (m === constants.CORNER ||
                            m === constants.CORNERS ||
                            m === constants.RADIUS ||
                            m === constants.CENTER) {
                            this._renderer._rectMode = m;
                          }
                          return this;
                        };
                        
                        /**
                         * Draws all geometry with smooth (anti-aliased) edges. smooth() will also
                         * improve image quality of resized images. Note that smooth() is active by
                         * default; noSmooth() can be used to disable smoothing of geometry,
                         * images, and fonts.
                         *
                         * @method smooth
                         * @return {p5} the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * background(0);
                         * noStroke();
                         * smooth();
                         * ellipse(30, 48, 36, 36);
                         * noSmooth();
                         * ellipse(70, 48, 36, 36);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.smooth = function() {
                          this._renderer.smooth();
                          return this;
                        };
                        
                        /**
                         * Sets the style for rendering line endings. These ends are either squared,
                         * extended, or rounded, each of which specified with the corresponding
                         * parameters: SQUARE, PROJECT, and ROUND. The default cap is ROUND.
                         *
                         * @method strokeCap
                         * @param  {Number/Constant} cap either SQUARE, PROJECT, or ROUND
                         * @return {p5}                  the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * strokeWeight(12.0);
                         * strokeCap(ROUND);
                         * line(20, 30, 80, 30);
                         * strokeCap(SQUARE);
                         * line(20, 50, 80, 50);
                         * strokeCap(PROJECT);
                         * line(20, 70, 80, 70);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.strokeCap = function(cap) {
                          if (cap === constants.ROUND ||
                            cap === constants.SQUARE ||
                            cap === constants.PROJECT) {
                            this._renderer.strokeCap(cap);
                          }
                          return this;
                        };
                        
                        /**
                         * Sets the style of the joints which connect line segments. These joints
                         * are either mitered, beveled, or rounded and specified with the
                         * corresponding parameters MITER, BEVEL, and ROUND. The default joint is
                         * MITER.
                         *
                         * @method strokeJoin
                         * @param  {Number/Constant} join either MITER, BEVEL, ROUND
                         * @return {p5}                   the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noFill();
                         * strokeWeight(10.0);
                         * strokeJoin(MITER);
                         * beginShape();
                         * vertex(35, 20);
                         * vertex(65, 50);
                         * vertex(35, 80);
                         * endShape();
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noFill();
                         * strokeWeight(10.0);
                         * strokeJoin(BEVEL);
                         * beginShape();
                         * vertex(35, 20);
                         * vertex(65, 50);
                         * vertex(35, 80);
                         * endShape();
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noFill();
                         * strokeWeight(10.0);
                         * strokeJoin(ROUND);
                         * beginShape();
                         * vertex(35, 20);
                         * vertex(65, 50);
                         * vertex(35, 80);
                         * endShape();
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.strokeJoin = function(join) {
                          if (join === constants.ROUND ||
                            join === constants.BEVEL ||
                            join === constants.MITER) {
                            this._renderer.strokeJoin(join);
                          }
                          return this;
                        };
                        
                        /**
                         * Sets the width of the stroke used for lines, points, and the border
                         * around shapes. All widths are set in units of pixels.
                         *
                         * @method strokeWeight
                         * @param  {Number} weight the weight (in pixels) of the stroke
                         * @return {p5}            the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * strokeWeight(1);  // Default
                         * line(20, 20, 80, 20);
                         * strokeWeight(4);  // Thicker
                         * line(20, 40, 80, 40);
                         * strokeWeight(10);  // Beastly
                         * line(20, 70, 80, 70);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.strokeWeight = function(w) {
                          this._renderer.strokeWeight(w);
                          return this;
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;./constants&quot;:47,&quot;./core&quot;:48}],46:[function(_dereq_,module,exports){
                        /**
                         * @requires constants
                         */
                        
                        var constants = _dereq_(&#x27;./constants&#x27;);
                        
                        module.exports = {
                        
                          modeAdjust: function(a, b, c, d, mode) {
                            if (mode === constants.CORNER) {
                              return { x: a, y: b, w: c, h: d };
                            } else if (mode === constants.CORNERS) {
                              return { x: a, y: b, w: c-a, h: d-b };
                            } else if (mode === constants.RADIUS) {
                              return { x: a-c, y: b-d, w: 2*c, h: 2*d };
                            } else if (mode === constants.CENTER) {
                              return { x: a-c*0.5, y: b-d*0.5, w: c, h: d };
                            }
                          },
                        
                          arcModeAdjust: function(a, b, c, d, mode) {
                            if (mode === constants.CORNER) {
                              return { x: a+c*0.5, y: b+d*0.5, w: c, h: d };
                            } else if (mode === constants.CORNERS) {
                              return { x: a, y: b, w: c+a, h: d+b };
                            } else if (mode === constants.RADIUS) {
                              return { x: a, y: b, w: 2*c, h: 2*d };
                            } else if (mode === constants.CENTER) {
                              return { x: a, y: b, w: c, h: d };
                            }
                          }
                        
                        };
                        
                        
                        },{&quot;./constants&quot;:47}],47:[function(_dereq_,module,exports){
                        /**
                         * @module Constants
                         * @submodule Constants
                         * @for p5
                         */
                        
                        var PI = Math.PI;
                        
                        module.exports = {
                        
                          // GRAPHICS RENDERER
                          P2D: &#x27;p2d&#x27;,
                          WEBGL: &#x27;webgl&#x27;,
                        
                          // ENVIRONMENT
                          ARROW: &#x27;default&#x27;,
                          CROSS: &#x27;crosshair&#x27;,
                          HAND: &#x27;pointer&#x27;,
                          MOVE: &#x27;move&#x27;,
                          TEXT: &#x27;text&#x27;,
                          WAIT: &#x27;wait&#x27;,
                        
                          // TRIGONOMETRY
                        
                          /**
                           * HALF_PI is a mathematical constant with the value
                           * 1.57079632679489661923. It is half the ratio of the
                           * circumference of a circle to its diameter. It is useful in
                           * combination with the trigonometric functions sin() and cos().
                           *
                           * @property HALF_PI
                           *
                           * @example
                           * &lt;div&gt;&lt;code&gt;
                           * arc(50, 50, 80, 80, 0, HALF_PI);
                           * &lt;/code&gt;&lt;/div&gt;
                           *
                           */
                          HALF_PI: PI / 2,
                          /**
                           * PI is a mathematical constant with the value
                           * 3.14159265358979323846. It is the ratio of the circumference
                           * of a circle to its diameter. It is useful in combination with
                           * the trigonometric functions sin() and cos().
                           *
                           * @property PI
                           *
                           * @example
                           * &lt;div&gt;&lt;code&gt;
                           * arc(50, 50, 80, 80, 0, PI);
                           * &lt;/code&gt;&lt;/div&gt;
                           */
                          PI: PI,
                          /**
                           * QUARTER_PI is a mathematical constant with the value 0.7853982.
                           * It is one quarter the ratio of the circumference of a circle to
                           * its diameter. It is useful in combination with the trigonometric
                           * functions sin() and cos().
                           *
                           * @property QUARTER_PI
                           *
                           * @example
                           * &lt;div&gt;&lt;code&gt;
                           * arc(50, 50, 80, 80, 0, QUARTER_PI);
                           * &lt;/code&gt;&lt;/div&gt;
                           *
                           */
                          QUARTER_PI: PI / 4,
                          /**
                           * TAU is an alias for TWO_PI, a mathematical constant with the
                           * value 6.28318530717958647693. It is twice the ratio of the
                           * circumference of a circle to its diameter. It is useful in
                           * combination with the trigonometric functions sin() and cos().
                           *
                           * @property TAU
                           *
                           * @example
                           * &lt;div&gt;&lt;code&gt;
                           * arc(50, 50, 80, 80, 0, TAU);
                           * &lt;/code&gt;&lt;/div&gt;
                           *
                           */
                          TAU: PI * 2,
                          /**
                           * TWO_PI is a mathematical constant with the value
                           * 6.28318530717958647693. It is twice the ratio of the
                           * circumference of a circle to its diameter. It is useful in
                           * combination with the trigonometric functions sin() and cos().
                           *
                           * @property TWO_PI
                           *
                           * @example
                           * &lt;div&gt;&lt;code&gt;
                           * arc(50, 50, 80, 80, 0, TWO_PI);
                           * &lt;/code&gt;&lt;/div&gt;
                           *
                           */
                          TWO_PI: PI * 2,
                          DEGREES: &#x27;degrees&#x27;,
                          RADIANS: &#x27;radians&#x27;,
                        
                          // SHAPE
                          CORNER: &#x27;corner&#x27;,
                          CORNERS: &#x27;corners&#x27;,
                          RADIUS: &#x27;radius&#x27;,
                          RIGHT: &#x27;right&#x27;,
                          LEFT: &#x27;left&#x27;,
                          CENTER: &#x27;center&#x27;,
                          TOP: &#x27;top&#x27;,
                          BOTTOM: &#x27;bottom&#x27;,
                          BASELINE: &#x27;alphabetic&#x27;,
                          POINTS: &#x27;points&#x27;,
                          LINES: &#x27;lines&#x27;,
                          TRIANGLES: &#x27;triangles&#x27;,
                          TRIANGLE_FAN: &#x27;triangles_fan&#x27;,
                          TRIANGLE_STRIP: &#x27;triangles_strip&#x27;,
                          QUADS: &#x27;quads&#x27;,
                          QUAD_STRIP: &#x27;quad_strip&#x27;,
                          CLOSE: &#x27;close&#x27;,
                          OPEN: &#x27;open&#x27;,
                          CHORD: &#x27;chord&#x27;,
                          PIE: &#x27;pie&#x27;,
                          PROJECT: &#x27;square&#x27;, // PEND: careful this is counterintuitive
                          SQUARE: &#x27;butt&#x27;,
                          ROUND: &#x27;round&#x27;,
                          BEVEL: &#x27;bevel&#x27;,
                          MITER: &#x27;miter&#x27;,
                        
                          // COLOR
                          RGB: &#x27;rgb&#x27;,
                          HSB: &#x27;hsb&#x27;,
                          HSL: &#x27;hsl&#x27;,
                        
                          // DOM EXTENSION
                          AUTO: &#x27;auto&#x27;,
                        
                          // INPUT
                          ALT: 18,
                          BACKSPACE: 8,
                          CONTROL: 17,
                          DELETE: 46,
                          DOWN_ARROW: 40,
                          ENTER: 13,
                          ESCAPE: 27,
                          LEFT_ARROW: 37,
                          OPTION: 18,
                          RETURN: 13,
                          RIGHT_ARROW: 39,
                          SHIFT: 16,
                          TAB: 9,
                          UP_ARROW: 38,
                        
                          // RENDERING
                          BLEND: &#x27;normal&#x27;,
                          ADD: &#x27;lighter&#x27;,
                          //ADD: &#x27;add&#x27;, //
                          //SUBTRACT: &#x27;subtract&#x27;, //
                          DARKEST: &#x27;darken&#x27;,
                          LIGHTEST: &#x27;lighten&#x27;,
                          DIFFERENCE: &#x27;difference&#x27;,
                          EXCLUSION: &#x27;exclusion&#x27;,
                          MULTIPLY: &#x27;multiply&#x27;,
                          SCREEN: &#x27;screen&#x27;,
                          REPLACE: &#x27;source-over&#x27;,
                          OVERLAY: &#x27;overlay&#x27;,
                          HARD_LIGHT: &#x27;hard-light&#x27;,
                          SOFT_LIGHT: &#x27;soft-light&#x27;,
                          DODGE: &#x27;color-dodge&#x27;,
                          BURN: &#x27;color-burn&#x27;,
                        
                          // FILTERS
                          THRESHOLD: &#x27;threshold&#x27;,
                          GRAY: &#x27;gray&#x27;,
                          OPAQUE: &#x27;opaque&#x27;,
                          INVERT: &#x27;invert&#x27;,
                          POSTERIZE: &#x27;posterize&#x27;,
                          DILATE: &#x27;dilate&#x27;,
                          ERODE: &#x27;erode&#x27;,
                          BLUR: &#x27;blur&#x27;,
                        
                          // TYPOGRAPHY
                          NORMAL: &#x27;normal&#x27;,
                          ITALIC: &#x27;italic&#x27;,
                          BOLD: &#x27;bold&#x27;,
                        
                          // TYPOGRAPHY-INTERNAL
                          _DEFAULT_TEXT_FILL: &#x27;#000000&#x27;,
                          _DEFAULT_LEADMULT: 1.25,
                          _CTX_MIDDLE: &#x27;middle&#x27;,
                        
                          // VERTICES
                          LINEAR: &#x27;linear&#x27;,
                          QUADRATIC: &#x27;quadratic&#x27;,
                          BEZIER: &#x27;bezier&#x27;,
                          CURVE: &#x27;curve&#x27;,
                        
                          // DEFAULTS
                          _DEFAULT_STROKE: &#x27;#000000&#x27;,
                          _DEFAULT_FILL: &#x27;#FFFFFF&#x27;
                        
                        };
                        
                        },{}],48:[function(_dereq_,module,exports){
                        /**
                         * @module Structure
                         * @submodule Structure
                         * @for p5
                         * @requires constants
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        _dereq_(&#x27;./shim&#x27;);
                        
                        // Core needs the PVariables object
                        var constants = _dereq_(&#x27;./constants&#x27;);
                        
                        /**
                         * This is the p5 instance constructor.
                         *
                         * A p5 instance holds all the properties and methods related to
                         * a p5 sketch.  It expects an incoming sketch closure and it can also
                         * take an optional node parameter for attaching the generated p5 canvas
                         * to a node.  The sketch closure takes the newly created p5 instance as
                         * its sole argument and may optionally set preload(), setup(), and/or
                         * draw() properties on it for running a sketch.
                         *
                         * A p5 sketch can run in &quot;global&quot; or &quot;instance&quot; mode:
                         * &quot;global&quot;   - all properties and methods are attached to the window
                         * &quot;instance&quot; - all properties and methods are bound to this p5 object
                         *
                         * @param  {Function}    sketch a closure that can set optional preload(),
                         *                              setup(), and/or draw() properties on the
                         *                              given p5 instance
                         * @param  {HTMLElement|boolean} node element to attach canvas to, if a
                         *                                    boolean is passed in use it as sync
                         * @param  {boolean}     [sync] start synchronously (optional)
                         * @return {p5}                 a p5 instance
                         */
                        var p5 = function(sketch, node, sync) {
                        
                          if (arguments.length === 2 &amp;&amp; typeof node === &#x27;boolean&#x27;) {
                            sync = node;
                            node = undefined;
                          }
                        
                          //////////////////////////////////////////////
                          // PUBLIC p5 PROPERTIES AND METHODS
                          //////////////////////////////////////////////
                        
                        
                          /**
                           * Called directly before setup(), the preload() function is used to handle
                           * asynchronous loading of external files. If a preload function is
                           * defined, setup() will wait until any load calls within have finished.
                           * Nothing besides load calls should be inside preload (loadImage,
                           * loadJSON, loadFont, loadStrings, etc).
                           *
                           * @method preload
                           * @example
                           * &lt;div&gt;&lt;code&gt;
                           * var img;
                           * var c;
                           * function preload() {  // preload() runs once
                           *   img = loadImage(&#x27;assets/laDefense.jpg&#x27;);
                           * }
                           *
                           * function setup() {  // setup() waits until preload() is done
                           *   img.loadPixels();
                           *   // get color of middle pixel
                           *   c = img.get(img.width/2, img.height/2);
                           * }
                           *
                           * function draw() {
                           *   background(c);
                           *   image(img, 25, 25, 50, 50);
                           * }
                           * &lt;/code&gt;&lt;/div&gt;
                           */
                        
                          /**
                           * The setup() function is called once when the program starts. It&#x27;s used to
                           * define initial environment properties such as screen size and background
                           * color and to load media such as images and fonts as the program starts.
                           * There can only be one setup() function for each program and it shouldn&#x27;t
                           * be called again after its initial execution.
                           * &lt;br&gt;&lt;br&gt;
                           * Note: Variables declared within setup() are not accessible within other
                           * functions, including draw().
                           *
                           * @method setup
                           * @example
                           * &lt;div&gt;&lt;code&gt;
                           * var a = 0;
                           *
                           * function setup() {
                           *   background(0);
                           *   noStroke();
                           *   fill(102);
                           * }
                           *
                           * function draw() {
                           *   rect(a++%width, 10, 2, 80);
                           * }
                           * &lt;/code&gt;&lt;/div&gt;
                           */
                        
                          /**
                           * Called directly after setup(), the draw() function continuously executes
                           * the lines of code contained inside its block until the program is stopped
                           * or noLoop() is called. draw() is called automatically and should never be
                           * called explicitly.
                           * &lt;br&gt;&lt;br&gt;
                           * It should always be controlled with noLoop(), redraw() and loop(). After
                           * noLoop() stops the code in draw() from executing, redraw() causes the
                           * code inside draw() to execute once, and loop() will cause the code
                           * inside draw() to resume executing continuously.
                           * &lt;br&gt;&lt;br&gt;
                           * The number of times draw() executes in each second may be controlled with
                           * the frameRate() function.
                           * &lt;br&gt;&lt;br&gt;
                           * There can only be one draw() function for each sketch, and draw() must
                           * exist if you want the code to run continuously, or to process events such
                           * as mousePressed(). Sometimes, you might have an empty call to draw() in
                           * your program, as shown in the above example.
                           *
                           * @method draw
                           * @example
                           * &lt;div&gt;&lt;code&gt;
                           * var yPos = 0;
                           * function setup() {  // setup() runs once
                           *   frameRate(30);
                           * }
                           * function draw() {  // draw() loops forever, until stopped
                           *   background(204);
                           *   yPos = yPos - 1;
                           *   if (yPos &lt; 0) {
                           *     yPos = height;
                           *   }
                           *   line(0, yPos, width, yPos);
                           * }
                           * &lt;/code&gt;&lt;/div&gt;
                           */
                        
                        
                          //////////////////////////////////////////////
                          // PRIVATE p5 PROPERTIES AND METHODS
                          //////////////////////////////////////////////
                        
                          this._setupDone = false;
                          // for handling hidpi
                          this._pixelDensity = Math.ceil(window.devicePixelRatio) || 1;
                          this._userNode = node;
                          this._curElement = null;
                          this._elements = [];
                          this._requestAnimId = 0;
                          this._preloadCount = 0;
                          this._isGlobal = false;
                          this._loop = true;
                          this._styles = [];
                          this._defaultCanvasSize = {
                            width: 100,
                            height: 100
                          };
                          this._events = { // keep track of user-events for unregistering later
                            &#x27;mousemove&#x27;: null,
                            &#x27;mousedown&#x27;: null,
                            &#x27;mouseup&#x27;: null,
                            &#x27;dragend&#x27;: null,
                            &#x27;dragover&#x27;: null,
                            &#x27;click&#x27;: null,
                            &#x27;mouseover&#x27;: null,
                            &#x27;mouseout&#x27;: null,
                            &#x27;keydown&#x27;: null,
                            &#x27;keyup&#x27;: null,
                            &#x27;keypress&#x27;: null,
                            &#x27;touchstart&#x27;: null,
                            &#x27;touchmove&#x27;: null,
                            &#x27;touchend&#x27;: null,
                            &#x27;resize&#x27;: null,
                            &#x27;blur&#x27;: null
                          };
                        
                          if (window.DeviceOrientationEvent) {
                            this._events.deviceorientation = null;
                          }
                          if (window.DeviceMotionEvent &amp;&amp; !window._isNodeWebkit) {
                            this._events.devicemotion = null;
                          }
                        
                          this._events.wheel = null;
                        
                        
                          this._loadingScreenId = &#x27;p5_loading&#x27;;
                        
                          this._start = function () {
                            // Find node if id given
                            if (this._userNode) {
                              if (typeof this._userNode === &#x27;string&#x27;) {
                                this._userNode = document.getElementById(this._userNode);
                              }
                            }
                        
                            // Always create a default canvas.
                            // Later on if the user calls createCanvas, this default one
                            // will be replaced
                            this.createCanvas(
                              this._defaultCanvasSize.width,
                              this._defaultCanvasSize.height,
                              &#x27;p2d&#x27;,
                              true
                            );
                        
                            var userPreload = this.preload || window.preload; // look for &quot;preload&quot;
                            if (userPreload) {
                        
                              // Setup loading screen
                              // Set loading scfeen into dom if not present
                              // Otherwise displays and removes user provided loading screen
                              var loadingScreen = document.getElementById(this._loadingScreenId);
                              if(!loadingScreen){
                                loadingScreen = document.createElement(&#x27;div&#x27;);
                                loadingScreen.innerHTML = &#x27;Loading...&#x27;;
                                loadingScreen.style.position = &#x27;absolute&#x27;;
                                loadingScreen.id = this._loadingScreenId;
                                var node = this._userNode || document.body;
                                node.appendChild(loadingScreen);
                              }
                              // var methods = this._preloadMethods;
                              for (var method in this._preloadMethods){
                                // default to p5 if no object defined
                                this._preloadMethods[method] = this._preloadMethods[method] || p5;
                                var obj = this._preloadMethods[method];
                                //it&#x27;s p5, check if it&#x27;s global or instance
                                if (obj === p5.prototype || obj === p5){
                                  obj = this._isGlobal ? window : this;
                                }
                                this._registeredPreloadMethods[method] = obj[method];
                                obj[method] = this._wrapPreload(obj, method);
                              }
                        
                              userPreload();
                              this._runIfPreloadsAreDone();
                            } else {
                              this._setup();
                              this._runFrames();
                              this._draw();
                            }
                          }.bind(this);
                        
                          this._runIfPreloadsAreDone = function(){
                            var context = this._isGlobal ? window : this;
                            if (context._preloadCount === 0) {
                              var loadingScreen = document.getElementById(context._loadingScreenId);
                              if (loadingScreen) {
                                loadingScreen.parentNode.removeChild(loadingScreen);
                              }
                              context._setup();
                              context._runFrames();
                              context._draw();
                            }
                          };
                        
                          this._decrementPreload = function(){
                            var context = this._isGlobal ? window : this;
                            context._setProperty(&#x27;_preloadCount&#x27;, context._preloadCount - 1);
                            context._runIfPreloadsAreDone();
                          };
                        
                          this._wrapPreload = function(obj, fnName){
                            return function(){
                              //increment counter
                              this._incrementPreload();
                              //call original function
                              var args = Array.prototype.slice.call(arguments);
                              args.push(this._decrementPreload.bind(this));
                              return this._registeredPreloadMethods[fnName].apply(obj, args);
                            }.bind(this);
                          };
                        
                          this._incrementPreload = function(){
                            var context = this._isGlobal ? window : this;
                            context._setProperty(&#x27;_preloadCount&#x27;, context._preloadCount + 1);
                          };
                        
                          this._setup = function() {
                        
                            // return preload functions to their normal vals if switched by preload
                            var context = this._isGlobal ? window : this;
                            if (typeof context.preload === &#x27;function&#x27;) {
                              for (var f in this._preloadMethods) {
                                context[f] = this._preloadMethods[f][f];
                                if (context[f] &amp;&amp; this) {
                                  context[f] = context[f].bind(this);
                                }
                              }
                            }
                        
                            // Short-circuit on this, in case someone used the library in &quot;global&quot;
                            // mode earlier
                            if (typeof context.setup === &#x27;function&#x27;) {
                              context.setup();
                            }
                        
                            // // unhide hidden canvas that was created
                            // this.canvas.style.visibility = &#x27;&#x27;;
                            // this.canvas.className = this.canvas.className.replace(&#x27;p5_hidden&#x27;, &#x27;&#x27;);
                        
                            // unhide any hidden canvases that were created
                            var reg = new RegExp(/(^|\s)p5_hidden(?!\S)/g);
                            var canvases = document.getElementsByClassName(&#x27;p5_hidden&#x27;);
                            for (var i = 0; i &lt; canvases.length; i++) {
                              var k = canvases[i];
                              k.style.visibility = &#x27;&#x27;;
                              k.className = k.className.replace(reg, &#x27;&#x27;);
                            }
                            this._setupDone = true;
                        
                          }.bind(this);
                        
                          this._draw = function () {
                            var now = window.performance.now();
                            var time_since_last = now - this._lastFrameTime;
                            var target_time_between_frames = 1000 / this._targetFrameRate;
                        
                            // only draw if we really need to; don&#x27;t overextend the browser.
                            // draw if we&#x27;re within 5ms of when our next frame should paint
                            // (this will prevent us from giving up opportunities to draw
                            // again when it&#x27;s really about time for us to do so). fixes an
                            // issue where the frameRate is too low if our refresh loop isn&#x27;t
                            // in sync with the browser. note that we have to draw once even
                            // if looping is off, so we bypass the time delay if that
                            // is the case.
                            var epsilon = 5;
                            if (!this._loop ||
                                time_since_last &gt;= target_time_between_frames - epsilon) {
                        
                              //mandatory update values(matrixs and stack) for 3d
                              if(this._renderer.isP3D){
                                this._renderer._update();
                              }
                        
                              this._setProperty(&#x27;frameCount&#x27;, this.frameCount + 1);
                              this._updateMouseCoords();
                              this._updateTouchCoords();
                              this.redraw();
                              this._frameRate = 1000.0/(now - this._lastFrameTime);
                              this._lastFrameTime = now;
                            }
                        
                            // get notified the next time the browser gives us
                            // an opportunity to draw.
                            if (this._loop) {
                              this._requestAnimId = window.requestAnimationFrame(this._draw);
                            }
                          }.bind(this);
                        
                          this._runFrames = function() {
                            if (this._updateInterval) {
                              clearInterval(this._updateInterval);
                            }
                          }.bind(this);
                        
                          this._setProperty = function(prop, value) {
                            this[prop] = value;
                            if (this._isGlobal) {
                              window[prop] = value;
                            }
                          }.bind(this);
                        
                          /**
                           * Removes the entire p5 sketch. This will remove the canvas and any
                           * elements created by p5.js. It will also stop the draw loop and unbind
                           * any properties or methods from the window global scope. It will
                           * leave a variable p5 in case you wanted to create a new p5 sketch.
                           * If you like, you can set p5 = null to erase it.
                           * @method remove
                           * @example
                           * &lt;div class=&#x27;norender&#x27;&gt;&lt;code&gt;
                           * function draw() {
                           *   ellipse(50, 50, 10, 10);
                           * }
                           *
                           * function mousePressed() {
                           *   remove(); // remove whole sketch on mouse press
                           * }
                           * &lt;/code&gt;&lt;/div&gt;
                           */
                          this.remove = function() {
                            if (this._curElement) {
                        
                              // stop draw
                              this._loop = false;
                              if (this._requestAnimId) {
                                window.cancelAnimationFrame(this._requestAnimId);
                              }
                        
                              // unregister events sketch-wide
                              for (var ev in this._events) {
                                window.removeEventListener(ev, this._events[ev]);
                              }
                        
                              // remove DOM elements created by p5, and listeners
                              for (var i=0; i&lt;this._elements.length; i++) {
                                var e = this._elements[i];
                                if (e.elt.parentNode) {
                                  e.elt.parentNode.removeChild(e.elt);
                                }
                                for (var elt_ev in e._events) {
                                  e.elt.removeEventListener(elt_ev, e._events[elt_ev]);
                                }
                              }
                        
                              // call any registered remove functions
                              var self = this;
                              this._registeredMethods.remove.forEach(function (f) {
                                if (typeof(f) !== &#x27;undefined&#x27;) {
                                  f.call(self);
                                }
                              });
                        
                              // remove window bound properties and methods
                              if (this._isGlobal) {
                                for (var p in p5.prototype) {
                                  try {
                                    delete window[p];
                                  } catch (x) {
                                    window[p] = undefined;
                                  }
                                }
                                for (var p2 in this) {
                                  if (this.hasOwnProperty(p2)) {
                                    try {
                                      delete window[p2];
                                    } catch (x) {
                                      window[p2] = undefined;
                                    }
                                  }
                                }
                              }
                            }
                            // window.p5 = undefined;
                          }.bind(this);
                        
                        
                          // attach constants to p5 instance
                          for (var k in constants) {
                            p5.prototype[k] = constants[k];
                          }
                        
                          // If the user has created a global setup or draw function,
                          // assume &quot;global&quot; mode and make everything global (i.e. on the window)
                          if (!sketch) {
                            this._isGlobal = true;
                            // Loop through methods on the prototype and attach them to the window
                            for (var p in p5.prototype) {
                              if(typeof p5.prototype[p] === &#x27;function&#x27;) {
                                var ev = p.substring(2);
                                if (!this._events.hasOwnProperty(ev)) {
                                  window[p] = p5.prototype[p].bind(this);
                                }
                              } else {
                                window[p] = p5.prototype[p];
                              }
                            }
                            // Attach its properties to the window
                            for (var p2 in this) {
                              if (this.hasOwnProperty(p2)) {
                                window[p2] = this[p2];
                              }
                            }
                        
                          } else {
                            // Else, the user has passed in a sketch closure that may set
                            // user-provided &#x27;setup&#x27;, &#x27;draw&#x27;, etc. properties on this instance of p5
                            sketch(this);
                          }
                        
                          // Bind events to window (not using container div bc key events don&#x27;t work)
                        
                          for (var e in this._events) {
                            var f = this[&#x27;_on&#x27;+e];
                            if (f) {
                              var m = f.bind(this);
                              window.addEventListener(e, m);
                              this._events[e] = m;
                            }
                          }
                        
                          var focusHandler = function() {
                            this._setProperty(&#x27;focused&#x27;, true);
                          }.bind(this);
                          var blurHandler = function() {
                            this._setProperty(&#x27;focused&#x27;, false);
                          }.bind(this);
                          window.addEventListener(&#x27;focus&#x27;, focusHandler);
                          window.addEventListener(&#x27;blur&#x27;, blurHandler);
                          this.registerMethod(&#x27;remove&#x27;, function() {
                            window.removeEventListener(&#x27;focus&#x27;, focusHandler);
                            window.removeEventListener(&#x27;blur&#x27;, blurHandler);
                          });
                        
                          // TODO: ???
                        
                          if (sync) {
                            this._start();
                          } else {
                            if (document.readyState === &#x27;complete&#x27;) {
                              this._start();
                            } else {
                              window.addEventListener(&#x27;load&#x27;, this._start.bind(this), false);
                            }
                          }
                        };
                        
                        
                        // functions that cause preload to wait
                        // more can be added by using registerPreloadMethod(func)
                        p5.prototype._preloadMethods = {
                          loadJSON: p5.prototype,
                          loadImage: p5.prototype,
                          loadStrings: p5.prototype,
                          loadXML: p5.prototype,
                          loadShape: p5.prototype,
                          loadTable: p5.prototype,
                          loadFont: p5.prototype
                        };
                        
                        p5.prototype._registeredMethods = { pre: [], post: [], remove: [] };
                        
                        p5.prototype._registeredPreloadMethods = {};
                        
                        p5.prototype.registerPreloadMethod = function(fnString, obj) {
                          // obj = obj || p5.prototype;
                          if (!p5.prototype._preloadMethods.hasOwnProperty(fnString)) {
                            p5.prototype._preloadMethods[fnString] = obj;
                          }
                        };
                        
                        p5.prototype.registerMethod = function(name, m) {
                          if (!p5.prototype._registeredMethods.hasOwnProperty(name)) {
                            p5.prototype._registeredMethods[name] = [];
                          }
                          p5.prototype._registeredMethods[name].push(m);
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;./constants&quot;:47,&quot;./shim&quot;:57}],49:[function(_dereq_,module,exports){
                        /**
                         * @module Shape
                         * @submodule Curves
                         * @for p5
                         * @requires core
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;./core&#x27;);
                        
                        _dereq_(&#x27;./error_helpers&#x27;);
                        
                        var bezierDetail = 20;
                        var curveDetail = 20;
                        
                        /**
                         * Draws a cubic Bezier curve on the screen. These curves are defined by a
                         * series of anchor and control points. The first two parameters specify
                         * the first anchor point and the last two parameters specify the other
                         * anchor point, which become the first and last points on the curve. The
                         * middle parameters specify the two control points which define the shape
                         * of the curve. Approximately speaking, control points &quot;pull&quot; the curve
                         * towards them.&lt;br /&gt;&lt;br /&gt;Bezier curves were developed by French
                         * automotive engineer Pierre Bezier, and are commonly used in computer
                         * graphics to define gently sloping curves. See also curve().
                         *
                         * @method bezier
                         * @param  {Number} x1 x-coordinate for the first anchor point
                         * @param  {Number} y1 y-coordinate for the first anchor point
                         * @param  {Number} x2 x-coordinate for the first control point
                         * @param  {Number} y2 y-coordinate for the first control point
                         * @param  {Number} x3 x-coordinate for the second control point
                         * @param  {Number} y3 y-coordinate for the second control point
                         * @param  {Number} x4 x-coordinate for the second anchor point
                         * @param  {Number} y4 y-coordinate for the second anchor point
                         * @return {Object}    the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noFill();
                         * stroke(255, 102, 0);
                         * line(85, 20, 10, 10);
                         * line(90, 90, 15, 80);
                         * stroke(0, 0, 0);
                         * bezier(85, 20, 10, 10, 90, 90, 15, 80);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.bezier = function(x1, y1, x2, y2, x3, y3, x4, y4) {
                          var args = new Array(arguments.length);
                          for (var i = 0; i &lt; args.length; ++i) {
                            args[i] = arguments[i];
                          }
                          this._validateParameters(
                            &#x27;bezier&#x27;,
                            args,
                            [ &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;,
                              &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27; ]
                          );
                        
                          if (!this._renderer._doStroke) {
                            return this;
                          }
                          this._renderer.bezier(x1, y1, x2, y2, x3, y3, x4, y4);
                          return this;
                        };
                        
                        /**
                         * Sets the resolution at which Beziers display.
                         *
                         * The default value is 20.
                         *
                         * @param {Number} detail resolution of the curves
                         * @return {Object} the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * background(204);
                         * bezierDetail(50);
                         * bezier(85, 20, 10, 10, 90, 90, 15, 80);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.bezierDetail = function(d) {
                          bezierDetail = d;
                          return this;
                        };
                        
                        /**
                         * Evaluates the Bezier at position t for points a, b, c, d.
                         * The parameters a and d are the first and last points
                         * on the curve, and b and c are the control points.
                         * The final parameter t varies between 0 and 1.
                         * This can be done once with the x coordinates and a second time
                         * with the y coordinates to get the location of a bezier curve at t.
                         *
                         * @method bezierPoint
                         * @param {Number} a coordinate of first point on the curve
                         * @param {Number} b coordinate of first control point
                         * @param {Number} c coordinate of second control point
                         * @param {Number} d coordinate of second point on the curve
                         * @param {Number} t value between 0 and 1
                         * @return {Number} the value of the Bezier at position t
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noFill();
                         * x1 = 85, x2 = 10, x3 = 90, x4 = 15;
                         * y1 = 20, y2 = 10, y3 = 90, y4 = 80;
                         * bezier(x1, y1, x2, y2, x3, y3, x4, y4);
                         * fill(255);
                         * steps = 10;
                         * for (i = 0; i &lt;= steps; i++) {
                         *   t = i / steps;
                         *   x = bezierPoint(x1, x2, x3, x4, t);
                         *   y = bezierPoint(y1, y2, y3, y4, t);
                         *   ellipse(x, y, 5, 5);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.bezierPoint = function(a, b, c, d, t) {
                          var adjustedT = 1-t;
                          return Math.pow(adjustedT,3)*a +
                           3*(Math.pow(adjustedT,2))*t*b +
                           3*adjustedT*Math.pow(t,2)*c +
                           Math.pow(t,3)*d;
                        };
                        
                        /**
                         * Evaluates the tangent to the Bezier at position t for points a, b, c, d.
                         * The parameters a and d are the first and last points
                         * on the curve, and b and c are the control points.
                         * The final parameter t varies between 0 and 1.
                         *
                         * @method bezierTangent
                         * @param {Number} a coordinate of first point on the curve
                         * @param {Number} b coordinate of first control point
                         * @param {Number} c coordinate of second control point
                         * @param {Number} d coordinate of second point on the curve
                         * @param {Number} t value between 0 and 1
                         * @return {Number} the tangent at position t
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noFill();
                         * bezier(85, 20, 10, 10, 90, 90, 15, 80);
                         * steps = 6;
                         * fill(255);
                         * for (i = 0; i &lt;= steps; i++) {
                         *   t = i / steps;
                         *   // Get the location of the point
                         *   x = bezierPoint(85, 10, 90, 15, t);
                         *   y = bezierPoint(20, 10, 90, 80, t);
                         *   // Get the tangent points
                         *   tx = bezierTangent(85, 10, 90, 15, t);
                         *   ty = bezierTangent(20, 10, 90, 80, t);
                         *   // Calculate an angle from the tangent points
                         *   a = atan2(ty, tx);
                         *   a += PI;
                         *   stroke(255, 102, 0);
                         *   line(x, y, cos(a)*30 + x, sin(a)*30 + y);
                         *   // The following line of code makes a line
                         *   // inverse of the above line
                         *   //line(x, y, cos(a)*-30 + x, sin(a)*-30 + y);
                         *   stroke(0);
                         *   ellipse(x, y, 5, 5);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noFill();
                         * bezier(85, 20, 10, 10, 90, 90, 15, 80);
                         * stroke(255, 102, 0);
                         * steps = 16;
                         * for (i = 0; i &lt;= steps; i++) {
                         *   t = i / steps;
                         *   x = bezierPoint(85, 10, 90, 15, t);
                         *   y = bezierPoint(20, 10, 90, 80, t);
                         *   tx = bezierTangent(85, 10, 90, 15, t);
                         *   ty = bezierTangent(20, 10, 90, 80, t);
                         *   a = atan2(ty, tx);
                         *   a -= HALF_PI;
                         *   line(x, y, cos(a)*8 + x, sin(a)*8 + y);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.bezierTangent = function(a, b, c, d, t) {
                          var adjustedT = 1-t;
                          return 3*d*Math.pow(t,2) -
                           3*c*Math.pow(t,2) +
                           6*c*adjustedT*t -
                           6*b*adjustedT*t +
                           3*b*Math.pow(adjustedT,2) -
                           3*a*Math.pow(adjustedT,2);
                        };
                        
                        /**
                         * Draws a curved line on the screen between two points, given as the
                         * middle four parameters. The first two parameters are a control point, as
                         * if the curve came from this point even though it&#x27;s not drawn. The last
                         * two parameters similarly describe the other control point. &lt;br /&gt;&lt;br /&gt;
                         * Longer curves can be created by putting a series of curve() functions
                         * together or using curveVertex(). An additional function called
                         * curveTightness() provides control for the visual quality of the curve.
                         * The curve() function is an implementation of Catmull-Rom splines.
                         *
                         * @method curve
                         * @param  {Number} x1 x-coordinate for the beginning control point
                         * @param  {Number} y1 y-coordinate for the beginning control point
                         * @param  {Number} x2 x-coordinate for the first point
                         * @param  {Number} y2 y-coordinate for the first point
                         * @param  {Number} x3 x-coordinate for the second point
                         * @param  {Number} y3 y-coordinate for the second point
                         * @param  {Number} x4 x-coordinate for the ending control point
                         * @param  {Number} y4 y-coordinate for the ending control point
                         * @return {Object}    the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noFill();
                         * stroke(255, 102, 0);
                         * curve(5, 26, 5, 26, 73, 24, 73, 61);
                         * stroke(0);
                         * curve(5, 26, 73, 24, 73, 61, 15, 65);
                         * stroke(255, 102, 0);
                         * curve(73, 24, 73, 61, 15, 65, 15, 65);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Define the curve points as JavaScript objects
                         * p1 = {x: 5, y: 26}, p2 = {x: 73, y: 24}
                         * p3 = {x: 73, y: 61}, p4 = {x: 15, y: 65}
                         * noFill();
                         * stroke(255, 102, 0);
                         * curve(p1.x, p1.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y)
                         * stroke(0);
                         * curve(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y)
                         * stroke(255, 102, 0);
                         * curve(p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, p4.x, p4.y)
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.curve = function(x1, y1, x2, y2, x3, y3, x4, y4) {
                          var args = new Array(arguments.length);
                          for (var i = 0; i &lt; args.length; ++i) {
                            args[i] = arguments[i];
                          }
                          this._validateParameters(
                            &#x27;curve&#x27;,
                            args,
                            [ &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;,
                              &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27; ]
                          );
                        
                          if (!this._renderer._doStroke) {
                            return;
                          }
                          this._renderer.curve(x1, y1, x2, y2, x3, y3, x4, y4);
                          return this;
                        };
                        
                        /**
                         * Sets the resolution at which curves display.
                         *
                         * The default value is 20.
                         *
                         * @param {Number} resolution of the curves
                         * @return {Object} the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * background(204);
                         * curveDetail(20);
                         * curve(5, 26, 5, 26, 73, 24, 73, 61);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.curveDetail = function(d) {
                          curveDetail = d;
                          return this;
                        };
                        
                        /**
                         * Modifies the quality of forms created with curve() and curveVertex().
                         * The parameter tightness determines how the curve fits to the vertex
                         * points. The value 0.0 is the default value for tightness (this value
                         * defines the curves to be Catmull-Rom splines) and the value 1.0 connects
                         * all the points with straight lines. Values within the range -5.0 and 5.0
                         * will deform the curves but will leave them recognizable and as values
                         * increase in magnitude, they will continue to deform.
                         *
                         * @method curveTightness
                         * @param {Number} amount of deformation from the original vertices
                         * @return {Object} the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Move the mouse left and right to see the curve change
                         *
                         * function setup() {
                         *   createCanvas(100, 100);
                         *   noFill();
                         * }
                         *
                         * function draw() {
                         *   background(204);
                         *   var t = map(mouseX, 0, width, -5, 5);
                         *   curveTightness(t);
                         *   beginShape();
                         *   curveVertex(10, 26);
                         *   curveVertex(10, 26);
                         *   curveVertex(83, 24);
                         *   curveVertex(83, 61);
                         *   curveVertex(25, 65);
                         *   curveVertex(25, 65);
                         *   endShape();
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.curveTightness = function (t) {
                          this._renderer._curveTightness = t;
                        };
                        
                        /**
                         * Evaluates the curve at position t for points a, b, c, d.
                         * The parameter t varies between 0 and 1, a and d are points
                         * on the curve, and b and c are the control points.
                         * This can be done once with the x coordinates and a second time
                         * with the y coordinates to get the location of a curve at t.
                         *
                         * @method curvePoint
                         * @param {Number} a coordinate of first point on the curve
                         * @param {Number} b coordinate of first control point
                         * @param {Number} c coordinate of second control point
                         * @param {Number} d coordinate of second point on the curve
                         * @param {Number} t value between 0 and 1
                         * @return {Number} bezier value at position t
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noFill();
                         * curve(5, 26, 5, 26, 73, 24, 73, 61);
                         * curve(5, 26, 73, 24, 73, 61, 15, 65);
                         * fill(255);
                         * ellipseMode(CENTER);
                         * steps = 6;
                         * for (i = 0; i &lt;= steps; i++) {
                         *   t = i / steps;
                         *   x = curvePoint(5, 5, 73, 73, t);
                         *   y = curvePoint(26, 26, 24, 61, t);
                         *   ellipse(x, y, 5, 5);
                         *   x = curvePoint(5, 73, 73, 15, t);
                         *   y = curvePoint(26, 24, 61, 65, t);
                         *   ellipse(x, y, 5, 5);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.curvePoint = function(a, b, c, d, t) {
                          var t3 = t*t*t,
                            t2 = t*t,
                            f1 = -0.5 * t3 + t2 - 0.5 * t,
                            f2 = 1.5 * t3 - 2.5 * t2 + 1.0,
                            f3 = -1.5 * t3 + 2.0 * t2 + 0.5 * t,
                            f4 = 0.5 * t3 - 0.5 * t2;
                          return a*f1 + b*f2 + c*f3 + d*f4;
                        };
                        
                        /**
                         * Evaluates the tangent to the curve at position t for points a, b, c, d.
                         * The parameter t varies between 0 and 1, a and d are points on the curve,
                         * and b and c are the control points
                         *
                         * @method curveTangent
                         * @param {Number} a coordinate of first point on the curve
                         * @param {Number} b coordinate of first control point
                         * @param {Number} c coordinate of second control point
                         * @param {Number} d coordinate of second point on the curve
                         * @param {Number} t value between 0 and 1
                         * @return {Number} the tangent at position t
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noFill();
                         * curve(5, 26, 73, 24, 73, 61, 15, 65);
                         * steps = 6;
                         * for (i = 0; i &lt;= steps; i++) {
                         *   t = i / steps;
                         *   x = curvePoint(5, 73, 73, 15, t);
                         *   y = curvePoint(26, 24, 61, 65, t);
                         *   //ellipse(x, y, 5, 5);
                         *   tx = curveTangent(5, 73, 73, 15, t);
                         *   ty = curveTangent(26, 24, 61, 65, t);
                         *   a = atan2(ty, tx);
                         *   a -= PI/2.0;
                         *   line(x, y, cos(a)*8 + x, sin(a)*8 + y);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.curveTangent = function(a, b,c, d, t) {
                          var t2 = t*t,
                            f1 = (-3*t2)/2 + 2*t - 0.5,
                            f2 = (9*t2)/2 - 5*t,
                            f3 = (-9*t2)/2 + 4*t + 0.5,
                            f4 = (3*t2)/2 - t;
                          return a*f1 + b*f2 + c*f3 + d*f4;
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;./core&quot;:48,&quot;./error_helpers&quot;:51}],50:[function(_dereq_,module,exports){
                        /**
                         * @module Environment
                         * @submodule Environment
                         * @for p5
                         * @requires core
                         * @requires constants
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;./core&#x27;);
                        var C = _dereq_(&#x27;./constants&#x27;);
                        
                        var standardCursors = [C.ARROW, C.CROSS, C.HAND, C.MOVE, C.TEXT, C.WAIT];
                        
                        p5.prototype._frameRate = 0;
                        p5.prototype._lastFrameTime = window.performance.now();
                        p5.prototype._targetFrameRate = 60;
                        
                        
                        if (window.console &amp;&amp; console.log) {
                          /**
                           * The print() function writes to the console area of your browser.
                           * This function is often helpful for looking at the data a program is
                           * producing. This function creates a new line of text for each call to
                           * the function. Individual elements can be
                           * separated with quotes (&quot;&quot;) and joined with the addition operator (+).
                           * &lt;br&gt;&lt;br&gt;
                           * While print() is similar to console.log(), it does not directly map to
                           * it in order to simulate easier to understand behavior than
                           * console.log(). Due to this, it is slower. For fastest results, use
                           * console.log().
                           *
                           * @method print
                           * @param {Any} contents any combination of Number, String, Object, Boolean,
                           *                       Array to print
                           * @example
                           * &lt;div&gt;&lt;code class=&#x27;norender&#x27;&gt;
                           * var x = 10;
                           * print(&quot;The value of x is &quot; + x);
                           * // prints &quot;The value of x is 10&quot;
                           * &lt;/code&gt;&lt;/div&gt;
                           */
                          // Converts passed args into a string and then parses that string to
                          // simulate synchronous behavior. This is a hack and is gross.
                          // Since this will not work on all objects, particularly circular
                          // structures, simply console.log() on error.
                          p5.prototype.print = function(args) {
                            try {
                              var newArgs = JSON.parse(JSON.stringify(args));
                              console.log(newArgs);
                            } catch(err) {
                              console.log(args);
                            }
                          };
                        } else {
                          p5.prototype.print = function() {};
                        }
                        
                        p5.prototype.println = p5.prototype.print;
                        
                        /**
                         * The system variable frameCount contains the number of frames that have
                         * been displayed since the program started. Inside setup() the value is 0,
                         * after the first iteration of draw it is 1, etc.
                         *
                         * @property frameCount
                         * @example
                         *   &lt;div&gt;&lt;code&gt;
                         *     function setup() {
                         *       frameRate(30);
                         *       textSize(20);
                         *       textSize(30);
                         *       textAlign(CENTER);
                         *     }
                         *
                         *     function draw() {
                         *       background(200);
                         *       text(frameCount, width/2, height/2);
                         *     }
                         *   &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.frameCount = 0;
                        
                        /**
                         * Confirms if the window a p5.js program is in is &quot;focused,&quot; meaning that
                         * the sketch will accept mouse or keyboard input. This variable is
                         * &quot;true&quot; if the window is focused and &quot;false&quot; if not.
                         *
                         * @property focused
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * // To demonstrate, put two windows side by side.
                         * // Click on the window that the p5 sketch isn&#x27;t in!
                         * function draw() {
                         *   if (focused) {  // or &quot;if (focused === true)&quot;
                         *     noStroke();
                         *     fill(0, 200, 0);
                         *     ellipse(25, 25, 50, 50);
                         *   } else {
                         *     stroke(200,0,0);
                         *     line(0, 0, 100, 100);
                         *     line(100, 0, 0, 100);
                         *   }
                         * }
                         *
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.focused = (document.hasFocus());
                        
                        /**
                         * Sets the cursor to a predefined symbol or an image, or makes it visible
                         * if already hidden. If you are trying to set an image as the cursor, the
                         * recommended size is 16x16 or 32x32 pixels. It is not possible to load an
                         * image as the cursor if you are exporting your program for the Web, and not
                         * all MODES work with all browsers. The values for parameters x and y must
                         * be less than the dimensions of the image.
                         *
                         * @method cursor
                         * @param {Number/Constant} type either ARROW, CROSS, HAND, MOVE, TEXT, or
                         *                               WAIT, or path for image
                         * @param {Number}          [x]  the horizontal active spot of the cursor
                         * @param {Number}          [y]  the vertical active spot of the cursor
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * // Move the mouse left and right across the image
                         * // to see the cursor change from a cross to a hand
                         * function draw() {
                         *   line(width/2, 0, width/2, height);
                         *   if (mouseX &lt; 50) {
                         *     cursor(CROSS);
                         *   } else {
                         *     cursor(HAND);
                         *   }
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.cursor = function(type, x, y) {
                          var cursor = &#x27;auto&#x27;;
                          var canvas = this._curElement.elt;
                          if (standardCursors.indexOf(type) &gt; -1) {
                            // Standard css cursor
                            cursor = type;
                          } else if (typeof type === &#x27;string&#x27;) {
                            var coords = &#x27;&#x27;;
                            if (x &amp;&amp; y &amp;&amp; (typeof x === &#x27;number&#x27; &amp;&amp; typeof y === &#x27;number&#x27;)) {
                              // Note that x and y values must be unit-less positive integers &lt; 32
                              // https://developer.mozilla.org/en-US/docs/Web/CSS/cursor
                              coords = x + &#x27; &#x27; + y;
                            }
                            if (type.substring(0, 6) !== &#x27;http://&#x27;) {
                              // Image (absolute url)
                              cursor = &#x27;url(&#x27; + type + &#x27;) &#x27; + coords + &#x27;, auto&#x27;;
                            } else if (/\.(cur|jpg|jpeg|gif|png|CUR|JPG|JPEG|GIF|PNG)$/.test(type)) {
                              // Image file (relative path) - Separated for performance reasons
                              cursor = &#x27;url(&#x27; + type + &#x27;) &#x27; + coords + &#x27;, auto&#x27;;
                            } else {
                              // Any valid string for the css cursor property
                              cursor = type;
                            }
                          }
                          canvas.style.cursor = cursor;
                        };
                        
                        /**
                         * Specifies the number of frames to be displayed every second. For example,
                         * the function call frameRate(30) will attempt to refresh 30 times a second.
                         * If the processor is not fast enough to maintain the specified rate, the
                         * frame rate will not be achieved. Setting the frame rate within setup() is
                         * recommended. The default rate is 60 frames per second. This is the same as
                         * setFrameRate(val).
                         * &lt;br&gt;&lt;br&gt;
                         * Calling frameRate() with no arguments returns the current framerate. This
                         * is the same as getFrameRate().
                         * &lt;br&gt;&lt;br&gt;
                         * Calling frameRate() with arguments that are not of the type numbers
                         * or are non positive also returns current framerate.
                         *
                         * @method frameRate
                         * @param  {Number} [fps] number of frames to be displayed every second
                         * @return {Number}       current frameRate
                         * @example
                         *
                         * &lt;div&gt;&lt;code&gt;
                         * var rectX = 0;
                         * var fr = 30; //starting FPS
                         * var clr;
                         *
                         * function setup() {
                         *   background(200);
                         *   frameRate(fr); // Attempt to refresh at starting FPS
                         *   clr = color(255,0,0);
                         * }
                         *
                         * function draw() {
                         *   background(200);
                         *   rectX = rectX += 1; // Move Rectangle
                         *
                         *   if (rectX &gt;= width) { // If you go off screen.
                         *     if (fr == 30) {
                         *       clr = color(0,0,255);
                         *       fr = 10;
                         *       frameRate(fr); // make frameRate 10 FPS
                         *     } else {
                         *       clr = color(255,0,0);
                         *       fr = 30;
                         *       frameRate(fr); // make frameRate 30 FPS
                         *     }
                         *     rectX = 0;
                         *   }
                         *   fill(clr);
                         *   rect(rectX, 40, 20,20);
                         * }
                         * &lt;/div&gt;&lt;/code&gt;
                         *
                         */
                        p5.prototype.frameRate = function(fps) {
                          if (typeof fps !== &#x27;number&#x27; || fps &lt;= 0) {
                            return this._frameRate;
                          } else {
                            this._setProperty(&#x27;_targetFrameRate&#x27;, fps);
                            this._runFrames();
                            return this;
                          }
                        };
                        /**
                         * Returns the current framerate.
                         *
                         * @return {Number} current frameRate
                         */
                        p5.prototype.getFrameRate = function() {
                          return this.frameRate();
                        };
                        
                        /**
                         * Specifies the number of frames to be displayed every second. For example,
                         * the function call frameRate(30) will attempt to refresh 30 times a second.
                         * If the processor is not fast enough to maintain the specified rate, the
                         * frame rate will not be achieved. Setting the frame rate within setup() is
                         * recommended. The default rate is 60 frames per second.
                         *
                         * Calling frameRate() with no arguments returns the current framerate.
                         *
                         * @param {Number} [fps] number of frames to be displayed every second
                         */
                        p5.prototype.setFrameRate = function(fps) {
                          return this.frameRate(fps);
                        };
                        
                        /**
                         * Hides the cursor from view.
                         *
                         * @method noCursor
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * function setup() {
                         *   noCursor();
                         * }
                         *
                         * function draw() {
                         *   background(200);
                         *   ellipse(mouseX, mouseY, 10, 10);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.noCursor = function() {
                          this._curElement.elt.style.cursor = &#x27;none&#x27;;
                        };
                        
                        
                        /**
                         * System variable that stores the width of the entire screen display. This
                         * is used to run a full-screen program on any display size.
                         *
                         * @property displayWidth
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;&lt;code&gt;
                         * createCanvas(displayWidth, displayHeight);
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.displayWidth = screen.width;
                        
                        /**
                         * System variable that stores the height of the entire screen display. This
                         * is used to run a full-screen program on any display size.
                         *
                         * @property displayHeight
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;&lt;code&gt;
                         * createCanvas(displayWidth, displayHeight);
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.displayHeight = screen.height;
                        
                        /**
                         * System variable that stores the width of the inner window, it maps to
                         * window.innerWidth.
                         *
                         * @property windowWidth
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;&lt;code&gt;
                         * createCanvas(windowWidth, windowHeight);
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.windowWidth = window.innerWidth;
                        /**
                         * System variable that stores the height of the inner window, it maps to
                         * window.innerHeight.
                         *
                         * @property windowHeight
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;&lt;code&gt;
                         * createCanvas(windowWidth, windowHeight);
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.windowHeight = window.innerHeight;
                        
                        /**
                         * The windowResized() function is called once every time the browser window
                         * is resized. This is a good place to resize the canvas or do any other
                         * adjustements to accomodate the new window size.
                         *
                         * @method windowResized
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;&lt;code&gt;
                         * function setup() {
                         *   createCanvas(windowWidth, windowHeight);
                         * }
                         *
                         * function draw() {
                         *  background(0, 100, 200);
                         * }
                         *
                         * function windowResized() {
                         *   resizeCanvas(windowWidth, windowHeight);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype._onresize = function(e){
                          this._setProperty(&#x27;windowWidth&#x27;, window.innerWidth);
                          this._setProperty(&#x27;windowHeight&#x27;, window.innerHeight);
                          var context = this._isGlobal ? window : this;
                          var executeDefault;
                          if (typeof context.windowResized === &#x27;function&#x27;) {
                            executeDefault = context.windowResized(e);
                            if (executeDefault !== undefined &amp;&amp; !executeDefault) {
                              e.preventDefault();
                            }
                          }
                        };
                        
                        /**
                         * System variable that stores the width of the drawing canvas. This value
                         * is set by the first parameter of the createCanvas() function.
                         * For example, the function call createCanvas(320, 240) sets the width
                         * variable to the value 320. The value of width defaults to 100 if
                         * createCanvas() is not used in a program.
                         *
                         * @property width
                         */
                        p5.prototype.width = 0;
                        
                        /**
                         * System variable that stores the height of the drawing canvas. This value
                         * is set by the second parameter of the createCanvas() function. For
                         * example, the function call createCanvas(320, 240) sets the height
                         * variable to the value 240. The value of height defaults to 100 if
                         * createCanvas() is not used in a program.
                         *
                         * @property height
                         */
                        p5.prototype.height = 0;
                        
                        /**
                         * If argument is given, sets the sketch to fullscreen or not based on the
                         * value of the argument. If no argument is given, returns the current
                         * fullscreen state. Note that due to browser restrictions this can only
                         * be called on user input, for example, on mouse press like the example
                         * below.
                         *
                         * @method fullScreen
                         * @param  {Boolean} [val] whether the sketch should be fullscreened or not
                         * @return {Boolean} current fullscreen state
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Clicking in the box toggles fullscreen on and off.
                         * function setup() {
                         *   background(200);
                         * }
                         * function mousePressed() {
                         *   if (mouseX &gt; 0 &amp;&amp; mouseX &lt; 100 &amp;&amp; mouseY &gt; 0 &amp;&amp; mouseY &lt; 100) {
                         *     var fs = fullScreen();
                         *     fullScreen(!fs);
                         *   }
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.fullScreen = function(val) {
                          // no arguments, return fullscreen or not
                          if (typeof val === &#x27;undefined&#x27;) {
                            return document.fullscreenElement ||
                                   document.webkitFullscreenElement ||
                                   document.mozFullScreenElement ||
                                   document.msFullscreenElement;
                          } else { // otherwise set to fullscreen or not
                            if (val) {
                              launchFullscreen(document.documentElement);
                            } else {
                              exitFullscreen();
                            }
                          }
                        };
                        
                        /**
                         * Sets the pixel scaling for high pixel density displays. By default
                         * pixel density is set to match display density, call pixelDensity(1)
                         * to turn this off. Calling pixelDensity() with no arguments returns
                         * the current pixel density of the sketch.
                         *
                         *
                         * @method pixelDensity
                         * @param  {Number} [val] whether or how much the sketch should scale
                         * @returns {Number} current pixel density of the sketch
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * function setup() {
                         *   pixelDensity(1);
                         *   createCanvas(100, 100);
                         *   background(200);
                         *   ellipse(width/2, height/2, 50, 50);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * function setup() {
                         *   pixelDensity(3.0);
                         *   createCanvas(100, 100);
                         *   background(200);
                         *   ellipse(width/2, height/2, 50, 50);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.pixelDensity = function(val) {
                          if (typeof val === &#x27;number&#x27;) {
                            this._pixelDensity = val;
                          } else {
                            return this._pixelDensity;
                          }
                          this.resizeCanvas(this.width, this.height, true);
                        };
                        
                        /**
                         * Returns the pixel density of the current display the sketch is running on.
                         *
                         * @method displayDensity
                         * @returns {Number} current pixel density of the display
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * function setup() {
                         *   var density = displayDensity();
                         *   pixelDensity(density);
                         *   createCanvas(100, 100);
                         *   background(200);
                         *   ellipse(width/2, height/2, 50, 50);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.displayDensity = function() {
                          return window.devicePixelRatio;
                        };
                        
                        function launchFullscreen(element) {
                          var enabled = document.fullscreenEnabled ||
                                        document.webkitFullscreenEnabled ||
                                        document.mozFullScreenEnabled ||
                                        document.msFullscreenEnabled;
                          if (!enabled) {
                            throw new Error(&#x27;Fullscreen not enabled in this browser.&#x27;);
                          }
                          if(element.requestFullscreen) {
                            element.requestFullscreen();
                          } else if(element.mozRequestFullScreen) {
                            element.mozRequestFullScreen();
                          } else if(element.webkitRequestFullscreen) {
                            element.webkitRequestFullscreen();
                          } else if(element.msRequestFullscreen) {
                            element.msRequestFullscreen();
                          }
                        }
                        
                        function exitFullscreen() {
                          if(document.exitFullscreen) {
                            document.exitFullscreen();
                          } else if(document.mozCancelFullScreen) {
                            document.mozCancelFullScreen();
                          } else if(document.webkitExitFullscreen) {
                            document.webkitExitFullscreen();
                          } else if (document.msExitFullscreen) {
                            document.msExitFullscreen();
                          }
                        }
                        
                        
                        /**
                         * Gets the current URL.
                         * @method getURL
                         * @return {String} url
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var url;
                         * var x = 100;
                         *
                         * function setup() {
                         *   fill(0);
                         *   noStroke();
                         *   url = getURL();
                         * }
                         *
                         * function draw() {
                         *   background(200);
                         *   text(url, x, height/2);
                         *   x--;
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.getURL = function() {
                          return location.href;
                        };
                        /**
                         * Gets the current URL path as an array.
                         * @method getURLPath
                         * @return {Array} path components
                         * @example
                         * &lt;div class=&#x27;norender&#x27;&gt;&lt;code&gt;
                         * function setup() {
                         *   var urlPath = getURLPath();
                         *   for (var i=0; i&amp;lt;urlPath.length; i++) {
                         *     text(urlPath[i], 10, i*20+20);
                         *   }
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.getURLPath = function() {
                          return location.pathname.split(&#x27;/&#x27;).filter(function(v){return v!==&#x27;&#x27;;});
                        };
                        /**
                         * Gets the current URL params as an Object.
                         * @method getURLParams
                         * @return {Object} URL params
                         * @example
                         * &lt;div class=&#x27;norender&#x27;&gt;
                         * &lt;code&gt;
                         * // Example: http://p5js.org?year=2014&amp;month=May&amp;day=15
                         *
                         * function setup() {
                         *   var params = getURLParams();
                         *   text(params.day, 10, 20);
                         *   text(params.month, 10, 40);
                         *   text(params.year, 10, 60);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.getURLParams = function() {
                          var re = /[?&amp;]([^&amp;=]+)(?:[&amp;=])([^&amp;=]+)/gim;
                          var m;
                          var v={};
                          while ((m = re.exec(location.search)) != null) {
                            if (m.index === re.lastIndex) {
                              re.lastIndex++;
                            }
                            v[m[1]]=m[2];
                          }
                          return v;
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;./constants&quot;:47,&quot;./core&quot;:48}],51:[function(_dereq_,module,exports){
                        /**
                         * @for p5
                         * @requires core
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;./core&#x27;);
                        var doFriendlyWelcome = false; // TEMP until we get it all working LM
                        
                        // -- Borrowed from jQuery 1.11.3 --
                        var class2type = {};
                        var toString = class2type.toString;
                        var names = [&#x27;Boolean&#x27;, &#x27;Number&#x27;, &#x27;String&#x27;, &#x27;Function&#x27;,
                                     &#x27;Array&#x27;, &#x27;Date&#x27;, &#x27;RegExp&#x27;, &#x27;Object&#x27;, &#x27;Error&#x27;];
                        for (var n=0; n&lt;names.length; n++) {
                          class2type[ &#x27;[object &#x27; + names[n] + &#x27;]&#x27; ] = names[n].toLowerCase();
                        }
                        var getType = function( obj ) {
                          if ( obj == null ) {
                            return obj + &#x27;&#x27;;
                          }
                          return typeof obj === &#x27;object&#x27; || typeof obj === &#x27;function&#x27; ?
                            class2type[ toString.call(obj) ] || &#x27;object&#x27; :
                            typeof obj;
                        };
                        var isArray = Array.isArray || function( obj ) {
                          return getType(obj) === &#x27;array&#x27;;
                        };
                        var isNumeric =function( obj ) {
                          // parseFloat NaNs numeric-cast false positives (null|true|false|&quot;&quot;)
                          // ...but misinterprets leading-number strings, particularly hex literals
                          // subtraction forces infinities to NaN
                          // adding 1 corrects loss of precision from parseFloat (#15100)
                          return !isArray( obj ) &amp;&amp; (obj - parseFloat( obj ) + 1) &gt;= 0;
                        };
                        // -- End borrow --
                        
                        /**
                         * Checks the definition type against the argument type
                         * If any of these passes (in order), it matches:
                         *
                         * - p5.* definitions are checked with instanceof
                         * - Booleans are let through (everything is truthy or falsey)
                         * - Lowercase of the definition is checked against the js type
                         * - Number types are checked to see if they are numerically castable
                         */
                        var numberTypes = [&#x27;Number&#x27;, &#x27;Integer&#x27;, &#x27;Number/Constant&#x27;];
                        function typeMatches(defType, argType, arg) {
                          if(defType.match(/^p5\./)) {
                            var parts = defType.split(&#x27;.&#x27;);
                            return arg instanceof p5[parts[1]];
                          }
                          return defType === &#x27;Boolean&#x27; || // Anything is truthy, cover in Debug Guide
                            (defType.toLowerCase() === argType) ||
                            (numberTypes.indexOf(defType) &gt; -1 &amp;&amp; isNumeric(arg));
                        }
                        
                        /**
                         * Prints out a fancy, colorful message to the console log
                         *
                         * @param  {String}               message the words to be said
                         * @param  {String}               func    the name of the function to link
                         * @param  {Integer/Color String} color   CSS color string or error type
                         *
                         * @return console logs
                         */
                        // Wrong number of params, undefined param, wrong type
                        var PARAM_COUNT = 0;
                        var EMPTY_VAR = 1;
                        var WRONG_TYPE = 2;
                        var FILE_LOAD = 3;
                        // p5.js blue, p5.js orange, auto dark green; fallback p5.js darkened magenta
                        // See testColors below for all the color codes and names
                        var typeColors = [&#x27;#2D7BB6&#x27;, &#x27;#EE9900&#x27;, &#x27;#4DB200&#x27;, &#x27;#C83C00&#x27;];
                        function report(message, func, color) {
                          if(doFriendlyWelcome){
                            friendlyWelcome();
                            doFriendlyWelcome =false;
                          }
                          if (&#x27;undefined&#x27; === getType(color)) {
                            color   = &#x27;#B40033&#x27;; // dark magenta
                          } else if (getType(color) === &#x27;number&#x27;) { // Type to color
                            color = typeColors[color];
                          }
                          // LM TEMP commenting this out until we get the whole system working
                          // if (func.substring(0,4) === &#x27;load&#x27;){
                          //   console.log(
                          //     &#x27;%c&gt; p5.js says: &#x27;+message+&#x27;%c&#x27;+
                          //     &#x27;[https://github.com/processing/p5.js/wiki/Local-server]&#x27;,
                          //     &#x27;background-color:&#x27; + color + &#x27;;color:#FFF;&#x27;,
                          //     &#x27;background-color:transparent;color:&#x27; + color +&#x27;;&#x27;,
                          //     &#x27;background-color:&#x27; + color + &#x27;;color:#FFF;&#x27;,
                          //     &#x27;background-color:transparent;color:&#x27; + color +&#x27;;&#x27;
                          //   );
                          // }
                          // else{
                          //   console.log(
                          //     &#x27;%c&gt; p5.js says: &#x27;+message+&#x27;%c [http://p5js.org/reference/#p5/&#x27;+func+
                          //     &#x27;]&#x27;, &#x27;background-color:&#x27; + color + &#x27;;color:#FFF;&#x27;,
                          //     &#x27;background-color:transparent;color:&#x27; + color +&#x27;;&#x27;
                          //   );
                          // }
                        }
                        
                        /**
                         * Validate all the parameters of a function for number and type
                         * NOTE THIS FUNCTION IS TEMPORARILY DISABLED UNTIL FURTHER WORK
                         * AND UPDATES ARE IMPLEMENTED. -LMCCART
                         *
                         * @param  {String} func  name of function we&#x27;re checking
                         * @param  {Array}  args  pass of the JS default arguments array
                         * @param  {Array}  types List of types accepted [&#x27;Number&#x27;, &#x27;String, ...] OR
                         *                        a list of lists for each format: [
                         *                          [&#x27;String&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;],
                         *                          [&#x27;String&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;
                         *                        ]
                         *
                         * @return console logs
                         */
                        p5.prototype._validateParameters = function(func, args, types) {
                          if (!isArray(types[0])) {
                            types = [types];
                          }
                          // Check number of parameters
                          // Example: &quot;You wrote ellipse(X,X,X). ellipse was expecting 4
                          //          parameters. Try ellipse(X,X,X,X).&quot;
                          var diff = Math.abs(args.length-types[0].length);
                          var message, tindex = 0;
                          for (var i=1, len=types.length; i&lt;len; i++) {
                            var d = Math.abs(args.length-types[i].length);
                            if (d &lt;= diff) {
                              tindex = i;
                              diff = d;
                            }
                          }
                          var symbol = &#x27;X&#x27;; // Parameter placeholder
                          if(diff &gt; 0) {
                            message = &#x27;You wrote &#x27; + func + &#x27;(&#x27;;
                            // Concat an appropriate number of placeholders for call
                            if (args.length &gt; 0) {
                              message += symbol + Array(args.length).join(&#x27;,&#x27; + symbol);
                            }
                            message += &#x27;). &#x27; + func + &#x27; was expecting &#x27; + types[tindex].length +
                              &#x27; parameters. Try &#x27; + func + &#x27;(&#x27;;
                            // Concat an appropriate number of placeholders for definition
                            if (types[tindex].length &gt; 0) {
                              message += symbol + Array(types[tindex].length).join(&#x27;,&#x27; + symbol);
                            }
                            message += &#x27;).&#x27;;
                            // If multiple definitions
                            if (types.length &gt; 1) {
                              message += &#x27; &#x27; + func + &#x27; takes different numbers of parameters &#x27; +
                                &#x27;depending on what you want to do. Click this link to learn more: &#x27;;
                            }
                            report(message, func, PARAM_COUNT);
                          }
                          // Type checking
                          // Example: &quot;It looks like ellipse received an empty variable in spot #2.&quot;
                          // Example: &quot;ellipse was expecting a number for parameter #1,
                          //           received &quot;foo&quot; instead.&quot;
                          for (var format=0; format&lt;types.length; format++) {
                            for (var p=0; p &lt; types[format].length &amp;&amp; p &lt; args.length; p++) {
                              var defType = types[format][p];
                              var argType = getType(args[p]);
                              if (&#x27;undefined&#x27; === argType || null === argType) {
                                report(&#x27;It looks like &#x27; + func +
                                  &#x27; received an empty variable in spot #&#x27; + (p+1) +
                                  &#x27;. If not intentional, this is often a problem with scope: &#x27; +
                                  &#x27;[link to scope].&#x27;, func, EMPTY_VAR);
                              } else if (defType !== &#x27;*&#x27; &amp;&amp; !typeMatches(defType, argType, args[p])) {
                                message = func + &#x27; was expecting a &#x27; + defType.toLowerCase() +
                                  &#x27; for parameter #&#x27; + (p+1) + &#x27;, received &#x27;;
                                // Wrap strings in quotes
                                message += &#x27;string&#x27; === argType ? &#x27;&quot;&#x27; + args[p] + &#x27;&quot;&#x27; : args[p];
                                message += &#x27; instead.&#x27;;
                                // If multiple definitions
                                if (types.length &gt; 1) {
                                  message += &#x27; &#x27; + func + &#x27; takes different numbers of parameters &#x27; +
                                    &#x27;depending on what you want to do. &#x27; +
                                    &#x27;Click this link to learn more:&#x27;;
                                }
                                report(message, func, WRONG_TYPE);
                              }
                            }
                          }
                        };
                        /*
                         * NOTE THIS FUNCTION IS TEMPORARILY DISABLED UNTIL FURTHER WORK
                         * AND UPDATES ARE IMPLEMENTED. -LMCCART
                         */
                        p5.prototype._validateParameters = function() {
                          return true;
                        };
                        
                        var errorCases = {
                          &#x27;0&#x27;: {
                            fileType: &#x27;image&#x27;,
                            method: &#x27;loadImage&#x27;,
                            message: &#x27; hosting the image online,&#x27;
                          },
                          &#x27;1&#x27;: {
                            fileType: &#x27;XML file&#x27;,
                            method: &#x27;loadXML&#x27;
                          },
                          &#x27;2&#x27;: {
                            fileType: &#x27;table file&#x27;,
                            method: &#x27;loadTable&#x27;
                          },
                          &#x27;3&#x27;: {
                            fileType: &#x27;text file&#x27;,
                            method: &#x27;loadStrings&#x27;
                          }
                        };
                        p5._friendlyFileLoadError = function (errorType, filePath) {
                          var errorInfo = errorCases[ errorType ];
                          var message = &#x27;It looks like there was a problem&#x27; +
                          &#x27; loading your &#x27; + errorInfo.fileType + &#x27;.&#x27; +
                          &#x27; Try checking if the file path%c [&#x27; + filePath + &#x27;] %cis correct,&#x27; +
                          (errorInfo.message || &#x27;&#x27;) + &#x27; or running a local server.&#x27;;
                          report(message, errorInfo.method, FILE_LOAD);
                        };
                        
                        function friendlyWelcome() {
                          // p5.js brand - magenta: #ED225D
                          var astrixBgColor = &#x27;transparent&#x27;;
                          var astrixTxtColor = &#x27;#ED225D&#x27;;
                          var welcomeBgColor = &#x27;#ED225D&#x27;;
                          var welcomeTextColor = &#x27;white&#x27;;
                          console.log(
                          &#x27;%c    _ \n&#x27;+
                          &#x27; /\\| |/\\ \n&#x27;+
                          &#x27; \\ &#x60; \&#x27; /  \n&#x27;+
                          &#x27; / , . \\  \n&#x27;+
                          &#x27; \\/|_|\\/ &#x27;+
                          &#x27;\n\n%c&gt; p5.js says: Welcome! &#x27;+
                          &#x27;This is your friendly debugger. &#x27; +
                          &#x27;To turn me off switch to using “p5.min.js”.&#x27;,
                          &#x27;background-color:&#x27;+astrixBgColor+&#x27;;color:&#x27; + astrixTxtColor +&#x27;;&#x27;,
                          &#x27;background-color:&#x27;+welcomeBgColor+&#x27;;color:&#x27; + welcomeTextColor +&#x27;;&#x27;
                          );
                        }
                        
                        /**
                         * Prints out all the colors in the color pallete with white text.
                         * For color blindness testing.
                         */
                        /* function testColors() {
                          var str = &#x27;A box of biscuits, a box of mixed biscuits and a biscuit mixer&#x27;;
                          report(str, &#x27;println&#x27;, &#x27;#ED225D&#x27;); // p5.js magenta
                          report(str, &#x27;println&#x27;, &#x27;#2D7BB6&#x27;); // p5.js blue
                          report(str, &#x27;println&#x27;, &#x27;#EE9900&#x27;); // p5.js orange
                          report(str, &#x27;println&#x27;, &#x27;#A67F59&#x27;); // p5.js light brown
                          report(str, &#x27;println&#x27;, &#x27;#704F21&#x27;); // p5.js gold
                          report(str, &#x27;println&#x27;, &#x27;#1CC581&#x27;); // auto cyan
                          report(str, &#x27;println&#x27;, &#x27;#FF6625&#x27;); // auto orange
                          report(str, &#x27;println&#x27;, &#x27;#79EB22&#x27;); // auto green
                          report(str, &#x27;println&#x27;, &#x27;#B40033&#x27;); // p5.js darkened magenta
                          report(str, &#x27;println&#x27;, &#x27;#084B7F&#x27;); // p5.js darkened blue
                          report(str, &#x27;println&#x27;, &#x27;#945F00&#x27;); // p5.js darkened orange
                          report(str, &#x27;println&#x27;, &#x27;#6B441D&#x27;); // p5.js darkened brown
                          report(str, &#x27;println&#x27;, &#x27;#2E1B00&#x27;); // p5.js darkened gold
                          report(str, &#x27;println&#x27;, &#x27;#008851&#x27;); // auto dark cyan
                          report(str, &#x27;println&#x27;, &#x27;#C83C00&#x27;); // auto dark orange
                          report(str, &#x27;println&#x27;, &#x27;#4DB200&#x27;); // auto dark green
                        } */
                        
                        // This is a list of p5 functions/variables that are commonly misused
                        // by beginners at top-level code, outside of setup/draw. We&#x27;d like to
                        // detect these errors and help the user by suggesting they move them
                        // into setup/draw.
                        //
                        // For more details, see https://github.com/processing/p5.js/issues/1121.
                        var misusedAtTopLevelCode = [
                          &#x27;color&#x27;,
                          &#x27;random&#x27;
                        ];
                        
                        function helpForMisusedAtTopLevelCode(e) {
                          misusedAtTopLevelCode.forEach(function(name) {
                            if (e.message &amp;&amp; e.message.indexOf(name) !== -1) {
                              console.log(&#x27;%c Did you just try to use p5.js\&#x27;s \&#x27;&#x27; + name + &#x27;\&#x27; &#x27; +
                                          &#x27;function or variable? If so, you may want to &#x27; +
                                          &#x27;move it into your sketch\&#x27;s setup() function.&#x27;,
                                          &#x27;color: #B40033&#x27; /* Dark magenta */);
                            }
                          });
                        }
                        
                        if (document.readyState !== &#x27;complete&#x27;) {
                          window.addEventListener(&#x27;error&#x27;, helpForMisusedAtTopLevelCode, false);
                        
                          // Our job is only to catch ReferenceErrors that are thrown when
                          // global (non-instance mode) p5 APIs are used at the top-level
                          // scope of a file, so we&#x27;ll unbind our error listener now to make
                          // sure we don&#x27;t log false positives later.
                          window.addEventListener(&#x27;load&#x27;, function() {
                            window.removeEventListener(&#x27;error&#x27;, helpForMisusedAtTopLevelCode, false);
                          });
                        }
                        
                        module.exports = p5;
                        
                        },{&quot;./core&quot;:48}],52:[function(_dereq_,module,exports){
                        /**
                         * @module DOM
                         * @submodule DOM
                         * @for p5.Element
                         */
                        
                        var p5 = _dereq_(&#x27;./core&#x27;);
                        
                        /**
                         * Base class for all elements added to a sketch, including canvas,
                         * graphics buffers, and other HTML elements. Methods in blue are
                         * included in the core functionality, methods in brown are added
                         * with the &lt;a href=&quot;http://p5js.org/libraries/&quot;&gt;p5.dom library&lt;/a&gt;.
                         * It is not called directly, but p5.Element
                         * objects are created by calling createCanvas, createGraphics,
                         * or in the p5.dom library, createDiv, createImg, createInput, etc.
                         *
                         * @class p5.Element
                         * @constructor
                         * @param {String} elt DOM node that is wrapped
                         * @param {Object} [pInst] pointer to p5 instance
                         */
                        p5.Element = function(elt, pInst) {
                          /**
                           * Underlying HTML element. All normal HTML methods can be called on this.
                           *
                           * @property elt
                           */
                          this.elt = elt;
                          this._pInst = pInst;
                          this._events = {};
                          this.width = this.elt.offsetWidth;
                          this.height = this.elt.offsetHeight;
                        };
                        
                        /**
                         *
                         * Attaches the element to the parent specified. A way of setting
                         * the container for the element. Accepts either a string ID, DOM
                         * node, or p5.Element. If no arguments given, parent node is returned.
                         *
                         * @method parent
                         * @param  {String|Object} parent the ID, DOM node, or p5.Element
                         *                         of desired parent element
                         * @return {p5.Element}
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;&lt;code&gt;
                         * // in the html file:
                         * &amp;lt;div id=&quot;myContainer&quot;&gt;&amp;lt;/div&gt;
                         * // in the js file:
                         * var cnv = createCanvas(100, 100);
                         * cnv.parent(&quot;myContainer&quot;);
                         * &lt;/code&gt;&lt;/div&gt;
                         * &lt;div class=&#x27;norender&#x27;&gt;&lt;code&gt;
                         * var div0 = createDiv(&#x27;this is the parent&#x27;);
                         * var div1 = createDiv(&#x27;this is the child&#x27;);
                         * div1.parent(div0); // use p5.Element
                         * &lt;/code&gt;&lt;/div&gt;
                         * &lt;div class=&#x27;norender&#x27;&gt;&lt;code&gt;
                         * var div0 = createDiv(&#x27;this is the parent&#x27;);
                         * div0.id(&#x27;apples&#x27;);
                         * var div1 = createDiv(&#x27;this is the child&#x27;);
                         * div1.parent(&#x27;apples&#x27;); // use id
                         * &lt;/code&gt;&lt;/div&gt;
                         * &lt;div class=&#x27;norender&#x27;&gt;&lt;code&gt;
                         * var elt = document.getElementById(&#x27;myParentDiv&#x27;);
                         * var div1 = createDiv(&#x27;this is the child&#x27;);
                         * div1.parent(elt); // use element from page
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.Element.prototype.parent = function(p) {
                          if (arguments.length === 0){
                            return this.elt.parentNode;
                          } else {
                            if (typeof p === &#x27;string&#x27;) {
                              if (p[0] === &#x27;#&#x27;) {
                                p = p.substring(1);
                              }
                              p = document.getElementById(p);
                            } else if (p instanceof p5.Element) {
                              p = p.elt;
                            }
                            p.appendChild(this.elt);
                            return this;
                          }
                        };
                        
                        /**
                         *
                         * Sets the ID of the element
                         *
                         * @method id
                         * @param  {String} id ID of the element
                         * @return {p5.Element}
                         */
                        p5.Element.prototype.id = function(id) {
                          if (arguments.length === 0) {
                            return this.elt.id;
                          } else {
                            this.elt.id = id;
                            this.width = this.elt.offsetWidth;
                            this.height = this.elt.offsetHeight;
                            return this;
                          }
                        };
                        
                        /**
                         *
                         * Adds given class to the element
                         *
                         * @method class
                         * @param  {String} class class to add
                         * @return {p5.Element}
                         */
                        p5.Element.prototype.class = function(c) {
                          if (arguments.length === 0) {
                            return this.elt.className;
                          } else {
                            this.elt.className = c;
                            this.width = this.elt.offsetWidth;
                            this.height = this.elt.offsetHeight;
                            return this;
                          }
                        };
                        
                        /**
                         * The .mousePressed() function is called once after every time a
                         * mouse button is pressed over the element. This can be used to
                         * attach element specific event listeners.
                         *
                         * @method mousePressed
                         * @param  {Function} fxn function to be fired when mouse is
                         *                    pressed over the element.
                         * @return {p5.Element}
                         * @example
                         * &lt;div class=&#x27;norender&#x27;&gt;&lt;code&gt;
                         * var cnv;
                         * var d;
                         * var g;
                         * function setup() {
                         *   cnv = createCanvas(100, 100);
                         *   cnv.mousePressed(changeGray); // attach listener for
                         *                                 // canvas click only
                         *   d = 10;
                         *   g = 100;
                         * }
                         *
                         * function draw() {
                         *   background(g);
                         *   ellipse(width/2, height/2, d, d);
                         * }
                         *
                         * // this function fires with any click anywhere
                         * function mousePressed() {
                         *   d = d + 10;
                         * }
                         *
                         * // this function fires only when cnv is clicked
                         * function changeGray() {
                         *   g = random(0, 255);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         *
                         */
                        p5.Element.prototype.mousePressed = function (fxn) {
                          attachListener(&#x27;mousedown&#x27;, fxn, this);
                          attachListener(&#x27;touchstart&#x27;, fxn, this);
                          return this;
                        };
                        
                        /**
                         * The .mouseWheel() function is called once after every time a
                         * mouse wheel is scrolled over the element. This can be used to
                         * attach element specific event listeners.&lt;br&gt;&lt;br&gt;
                         * The event.wheelDelta or event.detail property returns negative values if
                         * the mouse wheel if rotated up or away from the user and positive in the
                         * other direction. On OS X with &quot;natural&quot; scrolling enabled, the values are
                         * opposite.
                         *
                         * @method mouseWheel
                         * @param  {Function} fxn function to be fired when mouse wheel is
                         *                    scrolled over the element.
                         * @return {p5.Element}
                         */
                        p5.Element.prototype.mouseWheel = function (fxn) {
                          attachListener(&#x27;wheel&#x27;, fxn, this);
                          return this;
                        };
                        
                        /**
                         * The .mouseReleased() function is called once after every time a
                         * mouse button is released over the element. This can be used to
                         * attach element specific event listeners.
                         *
                         * @method mouseReleased
                         * @param  {Function} fxn function to be fired when mouse is
                         *                    released over the element.
                         * @return {p5.Element}
                         */
                        p5.Element.prototype.mouseReleased = function (fxn) {
                          attachListener(&#x27;mouseup&#x27;, fxn, this);
                          attachListener(&#x27;touchend&#x27;, fxn, this);
                          return this;
                        };
                        
                        
                        /**
                         * The .mouseClicked() function is called once after a mouse button is
                         * pressed and released over the element. This can be used to
                         * attach element specific event listeners.
                         *
                         * @method mouseClicked
                         * @param  {Function} fxn function to be fired when mouse is
                         *                    clicked over the element.
                         * @return {p5.Element}
                         */
                        p5.Element.prototype.mouseClicked = function (fxn) {
                          attachListener(&#x27;click&#x27;, fxn, this);
                          return this;
                        };
                        
                        /**
                         * The .mouseMoved() function is called once every time a
                         * mouse moves over the element. This can be used to attach an
                         * element specific event listener.
                         *
                         * @method mouseMoved
                         * @param  {Function} fxn function to be fired when mouse is
                         *                    moved over the element.
                         * @return {p5.Element}
                         */
                        p5.Element.prototype.mouseMoved = function (fxn) {
                          attachListener(&#x27;mousemove&#x27;, fxn, this);
                          attachListener(&#x27;touchmove&#x27;, fxn, this);
                          return this;
                        };
                        
                        /**
                         * The .mouseOver() function is called once after every time a
                         * mouse moves onto the element. This can be used to attach an
                         * element specific event listener.
                         *
                         * @method mouseOver
                         * @param  {Function} fxn function to be fired when mouse is
                         *                    moved over the element.
                         * @return {p5.Element}
                         */
                        p5.Element.prototype.mouseOver = function (fxn) {
                          attachListener(&#x27;mouseover&#x27;, fxn, this);
                          return this;
                        };
                        
                        
                        /**
                         * The .changed() function is called when the value of an
                         * element is changed.
                         * This can be used to attach an element specific event listener.
                         *
                         * @method changed
                         * @param  {Function} fxn function to be fired when the value of an
                         * element changes.
                         * @return {p5.Element}
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * var sel;
                         *
                         * function setup() {
                         *   textAlign(CENTER);
                         *   background(200);
                         *   sel = createSelect();
                         *   sel.position(10, 10);
                         *   sel.option(&#x27;pear&#x27;);
                         *   sel.option(&#x27;kiwi&#x27;);
                         *   sel.option(&#x27;grape&#x27;);
                         *   sel.changed(mySelectEvent);
                         * }
                         *
                         * function mySelectEvent() {
                         *   var item = sel.value();
                         *   background(200);
                         *   text(&quot;it&#x27;s a &quot;+item+&quot;!&quot;, 50, 50);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         * &lt;div&gt;&lt;code&gt;
                         * var checkbox;
                         * var cnv;
                         *
                         * function setup() {
                         *   checkbox = createCheckbox(&quot; fill&quot;);
                         *   checkbox.changed(changeFill);
                         *   cnv = createCanvas(100, 100);
                         *   cnv.position(0, 30);
                         *   noFill();
                         * }
                         *
                         * function draw() {
                         *   background(200);
                         *   ellipse(50, 50, 50, 50);
                         * }
                         *
                         * function changeFill() {
                         *   if (checkbox.checked()) {
                         *     fill(0);
                         *   } else {
                         *     noFill();
                         *   }
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.Element.prototype.changed = function (fxn) {
                          attachListener(&#x27;change&#x27;, fxn, this);
                          return this;
                        };
                        
                        /**
                         * The .input() function is called when any user input is
                         * detected with an element. The input event is often used
                         * to detect keystrokes in a input element, or changes on a
                         * slider element. This can be used to attach an element specific
                         * event listener.
                         *
                         * @method input
                         * @param  {Function} fxn function to be fired on user input.
                         * @return {p5.Element}
                         */
                        p5.Element.prototype.input = function (fxn) {
                          attachListener(&#x27;input&#x27;, fxn, this);
                          return this;
                        };
                        
                        /**
                         * The .mouseOut() function is called once after every time a
                         * mouse moves off the element. This can be used to attach an
                         * element specific event listener.
                         *
                         * @method mouseOut
                         * @param  {Function} fxn function to be fired when mouse is
                         *                    moved off the element.
                         * @return {p5.Element}
                         */
                        p5.Element.prototype.mouseOut = function (fxn) {
                          attachListener(&#x27;mouseout&#x27;, fxn, this);
                          return this;
                        };
                        
                        /**
                         * The .touchStarted() function is called once after every time a touch is
                         * registered. This can be used to attach element specific event listeners.
                         *
                         * @method touchStarted
                         * @param  {Function} fxn function to be fired when touch is
                         *                    started over the element.
                         * @return {p5.Element}
                         * @example
                         * &lt;div class=&#x27;norender&#x27;&gt;&lt;code&gt;
                         * var cnv;
                         * var d;
                         * var g;
                         * function setup() {
                         *   cnv = createCanvas(100, 100);
                         *   cnv.touchStarted(changeGray); // attach listener for
                         *                                 // canvas click only
                         *   d = 10;
                         *   g = 100;
                         * }
                         *
                         * function draw() {
                         *   background(g);
                         *   ellipse(width/2, height/2, d, d);
                         * }
                         *
                         * // this function fires with any touch anywhere
                         * function touchStarted() {
                         *   d = d + 10;
                         * }
                         *
                         * // this function fires only when cnv is clicked
                         * function changeGray() {
                         *   g = random(0, 255);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         *
                         */
                        p5.Element.prototype.touchStarted = function (fxn) {
                          attachListener(&#x27;touchstart&#x27;, fxn, this);
                          attachListener(&#x27;mousedown&#x27;, fxn, this);
                          return this;
                        };
                        
                        /**
                         * The .touchMoved() function is called once after every time a touch move is
                         * registered. This can be used to attach element specific event listeners.
                         *
                         * @method touchMoved
                         * @param  {Function} fxn function to be fired when touch is moved
                         *                    over the element.
                         * @return {p5.Element}
                         * @example
                         * &lt;div class=&#x27;norender&#x27;&gt;&lt;code&gt;
                         * var cnv;
                         * var g;
                         * function setup() {
                         *   cnv = createCanvas(100, 100);
                         *   cnv.touchMoved(changeGray); // attach listener for
                         *                               // canvas click only
                         *   g = 100;
                         * }
                         *
                         * function draw() {
                         *   background(g);
                         * }
                         *
                         * // this function fires only when cnv is clicked
                         * function changeGray() {
                         *   g = random(0, 255);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         *
                         */
                        p5.Element.prototype.touchMoved = function (fxn) {
                          attachListener(&#x27;touchmove&#x27;, fxn, this);
                          attachListener(&#x27;mousemove&#x27;, fxn, this);
                          return this;
                        };
                        
                        /**
                         * The .touchEnded() function is called once after every time a touch is
                         * registered. This can be used to attach element specific event listeners.
                         *
                         * @method touchEnded
                         * @param  {Function} fxn function to be fired when touch is
                         *                    ended over the element.
                         * @return {p5.Element}
                         * @example
                         * &lt;div class=&#x27;norender&#x27;&gt;&lt;code&gt;
                         * var cnv;
                         * var d;
                         * var g;
                         * function setup() {
                         *   cnv = createCanvas(100, 100);
                         *   cnv.touchEnded(changeGray);   // attach listener for
                         *                                 // canvas click only
                         *   d = 10;
                         *   g = 100;
                         * }
                         *
                         * function draw() {
                         *   background(g);
                         *   ellipse(width/2, height/2, d, d);
                         * }
                         *
                         * // this function fires with any touch anywhere
                         * function touchEnded() {
                         *   d = d + 10;
                         * }
                         *
                         * // this function fires only when cnv is clicked
                         * function changeGray() {
                         *   g = random(0, 255);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         *
                         */
                        p5.Element.prototype.touchEnded = function (fxn) {
                          attachListener(&#x27;touchend&#x27;, fxn, this);
                          attachListener(&#x27;mouseup&#x27;, fxn, this);
                          return this;
                        };
                        
                        
                        
                        /**
                         * The .dragOver() function is called once after every time a
                         * file is dragged over the element. This can be used to attach an
                         * element specific event listener.
                         *
                         * @method dragOver
                         * @param  {Function} fxn function to be fired when mouse is
                         *                    dragged over the element.
                         * @return {p5.Element}
                         */
                        p5.Element.prototype.dragOver = function (fxn) {
                          attachListener(&#x27;dragover&#x27;, fxn, this);
                          return this;
                        };
                        
                        /**
                         * The .dragLeave() function is called once after every time a
                         * dragged file leaves the element area. This can be used to attach an
                         * element specific event listener.
                         *
                         * @method dragLeave
                         * @param  {Function} fxn function to be fired when mouse is
                         *                    dragged over the element.
                         * @return {p5.Element}
                         */
                        p5.Element.prototype.dragLeave = function (fxn) {
                          attachListener(&#x27;dragleave&#x27;, fxn, this);
                          return this;
                        };
                        
                        /**
                         * The .drop() function is called for each file dropped on the element.
                         * It requires a callback that is passed a p5.File object.  You can
                         * optionally pass two callbacks, the first one (required) is triggered
                         * for each file dropped when the file is loaded.  The second (optional)
                         * is triggered just once when a file (or files) are dropped.
                         *
                         * @method drop
                         * @param  {Function} callback triggered when files are dropped.
                         * @param  {Function} callback to receive loaded file.
                         * @return {p5.Element}
                         */
                        p5.Element.prototype.drop = function (callback, fxn) {
                          // Make a file loader callback and trigger user&#x27;s callback
                          function makeLoader(theFile) {
                            // Making a p5.File object
                            var p5file = new p5.File(theFile);
                            return function(e) {
                              p5file.data = e.target.result;
                              callback(p5file);
                            };
                          }
                        
                          // Is the file stuff supported?
                          if (window.File &amp;&amp; window.FileReader &amp;&amp; window.FileList &amp;&amp; window.Blob) {
                        
                            // If you want to be able to drop you&#x27;ve got to turn off
                            // a lot of default behavior
                            attachListener(&#x27;dragover&#x27;,function(evt) {
                              evt.stopPropagation();
                              evt.preventDefault();
                            },this);
                        
                            // If this is a drag area we need to turn off the default behavior
                            attachListener(&#x27;dragleave&#x27;,function(evt) {
                              evt.stopPropagation();
                              evt.preventDefault();
                            },this);
                        
                            // If just one argument it&#x27;s the callback for the files
                            if (arguments.length &gt; 1) {
                              attachListener(&#x27;drop&#x27;, fxn, this);
                            }
                        
                            // Deal with the files
                            attachListener(&#x27;drop&#x27;, function(evt) {
                        
                              evt.stopPropagation();
                              evt.preventDefault();
                        
                              // A FileList
                              var files = evt.dataTransfer.files;
                        
                              // Load each one and trigger the callback
                              for (var i = 0; i &lt; files.length; i++) {
                                var f = files[i];
                                var reader = new FileReader();
                                reader.onload = makeLoader(f);
                        
                        
                                // Text or data?
                                // This should likely be improved
                                if (f.type.indexOf(&#x27;text&#x27;) &gt; -1) {
                                  reader.readAsText(f);
                                } else {
                                  reader.readAsDataURL(f);
                                }
                              }
                            }, this);
                          } else {
                            console.log(&#x27;The File APIs are not fully supported in this browser.&#x27;);
                          }
                        
                          return this;
                        };
                        
                        
                        
                        
                        function attachListener(ev, fxn, ctx) {
                          // LM removing, not sure why we had this?
                          // var _this = ctx;
                          // var f = function (e) { fxn(e, _this); };
                          var f = fxn.bind(ctx);
                          ctx.elt.addEventListener(ev, f, false);
                          ctx._events[ev] = f;
                        }
                        
                        /**
                         * Helper fxn for sharing pixel methods
                         *
                         */
                        p5.Element.prototype._setProperty = function (prop, value) {
                          this[prop] = value;
                        };
                        
                        
                        module.exports = p5.Element;
                        
                        },{&quot;./core&quot;:48}],53:[function(_dereq_,module,exports){
                        /**
                         * @module Rendering
                         * @submodule Rendering
                         * @for p5
                         */
                        
                        var p5 = _dereq_(&#x27;./core&#x27;);
                        var constants = _dereq_(&#x27;./constants&#x27;);
                        
                        /**
                         * Thin wrapper around a renderer, to be used for creating a
                         * graphics buffer object. Use this class if you need
                         * to draw into an off-screen graphics buffer. The two parameters define the
                         * width and height in pixels. The fields and methods for this class are
                         * extensive, but mirror the normal drawing API for p5.
                         *
                         * @class p5.Graphics
                         * @constructor
                         * @extends p5.Element
                         * @param {String} elt DOM node that is wrapped
                         * @param {Object} [pInst] pointer to p5 instance
                         * @param {Boolean} whether we&#x27;re using it as main canvas
                         */
                        p5.Graphics = function(w, h, renderer, pInst) {
                        
                          var r = renderer || constants.P2D;
                        
                          var c = document.createElement(&#x27;canvas&#x27;);
                          var node = this._userNode || document.body;
                          node.appendChild(c);
                        
                          p5.Element.call(this, c, pInst, false);
                          this._styles = [];
                          this.width = w;
                          this.height = h;
                          this._pixelDensity = pInst._pixelDensity;
                        
                          if (r === constants.WEBGL) {
                            this._renderer = new p5.Renderer3D(c, pInst, false);
                          } else {
                            this._renderer = new p5.Renderer2D(c, pInst, false);
                          }
                        
                          this._renderer.resize(w, h);
                          this._renderer._applyDefaults();
                        
                          pInst._elements.push(this);
                        
                          // bind methods and props of p5 to the new object
                          for (var p in p5.prototype) {
                            if (!this[p]) {
                              if (typeof p5.prototype[p] === &#x27;function&#x27;) {
                                this[p] = p5.prototype[p].bind(this);
                              } else {
                                this[p] = p5.prototype[p];
                              }
                            }
                          }
                        
                          return this;
                        };
                        
                        p5.Graphics.prototype = Object.create(p5.Element.prototype);
                        
                        module.exports = p5.Graphics;
                        
                        },{&quot;./constants&quot;:47,&quot;./core&quot;:48}],54:[function(_dereq_,module,exports){
                        /**
                         * @module Rendering
                         * @submodule Rendering
                         * @for p5
                         */
                        
                        var p5 = _dereq_(&#x27;./core&#x27;);
                        var constants = _dereq_(&#x27;../core/constants&#x27;);
                        
                        /**
                         * Main graphics and rendering context, as well as the base API
                         * implementation for p5.js &quot;core&quot;. To be used as the superclass for
                         * Renderer2D and Renderer3D classes, respecitvely.
                         *
                         * @class p5.Renderer
                         * @constructor
                         * @extends p5.Element
                         * @param {String} elt DOM node that is wrapped
                         * @param {Object} [pInst] pointer to p5 instance
                         * @param {Boolean} whether we&#x27;re using it as main canvas
                         */
                        p5.Renderer = function(elt, pInst, isMainCanvas) {
                          p5.Element.call(this, elt, pInst);
                          this.canvas = elt;
                          this._pInst = pInst;
                          if (isMainCanvas) {
                            this._isMainCanvas = true;
                            // for pixel method sharing with pimage
                            this._pInst._setProperty(&#x27;_curElement&#x27;, this);
                            this._pInst._setProperty(&#x27;canvas&#x27;, this.canvas);
                            this._pInst._setProperty(&#x27;width&#x27;, this.width);
                            this._pInst._setProperty(&#x27;height&#x27;, this.height);
                          } else { // hide if offscreen buffer by default
                            this.canvas.style.display = &#x27;none&#x27;;
                            this._styles = []; // non-main elt styles stored in p5.Renderer
                          }
                        
                        
                          this._textSize = 12;
                          this._textLeading = 15;
                          this._textFont = &#x27;sans-serif&#x27;;
                          this._textStyle = constants.NORMAL;
                          this._textAscent = null;
                          this._textDescent = null;
                        
                        
                          this._rectMode = constants.CORNER;
                          this._ellipseMode = constants.CENTER;
                          this._curveTightness = 0;
                          this._imageMode = constants.CORNER;
                        
                          this._tint = null;
                          this._doStroke = true;
                          this._doFill = true;
                          this._strokeSet = false;
                          this._fillSet = false;
                          this._colorMode = constants.RGB;
                          this._colorMaxes = {
                            rgb: [255, 255, 255, 255],
                            hsb: [360, 100, 100, 1],
                            hsl: [360, 100, 100, 1]
                          };
                        
                        };
                        
                        p5.Renderer.prototype = Object.create(p5.Element.prototype);
                        
                        
                        
                        
                        /**
                         * Resize our canvas element.
                         */
                        p5.Renderer.prototype.resize = function(w, h) {
                          this.width = w;
                          this.height = h;
                          this.elt.width = w * this._pInst._pixelDensity;
                          this.elt.height = h * this._pInst._pixelDensity;
                          this.elt.style.width = w +&#x27;px&#x27;;
                          this.elt.style.height = h + &#x27;px&#x27;;
                          if (this._isMainCanvas) {
                            this._pInst._setProperty(&#x27;width&#x27;, this.width);
                            this._pInst._setProperty(&#x27;height&#x27;, this.height);
                          }
                        };
                        
                        p5.Renderer.prototype.textLeading = function(l) {
                        
                          if (arguments.length &amp;&amp; arguments[0]) {
                        
                            this._setProperty(&#x27;_textLeading&#x27;, l);
                            return this;
                          }
                        
                          return this._textLeading;
                        };
                        
                        p5.Renderer.prototype.textSize = function(s) {
                        
                          if (arguments.length &amp;&amp; arguments[0]) {
                        
                            this._setProperty(&#x27;_textSize&#x27;, s);
                            this._setProperty(&#x27;_textLeading&#x27;, s * constants._DEFAULT_LEADMULT);
                            return this._applyTextProperties();
                          }
                        
                          return this._textSize;
                        };
                        
                        p5.Renderer.prototype.textStyle = function(s) {
                        
                          if (arguments.length &amp;&amp; arguments[0]) {
                        
                            if (s === constants.NORMAL ||
                              s === constants.ITALIC ||
                              s === constants.BOLD) {
                              this._setProperty(&#x27;_textStyle&#x27;, s);
                            }
                        
                            return this._applyTextProperties();
                          }
                        
                          return this._textStyle;
                        };
                        
                        p5.Renderer.prototype.textAscent = function() {
                          if (this._textAscent === null) {
                            this._updateTextMetrics();
                          }
                          return this._textAscent;
                        };
                        
                        p5.Renderer.prototype.textDescent = function() {
                        
                          if (this._textDescent === null) {
                            this._updateTextMetrics();
                          }
                          return this._textDescent;
                        };
                        
                        /**
                         * Helper fxn to check font type (system or otf)
                         */
                        p5.Renderer.prototype._isOpenType = function(f) {
                        
                          f = f || this._textFont;
                          return (typeof f === &#x27;object&#x27; &amp;&amp; f.font &amp;&amp; f.font.supported);
                        };
                        
                        p5.Renderer.prototype._updateTextMetrics = function() {
                        
                          if (this._isOpenType()) {
                        
                            this._setProperty(&#x27;_textAscent&#x27;, this._textFont._textAscent());
                            this._setProperty(&#x27;_textDescent&#x27;, this._textFont._textDescent());
                            return this;
                          }
                        
                          // Adapted from http://stackoverflow.com/a/25355178
                          var text = document.createElement(&#x27;span&#x27;);
                          text.style.fontFamily = this._textFont;
                          text.style.fontSize = this._textSize + &#x27;px&#x27;;
                          text.innerHTML = &#x27;ABCjgq|&#x27;;
                        
                          var block = document.createElement(&#x27;div&#x27;);
                          block.style.display = &#x27;inline-block&#x27;;
                          block.style.width = &#x27;1px&#x27;;
                          block.style.height = &#x27;0px&#x27;;
                        
                          var container = document.createElement(&#x27;div&#x27;);
                          container.appendChild(text);
                          container.appendChild(block);
                        
                          container.style.height = &#x27;0px&#x27;;
                          container.style.overflow = &#x27;hidden&#x27;;
                          document.body.appendChild(container);
                        
                          block.style.verticalAlign = &#x27;baseline&#x27;;
                          var blockOffset = calculateOffset(block);
                          var textOffset = calculateOffset(text);
                          var ascent = blockOffset[1] - textOffset[1];
                        
                          block.style.verticalAlign = &#x27;bottom&#x27;;
                          blockOffset = calculateOffset(block);
                          textOffset = calculateOffset(text);
                          var height = blockOffset[1] - textOffset[1];
                          var descent = height - ascent;
                        
                          document.body.removeChild(container);
                        
                          this._setProperty(&#x27;_textAscent&#x27;, ascent);
                          this._setProperty(&#x27;_textDescent&#x27;, descent);
                        
                          return this;
                        };
                        
                        /**
                         * Helper fxn to measure ascent and descent.
                         * Adapted from http://stackoverflow.com/a/25355178
                         */
                        function calculateOffset(object) {
                          var currentLeft = 0,
                            currentTop = 0;
                          if (object.offsetParent) {
                            do {
                              currentLeft += object.offsetLeft;
                              currentTop += object.offsetTop;
                            } while (object = object.offsetParent);
                          } else {
                            currentLeft += object.offsetLeft;
                            currentTop += object.offsetTop;
                          }
                          return [currentLeft, currentTop];
                        }
                        
                        module.exports = p5.Renderer;
                        
                        },{&quot;../core/constants&quot;:47,&quot;./core&quot;:48}],55:[function(_dereq_,module,exports){
                        
                        var p5 = _dereq_(&#x27;./core&#x27;);
                        var canvas = _dereq_(&#x27;./canvas&#x27;);
                        var constants = _dereq_(&#x27;./constants&#x27;);
                        var filters = _dereq_(&#x27;../image/filters&#x27;);
                        
                        _dereq_(&#x27;./p5.Renderer&#x27;);
                        
                        /**
                         * p5.Renderer2D
                         * The 2D graphics canvas renderer class.
                         * extends p5.Renderer
                         */
                        var styleEmpty = &#x27;rgba(0,0,0,0)&#x27;;
                        // var alphaThreshold = 0.00125; // minimum visible
                        
                        p5.Renderer2D = function(elt, pInst, isMainCanvas){
                          p5.Renderer.call(this, elt, pInst, isMainCanvas);
                          this.drawingContext = this.canvas.getContext(&#x27;2d&#x27;);
                          this._pInst._setProperty(&#x27;drawingContext&#x27;, this.drawingContext);
                          return this;
                        };
                        
                        p5.Renderer2D.prototype = Object.create(p5.Renderer.prototype);
                        
                        p5.Renderer2D.prototype._applyDefaults = function() {
                          this.drawingContext.fillStyle = constants._DEFAULT_FILL;
                          this.drawingContext.strokeStyle = constants._DEFAULT_STROKE;
                          this.drawingContext.lineCap = constants.ROUND;
                          this.drawingContext.font = &#x27;normal 12px sans-serif&#x27;;
                        };
                        
                        p5.Renderer2D.prototype.resize = function(w,h) {
                          p5.Renderer.prototype.resize.call(this, w,h);
                          this.drawingContext.scale(this._pInst._pixelDensity,
                                                    this._pInst._pixelDensity);
                        };
                        
                        //////////////////////////////////////////////
                        // COLOR | Setting
                        //////////////////////////////////////////////
                        
                        p5.Renderer2D.prototype.background = function() {
                          this.drawingContext.save();
                          this.drawingContext.setTransform(1, 0, 0, 1, 0, 0);
                          this.drawingContext.scale(this._pInst._pixelDensity,
                                                    this._pInst._pixelDensity);
                        
                          if (arguments[0] instanceof p5.Image) {
                            this._pInst.image(arguments[0], 0, 0, this.width, this.height);
                          } else {
                            var curFill = this.drawingContext.fillStyle;
                            // create background rect
                            var color = this._pInst.color.apply(this._pInst, arguments);
                            var newFill = color.toString();
                            this.drawingContext.fillStyle = newFill;
                            this.drawingContext.fillRect(0, 0, this.width, this.height);
                            // reset fill
                            this.drawingContext.fillStyle = curFill;
                          }
                          this.drawingContext.restore();
                        };
                        
                        p5.Renderer2D.prototype.clear = function() {
                          this.drawingContext.clearRect(0, 0, this.width, this.height);
                        };
                        
                        p5.Renderer2D.prototype.fill = function() {
                        
                          var ctx = this.drawingContext;
                          var color = this._pInst.color.apply(this._pInst, arguments);
                          ctx.fillStyle = color.toString();
                        };
                        
                        p5.Renderer2D.prototype.stroke = function() {
                          var ctx = this.drawingContext;
                          var color = this._pInst.color.apply(this._pInst, arguments);
                          ctx.strokeStyle = color.toString();
                        };
                        
                        //////////////////////////////////////////////
                        // IMAGE | Loading &amp; Displaying
                        //////////////////////////////////////////////
                        
                        p5.Renderer2D.prototype.image =
                          function (img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
                          var cnv;
                          try {
                            if (this._tint) {
                              if (p5.MediaElement &amp;&amp; img instanceof p5.MediaElement) {
                                img.loadPixels();
                              }
                              if (img.canvas) {
                                cnv = this._getTintedImageCanvas(img);
                              }
                            }
                            if (!cnv) {
                              cnv = img.canvas || img.elt;
                            }
                            this.drawingContext.drawImage(cnv, sx, sy, sWidth, sHeight, dx, dy,
                              dWidth, dHeight);
                          } catch (e) {
                            if (e.name !== &#x27;NS_ERROR_NOT_AVAILABLE&#x27;) {
                              throw e;
                            }
                          }
                        };
                        
                        p5.Renderer2D.prototype._getTintedImageCanvas = function (img) {
                          if (!img.canvas) {
                            return img;
                          }
                          var pixels = filters._toPixels(img.canvas);
                          var tmpCanvas = document.createElement(&#x27;canvas&#x27;);
                          tmpCanvas.width = img.canvas.width;
                          tmpCanvas.height = img.canvas.height;
                          var tmpCtx = tmpCanvas.getContext(&#x27;2d&#x27;);
                          var id = tmpCtx.createImageData(img.canvas.width, img.canvas.height);
                          var newPixels = id.data;
                          for (var i = 0; i &lt; pixels.length; i += 4) {
                            var r = pixels[i];
                            var g = pixels[i + 1];
                            var b = pixels[i + 2];
                            var a = pixels[i + 3];
                            newPixels[i] = r * this._tint[0] / 255;
                            newPixels[i + 1] = g * this._tint[1] / 255;
                            newPixels[i + 2] = b * this._tint[2] / 255;
                            newPixels[i + 3] = a * this._tint[3] / 255;
                          }
                          tmpCtx.putImageData(id, 0, 0);
                          return tmpCanvas;
                        };
                        
                        
                        //////////////////////////////////////////////
                        // IMAGE | Pixels
                        //////////////////////////////////////////////
                        
                        p5.Renderer2D.prototype.blendMode = function(mode) {
                          this.drawingContext.globalCompositeOperation = mode;
                        };
                        p5.Renderer2D.prototype.blend = function() {
                          var currBlend = this.drawingContext.globalCompositeOperation;
                          var blendMode = arguments[arguments.length - 1];
                        
                          var copyArgs = Array.prototype.slice.call(
                            arguments,
                            0,
                            arguments.length - 1
                          );
                        
                          this.drawingContext.globalCompositeOperation = blendMode;
                          this._pInst.copy.apply(this._pInst, copyArgs);
                          this.drawingContext.globalCompositeOperation = currBlend;
                        };
                        
                        p5.Renderer2D.prototype.copy = function () {
                          var srcImage, sx, sy, sw, sh, dx, dy, dw, dh;
                          if (arguments.length === 9) {
                            srcImage = arguments[0];
                            sx = arguments[1];
                            sy = arguments[2];
                            sw = arguments[3];
                            sh = arguments[4];
                            dx = arguments[5];
                            dy = arguments[6];
                            dw = arguments[7];
                            dh = arguments[8];
                          } else if (arguments.length === 8) {
                            srcImage = this._pInst;
                            sx = arguments[0];
                            sy = arguments[1];
                            sw = arguments[2];
                            sh = arguments[3];
                            dx = arguments[4];
                            dy = arguments[5];
                            dw = arguments[6];
                            dh = arguments[7];
                          } else {
                            throw new Error(&#x27;Signature not supported&#x27;);
                          }
                          p5.Renderer2D._copyHelper(srcImage, sx, sy, sw, sh, dx, dy, dw, dh);
                        };
                        
                        p5.Renderer2D._copyHelper =
                        function (srcImage, sx, sy, sw, sh, dx, dy, dw, dh) {
                          var s = srcImage.canvas.width / srcImage.width;
                          this.drawingContext.drawImage(srcImage.canvas,
                            s * sx, s * sy, s * sw, s * sh, dx, dy, dw, dh);
                        };
                        
                        p5.Renderer2D.prototype.get = function(x, y, w, h) {
                          if (x === undefined &amp;&amp; y === undefined &amp;&amp;
                              w === undefined &amp;&amp; h === undefined){
                            x = 0;
                            y = 0;
                            w = this.width;
                            h = this.height;
                          } else if (w === undefined &amp;&amp; h === undefined) {
                            w = 1;
                            h = 1;
                          }
                        
                          // if the section does not overlap the canvas
                          if(x + w &lt; 0 || y + h &lt; 0 || x &gt; this.width || y &gt; this.height){
                            return [0, 0, 0, 255];
                          }
                        
                          var ctx = this._pInst || this;
                        
                          var pd = ctx._pixelDensity;
                        
                          this.loadPixels.call(ctx);
                        
                          // round down to get integer numbers
                          x = Math.floor(x);
                          y = Math.floor(y);
                        
                          if (w === 1 &amp;&amp; h === 1){
                        
                            return [
                              ctx.pixels[pd*4*(y*this.width+x)],
                              ctx.pixels[pd*(4*(y*this.width+x)+1)],
                              ctx.pixels[pd*(4*(y*this.width+x)+2)],
                              ctx.pixels[pd*(4*(y*this.width+x)+3)]
                            ];
                          } else {
                            var sx = x * pd;
                            var sy = y * pd;
                            //auto constrain the width and height to
                            //dimensions of the source image
                            var dw = Math.min(w, ctx.width);
                            var dh = Math.min(h, ctx.height);
                            var sw = dw * pd;
                            var sh = dh * pd;
                        
                            var region = new p5.Image(dw, dh);
                            region.canvas.getContext(&#x27;2d&#x27;).drawImage(this.canvas, sx, sy, sw, sh,
                              0, 0, dw, dh);
                        
                            return region;
                          }
                        };
                        
                        p5.Renderer2D.prototype.loadPixels = function () {
                          var pd = this._pixelDensity || this._pInst._pixelDensity;
                          var w = this.width * pd;
                          var h = this.height * pd;
                          var imageData = this.drawingContext.getImageData(0, 0, w, h);
                          // @todo this should actually set pixels per object, so diff buffers can
                          // have diff pixel arrays.
                          if (this._pInst) {
                            this._pInst._setProperty(&#x27;imageData&#x27;, imageData);
                            this._pInst._setProperty(&#x27;pixels&#x27;, imageData.data);
                          } else { // if called by p5.Image
                            this._setProperty(&#x27;imageData&#x27;, imageData);
                            this._setProperty(&#x27;pixels&#x27;, imageData.data);
                          }
                        };
                        
                        p5.Renderer2D.prototype.set = function (x, y, imgOrCol) {
                          // round down to get integer numbers
                          x = Math.floor(x);
                          y = Math.floor(y);
                          if (imgOrCol instanceof p5.Image) {
                            this.drawingContext.save();
                            this.drawingContext.setTransform(1, 0, 0, 1, 0, 0);
                            this.drawingContext.scale(this._pInst._pixelDensity,
                              this._pInst._pixelDensity);
                            this.drawingContext.drawImage(imgOrCol.canvas, x, y);
                            this.loadPixels.call(this._pInst);
                            this.drawingContext.restore();
                          } else {
                            var ctx = this._pInst || this;
                            var r = 0, g = 0, b = 0, a = 0;
                            var idx = 4*((y * ctx._pixelDensity) *
                              (this.width * ctx._pixelDensity) + (x * ctx._pixelDensity));
                            if (!ctx.imageData) {
                              ctx.loadPixels.call(ctx);
                            }
                            if (typeof imgOrCol === &#x27;number&#x27;) {
                              if (idx &lt; ctx.pixels.length) {
                                r = imgOrCol;
                                g = imgOrCol;
                                b = imgOrCol;
                                a = 255;
                                //this.updatePixels.call(this);
                              }
                            }
                            else if (imgOrCol instanceof Array) {
                              if (imgOrCol.length &lt; 4) {
                                throw new Error(&#x27;pixel array must be of the form [R, G, B, A]&#x27;);
                              }
                              if (idx &lt; ctx.pixels.length) {
                                r = imgOrCol[0];
                                g = imgOrCol[1];
                                b = imgOrCol[2];
                                a = imgOrCol[3];
                                //this.updatePixels.call(this);
                              }
                            } else if (imgOrCol instanceof p5.Color) {
                              if (idx &lt; ctx.pixels.length) {
                                r = imgOrCol.levels[0];
                                g = imgOrCol.levels[1];
                                b = imgOrCol.levels[2];
                                a = imgOrCol.levels[3];
                                //this.updatePixels.call(this);
                              }
                            }
                            // loop over pixelDensity * pixelDensity
                            for (var i = 0; i &lt; ctx._pixelDensity; i++) {
                              for (var j = 0; j &lt; ctx._pixelDensity; j++) {
                                // loop over
                                idx = 4*((y * ctx._pixelDensity + j) * this.width *
                                  ctx._pixelDensity + (x * ctx._pixelDensity + i));
                                ctx.pixels[idx] = r;
                                ctx.pixels[idx+1] = g;
                                ctx.pixels[idx+2] = b;
                                ctx.pixels[idx+3] = a;
                              }
                            }
                          }
                        };
                        
                        p5.Renderer2D.prototype.updatePixels = function (x, y, w, h) {
                          var pd = this._pixelDensity || this._pInst._pixelDensity;
                          if (x === undefined &amp;&amp;
                              y === undefined &amp;&amp;
                              w === undefined &amp;&amp;
                              h === undefined) {
                            x = 0;
                            y = 0;
                            w = this.width;
                            h = this.height;
                          }
                          w *= pd;
                          h *= pd;
                        
                          if (this._pInst) {
                            this.drawingContext.putImageData(this._pInst.imageData, x, y, 0, 0, w, h);
                          } else {
                            this.drawingContext.putImageData(this.imageData, x, y, 0, 0, w, h);
                          }
                        };
                        
                        //////////////////////////////////////////////
                        // SHAPE | 2D Primitives
                        //////////////////////////////////////////////
                        
                        /**
                         * Generate a cubic Bezier representing an arc on the unit circle of total
                         * angle &#x60;size&#x60; radians, beginning &#x60;start&#x60; radians above the x-axis. Up to
                         * four of these curves are combined to make a full arc.
                         *
                         * See www.joecridge.me/bezier.pdf for an explanation of the method.
                         */
                        p5.Renderer2D.prototype._acuteArcToBezier =
                          function _acuteArcToBezier(start, size) {
                          // Evauate constants.
                          var alpha = size / 2.0,
                            cos_alpha = Math.cos(alpha),
                            sin_alpha = Math.sin(alpha),
                            cot_alpha = 1.0 / Math.tan(alpha),
                            phi = start + alpha,  // This is how far the arc needs to be rotated.
                            cos_phi = Math.cos(phi),
                            sin_phi = Math.sin(phi),
                            lambda = (4.0 - cos_alpha) / 3.0,
                            mu = sin_alpha + (cos_alpha - lambda) * cot_alpha;
                        
                          // Return rotated waypoints.
                          return {
                            ax: Math.cos(start),
                            ay: Math.sin(start),
                            bx: lambda * cos_phi + mu * sin_phi,
                            by: lambda * sin_phi - mu * cos_phi,
                            cx: lambda * cos_phi - mu * sin_phi,
                            cy: lambda * sin_phi + mu * cos_phi,
                            dx: Math.cos(start + size),
                            dy: Math.sin(start + size)
                          };
                        };
                        
                        p5.Renderer2D.prototype.arc =
                          function(x, y, w, h, start, stop, mode) {
                          var ctx = this.drawingContext;
                          var vals = canvas.arcModeAdjust(x, y, w, h, this._ellipseMode);
                          var rx = vals.w / 2.0;
                          var ry = vals.h / 2.0;
                          var epsilon = 0.00001;  // Smallest visible angle on displays up to 4K.
                          var arcToDraw = 0;
                          var curves = [];
                        
                          // Create curves
                          while(stop - start &gt; epsilon) {
                            arcToDraw = Math.min(stop - start, constants.HALF_PI);
                            curves.push(this._acuteArcToBezier(start, arcToDraw));
                            start += arcToDraw;
                          }
                        
                          // Fill curves
                          if (this._doFill) {
                            ctx.beginPath();
                            curves.forEach(function (curve, index) {
                              if (index === 0) {
                                ctx.moveTo(vals.x + curve.ax * rx, vals.y + curve.ay * ry);
                              }
                              ctx.bezierCurveTo(vals.x + curve.bx * rx, vals.y + curve.by * ry,
                                                vals.x + curve.cx * rx, vals.y + curve.cy * ry,
                                                vals.x + curve.dx * rx, vals.y + curve.dy * ry);
                            });
                            if (mode === constants.PIE || mode == null) {
                              ctx.lineTo(vals.x, vals.y);
                            }
                            ctx.closePath();
                            ctx.fill();
                          }
                        
                          // Stroke curves
                          if (this._doStroke) {
                            ctx.beginPath();
                            curves.forEach(function (curve, index) {
                              if (index === 0) {
                                ctx.moveTo(vals.x + curve.ax * rx, vals.y + curve.ay * ry);
                              }
                              ctx.bezierCurveTo(vals.x + curve.bx * rx, vals.y + curve.by * ry,
                                                vals.x + curve.cx * rx, vals.y + curve.cy * ry,
                                                vals.x + curve.dx * rx, vals.y + curve.dy * ry);
                            });
                            if (mode === constants.PIE) {
                              ctx.lineTo(vals.x, vals.y);
                              ctx.closePath();
                            } else if (mode === constants.CHORD) {
                              ctx.closePath();
                            }
                            ctx.stroke();
                          }
                          return this;
                        };
                        
                        p5.Renderer2D.prototype.ellipse = function(x, y, w, h) {
                          var ctx = this.drawingContext;
                          var doFill = this._doFill, doStroke = this._doStroke;
                          if (doFill &amp;&amp; !doStroke) {
                            if(ctx.fillStyle === styleEmpty) {
                              return this;
                            }
                          } else if (!doFill &amp;&amp; doStroke) {
                            if(ctx.strokeStyle === styleEmpty) {
                              return this;
                            }
                          }
                          var vals = canvas.modeAdjust(x, y, w, h, this._ellipseMode);
                          var kappa = 0.5522847498,
                            ox = (vals.w / 2) * kappa, // control point offset horizontal
                            oy = (vals.h / 2) * kappa, // control point offset vertical
                            xe = vals.x + vals.w,      // x-end
                            ye = vals.y + vals.h,      // y-end
                            xm = vals.x + vals.w / 2,  // x-middle
                            ym = vals.y + vals.h / 2;  // y-middle
                          ctx.beginPath();
                          ctx.moveTo(vals.x, ym);
                          ctx.bezierCurveTo(vals.x, ym - oy, xm - ox, vals.y, xm, vals.y);
                          ctx.bezierCurveTo(xm + ox, vals.y, xe, ym - oy, xe, ym);
                          ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                          ctx.bezierCurveTo(xm - ox, ye, vals.x, ym + oy, vals.x, ym);
                          ctx.closePath();
                          if (doFill) {
                            ctx.fill();
                          }
                          if (doStroke) {
                            ctx.stroke();
                          }
                        };
                        
                        p5.Renderer2D.prototype.line = function(x1, y1, x2, y2) {
                          var ctx = this.drawingContext;
                          if (!this._doStroke) {
                            return this;
                          } else if(ctx.strokeStyle === styleEmpty){
                            return this;
                          }
                          // Translate the line by (0.5, 0.5) to draw it crisp
                          if (ctx.lineWidth % 2 === 1) {
                            ctx.translate(0.5, 0.5);
                          }
                          ctx.beginPath();
                          ctx.moveTo(x1, y1);
                          ctx.lineTo(x2, y2);
                          ctx.stroke();
                          if (ctx.lineWidth % 2 === 1) {
                            ctx.translate(-0.5, -0.5);
                          }
                          return this;
                        };
                        
                        p5.Renderer2D.prototype.point = function(x, y) {
                          var ctx = this.drawingContext;
                          var s = ctx.strokeStyle;
                          var f = ctx.fillStyle;
                          if (!this._doStroke) {
                            return this;
                          } else if(ctx.strokeStyle === styleEmpty){
                            return this;
                          }
                          x = Math.round(x);
                          y = Math.round(y);
                          ctx.fillStyle = s;
                          if (ctx.lineWidth &gt; 1) {
                            ctx.beginPath();
                            ctx.arc(
                              x,
                              y,
                              ctx.lineWidth / 2,
                              0,
                              constants.TWO_PI,
                              false
                            );
                            ctx.fill();
                          } else {
                            ctx.fillRect(x, y, 1, 1);
                          }
                          ctx.fillStyle = f;
                        };
                        
                        p5.Renderer2D.prototype.quad =
                          function(x1, y1, x2, y2, x3, y3, x4, y4) {
                          var ctx = this.drawingContext;
                          var doFill = this._doFill, doStroke = this._doStroke;
                          if (doFill &amp;&amp; !doStroke) {
                            if(ctx.fillStyle === styleEmpty) {
                              return this;
                            }
                          } else if (!doFill &amp;&amp; doStroke) {
                            if(ctx.strokeStyle === styleEmpty) {
                              return this;
                            }
                          }
                          ctx.beginPath();
                          ctx.moveTo(x1, y1);
                          ctx.lineTo(x2, y2);
                          ctx.lineTo(x3, y3);
                          ctx.lineTo(x4, y4);
                          ctx.closePath();
                          if (doFill) {
                            ctx.fill();
                          }
                          if (doStroke) {
                            ctx.stroke();
                          }
                          return this;
                        };
                        
                        p5.Renderer2D.prototype.rect = function(x, y, w, h, tl, tr, br, bl) {
                          var ctx = this.drawingContext;
                          var doFill = this._doFill, doStroke = this._doStroke;
                          if (doFill &amp;&amp; !doStroke) {
                            if(ctx.fillStyle === styleEmpty) {
                              return this;
                            }
                          } else if (!doFill &amp;&amp; doStroke) {
                            if(ctx.strokeStyle === styleEmpty) {
                              return this;
                            }
                          }
                          var vals = canvas.modeAdjust(x, y, w, h, this._rectMode);
                          // Translate the line by (0.5, 0.5) to draw a crisp rectangle border
                          if (this._doStroke &amp;&amp; ctx.lineWidth % 2 === 1) {
                            ctx.translate(0.5, 0.5);
                          }
                          ctx.beginPath();
                        
                          if (typeof tl === &#x27;undefined&#x27;) {
                            // No rounded corners
                            ctx.rect(vals.x, vals.y, vals.w, vals.h);
                          } else {
                            // At least one rounded corner
                            // Set defaults when not specified
                            if (typeof tr === &#x27;undefined&#x27;) { tr = tl; }
                            if (typeof br === &#x27;undefined&#x27;) { br = tr; }
                            if (typeof bl === &#x27;undefined&#x27;) { bl = br; }
                        
                            // Cache and compute several values
                            var _x = vals.x;
                            var _y = vals.y;
                            var _w = vals.w;
                            var _h = vals.h;
                            var hw = _w / 2;
                            var hh = _h / 2;
                        
                            // Clip radii
                            if (_w &lt; 2 * tl) { tl = hw; }
                            if (_h &lt; 2 * tl) { tl = hh; }
                            if (_w &lt; 2 * tr) { tr = hw; }
                            if (_h &lt; 2 * tr) { tr = hh; }
                            if (_w &lt; 2 * br) { br = hw; }
                            if (_h &lt; 2 * br) { br = hh; }
                            if (_w &lt; 2 * bl) { bl = hw; }
                            if (_h &lt; 2 * bl) { bl = hh; }
                        
                            // Draw shape
                            ctx.beginPath();
                            ctx.moveTo(_x + tl, _y);
                            ctx.arcTo(_x + _w, _y, _x + _w, _y + _h, tr);
                            ctx.arcTo(_x + _w, _y + _h, _x, _y + _h, br);
                            ctx.arcTo(_x, _y + _h, _x, _y, bl);
                            ctx.arcTo(_x, _y, _x + _w, _y, tl);
                            ctx.closePath();
                          }
                          if (this._doFill) {
                            ctx.fill();
                          }
                          if (this._doStroke) {
                            ctx.stroke();
                          }
                          if (this._doStroke &amp;&amp; ctx.lineWidth % 2 === 1) {
                            ctx.translate(-0.5, -0.5);
                          }
                          return this;
                        };
                        
                        p5.Renderer2D.prototype.triangle = function(x1, y1, x2, y2, x3, y3) {
                          var ctx = this.drawingContext;
                          var doFill = this._doFill, doStroke = this._doStroke;
                          if (doFill &amp;&amp; !doStroke) {
                            if(ctx.fillStyle === styleEmpty) {
                              return this;
                            }
                          } else if (!doFill &amp;&amp; doStroke) {
                            if(ctx.strokeStyle === styleEmpty) {
                              return this;
                            }
                          }
                          ctx.beginPath();
                          ctx.moveTo(x1, y1);
                          ctx.lineTo(x2, y2);
                          ctx.lineTo(x3, y3);
                          ctx.closePath();
                          if (doFill) {
                            ctx.fill();
                          }
                          if (doStroke) {
                            ctx.stroke();
                          }
                        };
                        
                        p5.Renderer2D.prototype.endShape =
                        function (mode, vertices, isCurve, isBezier,
                            isQuadratic, isContour, shapeKind) {
                          if (vertices.length === 0) {
                            return this;
                          }
                          if (!this._doStroke &amp;&amp; !this._doFill) {
                            return this;
                          }
                          var closeShape = mode === constants.CLOSE;
                          var v;
                          if (closeShape &amp;&amp; !isContour) {
                            vertices.push(vertices[0]);
                          }
                          var i, j;
                          var numVerts = vertices.length;
                          if (isCurve &amp;&amp; (shapeKind === constants.POLYGON || shapeKind === null)) {
                            if (numVerts &gt; 3) {
                              var b = [], s = 1 - this._curveTightness;
                              this.drawingContext.beginPath();
                              this.drawingContext.moveTo(vertices[1][0], vertices[1][1]);
                              for (i = 1; i + 2 &lt; numVerts; i++) {
                                v = vertices[i];
                                b[0] = [
                                  v[0],
                                  v[1]
                                ];
                                b[1] = [
                                  v[0] + (s * vertices[i + 1][0] - s * vertices[i - 1][0]) / 6,
                                  v[1] + (s * vertices[i + 1][1] - s * vertices[i - 1][1]) / 6
                                ];
                                b[2] = [
                                  vertices[i + 1][0] +
                                  (s * vertices[i][0]-s * vertices[i + 2][0]) / 6,
                                  vertices[i + 1][1]+(s * vertices[i][1] - s*vertices[i + 2][1]) / 6
                                ];
                                b[3] = [
                                  vertices[i + 1][0],
                                  vertices[i + 1][1]
                                ];
                                this.drawingContext.bezierCurveTo(b[1][0],b[1][1],
                                  b[2][0],b[2][1],b[3][0],b[3][1]);
                              }
                              if (closeShape) {
                                this.drawingContext.lineTo(vertices[i + 1][0], vertices[i + 1][1]);
                              }
                              this._doFillStrokeClose();
                            }
                          } else if (isBezier&amp;&amp;(shapeKind===constants.POLYGON ||shapeKind === null)) {
                            this.drawingContext.beginPath();
                            for (i = 0; i &lt; numVerts; i++) {
                              if (vertices[i].isVert) {
                                if (vertices[i].moveTo) {
                                  this.drawingContext.moveTo(vertices[i][0], vertices[i][1]);
                                } else {
                                  this.drawingContext.lineTo(vertices[i][0], vertices[i][1]);
                                }
                              } else {
                                this.drawingContext.bezierCurveTo(vertices[i][0], vertices[i][1],
                                  vertices[i][2], vertices[i][3], vertices[i][4], vertices[i][5]);
                              }
                            }
                            this._doFillStrokeClose();
                          } else if (isQuadratic &amp;&amp;
                            (shapeKind === constants.POLYGON || shapeKind === null)) {
                            this.drawingContext.beginPath();
                            for (i = 0; i &lt; numVerts; i++) {
                              if (vertices[i].isVert) {
                                if (vertices[i].moveTo) {
                                  this.drawingContext.moveTo([0], vertices[i][1]);
                                } else {
                                  this.drawingContext.lineTo(vertices[i][0], vertices[i][1]);
                                }
                              } else {
                                this.drawingContext.quadraticCurveTo(vertices[i][0], vertices[i][1],
                                  vertices[i][2], vertices[i][3]);
                              }
                            }
                            this._doFillStrokeClose();
                          } else {
                            if (shapeKind === constants.POINTS) {
                              for (i = 0; i &lt; numVerts; i++) {
                                v = vertices[i];
                                if (this._doStroke) {
                                  this._pInst.stroke(v[6]);
                                }
                                this._pInst.point(v[0], v[1]);
                              }
                            } else if (shapeKind === constants.LINES) {
                              for (i = 0; i + 1 &lt; numVerts; i += 2) {
                                v = vertices[i];
                                if (this._doStroke) {
                                  this._pInst.stroke(vertices[i + 1][6]);
                                }
                                this._pInst.line(v[0], v[1], vertices[i + 1][0], vertices[i + 1][1]);
                              }
                            } else if (shapeKind === constants.TRIANGLES) {
                              for (i = 0; i + 2 &lt; numVerts; i += 3) {
                                v = vertices[i];
                                this.drawingContext.beginPath();
                                this.drawingContext.moveTo(v[0], v[1]);
                                this.drawingContext.lineTo(vertices[i + 1][0], vertices[i + 1][1]);
                                this.drawingContext.lineTo(vertices[i + 2][0], vertices[i + 2][1]);
                                this.drawingContext.lineTo(v[0], v[1]);
                                if (this._doFill) {
                                  this._pInst.fill(vertices[i + 2][5]);
                                  this.drawingContext.fill();
                                }
                                if (this._doStroke) {
                                  this._pInst.stroke(vertices[i + 2][6]);
                                  this.drawingContext.stroke();
                                }
                                this.drawingContext.closePath();
                              }
                            } else if (shapeKind === constants.TRIANGLE_STRIP) {
                              for (i = 0; i + 1 &lt; numVerts; i++) {
                                v = vertices[i];
                                this.drawingContext.beginPath();
                                this.drawingContext.moveTo(vertices[i + 1][0], vertices[i + 1][1]);
                                this.drawingContext.lineTo(v[0], v[1]);
                                if (this._doStroke) {
                                  this._pInst.stroke(vertices[i + 1][6]);
                                }
                                if (this._doFill) {
                                  this._pInst.fill(vertices[i + 1][5]);
                                }
                                if (i + 2 &lt; numVerts) {
                                  this.drawingContext.lineTo(vertices[i + 2][0], vertices[i + 2][1]);
                                  if (this._doStroke) {
                                    this._pInst.stroke(vertices[i + 2][6]);
                                  }
                                  if (this._doFill) {
                                    this._pInst.fill(vertices[i + 2][5]);
                                  }
                                }
                                this._doFillStrokeClose();
                              }
                            } else if (shapeKind === constants.TRIANGLE_FAN) {
                              if (numVerts &gt; 2) {
                                this.drawingContext.beginPath();
                                this.drawingContext.moveTo(vertices[0][0], vertices[0][1]);
                                this.drawingContext.lineTo(vertices[1][0], vertices[1][1]);
                                this.drawingContext.lineTo(vertices[2][0], vertices[2][1]);
                                if (this._doFill) {
                                  this._pInst.fill(vertices[2][5]);
                                }
                                if (this._doStroke) {
                                  this._pInst.stroke(vertices[2][6]);
                                }
                                this._doFillStrokeClose();
                                for (i = 3; i &lt; numVerts; i++) {
                                  v = vertices[i];
                                  this.drawingContext.beginPath();
                                  this.drawingContext.moveTo(vertices[0][0], vertices[0][1]);
                                  this.drawingContext.lineTo(vertices[i - 1][0], vertices[i - 1][1]);
                                  this.drawingContext.lineTo(v[0], v[1]);
                                  if (this._doFill) {
                                    this._pInst.fill(v[5]);
                                  }
                                  if (this._doStroke) {
                                    this._pInst.stroke(v[6]);
                                  }
                                  this._doFillStrokeClose();
                                }
                              }
                            } else if (shapeKind === constants.QUADS) {
                              for (i = 0; i + 3 &lt; numVerts; i += 4) {
                                v = vertices[i];
                                this.drawingContext.beginPath();
                                this.drawingContext.moveTo(v[0], v[1]);
                                for (j = 1; j &lt; 4; j++) {
                                  this.drawingContext.lineTo(vertices[i + j][0], vertices[i + j][1]);
                                }
                                this.drawingContext.lineTo(v[0], v[1]);
                                if (this._doFill) {
                                  this._pInst.fill(vertices[i + 3][5]);
                                }
                                if (this._doStroke) {
                                  this._pInst.stroke(vertices[i + 3][6]);
                                }
                                this._doFillStrokeClose();
                              }
                            } else if (shapeKind === constants.QUAD_STRIP) {
                              if (numVerts &gt; 3) {
                                for (i = 0; i + 1 &lt; numVerts; i += 2) {
                                  v = vertices[i];
                                  this.drawingContext.beginPath();
                                  if (i + 3 &lt; numVerts) {
                                    this.drawingContext.moveTo(vertices[i + 2][0], vertices[i+2][1]);
                                    this.drawingContext.lineTo(v[0], v[1]);
                                    this.drawingContext.lineTo(vertices[i + 1][0], vertices[i+1][1]);
                                    this.drawingContext.lineTo(vertices[i + 3][0], vertices[i+3][1]);
                                    if (this._doFill) {
                                      this._pInst.fill(vertices[i + 3][5]);
                                    }
                                    if (this._doStroke) {
                                      this._pInst.stroke(vertices[i + 3][6]);
                                    }
                                  } else {
                                    this.drawingContext.moveTo(v[0], v[1]);
                                    this.drawingContext.lineTo(vertices[i + 1][0], vertices[i+1][1]);
                                  }
                                  this._doFillStrokeClose();
                                }
                              }
                            } else {
                              this.drawingContext.beginPath();
                              this.drawingContext.moveTo(vertices[0][0], vertices[0][1]);
                              for (i = 1; i &lt; numVerts; i++) {
                                v = vertices[i];
                                if (v.isVert) {
                                  if (v.moveTo) {
                                    this.drawingContext.moveTo(v[0], v[1]);
                                  } else {
                                    this.drawingContext.lineTo(v[0], v[1]);
                                  }
                                }
                              }
                              this._doFillStrokeClose();
                            }
                          }
                          isCurve = false;
                          isBezier = false;
                          isQuadratic = false;
                          isContour = false;
                          if (closeShape) {
                            vertices.pop();
                          }
                          return this;
                        };
                        //////////////////////////////////////////////
                        // SHAPE | Attributes
                        //////////////////////////////////////////////
                        
                        p5.Renderer2D.prototype.noSmooth = function() {
                          if (&#x27;imageSmoothingEnabled&#x27; in this.drawingContext) {
                            this.drawingContext.imageSmoothingEnabled = false;
                          }
                          else if (&#x27;mozImageSmoothingEnabled&#x27; in this.drawingContext) {
                            this.drawingContext.mozImageSmoothingEnabled = false;
                          }
                          else if (&#x27;webkitImageSmoothingEnabled&#x27; in this.drawingContext) {
                            this.drawingContext.webkitImageSmoothingEnabled = false;
                          }
                          else if (&#x27;msImageSmoothingEnabled&#x27; in this.drawingContext) {
                            this.drawingContext.msImageSmoothingEnabled = false;
                          }
                          return this;
                        };
                        
                        p5.Renderer2D.prototype.smooth = function() {
                          if (&#x27;imageSmoothingEnabled&#x27; in this.drawingContext) {
                            this.drawingContext.imageSmoothingEnabled = true;
                          }
                          else if (&#x27;mozImageSmoothingEnabled&#x27; in this.drawingContext) {
                            this.drawingContext.mozImageSmoothingEnabled = true;
                          }
                          else if (&#x27;webkitImageSmoothingEnabled&#x27; in this.drawingContext) {
                            this.drawingContext.webkitImageSmoothingEnabled = true;
                          }
                          else if (&#x27;msImageSmoothingEnabled&#x27; in this.drawingContext) {
                            this.drawingContext.msImageSmoothingEnabled = true;
                          }
                          return this;
                        };
                        
                        p5.Renderer2D.prototype.strokeCap = function(cap) {
                          if (cap === constants.ROUND ||
                            cap === constants.SQUARE ||
                            cap === constants.PROJECT) {
                            this.drawingContext.lineCap = cap;
                          }
                          return this;
                        };
                        
                        p5.Renderer2D.prototype.strokeJoin = function(join) {
                          if (join === constants.ROUND ||
                            join === constants.BEVEL ||
                            join === constants.MITER) {
                            this.drawingContext.lineJoin = join;
                          }
                          return this;
                        };
                        
                        p5.Renderer2D.prototype.strokeWeight = function(w) {
                          if (typeof w === &#x27;undefined&#x27; || w === 0) {
                            // hack because lineWidth 0 doesn&#x27;t work
                            this.drawingContext.lineWidth = 0.0001;
                          } else {
                            this.drawingContext.lineWidth = w;
                          }
                          return this;
                        };
                        
                        p5.Renderer2D.prototype._getFill = function(){
                          return this.drawingContext.fillStyle;
                        };
                        
                        p5.Renderer2D.prototype._getStroke = function(){
                          return this.drawingContext.strokeStyle;
                        };
                        
                        //////////////////////////////////////////////
                        // SHAPE | Curves
                        //////////////////////////////////////////////
                        p5.Renderer2D.prototype.bezier = function (x1, y1, x2, y2, x3, y3, x4, y4) {
                          this._pInst.beginShape();
                          this._pInst.vertex(x1, y1);
                          this._pInst.bezierVertex(x2, y2, x3, y3, x4, y4);
                          this._pInst.endShape();
                          return this;
                        };
                        
                        p5.Renderer2D.prototype.curve = function (x1, y1, x2, y2, x3, y3, x4, y4) {
                          this._pInst.beginShape();
                          this._pInst.curveVertex(x1, y1);
                          this._pInst.curveVertex(x2, y2);
                          this._pInst.curveVertex(x3, y3);
                          this._pInst.curveVertex(x4, y4);
                          this._pInst.endShape();
                          return this;
                        };
                        
                        //////////////////////////////////////////////
                        // SHAPE | Vertex
                        //////////////////////////////////////////////
                        
                        p5.Renderer2D.prototype._doFillStrokeClose = function () {
                          if (this._doFill) {
                            this.drawingContext.fill();
                          }
                          if (this._doStroke) {
                            this.drawingContext.stroke();
                          }
                          this.drawingContext.closePath();
                        };
                        
                        //////////////////////////////////////////////
                        // TRANSFORM
                        //////////////////////////////////////////////
                        
                        p5.Renderer2D.prototype.applyMatrix =
                        function(n00, n01, n02, n10, n11, n12) {
                          this.drawingContext.transform(n00, n01, n02, n10, n11, n12);
                        };
                        
                        p5.Renderer2D.prototype.resetMatrix = function() {
                          this.drawingContext.setTransform(1, 0, 0, 1, 0, 0);
                          this.drawingContext.scale(this._pInst._pixelDensity,
                                                    this._pInst._pixelDensity);
                          return this;
                        };
                        
                        p5.Renderer2D.prototype.rotate = function(r) {
                          this.drawingContext.rotate(r);
                        };
                        
                        p5.Renderer2D.prototype.scale = function(x,y) {
                          this.drawingContext.scale(x, y);
                          return this;
                        };
                        
                        p5.Renderer2D.prototype.shearX = function(angle) {
                          if (this._pInst._angleMode === constants.DEGREES) {
                            angle = this._pInst.radians(angle);
                          }
                          this.drawingContext.transform(1, 0, this._pInst.tan(angle), 1, 0, 0);
                          return this;
                        };
                        
                        p5.Renderer2D.prototype.shearY = function(angle) {
                          if (this._pInst._angleMode === constants.DEGREES) {
                            angle = this._pInst.radians(angle);
                          }
                          this.drawingContext.transform(1, this._pInst.tan(angle), 0, 1, 0, 0);
                          return this;
                        };
                        
                        p5.Renderer2D.prototype.translate = function(x, y) {
                          this.drawingContext.translate(x, y);
                          return this;
                        };
                        
                        //////////////////////////////////////////////
                        // TYPOGRAPHY
                        //
                        //////////////////////////////////////////////
                        
                        p5.Renderer2D.prototype.text = function (str, x, y, maxWidth, maxHeight) {
                        
                          var p = this._pInst, cars, n, ii, jj, line, testLine,
                            testWidth, words, totalHeight, baselineHacked,
                            finalMaxHeight = Number.MAX_VALUE;
                        
                          // baselineHacked: (HACK)
                          // A temporary fix to conform to Processing&#x27;s implementation
                          // of BASELINE vertical alignment in a bounding box
                        
                          if (!(this._doFill || this._doStroke)) {
                            return;
                          }
                        
                          if (typeof str !== &#x27;string&#x27;) {
                            str = str.toString();
                          }
                        
                          str = str.replace(/(\t)/g, &#x27;  &#x27;);
                          cars = str.split(&#x27;\n&#x27;);
                        
                          if (typeof maxWidth !== &#x27;undefined&#x27;) {
                        
                            totalHeight = 0;
                            for (ii = 0; ii &lt; cars.length; ii++) {
                              line = &#x27;&#x27;;
                              words = cars[ii].split(&#x27; &#x27;);
                              for (n = 0; n &lt; words.length; n++) {
                                testLine = line + words[n] + &#x27; &#x27;;
                                testWidth = this.textWidth(testLine);
                                if (testWidth &gt; maxWidth) {
                                  line = words[n] + &#x27; &#x27;;
                                  totalHeight += p.textLeading();
                                } else {
                                  line = testLine;
                                }
                              }
                            }
                        
                            if (this._rectMode === constants.CENTER) {
                        
                              x -= maxWidth / 2;
                              y -= maxHeight / 2;
                            }
                        
                            switch (this.drawingContext.textAlign) {
                        
                            case constants.CENTER:
                              x += maxWidth / 2;
                              break;
                            case constants.RIGHT:
                              x += maxWidth;
                              break;
                            }
                        
                            if (typeof maxHeight !== &#x27;undefined&#x27;) {
                        
                              switch (this.drawingContext.textBaseline) {
                              case constants.BOTTOM:
                                y += (maxHeight - totalHeight);
                                break;
                              case constants._CTX_MIDDLE:
                                y += (maxHeight - totalHeight) / 2;
                                break;
                              case constants.BASELINE:
                                baselineHacked = true;
                                this.drawingContext.textBaseline = constants.TOP;
                                break;
                              }
                        
                              // remember the max-allowed y-position for any line (fix to #928)
                              finalMaxHeight = (y + maxHeight) - p.textAscent();
                            }
                        
                            for (ii = 0; ii &lt; cars.length; ii++) {
                        
                              line = &#x27;&#x27;;
                              words = cars[ii].split(&#x27; &#x27;);
                              for (n = 0; n &lt; words.length; n++) {
                                testLine = line + words[n] + &#x27; &#x27;;
                                testWidth = this.textWidth(testLine);
                                if (testWidth &gt; maxWidth &amp;&amp; line.length &gt; 0) {
                                  this._renderText(p, line, x, y, finalMaxHeight);
                                  line = words[n] + &#x27; &#x27;;
                                  y += p.textLeading();
                                } else {
                                  line = testLine;
                                }
                              }
                        
                              this._renderText(p, line, x, y, finalMaxHeight);
                              y += p.textLeading();
                            }
                          }
                          else {
                            for (jj = 0; jj &lt; cars.length; jj++) {
                        
                              this._renderText(p, cars[jj], x, y, finalMaxHeight);
                              y += p.textLeading();
                            }
                          }
                        
                          if (baselineHacked) {
                            this.drawingContext.textBaseline = constants.BASELINE;
                          }
                        
                          return p;
                        };
                        
                        p5.Renderer2D.prototype._renderText = function(p, line, x, y, maxY) {
                        
                          if (y &gt;= maxY) {
                            return; // don&#x27;t render lines beyond our maxY position
                          }
                        
                          p.push(); // fix to #803
                        
                          if (!this._isOpenType()) {  // a system/browser font
                        
                            // no stroke unless specified by user
                            if (this._doStroke &amp;&amp; this._strokeSet) {
                        
                              this.drawingContext.strokeText(line, x, y);
                            }
                        
                            if (this._doFill) {
                        
                              // if fill hasn&#x27;t been set by user, use default text fill
                              this.drawingContext.fillStyle =  this._fillSet ?
                                this.drawingContext.fillStyle : constants._DEFAULT_TEXT_FILL;
                        
                              this.drawingContext.fillText(line, x, y);
                            }
                          }
                          else { // an opentype font, let it handle the rendering
                        
                            this._textFont._renderPath(line, x, y, { renderer: this });
                          }
                        
                          p.pop();
                        
                          return p;
                        };
                        
                        p5.Renderer2D.prototype.textWidth = function(s) {
                        
                          if (this._isOpenType()) {
                        
                            return this._textFont._textWidth(s);
                          }
                        
                          return this.drawingContext.measureText(s).width;
                        };
                        
                        p5.Renderer2D.prototype.textAlign = function(h, v) {
                        
                          if (arguments.length) {
                        
                            if (h === constants.LEFT ||
                              h === constants.RIGHT ||
                              h === constants.CENTER) {
                        
                              this.drawingContext.textAlign = h;
                            }
                        
                            if (v === constants.TOP ||
                              v === constants.BOTTOM ||
                              v === constants.CENTER ||
                              v === constants.BASELINE) {
                        
                              if (v === constants.CENTER) {
                                this.drawingContext.textBaseline = constants._CTX_MIDDLE;
                              } else {
                                this.drawingContext.textBaseline = v;
                              }
                            }
                        
                            return this._pInst;
                        
                          } else {
                        
                            var valign = this.drawingContext.textBaseline;
                        
                            if (valign === constants._CTX_MIDDLE) {
                        
                              valign = constants.CENTER;
                            }
                        
                            return {
                        
                              horizontal: this.drawingContext.textAlign,
                              vertical: valign
                            };
                          }
                        };
                        
                        p5.Renderer2D.prototype._applyTextProperties = function() {
                        
                          var font, p = this._pInst;
                        
                          this._setProperty(&#x27;_textAscent&#x27;, null);
                          this._setProperty(&#x27;_textDescent&#x27;, null);
                        
                          font = this._textFont;
                        
                          if (this._isOpenType()) {
                        
                            font = this._textFont.font.familyName;
                            this._setProperty(&#x27;_textStyle&#x27;, this._textFont.font.styleName);
                          }
                        
                          this.drawingContext.font = this._textStyle + &#x27; &#x27; +
                          this._textSize + &#x27;px &#x27; + font;
                        
                          return p;
                        };
                        
                        
                        //////////////////////////////////////////////
                        // STRUCTURE
                        //////////////////////////////////////////////
                        
                        p5.Renderer2D.prototype.push = function() {
                          this.drawingContext.save();
                        };
                        
                        p5.Renderer2D.prototype.pop = function() {
                          this.drawingContext.restore();
                        };
                        
                        module.exports = p5.Renderer2D;
                        
                        },{&quot;../image/filters&quot;:65,&quot;./canvas&quot;:46,&quot;./constants&quot;:47,&quot;./core&quot;:48,&quot;./p5.Renderer&quot;:54}],56:[function(_dereq_,module,exports){
                        /**
                         * @module Rendering
                         * @submodule Rendering
                         * @for p5
                         */
                        
                        var p5 = _dereq_(&#x27;./core&#x27;);
                        var constants = _dereq_(&#x27;./constants&#x27;);
                        _dereq_(&#x27;./p5.Graphics&#x27;);
                        _dereq_(&#x27;./p5.Renderer2D&#x27;);
                        _dereq_(&#x27;../3d/p5.Renderer3D&#x27;);
                        var defaultId = &#x27;defaultCanvas0&#x27;; // this gets set again in createCanvas
                        
                        /**
                         * Creates a canvas element in the document, and sets the dimensions of it
                         * in pixels. This method should be called only once at the start of setup.
                         * Calling createCanvas more than once in a sketch will result in very
                         * unpredicable behavior. If you want more than one drawing canvas
                         * you could use createGraphics (hidden by default but it can be shown).
                         * &lt;br&gt;&lt;br&gt;
                         * The system variables width and height are set by the parameters passed
                         * to this function. If createCanvas() is not used, the window will be
                         * given a default size of 100x100 pixels.
                         *
                         * @method createCanvas
                         * @param  {Number} w width of the canvas
                         * @param  {Number} h height of the canvas
                         * @param  optional:{String} renderer &#x27;p2d&#x27; | &#x27;webgl&#x27;
                         * @return {Object} canvas generated
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * function setup() {
                         *   createCanvas(100, 50);
                         *   background(153);
                         *   line(0, 0, width, height);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        
                        p5.prototype.createCanvas = function(w, h, renderer) {
                          //optional: renderer, otherwise defaults to p2d
                          var r = renderer || constants.P2D;
                          var isDefault, c;
                        
                          //4th arg (isDefault) used when called onLoad,
                          //otherwise hidden to the public api
                          if(arguments[3]){
                            isDefault =
                            (typeof arguments[3] === &#x27;boolean&#x27;) ? arguments[3] : false;
                          }
                        
                          if(r === constants.WEBGL){
                            c = document.getElementById(defaultId);
                            if(c){ //if defaultCanvas already exists
                              c.parentNode.removeChild(c); //replace the existing defaultCanvas
                            }
                            c = document.createElement(&#x27;canvas&#x27;);
                            c.id = defaultId;
                          }
                          else {
                            if (isDefault) {
                              c = document.createElement(&#x27;canvas&#x27;);
                              var i = 0;
                              while (document.getElementById(&#x27;defaultCanvas&#x27;+i)) {
                                i++;
                              }
                              defaultId = &#x27;defaultCanvas&#x27;+i;
                              c.id = defaultId;
                            } else { // resize the default canvas if new one is created
                              c = this.canvas;
                            }
                          }
                        
                          // set to invisible if still in setup (to prevent flashing with manipulate)
                          if (!this._setupDone) {
                            c.className += &#x27; p5_hidden&#x27;; // tag to show later
                            c.style.visibility=&#x27;hidden&#x27;;
                          }
                        
                          if (this._userNode) { // user input node case
                            this._userNode.appendChild(c);
                          } else {
                            document.body.appendChild(c);
                          }
                        
                        
                        
                          // Init our graphics renderer
                          //webgl mode
                          if (r === constants.WEBGL) {
                            this._setProperty(&#x27;_renderer&#x27;, new p5.Renderer3D(c, this, true));
                            this._isdefaultGraphics = true;
                          }
                          //P2D mode
                          else {
                            if (!this._isdefaultGraphics) {
                              this._setProperty(&#x27;_renderer&#x27;, new p5.Renderer2D(c, this, true));
                              this._isdefaultGraphics = true;
                            }
                          }
                          this._renderer.resize(w, h);
                          this._renderer._applyDefaults();
                          if (isDefault) { // only push once
                            this._elements.push(this._renderer);
                          }
                          return this._renderer;
                        };
                        
                        /**
                         * Resizes the canvas to given width and height. The canvas will be cleared
                         * and draw will be called immediately, allowing the sketch to re-render itself
                         * in the resized canvas.
                         * @method resizeCanvas
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;&lt;code&gt;
                         * function setup() {
                         *   createCanvas(windowWidth, windowHeight);
                         * }
                         *
                         * function draw() {
                         *  background(0, 100, 200);
                         * }
                         *
                         * function windowResized() {
                         *   resizeCanvas(windowWidth, windowHeight);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.resizeCanvas = function (w, h, noRedraw) {
                          if (this._renderer) {
                        
                            // save canvas properties
                            var props = {};
                            for (var key in this.drawingContext) {
                              var val = this.drawingContext[key];
                              if (typeof val !== &#x27;object&#x27; &amp;&amp; typeof val !== &#x27;function&#x27;) {
                                props[key] = val;
                              }
                            }
                            this._renderer.resize(w, h);
                            // reset canvas properties
                            for (var savedKey in props) {
                              this.drawingContext[savedKey] = props[savedKey];
                            }
                            if (!noRedraw) {
                              this.redraw();
                            }
                          }
                        };
                        
                        
                        /**
                         * Removes the default canvas for a p5 sketch that doesn&#x27;t
                         * require a canvas
                         * @method noCanvas
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * function setup() {
                         *   noCanvas();
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.noCanvas = function() {
                          if (this.canvas) {
                            this.canvas.parentNode.removeChild(this.canvas);
                          }
                        };
                        
                        /**
                         * Creates and returns a new p5.Renderer object. Use this class if you need
                         * to draw into an off-screen graphics buffer. The two parameters define the
                         * width and height in pixels.
                         *
                         * @method createGraphics
                         * @param  {Number} w width of the offscreen graphics buffer
                         * @param  {Number} h height of the offscreen graphics buffer
                         * @param {String} renderer either &#x27;p2d&#x27; or &#x27;webgl&#x27;.
                         * undefined defaults to p2d
                         * @return {Object} offscreen graphics buffer
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var pg;
                         * function setup() {
                         *   createCanvas(100, 100);
                         *   pg = createGraphics(100, 100);
                         * }
                         * function draw() {
                         *   background(200);
                         *   pg.background(100);
                         *   pg.noStroke();
                         *   pg.ellipse(pg.width/2, pg.height/2, 50, 50);
                         *   image(pg, 50, 50);
                         *   image(pg, 0, 0, 50, 50);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.createGraphics = function(w, h, renderer){
                          return new p5.Graphics(w, h, renderer, this);
                        };
                        
                        /**
                         * Blends the pixels in the display window according to the defined mode.
                         * There is a choice of the following modes to blend the source pixels (A)
                         * with the ones of pixels already in the display window (B):
                         * &lt;ul&gt;
                         * &lt;li&gt;&lt;code&gt;BLEND&lt;/code&gt; - linear interpolation of colours: C =
                         * A*factor + B. This is the default blending mode.&lt;/li&gt;
                         * &lt;li&gt;&lt;code&gt;ADD&lt;/code&gt; - sum of A and B&lt;/li&gt;
                         * &lt;li&gt;&lt;code&gt;DARKEST&lt;/code&gt; - only the darkest colour succeeds: C =
                         * min(A*factor, B).&lt;/li&gt;
                         * &lt;li&gt;&lt;code&gt;LIGHTEST&lt;/code&gt; - only the lightest colour succeeds: C =
                         * max(A*factor, B).&lt;/li&gt;
                         * &lt;li&gt;&lt;code&gt;DIFFERENCE&lt;/code&gt; - subtract colors from underlying image.&lt;/li&gt;
                         * &lt;li&gt;&lt;code&gt;EXCLUSION&lt;/code&gt; - similar to &lt;code&gt;DIFFERENCE&lt;/code&gt;, but less
                         * extreme.&lt;/li&gt;
                         * &lt;li&gt;&lt;code&gt;MULTIPLY&lt;/code&gt; - multiply the colors, result will always be
                         * darker.&lt;/li&gt;
                         * &lt;li&gt;&lt;code&gt;SCREEN&lt;/code&gt; - opposite multiply, uses inverse values of the
                         * colors.&lt;/li&gt;
                         * &lt;li&gt;&lt;code&gt;REPLACE&lt;/code&gt; - the pixels entirely replace the others and
                         * don&#x27;t utilize alpha (transparency) values.&lt;/li&gt;
                         * &lt;li&gt;&lt;code&gt;OVERLAY&lt;/code&gt; - mix of &lt;code&gt;MULTIPLY&lt;/code&gt; and &lt;code&gt;SCREEN
                         * &lt;/code&gt;. Multiplies dark values, and screens light values.&lt;/li&gt;
                         * &lt;li&gt;&lt;code&gt;HARD_LIGHT&lt;/code&gt; - &lt;code&gt;SCREEN&lt;/code&gt; when greater than 50%
                         * gray, &lt;code&gt;MULTIPLY&lt;/code&gt; when lower.&lt;/li&gt;
                         * &lt;li&gt;&lt;code&gt;SOFT_LIGHT&lt;/code&gt; - mix of &lt;code&gt;DARKEST&lt;/code&gt; and
                         * &lt;code&gt;LIGHTEST&lt;/code&gt;. Works like &lt;code&gt;OVERLAY&lt;/code&gt;, but not as harsh.
                         * &lt;/li&gt;
                         * &lt;li&gt;&lt;code&gt;DODGE&lt;/code&gt; - lightens light tones and increases contrast,
                         * ignores darks.&lt;/li&gt;
                         * &lt;li&gt;&lt;code&gt;BURN&lt;/code&gt; - darker areas are applied, increasing contrast,
                         * ignores lights.&lt;/li&gt;
                         * &lt;/ul&gt;
                         *
                         * @method blendMode
                         * @param  {String/Constant} mode blend mode to set for canvas
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * blendMode(LIGHTEST);
                         * strokeWeight(30);
                         * stroke(80, 150, 255);
                         * line(25, 25, 75, 75);
                         * stroke(255, 50, 50);
                         * line(75, 25, 25, 75);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * blendMode(MULTIPLY);
                         * strokeWeight(30);
                         * stroke(80, 150, 255);
                         * line(25, 25, 75, 75);
                         * stroke(255, 50, 50);
                         * line(75, 25, 25, 75);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.blendMode = function(mode) {
                          if (mode === constants.BLEND || mode === constants.DARKEST ||
                            mode === constants.LIGHTEST || mode === constants.DIFFERENCE ||
                            mode === constants.MULTIPLY || mode === constants.EXCLUSION ||
                            mode === constants.SCREEN || mode === constants.REPLACE ||
                            mode === constants.OVERLAY || mode === constants.HARD_LIGHT ||
                            mode === constants.SOFT_LIGHT || mode === constants.DODGE ||
                            mode === constants.BURN || mode === constants.ADD ||
                            mode === constants.NORMAL) {
                            this._renderer.blendMode(mode);
                          } else {
                            throw new Error(&#x27;Mode &#x27;+mode+&#x27; not recognized.&#x27;);
                          }
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;../3d/p5.Renderer3D&quot;:36,&quot;./constants&quot;:47,&quot;./core&quot;:48,&quot;./p5.Graphics&quot;:53,&quot;./p5.Renderer2D&quot;:55}],57:[function(_dereq_,module,exports){
                        
                        // requestAnim shim layer by Paul Irish
                        window.requestAnimationFrame = (function(){
                          return window.requestAnimationFrame      ||
                                window.webkitRequestAnimationFrame ||
                                window.mozRequestAnimationFrame    ||
                                window.oRequestAnimationFrame      ||
                                window.msRequestAnimationFrame     ||
                                function(callback, element){
                                  // should &#x27;60&#x27; here be framerate?
                                  window.setTimeout(callback, 1000 / 60);
                                };
                        })();
                        
                        // use window.performance() to get max fast and accurate time in milliseconds
                        window.performance = window.performance || {};
                        window.performance.now = (function(){
                          var load_date = Date.now();
                          return window.performance.now        ||
                                window.performance.mozNow      ||
                                window.performance.msNow       ||
                                window.performance.oNow        ||
                                window.performance.webkitNow   ||
                                function () {
                                  return Date.now() - load_date;
                                };
                        })();
                        
                        /*
                        // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
                        // http://my.opera.com/emoller/blog/2011/12/20/
                        // requestanimationframe-for-smart-er-animating
                        // requestAnimationFrame polyfill by Erik Möller
                        // fixes from Paul Irish and Tino Zijdel
                        (function() {
                          var lastTime = 0;
                          var vendors = [&#x27;ms&#x27;, &#x27;moz&#x27;, &#x27;webkit&#x27;, &#x27;o&#x27;];
                          for (var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) {
                            window.requestAnimationFrame =
                              window[vendors[x]+&#x27;RequestAnimationFrame&#x27;];
                            window.cancelAnimationFrame =
                              window[vendors[x]+&#x27;CancelAnimationFrame&#x27;] ||
                              window[vendors[x]+&#x27;CancelRequestAnimationFrame&#x27;];
                          }
                        
                          if (!window.requestAnimationFrame) {
                            window.requestAnimationFrame = function(callback, element) {
                              var currTime = new Date().getTime();
                              var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                              var id = window.setTimeout(function()
                                { callback(currTime + timeToCall); }, timeToCall);
                              lastTime = currTime + timeToCall;
                              return id;
                            };
                          }
                        
                          if (!window.cancelAnimationFrame) {
                            window.cancelAnimationFrame = function(id) {
                              clearTimeout(id);
                            };
                          }
                        }());
                        */
                        
                        /**
                         * shim for Uint8ClampedArray.slice
                         * (allows arrayCopy to work with pixels[])
                         * with thanks to http://halfpapstudios.com/blog/tag/html5-canvas/
                         */
                        (function () {
                          &#x27;use strict&#x27;;
                        
                          if (typeof Uint8ClampedArray !== &#x27;undefined&#x27;) {
                            //Firefox and Chrome
                            Uint8ClampedArray.prototype.slice = Array.prototype.slice;
                          }
                        }());
                        
                        
                        },{}],58:[function(_dereq_,module,exports){
                        /**
                         * @module Structure
                         * @submodule Structure
                         * @for p5
                         * @requires core
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;./core&#x27;);
                        
                        p5.prototype.exit = function() {
                          throw &#x27;exit() not implemented, see remove()&#x27;;
                        };
                        /**
                         * Stops p5.js from continuously executing the code within draw().
                         * If loop() is called, the code in draw() begins to run continuously again.
                         * If using noLoop() in setup(), it should be the last line inside the block.
                         * &lt;br&gt;&lt;br&gt;
                         * When noLoop() is used, it&#x27;s not possible to manipulate or access the
                         * screen inside event handling functions such as mousePressed() or
                         * keyPressed(). Instead, use those functions to call redraw() or loop(),
                         * which will run draw(), which can update the screen properly. This means
                         * that when noLoop() has been called, no drawing can happen, and functions
                         * like saveFrame() or loadPixels() may not be used.
                         * &lt;br&gt;&lt;br&gt;
                         * Note that if the sketch is resized, redraw() will be called to update
                         * the sketch, even after noLoop() has been specified. Otherwise, the sketch
                         * would enter an odd state until loop() was called.
                         *
                         * @method noLoop
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * function setup() {
                         *   createCanvas(100, 100);
                         *   background(200);
                         *   noLoop();
                         * }
                        
                         * function draw() {
                         *   line(10, 10, 90, 90);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         *
                         * &lt;div&gt;&lt;code&gt;
                         * var x = 0;
                         * function setup() {
                         *   createCanvas(100, 100);
                         * }
                         *
                         * function draw() {
                         *   background(204);
                         *   x = x + 0.1;
                         *   if (x &gt; width) {
                         *     x = 0;
                         *   }
                         *   line(x, 0, x, height);
                         * }
                         *
                         * function mousePressed() {
                         *   noLoop();
                         * }
                         *
                         * function mouseReleased() {
                         *   loop();
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.noLoop = function() {
                          this._loop = false;
                        };
                        /**
                         * By default, p5.js loops through draw() continuously, executing the code
                         * within it. However, the draw() loop may be stopped by calling noLoop().
                         * In that case, the draw() loop can be resumed with loop().
                         *
                         * @method loop
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * var x = 0;
                         * function setup() {
                         *   createCanvas(100, 100);
                         *   noLoop();
                         * }
                         *
                         * function draw() {
                         *   background(204);
                         *   x = x + 0.1;
                         *   if (x &gt; width) {
                         *     x = 0;
                         *   }
                         *   line(x, 0, x, height);
                         * }
                         *
                         * function mousePressed() {
                         *   loop();
                         * }
                         *
                         * function mouseReleased() {
                         *   noLoop();
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        
                        p5.prototype.loop = function() {
                          this._loop = true;
                          this._draw();
                        };
                        
                        /**
                         * The push() function saves the current drawing style settings and
                         * transformations, while pop() restores these settings. Note that these
                         * functions are always used together. They allow you to change the style
                         * and transformation settings and later return to what you had. When a new
                         * state is started with push(), it builds on the current style and transform
                         * information. The push() and pop() functions can be embedded to provide
                         * more control. (See the second example for a demonstration.)
                         * &lt;br&gt;&lt;br&gt;
                         * push() stores information related to the current transformation state
                         * and style settings controlled by the following functions: fill(),
                         * stroke(), tint(), strokeWeight(), strokeCap(), strokeJoin(),
                         * imageMode(), rectMode(), ellipseMode(), colorMode(), textAlign(),
                         * textFont(), textMode(), textSize(), textLeading().
                         *
                         * @method push
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * ellipse(0, 50, 33, 33);  // Left circle
                         *
                         * push();  // Start a new drawing state
                         * strokeWeight(10);
                         * fill(204, 153, 0);
                         * translate(50, 0);
                         * ellipse(0, 50, 33, 33);  // Middle circle
                         * pop();  // Restore original state
                         *
                         * ellipse(100, 50, 33, 33);  // Right circle
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * ellipse(0, 50, 33, 33);  // Left circle
                         *
                         * push();  // Start a new drawing state
                         * strokeWeight(10);
                         * fill(204, 153, 0);
                         * ellipse(33, 50, 33, 33);  // Left-middle circle
                         *
                         * push();  // Start another new drawing state
                         * stroke(0, 102, 153);
                         * ellipse(66, 50, 33, 33);  // Right-middle circle
                         * pop();  // Restore previous state
                         *
                         * pop();  // Restore original state
                         *
                         * ellipse(100, 50, 33, 33);  // Right circle
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.push = function () {
                          this._renderer.push();
                          this._styles.push({
                            _doStroke: this._renderer._doStroke,
                            _doFill: this._renderer._doFill,
                            _tint: this._renderer._tint,
                            _imageMode: this._renderer._imageMode,
                            _rectMode: this._renderer._rectMode,
                            _ellipseMode: this._renderer._ellipseMode,
                            _colorMode: this._renderer._colorMode,
                            _textFont: this._renderer._textFont,
                            _textLeading: this._renderer._textLeading,
                            _textSize: this._renderer._textSize,
                            _textStyle: this._renderer._textStyle
                          });
                        };
                        
                        /**
                         * The push() function saves the current drawing style settings and
                         * transformations, while pop() restores these settings. Note that these
                         * functions are always used together. They allow you to change the style
                         * and transformation settings and later return to what you had. When a new
                         * state is started with push(), it builds on the current style and transform
                         * information. The push() and pop() functions can be embedded to provide
                         * more control. (See the second example for a demonstration.)
                         * &lt;br&gt;&lt;br&gt;
                         * push() stores information related to the current transformation state
                         * and style settings controlled by the following functions: fill(),
                         * stroke(), tint(), strokeWeight(), strokeCap(), strokeJoin(),
                         * imageMode(), rectMode(), ellipseMode(), colorMode(), textAlign(),
                         * textFont(), textMode(), textSize(), textLeading().
                         *
                         * @method pop
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * ellipse(0, 50, 33, 33);  // Left circle
                         *
                         * push();  // Start a new drawing state
                         * translate(50, 0);
                         * strokeWeight(10);
                         * fill(204, 153, 0);
                         * ellipse(0, 50, 33, 33);  // Middle circle
                         * pop();  // Restore original state
                         *
                         * ellipse(100, 50, 33, 33);  // Right circle
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * ellipse(0, 50, 33, 33);  // Left circle
                         *
                         * push();  // Start a new drawing state
                         * strokeWeight(10);
                         * fill(204, 153, 0);
                         * ellipse(33, 50, 33, 33);  // Left-middle circle
                         *
                         * push();  // Start another new drawing state
                         * stroke(0, 102, 153);
                         * ellipse(66, 50, 33, 33);  // Right-middle circle
                         * pop();  // Restore previous state
                         *
                         * pop();  // Restore original state
                         *
                         * ellipse(100, 50, 33, 33);  // Right circle
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.pop = function () {
                          this._renderer.pop();
                          var lastS = this._styles.pop();
                          for(var prop in lastS){
                            this._renderer[prop] = lastS[prop];
                          }
                        };
                        
                        p5.prototype.pushStyle = function() {
                          throw new Error(&#x27;pushStyle() not used, see push()&#x27;);
                        };
                        
                        p5.prototype.popStyle = function() {
                          throw new Error(&#x27;popStyle() not used, see pop()&#x27;);
                        };
                        
                        /**
                         *
                         * Executes the code within draw() one time. This functions allows the
                         * program to update the display window only when necessary, for example
                         * when an event registered by mousePressed() or keyPressed() occurs.
                         * &lt;br&gt;&lt;br&gt;
                         * In structuring a program, it only makes sense to call redraw() within
                         * events such as mousePressed(). This is because redraw() does not run
                         * draw() immediately (it only sets a flag that indicates an update is
                         * needed).
                         * &lt;br&gt;&lt;br&gt;
                         * The redraw() function does not work properly when called inside draw().
                         * To enable/disable animations, use loop() and noLoop().
                         *
                         * @method redraw
                         * @example
                         *   &lt;div&gt;&lt;code&gt;
                         *     var x = 0;
                         *
                         *     function setup() {
                         *       createCanvas(100, 100);
                         *       noLoop();
                         *     }
                         *
                         *     function draw() {
                         *       background(204);
                         *       line(x, 0, x, height);
                         *     }
                         *
                         *     function mousePressed() {
                         *       x += 1;
                         *       redraw();
                         *     }
                         *   &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.redraw = function () {
                          var userSetup = this.setup || window.setup;
                          var userDraw = this.draw || window.draw;
                          if (typeof userDraw === &#x27;function&#x27;) {
                            this.push();
                            if (typeof userSetup === &#x27;undefined&#x27;) {
                              this.scale(this._pixelDensity, this._pixelDensity);
                            }
                            var self = this;
                            this._registeredMethods.pre.forEach(function (f) {
                              f.call(self);
                            });
                            userDraw();
                            this._registeredMethods.post.forEach(function (f) {
                              f.call(self);
                            });
                            this.pop();
                          }
                        };
                        
                        p5.prototype.size = function() {
                          var s = &#x27;size() is not a valid p5 function, to set the size of the &#x27;;
                          s += &#x27;drawing canvas, please use createCanvas() instead&#x27;;
                          throw s;
                        };
                        
                        
                        module.exports = p5;
                        
                        },{&quot;./core&quot;:48}],59:[function(_dereq_,module,exports){
                        /**
                         * @module Transform
                         * @submodule Transform
                         * @for p5
                         * @requires core
                         * @requires constants
                         */
                        
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;./core&#x27;);
                        var constants = _dereq_(&#x27;./constants&#x27;);
                        
                        /**
                         * Multiplies the current matrix by the one specified through the parameters.
                         * This is very slow because it will try to calculate the inverse of the
                         * transform, so avoid it whenever possible.
                         *
                         * @method applyMatrix
                         * @param  {Number} n00 numbers which define the 3x2 matrix to be multiplied
                         * @param  {Number} n01 numbers which define the 3x2 matrix to be multiplied
                         * @param  {Number} n02 numbers which define the 3x2 matrix to be multiplied
                         * @param  {Number} n10 numbers which define the 3x2 matrix to be multiplied
                         * @param  {Number} n11 numbers which define the 3x2 matrix to be multiplied
                         * @param  {Number} n12 numbers which define the 3x2 matrix to be multiplied
                         * @return {p5}         the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Example in the works.
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.applyMatrix = function(n00, n01, n02, n10, n11, n12) {
                          this._renderer.applyMatrix(n00, n01, n02, n10, n11, n12);
                          return this;
                        };
                        
                        p5.prototype.popMatrix = function() {
                          throw new Error(&#x27;popMatrix() not used, see pop()&#x27;);
                        };
                        
                        p5.prototype.printMatrix = function() {
                          throw new Error(&#x27;printMatrix() not implemented&#x27;);
                        };
                        
                        p5.prototype.pushMatrix = function() {
                          throw new Error(&#x27;pushMatrix() not used, see push()&#x27;);
                        };
                        
                        /**
                         * Replaces the current matrix with the identity matrix.
                         *
                         * @method resetMatrix
                         * @return {p5} the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Example in the works.
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.resetMatrix = function() {
                          this._renderer.resetMatrix();
                          return this;
                        };
                        
                        /**
                         * Rotates a shape the amount specified by the angle parameter. This
                         * function accounts for angleMode, so angles can be entered in either
                         * RADIANS or DEGREES.
                         * &lt;br&gt;&lt;br&gt;
                         * Objects are always rotated around their relative position to the
                         * origin and positive numbers rotate objects in a clockwise direction.
                         * Transformations apply to everything that happens after and subsequent
                         * calls to the function accumulates the effect. For example, calling
                         * rotate(HALF_PI) and then rotate(HALF_PI) is the same as rotate(PI).
                         * All tranformations are reset when draw() begins again.
                         * &lt;br&gt;&lt;br&gt;
                         * Technically, rotate() multiplies the current transformation matrix
                         * by a rotation matrix. This function can be further controlled by
                         * the push() and pop().
                         *
                         * @method rotate
                         * @param  {Number} angle the angle of rotation, specified in radians
                         *                        or degrees, depending on current angleMode
                         * @return {p5}           the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * translate(width/2, height/2);
                         * rotate(PI/3.0);
                         * rect(-26, -26, 52, 52);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.rotate = function() {
                          var r = arguments[0];
                          if (this._angleMode === constants.DEGREES) {
                            r = this.radians(r);
                          }
                          //in webgl mode
                          if(arguments.length &gt; 1){
                            this._renderer.rotate(r, arguments[1]);
                          }
                          else {
                            this._renderer.rotate(r);
                          }
                          return this;
                        };
                        
                        /**
                         * [rotateX description]
                         * @param  {[type]} rad [description]
                         * @return {[type]}     [description]
                         */
                        p5.prototype.rotateX = function(rad) {
                          var args = new Array(arguments.length);
                          for (var i = 0; i &lt; args.length; ++i) {
                            args[i] = arguments[i];
                          }
                          if (this._renderer.isP3D) {
                            this._validateParameters(
                              &#x27;rotateX&#x27;,
                              args,
                              [
                                [&#x27;Number&#x27;]
                              ]
                            );
                            this._renderer.rotateX(rad);
                          } else {
                            throw &#x27;not supported in p2d. Please use webgl mode&#x27;;
                          }
                          return this;
                        };
                        
                        /**
                         * [rotateY description]
                         * @param  {[type]} rad [description]
                         * @return {[type]}     [description]
                         */
                        p5.prototype.rotateY = function(rad) {
                          if (this._renderer.isP3D) {
                            var args = new Array(arguments.length);
                            for (var i = 0; i &lt; args.length; ++i) {
                              args[i] = arguments[i];
                            }
                            this._validateParameters(
                              &#x27;rotateY&#x27;,
                              args,
                              [
                                [&#x27;Number&#x27;]
                              ]
                            );
                            this._renderer.rotateY(rad);
                          } else {
                            throw &#x27;not supported in p2d. Please use webgl mode&#x27;;
                          }
                          return this;
                        };
                        
                        /**
                         * [rotateZ description]
                         * @param  {[type]} rad [description]
                         * @return {[type]}     [description]
                         */
                        p5.prototype.rotateZ = function(rad) {
                          if (this._renderer.isP3D) {
                            var args = new Array(arguments.length);
                            for (var i = 0; i &lt; args.length; ++i) {
                              args[i] = arguments[i];
                            }
                            this._validateParameters(
                              &#x27;rotateZ&#x27;,
                              args,
                              [
                                [&#x27;Number&#x27;]
                              ]
                            );
                            this._renderer.rotateZ(rad);
                          } else {
                            throw &#x27;not supported in p2d. Please use webgl mode&#x27;;
                          }
                          return this;
                        };
                        
                        /**
                         * Increases or decreases the size of a shape by expanding and contracting
                         * vertices. Objects always scale from their relative origin to the
                         * coordinate system. Scale values are specified as decimal percentages.
                         * For example, the function call scale(2.0) increases the dimension of a
                         * shape by 200%.
                         * &lt;br&gt;&lt;br&gt;
                         * Transformations apply to everything that happens after and subsequent
                         * calls to the function multiply the effect. For example, calling scale(2.0)
                         * and then scale(1.5) is the same as scale(3.0). If scale() is called
                         * within draw(), the transformation is reset when the loop begins again.
                         * &lt;br&gt;&lt;br&gt;
                         * Using this fuction with the z parameter requires using P3D as a
                         * parameter for size(), as shown in the third example above. This function
                         * can be further controlled with push() and pop().
                         *
                         * @method scale
                         * @param  {Number | p5.Vector | Array} s
                         *                      percent to scale the object, or percentage to
                         *                      scale the object in the x-axis if multiple arguments
                         *                      are given
                         * @param  {Number} [y] percent to scale the object in the y-axis
                         * @param  {Number} [z] percent to scale the object in the z-axis (webgl only)
                         * @return {p5}         the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * translate(width/2, height/2);
                         * rotate(PI/3.0);
                         * rect(-26, -26, 52, 52);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * rect(30, 20, 50, 50);
                         * scale(0.5, 1.3);
                         * rect(30, 20, 50, 50);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.scale = function() {
                          var x,y,z;
                          var args = new Array(arguments.length);
                          for(var i = 0; i &lt; args.length; i++) {
                            args[i] = arguments[i];
                          }
                          if(args[0] instanceof p5.Vector){
                            x = args[0].x;
                            y = args[0].y;
                            z = args[0].z;
                          }
                          else if(args[0] instanceof Array){
                            x = args[0][0];
                            y = args[0][1];
                            z = args[0][2] || 1;
                          }
                          else {
                            if(args.length === 1){
                              x = y = z = args[0];
                            }
                            else {
                              x = args[0];
                              y = args[1];
                              z = args[2] || 1;
                            }
                          }
                        
                          if(this._renderer.isP3D){
                            this._renderer.scale.call(this._renderer, x,y,z);
                          }
                          else {
                            this._renderer.scale.call(this._renderer, x,y);
                          }
                          return this;
                        };
                        
                        /**
                         * Shears a shape around the x-axis the amount specified by the angle
                         * parameter. Angles should be specified in the current angleMode.
                         * Objects are always sheared around their relative position to the origin
                         * and positive numbers shear objects in a clockwise direction.
                         * &lt;br&gt;&lt;br&gt;
                         * Transformations apply to everything that happens after and subsequent
                         * calls to the function accumulates the effect. For example, calling
                         * shearX(PI/2) and then shearX(PI/2) is the same as shearX(PI).
                         * If shearX() is called within the draw(), the transformation is reset when
                         * the loop begins again.
                         * &lt;br&gt;&lt;br&gt;
                         * Technically, shearX() multiplies the current transformation matrix by a
                         * rotation matrix. This function can be further controlled by the
                         * push() and pop() functions.
                         *
                         * @method shearX
                         * @param  {Number} angle angle of shear specified in radians or degrees,
                         *                        depending on current angleMode
                         * @return {p5}           the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * translate(width/4, height/4);
                         * shearX(PI/4.0);
                         * rect(0, 0, 30, 30);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.shearX = function(angle) {
                          if (this._angleMode === constants.DEGREES) {
                            angle = this.radians(angle);
                          }
                          this._renderer.shearX(angle);
                          return this;
                        };
                        
                        /**
                         * Shears a shape around the y-axis the amount specified by the angle
                         * parameter. Angles should be specified in the current angleMode. Objects
                         * are always sheared around their relative position to the origin and
                         * positive numbers shear objects in a clockwise direction.
                         * &lt;br&gt;&lt;br&gt;
                         * Transformations apply to everything that happens after and subsequent
                         * calls to the function accumulates the effect. For example, calling
                         * shearY(PI/2) and then shearY(PI/2) is the same as shearY(PI). If
                         * shearY() is called within the draw(), the transformation is reset when
                         * the loop begins again.
                         * &lt;br&gt;&lt;br&gt;
                         * Technically, shearY() multiplies the current transformation matrix by a
                         * rotation matrix. This function can be further controlled by the
                         * push() and pop() functions.
                         *
                         * @method shearY
                         * @param  {Number} angle angle of shear specified in radians or degrees,
                         *                        depending on current angleMode
                         * @return {p5}           the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * translate(width/4, height/4);
                         * shearY(PI/4.0);
                         * rect(0, 0, 30, 30);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.shearY = function(angle) {
                          if (this._angleMode === constants.DEGREES) {
                            angle = this.radians(angle);
                          }
                          this._renderer.shearY(angle);
                          return this;
                        };
                        
                        /**
                         * Specifies an amount to displace objects within the display window.
                         * The x parameter specifies left/right translation, the y parameter
                         * specifies up/down translation.
                         * &lt;br&gt;&lt;br&gt;
                         * Transformations are cumulative and apply to everything that happens after
                         * and subsequent calls to the function accumulates the effect. For example,
                         * calling translate(50, 0) and then translate(20, 0) is the same as
                         * translate(70, 0). If translate() is called within draw(), the
                         * transformation is reset when the loop begins again. This function can be
                         * further controlled by using push() and pop().
                         *
                         * @method translate
                         * @param  {Number} x left/right translation
                         * @param  {Number} y up/down translation
                         * @return {p5}       the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * translate(30, 20);
                         * rect(0, 0, 55, 55);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * rect(0, 0, 55, 55);  // Draw rect at original 0,0
                         * translate(30, 20);
                         * rect(0, 0, 55, 55);  // Draw rect at new 0,0
                         * translate(14, 14);
                         * rect(0, 0, 55, 55);  // Draw rect at new 0,0
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.translate = function(x, y, z) {
                          var args = new Array(arguments.length);
                          for (var i = 0; i &lt; args.length; ++i) {
                            args[i] = arguments[i];
                          }
                        
                          if (this._renderer.isP3D) {
                            this._validateParameters(
                              &#x27;translate&#x27;,
                              args,
                              [
                                //p3d
                                [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;]
                              ]
                            );
                            this._renderer.translate(x, y, z);
                          } else {
                            this._validateParameters(
                              &#x27;translate&#x27;,
                              args,
                              [
                                //p2d
                                [&#x27;Number&#x27;, &#x27;Number&#x27;]
                              ]
                            );
                            this._renderer.translate(x, y);
                          }
                          return this;
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;./constants&quot;:47,&quot;./core&quot;:48}],60:[function(_dereq_,module,exports){
                        /**
                         * @module Shape
                         * @submodule Vertex
                         * @for p5
                         * @requires core
                         * @requires constants
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;./core&#x27;);
                        var constants = _dereq_(&#x27;./constants&#x27;);
                        var shapeKind = null;
                        var vertices = [];
                        var contourVertices = [];
                        var isBezier = false;
                        var isCurve = false;
                        var isQuadratic = false;
                        var isContour = false;
                        
                        /**
                         * Use the beginContour() and endContour() functions to create negative
                         * shapes within shapes such as the center of the letter &#x27;O&#x27;. beginContour()
                         * begins recording vertices for the shape and endContour() stops recording.
                         * The vertices that define a negative shape must &quot;wind&quot; in the opposite
                         * direction from the exterior shape. First draw vertices for the exterior
                         * clockwise order, then for internal shapes, draw vertices
                         * shape in counter-clockwise.
                         * &lt;br&gt;&lt;br&gt;
                         * These functions can only be used within a beginShape()/endShape() pair and
                         * transformations such as translate(), rotate(), and scale() do not work
                         * within a beginContour()/endContour() pair. It is also not possible to use
                         * other shapes, such as ellipse() or rect() within.
                         *
                         * @method beginContour
                         * @return {Object} the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * translate(50, 50);
                         * stroke(255, 0, 0);
                         * beginShape();
                         * // Exterior part of shape, clockwise winding
                         * vertex(-40, -40);
                         * vertex(40, -40);
                         * vertex(40, 40);
                         * vertex(-40, 40);
                         * // Interior part of shape, counter-clockwise winding
                         * beginContour();
                         * vertex(-20, -20);
                         * vertex(-20, 20);
                         * vertex(20, 20);
                         * vertex(20, -20);
                         * endContour();
                         * endShape(CLOSE);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.beginContour = function() {
                          contourVertices = [];
                          isContour = true;
                          return this;
                        };
                        
                        /**
                         * Using the beginShape() and endShape() functions allow creating more
                         * complex forms. beginShape() begins recording vertices for a shape and
                         * endShape() stops recording. The value of the kind parameter tells it which
                         * types of shapes to create from the provided vertices. With no mode
                         * specified, the shape can be any irregular polygon.
                         * &lt;br&gt;&lt;br&gt;
                         * The parameters available for beginShape() are POINTS, LINES, TRIANGLES,
                         * TRIANGLE_FAN, TRIANGLE_STRIP, QUADS, and QUAD_STRIP. After calling the
                         * beginShape() function, a series of vertex() commands must follow. To stop
                         * drawing the shape, call endShape(). Each shape will be outlined with the
                         * current stroke color and filled with the fill color.
                         * &lt;br&gt;&lt;br&gt;
                         * Transformations such as translate(), rotate(), and scale() do not work
                         * within beginShape(). It is also not possible to use other shapes, such as
                         * ellipse() or rect() within beginShape().
                         *
                         * @method beginShape
                         * @param  {Number/Constant} kind either POINTS, LINES, TRIANGLES,
                         *                                TRIANGLE_FAN, TRIANGLE_STRIP, QUADS,
                         *                                or QUAD_STRIP
                         * @return {Object}               the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * beginShape();
                         * vertex(30, 20);
                         * vertex(85, 20);
                         * vertex(85, 75);
                         * vertex(30, 75);
                         * endShape(CLOSE);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // currently not working
                         * beginShape(POINTS);
                         * vertex(30, 20);
                         * vertex(85, 20);
                         * vertex(85, 75);
                         * vertex(30, 75);
                         * endShape();
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * beginShape(LINES);
                         * vertex(30, 20);
                         * vertex(85, 20);
                         * vertex(85, 75);
                         * vertex(30, 75);
                         * endShape();
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noFill();
                         * beginShape();
                         * vertex(30, 20);
                         * vertex(85, 20);
                         * vertex(85, 75);
                         * vertex(30, 75);
                         * endShape();
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noFill();
                         * beginShape();
                         * vertex(30, 20);
                         * vertex(85, 20);
                         * vertex(85, 75);
                         * vertex(30, 75);
                         * endShape(CLOSE);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * beginShape(TRIANGLES);
                         * vertex(30, 75);
                         * vertex(40, 20);
                         * vertex(50, 75);
                         * vertex(60, 20);
                         * vertex(70, 75);
                         * vertex(80, 20);
                         * endShape();
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * beginShape(TRIANGLE_STRIP);
                         * vertex(30, 75);
                         * vertex(40, 20);
                         * vertex(50, 75);
                         * vertex(60, 20);
                         * vertex(70, 75);
                         * vertex(80, 20);
                         * vertex(90, 75);
                         * endShape();
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * beginShape(TRIANGLE_FAN);
                         * vertex(57.5, 50);
                         * vertex(57.5, 15);
                         * vertex(92, 50);
                         * vertex(57.5, 85);
                         * vertex(22, 50);
                         * vertex(57.5, 15);
                         * endShape();
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * beginShape(QUADS);
                         * vertex(30, 20);
                         * vertex(30, 75);
                         * vertex(50, 75);
                         * vertex(50, 20);
                         * vertex(65, 20);
                         * vertex(65, 75);
                         * vertex(85, 75);
                         * vertex(85, 20);
                         * endShape();
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * beginShape(QUAD_STRIP);
                         * vertex(30, 20);
                         * vertex(30, 75);
                         * vertex(50, 20);
                         * vertex(50, 75);
                         * vertex(65, 20);
                         * vertex(65, 75);
                         * vertex(85, 20);
                         * vertex(85, 75);
                         * endShape();
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * beginShape();
                         * vertex(20, 20);
                         * vertex(40, 20);
                         * vertex(40, 40);
                         * vertex(60, 40);
                         * vertex(60, 60);
                         * vertex(20, 60);
                         * endShape(CLOSE);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.beginShape = function(kind) {
                          if (kind === constants.POINTS ||
                            kind === constants.LINES ||
                            kind === constants.TRIANGLES ||
                            kind === constants.TRIANGLE_FAN ||
                            kind === constants.TRIANGLE_STRIP ||
                            kind === constants.QUADS ||
                            kind === constants.QUAD_STRIP) {
                            shapeKind = kind;
                          } else {
                            shapeKind = null;
                          }
                          if(this._renderer.isP3D){
                            this._renderer.beginShape(kind);
                          } else {
                            vertices = [];
                            contourVertices = [];
                          }
                          return this;
                        };
                        
                        /**
                         * Specifies vertex coordinates for Bezier curves. Each call to
                         * bezierVertex() defines the position of two control points and
                         * one anchor point of a Bezier curve, adding a new segment to a
                         * line or shape.
                         * &lt;br&gt;&lt;br&gt;
                         * The first time bezierVertex() is used within a
                         * beginShape() call, it must be prefaced with a call to vertex()
                         * to set the first anchor point. This function must be used between
                         * beginShape() and endShape() and only when there is no MODE
                         * parameter specified to beginShape().
                         *
                         * @method bezierVertex
                         * @param  {Number} x2 x-coordinate for the first control point
                         * @param  {Number} y2 y-coordinate for the first control point
                         * @param  {Number} x3 x-coordinate for the second control point
                         * @param  {Number} y3 y-coordinate for the second control point
                         * @param  {Number} x4 x-coordinate for the anchor point
                         * @param  {Number} y4 y-coordinate for the anchor point
                         * @return {Object}    the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noFill();
                         * beginShape();
                         * vertex(30, 20);
                         * bezierVertex(80, 0, 80, 75, 30, 75);
                         * endShape();
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * beginShape();
                         * vertex(30, 20);
                         * bezierVertex(80, 0, 80, 75, 30, 75);
                         * bezierVertex(50, 80, 60, 25, 30, 20);
                         * endShape();
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.bezierVertex = function(x2, y2, x3, y3, x4, y4) {
                          if (vertices.length === 0) {
                            throw &#x27;vertex() must be used once before calling bezierVertex()&#x27;;
                          } else {
                            isBezier = true;
                            var vert = [];
                            for (var i = 0; i &lt; arguments.length; i++) {
                              vert[i] = arguments[i];
                            }
                            vert.isVert = false;
                            if (isContour) {
                              contourVertices.push(vert);
                            } else {
                              vertices.push(vert);
                            }
                          }
                          return this;
                        };
                        
                        /**
                         * Specifies vertex coordinates for curves. This function may only
                         * be used between beginShape() and endShape() and only when there
                         * is no MODE parameter specified to beginShape().
                         * &lt;br&gt;&lt;br&gt;
                         * The first and last points in a series of curveVertex() lines will be used to
                         * guide the beginning and end of a the curve. A minimum of four
                         * points is required to draw a tiny curve between the second and
                         * third points. Adding a fifth point with curveVertex() will draw
                         * the curve between the second, third, and fourth points. The
                         * curveVertex() function is an implementation of Catmull-Rom
                         * splines.
                         *
                         * @method curveVertex
                         * @param {Number} x x-coordinate of the vertex
                         * @param {Number} y y-coordinate of the vertex
                         * @return {Object} the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noFill();
                         * beginShape();
                         * curveVertex(84,  91);
                         * curveVertex(84,  91);
                         * curveVertex(68,  19);
                         * curveVertex(21,  17);
                         * curveVertex(32, 100);
                         * curveVertex(32, 100);
                         * endShape();
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.curveVertex = function(x,y) {
                          isCurve = true;
                          this.vertex(x, y);
                          return this;
                        };
                        
                        /**
                         * Use the beginContour() and endContour() functions to create negative
                         * shapes within shapes such as the center of the letter &#x27;O&#x27;. beginContour()
                         * begins recording vertices for the shape and endContour() stops recording.
                         * The vertices that define a negative shape must &quot;wind&quot; in the opposite
                         * direction from the exterior shape. First draw vertices for the exterior
                         * clockwise order, then for internal shapes, draw vertices
                         * shape in counter-clockwise.
                         * &lt;br&gt;&lt;br&gt;
                         * These functions can only be used within a beginShape()/endShape() pair and
                         * transformations such as translate(), rotate(), and scale() do not work
                         * within a beginContour()/endContour() pair. It is also not possible to use
                         * other shapes, such as ellipse() or rect() within.
                         *
                         * @method endContour
                         * @return {Object} the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * translate(50, 50);
                         * stroke(255, 0, 0);
                         * beginShape();
                         * // Exterior part of shape, clockwise winding
                         * vertex(-40, -40);
                         * vertex(40, -40);
                         * vertex(40, 40);
                         * vertex(-40, 40);
                         * // Interior part of shape, counter-clockwise winding
                         * beginContour();
                         * vertex(-20, -20);
                         * vertex(-20, 20);
                         * vertex(20, 20);
                         * vertex(20, -20);
                         * endContour();
                         * endShape(CLOSE);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.endContour = function() {
                          var vert = contourVertices[0].slice(); // copy all data
                          vert.isVert = contourVertices[0].isVert;
                          vert.moveTo = false;
                          contourVertices.push(vert);
                        
                          vertices.push(vertices[0]);
                          for (var i = 0; i &lt; contourVertices.length; i++) {
                            vertices.push(contourVertices[i]);
                          }
                          return this;
                        };
                        
                        /**
                         * The endShape() function is the companion to beginShape() and may only be
                         * called after beginShape(). When endshape() is called, all of image data
                         * defined since the previous call to beginShape() is written into the image
                         * buffer. The constant CLOSE as the value for the MODE parameter to close
                         * the shape (to connect the beginning and the end).
                         *
                         * @method endShape
                         * @param  {Number/Constant} mode use CLOSE to close the shape
                         * @return {Object}               the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noFill();
                         *
                         * beginShape();
                         * vertex(20, 20);
                         * vertex(45, 20);
                         * vertex(45, 80);
                         * endShape(CLOSE);
                         *
                         * beginShape();
                         * vertex(50, 20);
                         * vertex(75, 20);
                         * vertex(75, 80);
                         * endShape();
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.endShape = function(mode) {
                          if(this._renderer.isP3D){
                            this._renderer.endShape();
                          }else{
                            if (vertices.length === 0) { return this; }
                            if (!this._renderer._doStroke &amp;&amp; !this._renderer._doFill) { return this; }
                        
                            var closeShape = mode === constants.CLOSE;
                        
                            // if the shape is closed, the first element is also the last element
                            if (closeShape &amp;&amp; !isContour) {
                              vertices.push(vertices[0]);
                            }
                        
                            this._renderer.endShape(mode, vertices, isCurve, isBezier,
                              isQuadratic, isContour, shapeKind);
                        
                            // Reset some settings
                            isCurve = false;
                            isBezier = false;
                            isQuadratic = false;
                            isContour = false;
                        
                            // If the shape is closed, the first element was added as last element.
                            // We must remove it again to prevent the list of vertices from growing
                            // over successive calls to endShape(CLOSE)
                            if (closeShape) {
                              vertices.pop();
                            }
                          }
                          return this;
                        };
                        
                        /**
                         * Specifies vertex coordinates for quadratic Bezier curves. Each call to
                         * quadraticVertex() defines the position of one control points and one
                         * anchor point of a Bezier curve, adding a new segment to a line or shape.
                         * The first time quadraticVertex() is used within a beginShape() call, it
                         * must be prefaced with a call to vertex() to set the first anchor point.
                         * This function must be used between beginShape() and endShape() and only
                         * when there is no MODE parameter specified to beginShape().
                         *
                         * @method quadraticVertex
                         * @param  {Number} cx x-coordinate for the control point
                         * @param  {Number} cy y-coordinate for the control point
                         * @param  {Number} x3 x-coordinate for the anchor point
                         * @param  {Number} y3 y-coordinate for the anchor point
                         * @return {Object}    the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noFill();
                         * strokeWeight(4);
                         * beginShape();
                         * vertex(20, 20);
                         * quadraticVertex(80, 20, 50, 50);
                         * endShape();
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * noFill();
                         * strokeWeight(4);
                         * beginShape();
                         * vertex(20, 20);
                         * quadraticVertex(80, 20, 50, 50);
                         * quadraticVertex(20, 80, 80, 80);
                         * vertex(80, 60);
                         * endShape();
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.quadraticVertex = function(cx, cy, x3, y3) {
                          //if we&#x27;re drawing a contour, put the points into an
                          // array for inside drawing
                          if(this._contourInited) {
                            var pt = {};
                            pt.x = cx;
                            pt.y = cy;
                            pt.x3 = x3;
                            pt.y3 = y3;
                            pt.type = constants.QUADRATIC;
                            this._contourVertices.push(pt);
                        
                            return this;
                          }
                          if (vertices.length &gt; 0) {
                            isQuadratic = true;
                            var vert = [];
                            for (var i = 0; i &lt; arguments.length; i++) {
                              vert[i] = arguments[i];
                            }
                            vert.isVert = false;
                            if (isContour) {
                              contourVertices.push(vert);
                            } else {
                              vertices.push(vert);
                            }
                          } else {
                            throw &#x27;vertex() must be used once before calling quadraticVertex()&#x27;;
                          }
                          return this;
                        };
                        
                        /**
                         * All shapes are constructed by connecting a series of vertices. vertex()
                         * is used to specify the vertex coordinates for points, lines, triangles,
                         * quads, and polygons. It is used exclusively within the beginShape() and
                         * endShape() functions.
                         *
                         * @method vertex
                         * @param  {Number} x x-coordinate of the vertex
                         * @param  {Number} y y-coordinate of the vertex
                         * @return {Object}   the p5 object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * beginShape(POINTS);
                         * vertex(30, 20);
                         * vertex(85, 20);
                         * vertex(85, 75);
                         * vertex(30, 75);
                         * endShape();
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.vertex = function(x, y, moveTo) {
                          var args = new Array(arguments.length);
                          for (var i = 0; i &lt; args.length; ++i) {
                            args[i] = arguments[i];
                          }
                          if(this._renderer.isP3D){
                            this._validateParameters(
                              &#x27;vertex&#x27;,
                              args,
                              [
                                [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;]
                              ]
                            );
                            this._renderer.vertex
                            (arguments[0], arguments[1], arguments[2]);
                          }else{
                            this._validateParameters(
                              &#x27;vertex&#x27;,
                              args,
                              [
                                [&#x27;Number&#x27;, &#x27;Number&#x27;],
                                [&#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;]
                              ]
                            );
                            var vert = [];
                            vert.isVert = true;
                            vert[0] = x;
                            vert[1] = y;
                            vert[2] = 0;
                            vert[3] = 0;
                            vert[4] = 0;
                            vert[5] = this._renderer._getFill();
                            vert[6] = this._renderer._getStroke();
                        
                            if (moveTo) {
                              vert.moveTo = moveTo;
                            }
                            if (isContour) {
                              if (contourVertices.length === 0) {
                                vert.moveTo = true;
                              }
                              contourVertices.push(vert);
                            } else {
                              vertices.push(vert);
                            }
                          }
                          return this;
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;./constants&quot;:47,&quot;./core&quot;:48}],61:[function(_dereq_,module,exports){
                        /**
                         * @module Events
                         * @submodule Acceleration
                         * @for p5
                         * @requires core
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        
                        /**
                         * The system variable deviceOrientation always contains the orientation of
                         * the device. The value of this variable will either be set &#x27;landscape&#x27;
                         * or &#x27;portrait&#x27;. If no data is available it will be set to &#x27;undefined&#x27;.
                         *
                         * @property deviceOrientation
                         */
                        p5.prototype.deviceOrientation = undefined;
                        
                        /**
                         * The system variable accelerationX always contains the acceleration of the
                         * device along the x axis. Value is represented as meters per second squared.
                         *
                         * @property accelerationX
                         */
                        p5.prototype.accelerationX = 0;
                        
                        /**
                         * The system variable accelerationY always contains the acceleration of the
                         * device along the y axis. Value is represented as meters per second squared.
                         *
                         * @property accelerationY
                         */
                        p5.prototype.accelerationY = 0;
                        
                        /**
                         * The system variable accelerationZ always contains the acceleration of the
                         * device along the z axis. Value is represented as meters per second squared.
                         *
                         * @property accelerationZ
                         */
                        p5.prototype.accelerationZ = 0;
                        
                        /**
                         * The system variable pAccelerationX always contains the acceleration of the
                         * device along the x axis in the frame previous to the current frame. Value
                         * is represented as meters per second squared.
                         *
                         * @property pAccelerationX
                         */
                        p5.prototype.pAccelerationX = 0;
                        
                        /**
                         * The system variable pAccelerationY always contains the acceleration of the
                         * device along the y axis in the frame previous to the current frame. Value
                         * is represented as meters per second squared.
                         *
                         * @property pAccelerationY
                         */
                        p5.prototype.pAccelerationY = 0;
                        
                        /**
                         * The system variable pAccelerationZ always contains the acceleration of the
                         * device along the z axis in the frame previous to the current frame. Value
                         * is represented as meters per second squared.
                         *
                         * @property pAccelerationZ
                         */
                        p5.prototype.pAccelerationZ = 0;
                        
                        /**
                         * _updatePAccelerations updates the pAcceleration values
                         *
                         * @private
                         */
                        p5.prototype._updatePAccelerations = function(){
                          this._setProperty(&#x27;pAccelerationX&#x27;, this.accelerationX);
                          this._setProperty(&#x27;pAccelerationY&#x27;, this.accelerationY);
                          this._setProperty(&#x27;pAccelerationZ&#x27;, this.accelerationZ);
                        };
                        
                        /**
                         * The system variable rotationX always contains the rotation of the
                         * device along the x axis. Value is represented as 0 to +/-180 degrees.
                         *
                         * @property rotationX
                         */
                        p5.prototype.rotationX = 0;
                        
                        /**
                         * The system variable rotationY always contains the rotation of the
                         * device along the y axis. Value is represented as 0 to +/-180 degrees.
                         *
                         * @property rotationY
                         */
                        p5.prototype.rotationY = 0;
                        
                        /**
                         * The system variable rotationZ always contains the rotation of the
                         * device along the z axis. Value is represented as 0 to 359 degrees.
                         * &lt;br&gt;&lt;br&gt;
                         * Unlike rotationX and rotationY, this variable is available for devices
                         * with a built-in compass only.
                         *
                         * @property rotationZ
                         */
                        p5.prototype.rotationZ = 0;
                        
                        /**
                         * The system variable pRotationX always contains the rotation of the
                         * device along the x axis in the frame previous to the current frame. Value
                         * is represented as 0 to +/-180 degrees.
                         * &lt;br&gt;&lt;br&gt;
                         * pRotationX can also be used with rotationX to determine the rotate
                         * direction of the device along the X-axis.
                         * @example
                         * &lt;div class=&#x27;norender&#x27;&gt;
                         * &lt;code&gt;
                         * // A simple if statement looking at whether
                         * // rotationX - pRotationX &lt; 0 is true or not will be
                         * // sufficient for determining the rotate direction
                         * // in most cases.
                         *
                         * // Some extra logic is needed to account for cases where
                         * // the angles wrap around.
                         * var rotateDirection = &#x27;clockwise&#x27;;
                         *
                         * // Simple range conversion to make things simpler.
                         * // This is not absolutely neccessary but the logic
                         * // will be different in that case.
                         *
                         * var rX = rotationX + 180;
                         * var pRX = pRotationX + 180;
                         *
                         * if ((rX - pRX &gt; 0 &amp;&amp; rX - pRX &lt; 270)|| rX - pRX &lt; -270){
                         *   rotateDirection = &#x27;clockwise&#x27;;
                         * } else if (rX - pRX &lt; 0 || rX - pRX &gt; 270){
                         *   rotateDirection = &#x27;counter-clockwise&#x27;;
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * @property pRotationX
                         */
                        p5.prototype.pRotationX = 0;
                        
                        /**
                         * The system variable pRotationY always contains the rotation of the
                         * device along the y axis in the frame previous to the current frame. Value
                         * is represented as 0 to +/-180 degrees.
                         * &lt;br&gt;&lt;br&gt;
                         * pRotationY can also be used with rotationY to determine the rotate
                         * direction of the device along the Y-axis.
                         * @example
                         * &lt;div class=&#x27;norender&#x27;&gt;
                         * &lt;code&gt;
                         * // A simple if statement looking at whether
                         * // rotationY - pRotationY &lt; 0 is true or not will be
                         * // sufficient for determining the rotate direction
                         * // in most cases.
                         *
                         * // Some extra logic is needed to account for cases where
                         * // the angles wrap around.
                         * var rotateDirection = &#x27;clockwise&#x27;;
                         *
                         * // Simple range conversion to make things simpler.
                         * // This is not absolutely neccessary but the logic
                         * // will be different in that case.
                         *
                         * var rY = rotationY + 180;
                         * var pRY = pRotationY + 180;
                         *
                         * if ((rY - pRY &gt; 0 &amp;&amp; rY - pRY &lt; 270)|| rY - pRY &lt; -270){
                         *   rotateDirection = &#x27;clockwise&#x27;;
                         * } else if (rY - pRY &lt; 0 || rY - pRY &gt; 270){
                         *   rotateDirection = &#x27;counter-clockwise&#x27;;
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * @property pRotationY
                         */
                        p5.prototype.pRotationY = 0;
                        
                        /**
                         * The system variable pRotationZ always contains the rotation of the
                         * device along the z axis in the frame previous to the current frame. Value
                         * is represented as 0 to 359 degrees.
                         * &lt;br&gt;&lt;br&gt;
                         * pRotationZ can also be used with rotationZ to determine the rotate
                         * direction of the device along the Z-axis.
                         * @example
                         * &lt;div class=&#x27;norender&#x27;&gt;
                         * &lt;code&gt;
                         * // A simple if statement looking at whether
                         * // rotationZ - pRotationZ &lt; 0 is true or not will be
                         * // sufficient for determining the rotate direction
                         * // in most cases.
                         *
                         * // Some extra logic is needed to account for cases where
                         * // the angles wrap around.
                         * var rotateDirection = &#x27;clockwise&#x27;;
                         *
                         * if ((rotationZ - pRotationZ &gt; 0 &amp;&amp;
                         *   rotationZ - pRotationZ &lt; 270)||
                         *   rotationZ - pRotationZ &lt; -270){
                         *
                         *   rotateDirection = &#x27;clockwise&#x27;;
                         *
                         * } else if (rotationZ - pRotationZ &lt; 0 ||
                         *   rotationZ - pRotationZ &gt; 270){
                         *
                         *   rotateDirection = &#x27;counter-clockwise&#x27;;
                         *
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * @property pRotationZ
                         */
                        p5.prototype.pRotationZ = 0;
                        
                        var startAngleX = 0;
                        var startAngleY = 0;
                        var startAngleZ = 0;
                        
                        var rotateDirectionX = &#x27;clockwise&#x27;;
                        var rotateDirectionY = &#x27;clockwise&#x27;;
                        var rotateDirectionZ = &#x27;clockwise&#x27;;
                        
                        var pRotateDirectionX;
                        var pRotateDirectionY;
                        var pRotateDirectionZ;
                        
                        p5.prototype._updatePRotations = function(){
                          this._setProperty(&#x27;pRotationX&#x27;, this.rotationX);
                          this._setProperty(&#x27;pRotationY&#x27;, this.rotationY);
                          this._setProperty(&#x27;pRotationZ&#x27;, this.rotationZ);
                        };
                        
                        p5.prototype.turnAxis = undefined;
                        
                        var move_threshold = 0.5;
                        var shake_threshold = 30;
                        
                        /**
                         * The setMoveThreshold() function is used to set the movement threshold for
                         * the deviceMoved() function. The default threshold is set to 0.5.
                         *
                         * @method setMoveThreshold
                         * @param {number} value The threshold value
                         */
                        p5.prototype.setMoveThreshold = function(val){
                          if(typeof val === &#x27;number&#x27;){
                            move_threshold = val;
                          }
                        };
                        
                        /**
                         * The setShakeThreshold() function is used to set the movement threshold for
                         * the deviceShaken() function. The default threshold is set to 30.
                         *
                         * @method setShakeThreshold
                         * @param {number} value The threshold value
                         */
                        p5.prototype.setShakeThreshold = function(val){
                          if(typeof val === &#x27;number&#x27;){
                            shake_threshold = val;
                          }
                        };
                        
                        /**
                         * The deviceMoved() function is called when the device is moved by more than
                         * the threshold value along X, Y or Z axis. The default threshold is set to
                         * 0.5.
                         * @method deviceMoved
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Run this example on a mobile device
                         * // Move the device around
                         * // to change the value.
                         *
                         * var value = 0;
                         * function draw() {
                         *   fill(value);
                         *   rect(25, 25, 50, 50);
                         * }
                         * function deviceMoved() {
                         *   value = value + 5;
                         *   if (value &gt; 255) {
                         *     value = 0;
                         *   }
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        
                        /**
                         * The deviceTurned() function is called when the device rotates by
                         * more than 90 degrees continuously.
                         * &lt;br&gt;&lt;br&gt;
                         * The axis that triggers the deviceTurned() method is stored in the turnAxis
                         * variable. The deviceTurned() method can be locked to trigger on any axis:
                         * X, Y or Z by comparing the turnAxis variable to &#x27;X&#x27;, &#x27;Y&#x27; or &#x27;Z&#x27;.
                         *
                         * @method deviceTurned
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Run this example on a mobile device
                         * // Rotate the device by 90 degrees
                         * // to change the value.
                         *
                         * var value = 0;
                         * function draw() {
                         *   fill(value);
                         *   rect(25, 25, 50, 50);
                         * }
                         * function deviceTurned() {
                         *   if (value == 0){
                         *     value = 255
                         *   } else if (value == 255) {
                         *     value = 0;
                         *   }
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Run this example on a mobile device
                         * // Rotate the device by 90 degrees in the
                         * // X-axis to change the value.
                         *
                         * var value = 0;
                         * function draw() {
                         *   fill(value);
                         *   rect(25, 25, 50, 50);
                         * }
                         * function deviceTurned() {
                         *   if (turnAxis == &#x27;X&#x27;){
                         *     if (value == 0){
                         *       value = 255
                         *     } else if (value == 255) {
                         *       value = 0;
                         *     }
                         *   }
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        
                        /**
                         * The deviceShaken() function is called when the device total acceleration
                         * changes of accelerationX and accelerationY values is more than
                         * the threshold value. The default threshold is set to 30.
                         * @method deviceShaken
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Run this example on a mobile device
                         * // Shake the device to change the value.
                         *
                         * var value = 0;
                         * function draw() {
                         *   fill(value);
                         *   rect(25, 25, 50, 50);
                         * }
                         * function deviceShaken() {
                         *   value = value + 5;
                         *   if (value &gt; 255) {
                         *     value = 0;
                         *   }
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        
                        p5.prototype._ondeviceorientation = function (e) {
                          this._updatePRotations();
                          this._setProperty(&#x27;rotationX&#x27;, e.beta);
                          this._setProperty(&#x27;rotationY&#x27;, e.gamma);
                          this._setProperty(&#x27;rotationZ&#x27;, e.alpha);
                          this._handleMotion();
                        };
                        p5.prototype._ondevicemotion = function (e) {
                          this._updatePAccelerations();
                          this._setProperty(&#x27;accelerationX&#x27;, e.acceleration.x * 2);
                          this._setProperty(&#x27;accelerationY&#x27;, e.acceleration.y * 2);
                          this._setProperty(&#x27;accelerationZ&#x27;, e.acceleration.z * 2);
                          this._handleMotion();
                        };
                        p5.prototype._handleMotion = function() {
                          if (window.orientation === 90 || window.orientation === -90) {
                            this._setProperty(&#x27;deviceOrientation&#x27;, &#x27;landscape&#x27;);
                          } else if (window.orientation === 0) {
                            this._setProperty(&#x27;deviceOrientation&#x27;, &#x27;portrait&#x27;);
                          } else if (window.orientation === undefined) {
                            this._setProperty(&#x27;deviceOrientation&#x27;, &#x27;undefined&#x27;);
                          }
                          var deviceMoved = this.deviceMoved || window.deviceMoved;
                          if (typeof deviceMoved === &#x27;function&#x27;) {
                            if (Math.abs(this.accelerationX - this.pAccelerationX) &gt; move_threshold ||
                              Math.abs(this.accelerationY - this.pAccelerationY) &gt; move_threshold ||
                              Math.abs(this.accelerationZ - this.pAccelerationZ) &gt; move_threshold) {
                              deviceMoved();
                            }
                          }
                          var deviceTurned = this.deviceTurned || window.deviceTurned;
                          if (typeof deviceTurned === &#x27;function&#x27;) {
                            // The angles given by rotationX etc is from range -180 to 180.
                            // The following will convert them to 0 to 360 for ease of calculation
                            // of cases when the angles wrapped around.
                            // _startAngleX will be converted back at the end and updated.
                            var wRX = this.rotationX + 180;
                            var wPRX = this.pRotationX + 180;
                            var wSAX = startAngleX + 180;
                            if ((wRX - wPRX &gt; 0 &amp;&amp; wRX - wPRX &lt; 270)|| wRX - wPRX &lt; -270){
                              rotateDirectionX = &#x27;clockwise&#x27;;
                            } else if (wRX - wPRX &lt; 0 || wRX - wPRX &gt; 270){
                              rotateDirectionX = &#x27;counter-clockwise&#x27;;
                            }
                            if (rotateDirectionX !== pRotateDirectionX){
                              wSAX = wRX;
                            }
                            if (Math.abs(wRX - wSAX) &gt; 90 &amp;&amp; Math.abs(wRX - wSAX) &lt; 270){
                              wSAX = wRX;
                              this._setProperty(&#x27;turnAxis&#x27;, &#x27;X&#x27;);
                              deviceTurned();
                            }
                            pRotateDirectionX = rotateDirectionX;
                            startAngleX = wSAX - 180;
                        
                            // Y-axis is identical to X-axis except for changing some names.
                            var wRY = this.rotationY + 180;
                            var wPRY = this.pRotationY + 180;
                            var wSAY = startAngleY + 180;
                            if ((wRY - wPRY &gt; 0 &amp;&amp; wRY - wPRY &lt; 270)|| wRY - wPRY &lt; -270){
                              rotateDirectionY = &#x27;clockwise&#x27;;
                            } else if (wRY - wPRY &lt; 0 || wRY - this.pRotationY &gt; 270){
                              rotateDirectionY = &#x27;counter-clockwise&#x27;;
                            }
                            if (rotateDirectionY !== pRotateDirectionY){
                              wSAY = wRY;
                            }
                            if (Math.abs(wRY - wSAY) &gt; 90 &amp;&amp; Math.abs(wRY - wSAY) &lt; 270){
                              wSAY = wRY;
                              this._setProperty(&#x27;turnAxis&#x27;, &#x27;Y&#x27;);
                              deviceTurned();
                            }
                            pRotateDirectionY = rotateDirectionY;
                            startAngleY = wSAY - 180;
                        
                            // Z-axis is already in the range 0 to 360
                            // so no conversion is needed.
                            if ((this.rotationZ - this.pRotationZ &gt; 0 &amp;&amp;
                              this.rotationZ - this.pRotationZ &lt; 270)||
                              this.rotationZ - this.pRotationZ &lt; -270){
                              rotateDirectionZ = &#x27;clockwise&#x27;;
                            } else if (this.rotationZ - this.pRotationZ &lt; 0 ||
                              this.rotationZ - this.pRotationZ &gt; 270){
                              rotateDirectionZ = &#x27;counter-clockwise&#x27;;
                            }
                            if (rotateDirectionZ !== pRotateDirectionZ){
                              startAngleZ = this.rotationZ;
                            }
                            if (Math.abs(this.rotationZ - startAngleZ) &gt; 90 &amp;&amp;
                              Math.abs(this.rotationZ - startAngleZ) &lt; 270){
                              startAngleZ = this.rotationZ;
                              this._setProperty(&#x27;turnAxis&#x27;, &#x27;Z&#x27;);
                              deviceTurned();
                            }
                            pRotateDirectionZ = rotateDirectionZ;
                            this._setProperty(&#x27;turnAxis&#x27;, undefined);
                          }
                          var deviceShaken = this.deviceShaken || window.deviceShaken;
                          if (typeof deviceShaken === &#x27;function&#x27;) {
                            var accelerationChangeX;
                            var accelerationChangeY;
                            // Add accelerationChangeZ if acceleration change on Z is needed
                            if (this.pAccelerationX !== null) {
                              accelerationChangeX = Math.abs(this.accelerationX - this.pAccelerationX);
                              accelerationChangeY = Math.abs(this.accelerationY - this.pAccelerationY);
                            }
                            if (accelerationChangeX + accelerationChangeY &gt; shake_threshold) {
                              deviceShaken();
                            }
                          }
                        };
                        
                        
                        module.exports = p5;
                        
                        },{&quot;../core/core&quot;:48}],62:[function(_dereq_,module,exports){
                        /**
                         * @module Events
                         * @submodule Keyboard
                         * @for p5
                         * @requires core
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        
                        /**
                         * Holds the key codes of currently pressed keys.
                         * @private
                         */
                        var downKeys = {};
                        
                        /**
                         * The boolean system variable keyIsPressed is true if any key is pressed
                         * and false if no keys are pressed.
                         *
                         * @property keyIsPressed
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var value = 0;
                         * function draw() {
                         *   if (keyIsPressed === true) {
                         *     fill(0);
                         *   } else {
                         *     fill(255);
                         *   }
                         *   rect(25, 25, 50, 50);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.isKeyPressed = false;
                        p5.prototype.keyIsPressed = false; // khan
                        
                        /**
                         * The system variable key always contains the value of the most recent
                         * key on the keyboard that was typed. To get the proper capitalization, it
                         * is best to use it within keyTyped(). For non-ASCII keys, use the keyCode
                         * variable.
                         *
                         * @property key
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * // Click any key to display it!
                         * // (Not Guaranteed to be Case Sensitive)
                         * function setup() {
                         *   fill(245, 123, 158);
                         *   textSize(50);
                         * }
                         *
                         * function draw() {
                         *   background(200);
                         *   text(key, 33,65); // Display last key pressed.
                         * }
                         * &lt;/div&gt;&lt;/code&gt;
                         */
                        p5.prototype.key = &#x27;&#x27;;
                        
                        /**
                         * The variable keyCode is used to detect special keys such as BACKSPACE,
                         * DELETE, ENTER, RETURN, TAB, ESCAPE, SHIFT, CONTROL, OPTION, ALT, UP_ARROW,
                         * DOWN_ARROW, LEFT_ARROW, RIGHT_ARROW.
                         *
                         * @property keyCode
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * var fillVal = 126;
                         * function draw() {
                         *   fill(fillVal);
                         *   rect(25, 25, 50, 50);
                         * }
                         *
                         * function keyPressed() {
                         *   if (keyCode == UP_ARROW) {
                         *     fillVal = 255;
                         *   } else if (keyCode == DOWN_ARROW) {
                         *     fillVal = 0;
                         *   }
                         *   return false; // prevent default
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.keyCode = 0;
                        
                        /**
                         * The keyPressed() function is called once every time a key is pressed. The
                         * keyCode for the key that was pressed is stored in the keyCode variable.
                         * &lt;br&gt;&lt;br&gt;
                         * For non-ASCII keys, use the keyCode variable. You can check if the keyCode
                         * equals BACKSPACE, DELETE, ENTER, RETURN, TAB, ESCAPE, SHIFT, CONTROL,
                         * OPTION, ALT, UP_ARROW, DOWN_ARROW, LEFT_ARROW, RIGHT_ARROW.
                         * &lt;br&gt;&lt;br&gt;
                         * For ASCII keys that was pressed is stored in the key variable. However, it
                         * does not distinguish between uppercase and lowercase. For this reason, it
                         * is recommended to use keyTyped() to read the key variable, in which the
                         * case of the variable will be distinguished.
                         * &lt;br&gt;&lt;br&gt;
                         * Because of how operating systems handle key repeats, holding down a key
                         * may cause multiple calls to keyTyped() (and keyReleased() as well). The
                         * rate of repeat is set by the operating system and how each computer is
                         * configured.&lt;br&gt;&lt;br&gt;
                         * Browsers may have different default
                         * behaviors attached to various key events. To prevent any default
                         * behavior for this event, add &quot;return false&quot; to the end of the method.
                         *
                         * @method keyPressed
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var value = 0;
                         * function draw() {
                         *   fill(value);
                         *   rect(25, 25, 50, 50);
                         * }
                         * function keyPressed() {
                         *   if (value === 0) {
                         *     value = 255;
                         *   } else {
                         *     value = 0;
                         *   }
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var value = 0;
                         * function draw() {
                         *   fill(value);
                         *   rect(25, 25, 50, 50);
                         * }
                         * function keyPressed() {
                         *   if (keyCode === LEFT_ARROW) {
                         *     value = 255;
                         *   } else if (keyCode === RIGHT_ARROW) {
                         *     value = 0;
                         *   }
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * function keyPressed(){
                         *   // Do something
                         *   return false; // prevent any default behaviour
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype._onkeydown = function (e) {
                          if (downKeys[e.which]) { // prevent multiple firings
                            return;
                          }
                          this._setProperty(&#x27;isKeyPressed&#x27;, true);
                          this._setProperty(&#x27;keyIsPressed&#x27;, true);
                          this._setProperty(&#x27;keyCode&#x27;, e.which);
                          downKeys[e.which] = true;
                          var key = String.fromCharCode(e.which);
                          if (!key) {
                            key = e.which;
                          }
                          this._setProperty(&#x27;key&#x27;, key);
                          var keyPressed = this.keyPressed || window.keyPressed;
                          if (typeof keyPressed === &#x27;function&#x27; &amp;&amp; !e.charCode) {
                            var executeDefault = keyPressed(e);
                            if(executeDefault === false) {
                              e.preventDefault();
                            }
                          }
                        };
                        /**
                         * The keyReleased() function is called once every time a key is released.
                         * See key and keyCode for more information.&lt;br&gt;&lt;br&gt;
                         * Browsers may have different default
                         * behaviors attached to various key events. To prevent any default
                         * behavior for this event, add &quot;return false&quot; to the end of the method.
                         *
                         * @method keyReleased
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var value = 0;
                         * function draw() {
                         *   fill(value);
                         *   rect(25, 25, 50, 50);
                         * }
                         * function keyReleased() {
                         *   if (value === 0) {
                         *     value = 255;
                         *   } else {
                         *     value = 0;
                         *   }
                         *   return false; // prevent any default behavior
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype._onkeyup = function (e) {
                          var keyReleased = this.keyReleased || window.keyReleased;
                          this._setProperty(&#x27;isKeyPressed&#x27;, false);
                          this._setProperty(&#x27;keyIsPressed&#x27;, false);
                          this._setProperty(&#x27;_lastKeyCodeTyped&#x27;, null);
                          downKeys[e.which] = false;
                          //delete this._downKeys[e.which];
                          var key = String.fromCharCode(e.which);
                          if (!key) {
                            key = e.which;
                          }
                          this._setProperty(&#x27;key&#x27;, key);
                          this._setProperty(&#x27;keyCode&#x27;, e.which);
                          if (typeof keyReleased === &#x27;function&#x27;) {
                            var executeDefault = keyReleased(e);
                            if(executeDefault === false) {
                              e.preventDefault();
                            }
                          }
                        };
                        
                        /**
                         * The keyTyped() function is called once every time a key is pressed, but
                         * action keys such as Ctrl, Shift, and Alt are ignored. The most recent
                         * key pressed will be stored in the key variable.
                         * &lt;br&gt;&lt;br&gt;
                         * Because of how operating systems handle key repeats, holding down a key
                         * will cause multiple calls to keyTyped() (and keyReleased() as well). The
                         * rate of repeat is set by the operating system and how each computer is
                         * configured.&lt;br&gt;&lt;br&gt;
                         * Browsers may have different default behaviors attached to various key
                         * events. To prevent any default behavior for this event, add &quot;return false&quot;
                         * to the end of the method.
                         *
                         * @method keyTyped
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var value = 0;
                         * function draw() {
                         *   fill(value);
                         *   rect(25, 25, 50, 50);
                         * }
                         * function keyTyped() {
                         *   if (key === &#x27;a&#x27;) {
                         *     value = 255;
                         *   } else if (key === &#x27;b&#x27;) {
                         *     value = 0;
                         *   }
                         *   return false; // prevent any default behavior
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype._onkeypress = function (e) {
                          if (e.which === this._lastKeyCodeTyped) { // prevent multiple firings
                            return;
                          }
                          this._setProperty(&#x27;keyCode&#x27;, e.which);
                          this._setProperty(&#x27;_lastKeyCodeTyped&#x27;, e.which); // track last keyCode
                          this._setProperty(&#x27;key&#x27;, String.fromCharCode(e.which));
                          var keyTyped = this.keyTyped || window.keyTyped;
                          if (typeof keyTyped === &#x27;function&#x27;) {
                            var executeDefault = keyTyped(e);
                            if(executeDefault === false) {
                              e.preventDefault();
                            }
                          }
                        };
                        /**
                         * The onblur function is called when the user is no longer focused
                         * on the p5 element. Because the keyup events will not fire if the user is
                         * not focused on the element we must assume all keys currently down have
                         * been released.
                         */
                        p5.prototype._onblur = function (e) {
                          downKeys = {};
                        };
                        
                        /**
                         * The keyIsDown() function checks if the key is currently down, i.e. pressed.
                         * It can be used if you have an object that moves, and you want several keys
                         * to be able to affect its behaviour simultaneously, such as moving a
                         * sprite diagonally. You can put in any number representing the keyCode of
                         * the key, or use any of the variable keyCode names listed
                         * &lt;a href=&quot;http://p5js.org/reference/#p5/keyCode&quot;&gt;here&lt;/a&gt;.
                         *
                         * @method keyIsDown
                         * @param {Number}          code The key to check for.
                         * @return {Boolean}        whether key is down or not
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * var x = 100;
                         * var y = 100;
                         *
                         * function setup() {
                         *   createCanvas(512, 512);
                         * }
                         *
                         * function draw() {
                         *   if (keyIsDown(LEFT_ARROW))
                         *     x-=5;
                         *
                         *   if (keyIsDown(RIGHT_ARROW))
                         *     x+=5;
                         *
                         *   if (keyIsDown(UP_ARROW))
                         *     y-=5;
                         *
                         *   if (keyIsDown(DOWN_ARROW))
                         *     y+=5;
                         *
                         *   clear();
                         *   fill(255, 0, 0);
                         *   ellipse(x, y, 50, 50);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.keyIsDown = function(code) {
                          return downKeys[code];
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;../core/core&quot;:48}],63:[function(_dereq_,module,exports){
                        /**
                         * @module Events
                         * @submodule Mouse
                         * @for p5
                         * @requires core
                         * @requires constants
                         */
                        
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        var constants = _dereq_(&#x27;../core/constants&#x27;);
                        
                        /*
                         * These are helper vars that store the mouseX and mouseY vals
                         * between the time that a mouse event happens and the next frame
                         * of draw. This is done to deal with the asynchronicity of event
                         * calls interacting with the draw loop. When a mouse event occurs
                         * the _nextMouseX/Y vars are updated, then on each call of draw, mouseX/Y
                         * and pmouseX/Y are updated using the _nextMouseX/Y vals.
                         */
                        p5.prototype._nextMouseX = 0;
                        p5.prototype._nextMouseY = 0;
                        
                        /**
                         * The system variable mouseX always contains the current horizontal
                         * position of the mouse, relative to (0, 0) of the canvas.
                         *
                         * @property mouseX
                         *
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Move the mouse across the canvas
                         * function draw() {
                         *   background(244, 248, 252);
                         *   line(mouseX, 0, mouseX, 100);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.mouseX = 0;
                        
                        /**
                         * The system variable mouseY always contains the current vertical position
                         * of the mouse, relative to (0, 0) of the canvas.
                         *
                         * @property mouseY
                         *
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Move the mouse across the canvas
                         * function draw() {
                         *   background(244, 248, 252);
                         *   line(0, mouseY, 100, mouseY);
                         *}
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.mouseY = 0;
                        
                        /**
                         * The system variable pmouseX always contains the horizontal position of
                         * the mouse in the frame previous to the current frame, relative to (0, 0)
                         * of the canvas.
                         *
                         * @property pmouseX
                         *
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Move the mouse across the canvas to leave a trail
                         * function setup() {
                         *   //slow down the frameRate to make it more visible
                         *   frameRate(10);
                         * }
                         *
                         * function draw() {
                         *   background(244, 248, 252);
                         *   line(mouseX, mouseY, pmouseX, pmouseY);
                         *   print(pmouseX + &quot; -&gt; &quot; + mouseX);
                         * }
                         *
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.pmouseX = 0;
                        
                        /**
                         * The system variable pmouseY always contains the vertical position of the
                         * mouse in the frame previous to the current frame, relative to (0, 0) of
                         * the canvas.
                         *
                         * @property pmouseY
                         *
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * function draw() {
                         *   background(237, 34, 93);
                         *   fill(0);
                         *   //draw a square only if the mouse is not moving
                         *   if(mouseY == pmouseY &amp;&amp; mouseX == pmouseX)
                         *     rect(20,20,60,60);
                         *
                         *   print(pmouseY + &quot; -&gt; &quot; + mouseY);
                         * }
                         *
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.pmouseY = 0;
                        
                        /**
                         * The system variable winMouseX always contains the current horizontal
                         * position of the mouse, relative to (0, 0) of the window.
                         *
                         * @property winMouseX
                         *
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var myCanvas;
                         *
                         * function setup() {
                         *   //use a variable to store a pointer to the canvas
                         *   myCanvas = createCanvas(100, 100);
                         * }
                         *
                         * function draw() {
                         *   background(237, 34, 93);
                         *   fill(0);
                         *
                         *   //move the canvas to the horizontal mouse position
                         *   //relative to the window
                         *   myCanvas.position(winMouseX+1, windowHeight/2);
                         *
                         *  //the y of the square is relative to the canvas
                         *  rect(20,mouseY,60,60);
                         * }
                         *
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.winMouseX = 0;
                        
                        /**
                         * The system variable winMouseY always contains the current vertical
                         * position of the mouse, relative to (0, 0) of the window.
                         *
                         * @property winMouseY
                         *
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         *var myCanvas;
                         *
                         * function setup() {
                         *   //use a variable to store a pointer to the canvas
                         *   myCanvas = createCanvas(100, 100);
                         * }
                         *
                         * function draw() {
                         *   background(237, 34, 93);
                         *   fill(0);
                         *
                         *   //move the canvas to the vertical mouse position
                         *   //relative to the window
                         *   myCanvas.position(windowWidth/2, winMouseY+1);
                         *
                         *  //the x of the square is relative to the canvas
                         *  rect(mouseX,20,60,60);
                         * }
                         *
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.winMouseY = 0;
                        
                        /**
                         * The system variable pwinMouseX always contains the horizontal position
                         * of the mouse in the frame previous to the current frame, relative to
                         * (0, 0) of the window.
                         *
                         * @property pwinMouseX
                         *
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         *
                         * var myCanvas;
                         *
                         * function setup() {
                         *   //use a variable to store a pointer to the canvas
                         *   myCanvas = createCanvas(100, 100);
                         *   noStroke();
                         *   fill(237, 34, 93);
                         *   }
                         *
                         * function draw() {
                         *   clear();
                         *   //the difference between previous and
                         *   //current x position is the horizontal mouse speed
                         *   var speed = abs(winMouseX-pwinMouseX);
                         *   //change the size of the circle
                         *   //according to the horizontal speed
                         *   ellipse(50, 50, 10+speed*5, 10+speed*5);
                         *   //move the canvas to the mouse position
                         *   myCanvas.position( winMouseX+1, winMouseY+1);
                         * }
                         *
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.pwinMouseX = 0;
                        
                        /**
                         * The system variable pwinMouseY always contains the vertical position of
                         * the mouse in the frame previous to the current frame, relative to (0, 0)
                         * of the window.
                         *
                         * @property pwinMouseY
                         *
                         *
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         *
                         * var myCanvas;
                         *
                         * function setup() {
                         *   //use a variable to store a pointer to the canvas
                         *   myCanvas = createCanvas(100, 100);
                         *   noStroke();
                         *   fill(237, 34, 93);
                         *   }
                         *
                         * function draw() {
                         *   clear();
                         *   //the difference between previous and
                         *   //current y position is the vertical mouse speed
                         *   var speed = abs(winMouseY-pwinMouseY);
                         *   //change the size of the circle
                         *   //according to the vertical speed
                         *   ellipse(50, 50, 10+speed*5, 10+speed*5);
                         *   //move the canvas to the mouse position
                         *   myCanvas.position( winMouseX+1, winMouseY+1);
                         * }
                         *
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.pwinMouseY = 0;
                        
                        /**
                         * Processing automatically tracks if the mouse button is pressed and which
                         * button is pressed. The value of the system variable mouseButton is either
                         * LEFT, RIGHT, or CENTER depending on which button was pressed last.
                         * Warning: different browsers may track mouseButton differently.
                         *
                         * @property mouseButton
                         *
                         * @example
                            * &lt;div&gt;
                            * &lt;code&gt;
                            * function draw() {
                            *   background(237, 34, 93);
                            *   fill(0);
                            *
                            *   if (mouseIsPressed) {
                            *     if (mouseButton == LEFT)
                            *       ellipse(50, 50, 50, 50);
                            *     if (mouseButton == RIGHT)
                            *       rect(25, 25, 50, 50);
                            *     if (mouseButton == CENTER)
                            *       triangle(23, 75, 50, 20, 78, 75);
                            *   }
                            *
                            *   print(mouseButton);
                            * }
                            * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.mouseButton = 0;
                        
                        /**
                         * The boolean system variable mouseIsPressed is true if the mouse is pressed
                         * and false if not.
                         *
                         * @property mouseIsPressed
                         *
                         * @example
                            * &lt;div&gt;
                            * &lt;code&gt;
                            * function draw() {
                            *   background(237, 34, 93);
                            *   fill(0);
                            *
                            *   if (mouseIsPressed)
                            *     ellipse(50, 50, 50, 50);
                            *   else
                            *     rect(25, 25, 50, 50);
                            *
                            *   print(mouseIsPressed);
                            * }
                            * &lt;/code&gt;
                            * &lt;/div&gt;
                         */
                        p5.prototype.mouseIsPressed = false;
                        p5.prototype.isMousePressed = false; // both are supported
                        
                        p5.prototype._updateNextMouseCoords = function(e) {
                          if(e.type === &#x27;touchstart&#x27; ||
                             e.type === &#x27;touchmove&#x27; ||
                             e.type === &#x27;touchend&#x27;) {
                            this._setProperty(&#x27;_nextMouseX&#x27;, this._nextTouchX);
                            this._setProperty(&#x27;_nextMouseY&#x27;, this._nextTouchY);
                          } else {
                            if(this._curElement !== null) {
                              var mousePos = getMousePos(this._curElement.elt, e);
                              this._setProperty(&#x27;_nextMouseX&#x27;, mousePos.x);
                              this._setProperty(&#x27;_nextMouseY&#x27;, mousePos.y);
                            }
                          }
                          this._setProperty(&#x27;winMouseX&#x27;, e.pageX);
                          this._setProperty(&#x27;winMouseY&#x27;, e.pageY);
                        };
                        
                        p5.prototype._updateMouseCoords = function() {
                          this._setProperty(&#x27;pmouseX&#x27;, this.mouseX);
                          this._setProperty(&#x27;pmouseY&#x27;, this.mouseY);
                          this._setProperty(&#x27;mouseX&#x27;, this._nextMouseX);
                          this._setProperty(&#x27;mouseY&#x27;, this._nextMouseY);
                          this._setProperty(&#x27;pwinMouseX&#x27;, this.winMouseX);
                          this._setProperty(&#x27;pwinMouseY&#x27;, this.winMouseY);
                        };
                        
                        function getMousePos(canvas, evt) {
                          var rect = canvas.getBoundingClientRect();
                          return {
                            x: evt.clientX - rect.left,
                            y: evt.clientY - rect.top
                          };
                        }
                        
                        p5.prototype._setMouseButton = function(e) {
                          if (e.button === 1) {
                            this._setProperty(&#x27;mouseButton&#x27;, constants.CENTER);
                          } else if (e.button === 2) {
                            this._setProperty(&#x27;mouseButton&#x27;, constants.RIGHT);
                          } else {
                            this._setProperty(&#x27;mouseButton&#x27;, constants.LEFT);
                          }
                        };
                        
                        /**
                         * The mouseMoved() function is called every time the mouse moves and a mouse
                         * button is not pressed.&lt;br&gt;&lt;br&gt;
                         * Browsers may have different default
                         * behaviors attached to various mouse events. To prevent any default
                         * behavior for this event, add &quot;return false&quot; to the end of the method.
                         *
                         * @method mouseMoved
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Move the mouse across the page
                         * // to change its value
                         *
                         * var value = 0;
                         * function draw() {
                         *   fill(value);
                         *   rect(25, 25, 50, 50);
                         * }
                         * function mouseMoved() {
                         *   value = value + 5;
                         *   if (value &gt; 255) {
                         *     value = 0;
                         *   }
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * function mouseMoved() {
                         *   ellipse(mouseX, mouseY, 5, 5);
                         *   // prevent default
                         *   return false;
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        
                        /**
                         * The mouseDragged() function is called once every time the mouse moves and
                         * a mouse button is pressed. If no mouseDragged() function is defined, the
                         * touchMoved() function will be called instead if it is defined.&lt;br&gt;&lt;br&gt;
                         * Browsers may have different default
                         * behaviors attached to various mouse events. To prevent any default
                         * behavior for this event, add &quot;return false&quot; to the end of the method.
                         *
                         * @method mouseDragged
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Drag the mouse across the page
                         * // to change its value
                         *
                         * var value = 0;
                         * function draw() {
                         *   fill(value);
                         *   rect(25, 25, 50, 50);
                         * }
                         * function mouseDragged() {
                         *   value = value + 5;
                         *   if (value &gt; 255) {
                         *     value = 0;
                         *   }
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * function mouseDragged() {
                         *   ellipse(mouseX, mouseY, 5, 5);
                         *   // prevent default
                         *   return false;
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype._onmousemove = function(e){
                          var context = this._isGlobal ? window : this;
                          var executeDefault;
                          this._updateNextMouseCoords(e);
                          this._updateNextTouchCoords(e);
                          if (!this.isMousePressed) {
                            if (typeof context.mouseMoved === &#x27;function&#x27;) {
                              executeDefault = context.mouseMoved(e);
                              if(executeDefault === false) {
                                e.preventDefault();
                              }
                            }
                          }
                          else {
                            if (typeof context.mouseDragged === &#x27;function&#x27;) {
                              executeDefault = context.mouseDragged(e);
                              if(executeDefault === false) {
                                e.preventDefault();
                              }
                            } else if (typeof context.touchMoved === &#x27;function&#x27;) {
                              executeDefault = context.touchMoved(e);
                              if(executeDefault === false) {
                                e.preventDefault();
                              }
                            }
                          }
                        };
                        
                        /**
                         * The mousePressed() function is called once after every time a mouse button
                         * is pressed. The mouseButton variable (see the related reference entry)
                         * can be used to determine which button has been pressed. If no
                         * mousePressed() function is defined, the touchStarted() function will be
                         * called instead if it is defined.&lt;br&gt;&lt;br&gt;
                         * Browsers may have different default
                         * behaviors attached to various mouse events. To prevent any default
                         * behavior for this event, add &quot;return false&quot; to the end of the method.
                         *
                         * @method mousePressed
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Click within the image to change
                         * // the value of the rectangle
                         *
                         * var value = 0;
                         * function draw() {
                         *   fill(value);
                         *   rect(25, 25, 50, 50);
                         * }
                         * function mousePressed() {
                         *   if (value == 0) {
                         *     value = 255;
                         *   } else {
                         *     value = 0;
                         *   }
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * function mousePressed() {
                         *   ellipse(mouseX, mouseY, 5, 5);
                         *   // prevent default
                         *   return false;
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype._onmousedown = function(e) {
                          var context = this._isGlobal ? window : this;
                          var executeDefault;
                          this._setProperty(&#x27;isMousePressed&#x27;, true);
                          this._setProperty(&#x27;mouseIsPressed&#x27;, true);
                          this._setMouseButton(e);
                          this._updateNextMouseCoords(e);
                          this._updateNextTouchCoords(e);
                          if (typeof context.mousePressed === &#x27;function&#x27;) {
                            executeDefault = context.mousePressed(e);
                            if(executeDefault === false) {
                              e.preventDefault();
                            }
                          } else if (typeof context.touchStarted === &#x27;function&#x27;) {
                            executeDefault = context.touchStarted(e);
                            if(executeDefault === false) {
                              e.preventDefault();
                            }
                          }
                        };
                        
                        /**
                         * The mouseReleased() function is called every time a mouse button is
                         * released. If no mouseReleased() function is defined, the touchEnded()
                         * function will be called instead if it is defined.&lt;br&gt;&lt;br&gt;
                         * Browsers may have different default
                         * behaviors attached to various mouse events. To prevent any default
                         * behavior for this event, add &quot;return false&quot; to the end of the method.
                         *
                         *
                         * @method mouseReleased
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Click within the image to change
                         * // the value of the rectangle
                         * // after the mouse has been clicked
                         *
                         * var value = 0;
                         * function draw() {
                         *   fill(value);
                         *   rect(25, 25, 50, 50);
                         * }
                         * function mouseReleased() {
                         *   if (value == 0) {
                         *     value = 255;
                         *   } else {
                         *     value = 0;
                         *   }
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * function mouseReleased() {
                         *   ellipse(mouseX, mouseY, 5, 5);
                         *   // prevent default
                         *   return false;
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype._onmouseup = function(e) {
                          var context = this._isGlobal ? window : this;
                          var executeDefault;
                          this._setProperty(&#x27;isMousePressed&#x27;, false);
                          this._setProperty(&#x27;mouseIsPressed&#x27;, false);
                          if (typeof context.mouseReleased === &#x27;function&#x27;) {
                            executeDefault = context.mouseReleased(e);
                            if(executeDefault === false) {
                              e.preventDefault();
                            }
                          } else if (typeof context.touchEnded === &#x27;function&#x27;) {
                            executeDefault = context.touchEnded(e);
                            if(executeDefault === false) {
                              e.preventDefault();
                            }
                          }
                        };
                        
                        p5.prototype._ondragend = p5.prototype._onmouseup;
                        p5.prototype._ondragover = p5.prototype._onmousemove;
                        
                        /**
                         * The mouseClicked() function is called once after a mouse button has been
                         * pressed and then released.&lt;br&gt;&lt;br&gt;
                         * Browsers may have different default
                         * behaviors attached to various mouse events. To prevent any default
                         * behavior for this event, add &quot;return false&quot; to the end of the method.
                         *
                         * @method mouseClicked
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Click within the image to change
                         * // the value of the rectangle
                         * // after the mouse has been clicked
                         *
                         * var value = 0;
                         * function draw() {
                         *   fill(value);
                         *   rect(25, 25, 50, 50);
                         * }
                         * function mouseClicked() {
                         *   if (value == 0) {
                         *     value = 255;
                         *   } else {
                         *     value = 0;
                         *   }
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * function mouseClicked() {
                         *   ellipse(mouseX, mouseY, 5, 5);
                         *   // prevent default
                         *   return false;
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype._onclick = function(e) {
                          var context = this._isGlobal ? window : this;
                          if (typeof context.mouseClicked === &#x27;function&#x27;) {
                            var executeDefault = context.mouseClicked(e);
                            if(executeDefault === false) {
                              e.preventDefault();
                            }
                          }
                        };
                        
                        /**
                         * The function mouseWheel() is executed every time a vertical mouse wheel
                         * event is detected either triggered by an actual mouse wheel or by a
                         * touchpad.&lt;br&gt;&lt;br&gt;
                         * The event.delta property returns the amount the mouse wheel
                         * have scrolled. The values can be positive or negative depending on the
                         * scroll direction (on OS X with &quot;natural&quot; scrolling enabled, the signs
                         * are inverted).&lt;br&gt;&lt;br&gt;
                         * Browsers may have different default behaviors attached to various
                         * mouse events. To prevent any default behavior for this event, add
                         * &quot;return false&quot; to the end of the method.&lt;br&gt;&lt;br&gt;
                         * Due to the current support of the &quot;wheel&quot; event on Safari, the function
                         * may only work as expected if &quot;return false&quot; is included while using Safari.
                         *
                         * @method mouseWheel
                         *
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var pos = 25;
                         *
                         * function draw() {
                         *   background(237, 34, 93);
                         *   fill(0);
                         *   rect(25, pos, 50, 50);
                         * }
                         *
                         * function mouseWheel(event) {
                         *   print(event.delta);
                         *   //move the square according to the vertical scroll amount
                         *   pos += event.delta;
                         *   //uncomment to block page scrolling
                         *   //return false;
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype._onwheel = function(e) {
                          var context = this._isGlobal ? window : this;
                          if (typeof context.mouseWheel === &#x27;function&#x27;) {
                            e.delta = e.deltaY;
                            var executeDefault = context.mouseWheel(e);
                            if(executeDefault === false) {
                              e.preventDefault();
                            }
                          }
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;../core/constants&quot;:47,&quot;../core/core&quot;:48}],64:[function(_dereq_,module,exports){
                        /**
                         * @module Events
                         * @submodule Touch
                         * @for p5
                         * @requires core
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        
                        /*
                         * These are helper vars that store the touchX and touchY vals
                         * between the time that a mouse event happens and the next frame
                         * of draw. This is done to deal with the asynchronicity of event
                         * calls interacting with the draw loop. When a touch event occurs
                         * the _nextTouchX/Y vars are updated, then on each call of draw, touchX/Y
                         * and ptouchX/Y are updated using the _nextMouseX/Y vals.
                         */
                        p5.prototype._nextTouchX = 0;
                        p5.prototype._nextTouchY = 0;
                        
                        /**
                         * The system variable touchX always contains the horizontal position of
                         * one finger, relative to (0, 0) of the canvas. This is best used for
                         * single touch interactions. For multi-touch interactions, use the
                         * touches[] array.
                         *
                         * @property touchX
                         */
                        p5.prototype.touchX = 0;
                        
                        /**
                         * The system variable touchY always contains the vertical position of
                         * one finger, relative to (0, 0) of the canvas. This is best used for
                         * single touch interactions. For multi-touch interactions, use the
                         * touches[] array.
                         *
                         * @property touchY
                         */
                        p5.prototype.touchY = 0;
                        
                        /**
                         * The system variable ptouchX always contains the horizontal position of
                         * one finger, relative to (0, 0) of the canvas, in the frame previous to the
                         * current frame.
                         *
                         * @property ptouchX
                         */
                        p5.prototype.ptouchX = 0;
                        
                        /**
                         * The system variable ptouchY always contains the vertical position of
                         * one finger, relative to (0, 0) of the canvas, in the frame previous to the
                         * current frame.
                         *
                         * @property ptouchY
                         */
                        p5.prototype.ptouchY = 0;
                        
                        /**
                         * The system variable touches[] contains an array of the positions of all
                         * current touch points, relative to (0, 0) of the canvas, and IDs identifying a
                         * unique touch as it moves. Each element in the array is an object with x, y,
                         * and id properties.
                         *
                         * @property touches[]
                         */
                        p5.prototype.touches = [];
                        
                        /**
                         * The boolean system variable touchIsDown is true if the screen is
                         * touched and false if not.
                         *
                         * @property touchIsDown
                         */
                        p5.prototype.touchIsDown = false;
                        
                        p5.prototype._updateNextTouchCoords = function(e) {
                          if(e.type === &#x27;mousedown&#x27; ||
                             e.type === &#x27;mousemove&#x27; ||
                             e.type === &#x27;mouseup&#x27;){
                            this._setProperty(&#x27;_nextTouchX&#x27;, this._nextMouseX);
                            this._setProperty(&#x27;_nextTouchY&#x27;, this._nextMouseY);
                          } else {
                            if(this._curElement !== null) {
                              var touchInfo = getTouchInfo(this._curElement.elt, e, 0);
                              this._setProperty(&#x27;_nextTouchX&#x27;, touchInfo.x);
                              this._setProperty(&#x27;_nextTouchY&#x27;, touchInfo.y);
                        
                              var touches = [];
                              for(var i = 0; i &lt; e.touches.length; i++){
                                touches[i] = getTouchInfo(this._curElement.elt, e, i);
                              }
                              this._setProperty(&#x27;touches&#x27;, touches);
                            }
                          }
                        };
                        
                        p5.prototype._updateTouchCoords = function() {
                          this._setProperty(&#x27;ptouchX&#x27;, this.touchX);
                          this._setProperty(&#x27;ptouchY&#x27;, this.touchY);
                          this._setProperty(&#x27;touchX&#x27;, this._nextTouchX);
                          this._setProperty(&#x27;touchY&#x27;, this._nextTouchY);
                        };
                        
                        function getTouchInfo(canvas, e, i) {
                          i = i || 0;
                          var rect = canvas.getBoundingClientRect();
                          var touch = e.touches[i] || e.changedTouches[i];
                          return {
                            x: touch.clientX - rect.left,
                            y: touch.clientY - rect.top,
                            id: touch.identifier
                          };
                        }
                        
                        /**
                         * The touchStarted() function is called once after every time a touch is
                         * registered. If no touchStarted() function is defined, the mousePressed()
                         * function will be called instead if it is defined.&lt;br&gt;&lt;br&gt;
                         * Browsers may have different default behaviors attached to various touch
                         * events. To prevent any default behavior for this event, add &quot;return false&quot;
                         * to the end of the method.
                         *
                         * @method touchStarted
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Touch within the image to change
                         * // the value of the rectangle
                         *
                         * var value = 0;
                         * function draw() {
                         *   fill(value);
                         *   rect(25, 25, 50, 50);
                         * }
                         * function touchStarted() {
                         *   if (value == 0) {
                         *     value = 255;
                         *   } else {
                         *     value = 0;
                         *   }
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * function touchStarted() {
                         *   ellipse(touchX, touchY, 5, 5);
                         *   // prevent default
                         *   return false;
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype._ontouchstart = function(e) {
                          var context = this._isGlobal ? window : this;
                          var executeDefault;
                          this._updateNextTouchCoords(e);
                          this._updateNextMouseCoords(e);
                          this._setProperty(&#x27;touchIsDown&#x27;, true);
                          if(typeof context.touchStarted === &#x27;function&#x27;) {
                            executeDefault = context.touchStarted(e);
                            if(executeDefault === false) {
                              e.preventDefault();
                            }
                          } else if (typeof context.mousePressed === &#x27;function&#x27;) {
                            executeDefault = context.mousePressed(e);
                            if(executeDefault === false) {
                              e.preventDefault();
                            }
                            //this._setMouseButton(e);
                          }
                        };
                        
                        /**
                         * The touchMoved() function is called every time a touch move is registered.
                         * If no touchMoved() function is defined, the mouseDragged() function will
                         * be called instead if it is defined.&lt;br&gt;&lt;br&gt;
                         * Browsers may have different default behaviors attached to various touch
                         * events. To prevent any default behavior for this event, add &quot;return false&quot;
                         * to the end of the method.
                         *
                         * @method touchMoved
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Move your finger across the page
                         * // to change its value
                         *
                         * var value = 0;
                         * function draw() {
                         *   fill(value);
                         *   rect(25, 25, 50, 50);
                         * }
                         * function touchMoved() {
                         *   value = value + 5;
                         *   if (value &gt; 255) {
                         *     value = 0;
                         *   }
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * function touchMoved() {
                         *   ellipse(touchX, touchY, 5, 5);
                         *   // prevent default
                         *   return false;
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype._ontouchmove = function(e) {
                          var context = this._isGlobal ? window : this;
                          var executeDefault;
                          this._updateNextTouchCoords(e);
                          this._updateNextMouseCoords(e);
                          if (typeof context.touchMoved === &#x27;function&#x27;) {
                            executeDefault = context.touchMoved(e);
                            if(executeDefault === false) {
                              e.preventDefault();
                            }
                          } else if (typeof context.mouseDragged === &#x27;function&#x27;) {
                            executeDefault = context.mouseDragged(e);
                            if(executeDefault === false) {
                              e.preventDefault();
                            }
                          }
                        };
                        
                        /**
                         * The touchEnded() function is called every time a touch ends. If no
                         * touchEnded() function is defined, the mouseReleased() function will be
                         * called instead if it is defined.&lt;br&gt;&lt;br&gt;
                         * Browsers may have different default behaviors attached to various touch
                         * events. To prevent any default behavior for this event, add &quot;return false&quot;
                         * to the end of the method.
                         *
                         * @method touchEnded
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Release touch within the image to
                         * // change the value of the rectangle
                         *
                         * var value = 0;
                         * function draw() {
                         *   fill(value);
                         *   rect(25, 25, 50, 50);
                         * }
                         * function touchEnded() {
                         *   if (value == 0) {
                         *     value = 255;
                         *   } else {
                         *     value = 0;
                         *   }
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * function touchEnded() {
                         *   ellipse(touchX, touchY, 5, 5);
                         *   // prevent default
                         *   return false;
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype._ontouchend = function(e) {
                          this._updateNextTouchCoords(e);
                          this._updateNextMouseCoords(e);
                          if (this.touches.length === 0) {
                            this._setProperty(&#x27;touchIsDown&#x27;, false);
                          }
                          var context = this._isGlobal ? window : this;
                          var executeDefault;
                          if (typeof context.touchEnded === &#x27;function&#x27;) {
                            executeDefault = context.touchEnded(e);
                            if(executeDefault === false) {
                              e.preventDefault();
                            }
                          } else if (typeof context.mouseReleased === &#x27;function&#x27;) {
                            executeDefault = context.mouseReleased(e);
                            if(executeDefault === false) {
                              e.preventDefault();
                            }
                          }
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;../core/core&quot;:48}],65:[function(_dereq_,module,exports){
                        /*global ImageData:false */
                        
                        /**
                         * This module defines the filters for use with image buffers.
                         *
                         * This module is basically a collection of functions stored in an object
                         * as opposed to modules. The functions are destructive, modifying
                         * the passed in canvas rather than creating a copy.
                         *
                         * Generally speaking users of this module will use the Filters.apply method
                         * on a canvas to create an effect.
                         *
                         * A number of functions are borrowed/adapted from
                         * http://www.html5rocks.com/en/tutorials/canvas/imagefilters/
                         * or the java processing implementation.
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var Filters = {};
                        
                        
                        /*
                         * Helper functions
                         */
                        
                        
                        /**
                         * Returns the pixel buffer for a canvas
                         *
                         * @private
                         *
                         * @param  {Canvas|ImageData} canvas the canvas to get pixels from
                         * @return {Uint8ClampedArray}       a one-dimensional array containing
                         *                                   the data in thc RGBA order, with integer
                         *                                   values between 0 and 255
                         */
                        Filters._toPixels = function (canvas) {
                          if (canvas instanceof ImageData) {
                            return canvas.data;
                          } else {
                            return canvas.getContext(&#x27;2d&#x27;).getImageData(
                              0,
                              0,
                              canvas.width,
                              canvas.height
                            ).data;
                          }
                        };
                        
                        /**
                         * Returns a 32 bit number containing ARGB data at ith pixel in the
                         * 1D array containing pixels data.
                         *
                         * @private
                         *
                         * @param  {Uint8ClampedArray} data array returned by _toPixels()
                         * @param  {Integer}           i    index of a 1D Image Array
                         * @return {Integer}                32 bit integer value representing
                         *                                  ARGB value.
                         */
                        Filters._getARGB = function (data, i) {
                          var offset = i * 4;
                          return (data[offset+3] &lt;&lt; 24) &amp; 0xff000000 |
                            (data[offset] &lt;&lt; 16) &amp; 0x00ff0000 |
                            (data[offset+1] &lt;&lt; 8) &amp; 0x0000ff00 |
                            data[offset+2] &amp; 0x000000ff;
                        };
                        
                        /**
                         * Modifies pixels RGBA values to values contained in the data object.
                         *
                         * @private
                         *
                         * @param {Uint8ClampedArray} pixels array returned by _toPixels()
                         * @param {Int32Array}        data   source 1D array where each value
                         *                                   represents ARGB values
                         */
                        Filters._setPixels = function (pixels, data) {
                          var offset = 0;
                          for( var i = 0, al = pixels.length; i &lt; al; i++) {
                            offset = i*4;
                            pixels[offset + 0] = (data[i] &amp; 0x00ff0000)&gt;&gt;&gt;16;
                            pixels[offset + 1] = (data[i] &amp; 0x0000ff00)&gt;&gt;&gt;8;
                            pixels[offset + 2] = (data[i] &amp; 0x000000ff);
                            pixels[offset + 3] = (data[i] &amp; 0xff000000)&gt;&gt;&gt;24;
                          }
                        };
                        
                        /**
                         * Returns the ImageData object for a canvas
                         * https://developer.mozilla.org/en-US/docs/Web/API/ImageData
                         *
                         * @private
                         *
                         * @param  {Canvas|ImageData} canvas canvas to get image data from
                         * @return {ImageData}               Holder of pixel data (and width and
                         *                                   height) for a canvas
                         */
                        Filters._toImageData = function (canvas) {
                          if (canvas instanceof ImageData) {
                            return canvas;
                          } else {
                            return canvas.getContext(&#x27;2d&#x27;).getImageData(
                              0,
                              0,
                              canvas.width,
                              canvas.height
                            );
                          }
                        };
                        
                        /**
                         * Returns a blank ImageData object.
                         *
                         * @private
                         *
                         * @param  {Integer} width
                         * @param  {Integer} height
                         * @return {ImageData}
                         */
                        Filters._createImageData = function (width, height) {
                          Filters._tmpCanvas = document.createElement(&#x27;canvas&#x27;);
                          Filters._tmpCtx = Filters._tmpCanvas.getContext(&#x27;2d&#x27;);
                          return this._tmpCtx.createImageData(width, height);
                        };
                        
                        
                        /**
                         * Applys a filter function to a canvas.
                         *
                         * The difference between this and the actual filter functions defined below
                         * is that the filter functions generally modify the pixel buffer but do
                         * not actually put that data back to the canvas (where it would actually
                         * update what is visible). By contrast this method does make the changes
                         * actually visible in the canvas.
                         *
                         * The apply method is the method that callers of this module would generally
                         * use. It has been separated from the actual filters to support an advanced
                         * use case of creating a filter chain that executes without actually updating
                         * the canvas in between everystep.
                         *
                         * @param  {[type]} func   [description]
                         * @param  {[type]} canvas [description]
                         * @param  {[type]} level  [description]
                         * @return {[type]}        [description]
                         */
                        Filters.apply = function (canvas, func, filterParam) {
                          var ctx = canvas.getContext(&#x27;2d&#x27;);
                          var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        
                          //Filters can either return a new ImageData object, or just modify
                          //the one they received.
                          var newImageData = func(imageData, filterParam);
                          if (newImageData instanceof ImageData) {
                            ctx.putImageData(newImageData, 0, 0, 0, 0, canvas.width, canvas.height);
                          } else {
                            ctx.putImageData(imageData, 0, 0, 0, 0, canvas.width, canvas.height);
                          }
                        };
                        
                        
                        /*
                         * Filters
                         */
                        
                        
                        /**
                         * Converts the image to black and white pixels depending if they are above or
                         * below the threshold defined by the level parameter. The parameter must be
                         * between 0.0 (black) and 1.0 (white). If no level is specified, 0.5 is used.
                         *
                         * Borrowed from http://www.html5rocks.com/en/tutorials/canvas/imagefilters/
                         *
                         * @param  {Canvas} canvas
                         * @param  {Float} level
                         */
                        Filters.threshold = function (canvas, level) {
                          var pixels = Filters._toPixels(canvas);
                        
                          if (level === undefined) {
                            level = 0.5;
                          }
                          var thresh = Math.floor(level * 255);
                        
                          for (var i = 0; i &lt; pixels.length; i += 4) {
                            var r = pixels[i];
                            var g = pixels[i + 1];
                            var b = pixels[i + 2];
                            var gray = (0.2126 * r + 0.7152 * g + 0.0722 * b);
                            var val;
                            if (gray &gt;= thresh) {
                              val = 255;
                            } else {
                              val = 0;
                            }
                            pixels[i] = pixels[i + 1] = pixels[i + 2] = val;
                          }
                        
                        };
                        
                        
                        /**
                         * Converts any colors in the image to grayscale equivalents.
                         * No parameter is used.
                         *
                         * Borrowed from http://www.html5rocks.com/en/tutorials/canvas/imagefilters/
                         *
                         * @param {Canvas} canvas
                         */
                        Filters.gray = function (canvas) {
                          var pixels = Filters._toPixels(canvas);
                        
                          for (var i = 0; i &lt; pixels.length; i += 4) {
                            var r = pixels[i];
                            var g = pixels[i + 1];
                            var b = pixels[i + 2];
                        
                            // CIE luminance for RGB
                            var gray = (0.2126 * r + 0.7152 * g + 0.0722 * b);
                            pixels[i] = pixels[i + 1] = pixels[i + 2] = gray;
                          }
                        };
                        
                        /**
                         * Sets the alpha channel to entirely opaque. No parameter is used.
                         *
                         * @param {Canvas} canvas
                         */
                        Filters.opaque = function (canvas) {
                          var pixels = Filters._toPixels(canvas);
                        
                          for (var i = 0; i &lt; pixels.length; i += 4) {
                            pixels[i + 3] = 255;
                          }
                        
                          return pixels;
                        };
                        
                        /**
                         * Sets each pixel to its inverse value. No parameter is used.
                         * @param {Invert}
                         */
                        Filters.invert = function (canvas) {
                          var pixels = Filters._toPixels(canvas);
                        
                          for (var i = 0; i &lt; pixels.length; i += 4) {
                            pixels[i] = 255 - pixels[i];
                            pixels[i + 1] = 255 - pixels[i + 1];
                            pixels[i + 2] = 255 - pixels[i + 2];
                          }
                        
                        };
                        
                        
                        /**
                         * Limits each channel of the image to the number of colors specified as
                         * the parameter. The parameter can be set to values between 2 and 255, but
                         * results are most noticeable in the lower ranges.
                         *
                         * Adapted from java based processing implementation
                         *
                         * @param  {Canvas} canvas
                         * @param  {Integer} level
                         */
                        Filters.posterize = function (canvas, level) {
                          var pixels = Filters._toPixels(canvas);
                        
                          if ((level &lt; 2) || (level &gt; 255)) {
                            throw new Error(
                              &#x27;Level must be greater than 2 and less than 255 for posterize&#x27;
                            );
                          }
                        
                          var levels1 = level - 1;
                          for (var i = 0; i &lt; pixels.length; i+=4) {
                            var rlevel = pixels[i];
                            var glevel = pixels[i + 1];
                            var blevel = pixels[i + 2];
                        
                            pixels[i] = (((rlevel * level) &gt;&gt; 8) * 255) / levels1;
                            pixels[i + 1] = (((glevel * level) &gt;&gt; 8) * 255) / levels1;
                            pixels[i + 2] = (((blevel * level) &gt;&gt; 8) * 255) / levels1;
                          }
                        };
                        
                        /**
                         * reduces the bright areas in an image
                         * @param  {Canvas} canvas
                         *
                         */
                        Filters.dilate = function (canvas) {
                          var pixels = Filters._toPixels(canvas);
                          var currIdx = 0;
                          var maxIdx = pixels.length ? pixels.length/4 : 0;
                          var out = new Int32Array(maxIdx);
                          var currRowIdx, maxRowIdx, colOrig, colOut, currLum;
                          var idxRight, idxLeft, idxUp, idxDown,
                              colRight, colLeft, colUp, colDown,
                              lumRight, lumLeft, lumUp, lumDown;
                        
                          while(currIdx &lt; maxIdx) {
                            currRowIdx = currIdx;
                            maxRowIdx = currIdx + canvas.width;
                            while (currIdx &lt; maxRowIdx) {
                              colOrig = colOut = Filters._getARGB(pixels, currIdx);
                              idxLeft = currIdx - 1;
                              idxRight = currIdx + 1;
                              idxUp = currIdx - canvas.width;
                              idxDown = currIdx + canvas.width;
                        
                              if (idxLeft &lt; currRowIdx) {
                                idxLeft = currIdx;
                              }
                              if (idxRight &gt;= maxRowIdx) {
                                idxRight = currIdx;
                              }
                              if (idxUp &lt; 0){
                                idxUp = 0;
                              }
                              if (idxDown &gt;= maxIdx) {
                                idxDown = currIdx;
                              }
                              colUp = Filters._getARGB(pixels, idxUp);
                              colLeft = Filters._getARGB(pixels, idxLeft);
                              colDown = Filters._getARGB(pixels, idxDown);
                              colRight = Filters._getARGB(pixels, idxRight);
                        
                              //compute luminance
                              currLum = 77*(colOrig&gt;&gt;16&amp;0xff) +
                                151*(colOrig&gt;&gt;8&amp;0xff) +
                                28*(colOrig&amp;0xff);
                              lumLeft = 77*(colLeft&gt;&gt;16&amp;0xff) +
                                151*(colLeft&gt;&gt;8&amp;0xff) +
                                28*(colLeft&amp;0xff);
                              lumRight = 77*(colRight&gt;&gt;16&amp;0xff) +
                                151*(colRight&gt;&gt;8&amp;0xff) +
                                28*(colRight&amp;0xff);
                              lumUp = 77*(colUp&gt;&gt;16&amp;0xff) +
                                151*(colUp&gt;&gt;8&amp;0xff) +
                                28*(colUp&amp;0xff);
                              lumDown = 77*(colDown&gt;&gt;16&amp;0xff) +
                                151*(colDown&gt;&gt;8&amp;0xff) +
                                28*(colDown&amp;0xff);
                        
                              if (lumLeft &gt; currLum) {
                                colOut = colLeft;
                                currLum = lumLeft;
                              }
                              if (lumRight &gt; currLum) {
                                colOut = colRight;
                                currLum = lumRight;
                              }
                              if (lumUp &gt; currLum) {
                                colOut = colUp;
                                currLum = lumUp;
                              }
                              if (lumDown &gt; currLum) {
                                colOut = colDown;
                                currLum = lumDown;
                              }
                              out[currIdx++]=colOut;
                            }
                          }
                          Filters._setPixels(pixels, out);
                        };
                        
                        /**
                         * increases the bright areas in an image
                         * @param  {Canvas} canvas
                         *
                         */
                        Filters.erode = function(canvas) {
                          var pixels = Filters._toPixels(canvas);
                          var currIdx = 0;
                          var maxIdx = pixels.length ? pixels.length/4 : 0;
                          var out = new Int32Array(maxIdx);
                          var currRowIdx, maxRowIdx, colOrig, colOut, currLum;
                          var idxRight, idxLeft, idxUp, idxDown,
                              colRight, colLeft, colUp, colDown,
                              lumRight, lumLeft, lumUp, lumDown;
                        
                          while(currIdx &lt; maxIdx) {
                            currRowIdx = currIdx;
                            maxRowIdx = currIdx + canvas.width;
                            while (currIdx &lt; maxRowIdx) {
                              colOrig = colOut = Filters._getARGB(pixels, currIdx);
                              idxLeft = currIdx - 1;
                              idxRight = currIdx + 1;
                              idxUp = currIdx - canvas.width;
                              idxDown = currIdx + canvas.width;
                        
                              if (idxLeft &lt; currRowIdx) {
                                idxLeft = currIdx;
                              }
                              if (idxRight &gt;= maxRowIdx) {
                                idxRight = currIdx;
                              }
                              if (idxUp &lt; 0) {
                                idxUp = 0;
                              }
                              if (idxDown &gt;= maxIdx) {
                                idxDown = currIdx;
                              }
                              colUp = Filters._getARGB(pixels, idxUp);
                              colLeft = Filters._getARGB(pixels, idxLeft);
                              colDown = Filters._getARGB(pixels, idxDown);
                              colRight = Filters._getARGB(pixels, idxRight);
                        
                              //compute luminance
                              currLum = 77*(colOrig&gt;&gt;16&amp;0xff) +
                                151*(colOrig&gt;&gt;8&amp;0xff) +
                                28*(colOrig&amp;0xff);
                              lumLeft = 77*(colLeft&gt;&gt;16&amp;0xff) +
                                151*(colLeft&gt;&gt;8&amp;0xff) +
                                28*(colLeft&amp;0xff);
                              lumRight = 77*(colRight&gt;&gt;16&amp;0xff) +
                                151*(colRight&gt;&gt;8&amp;0xff) +
                                28*(colRight&amp;0xff);
                              lumUp = 77*(colUp&gt;&gt;16&amp;0xff) +
                                151*(colUp&gt;&gt;8&amp;0xff) +
                                28*(colUp&amp;0xff);
                              lumDown = 77*(colDown&gt;&gt;16&amp;0xff) +
                                151*(colDown&gt;&gt;8&amp;0xff) +
                                28*(colDown&amp;0xff);
                        
                              if (lumLeft &lt; currLum) {
                                colOut = colLeft;
                                currLum = lumLeft;
                              }
                              if (lumRight &lt; currLum) {
                                colOut = colRight;
                                currLum = lumRight;
                              }
                              if (lumUp &lt; currLum) {
                                colOut = colUp;
                                currLum = lumUp;
                              }
                              if (lumDown &lt; currLum) {
                                colOut = colDown;
                                currLum = lumDown;
                              }
                        
                              out[currIdx++]=colOut;
                            }
                          }
                          Filters._setPixels(pixels, out);
                        };
                        
                        // BLUR
                        
                        // internal kernel stuff for the gaussian blur filter
                        var blurRadius;
                        var blurKernelSize;
                        var blurKernel;
                        var blurMult;
                        
                        /*
                         * Port of https://github.com/processing/processing/blob/
                         * master/core/src/processing/core/PImage.java#L1250
                         *
                         * Optimized code for building the blur kernel.
                         * further optimized blur code (approx. 15% for radius=20)
                         * bigger speed gains for larger radii (~30%)
                         * added support for various image types (ALPHA, RGB, ARGB)
                         * [toxi 050728]
                         */
                        function buildBlurKernel(r) {
                          var radius = (r * 3.5)|0;
                          radius = (radius &lt; 1) ? 1 : ((radius &lt; 248) ? radius : 248);
                        
                          if (blurRadius !== radius) {
                            blurRadius = radius;
                            blurKernelSize = 1 + blurRadius&lt;&lt;1;
                            blurKernel = new Int32Array(blurKernelSize);
                            blurMult = new Array(blurKernelSize);
                            for(var l = 0; l &lt; blurKernelSize; l++){
                              blurMult[l] = new Int32Array(256);
                            }
                        
                            var bk,bki;
                            var bm,bmi;
                        
                            for (var i = 1, radiusi = radius - 1; i &lt; radius; i++) {
                              blurKernel[radius+i] = blurKernel[radiusi] = bki = radiusi * radiusi;
                              bm = blurMult[radius+i];
                              bmi = blurMult[radiusi--];
                              for (var j = 0; j &lt; 256; j++){
                                bm[j] = bmi[j] = bki * j;
                              }
                            }
                            bk = blurKernel[radius] = radius * radius;
                            bm = blurMult[radius];
                        
                            for (var k = 0; k &lt; 256; k++){
                              bm[k] = bk * k;
                            }
                          }
                        
                        }
                        
                        // Port of https://github.com/processing/processing/blob/
                        // master/core/src/processing/core/PImage.java#L1433
                        function blurARGB(canvas, radius) {
                          var pixels = Filters._toPixels(canvas);
                          var width = canvas.width;
                          var height = canvas.height;
                          var numPackedPixels = width * height;
                          var argb = new Int32Array(numPackedPixels);
                          for (var j = 0; j &lt; numPackedPixels; j++) {
                            argb[j] = Filters._getARGB(pixels, j);
                          }
                          var sum, cr, cg, cb, ca;
                          var read, ri, ym, ymi, bk0;
                          var a2 = new Int32Array(numPackedPixels);
                          var r2 = new Int32Array(numPackedPixels);
                          var g2 = new Int32Array(numPackedPixels);
                          var b2 = new Int32Array(numPackedPixels);
                          var yi = 0;
                          buildBlurKernel(radius);
                          var x, y, i;
                          var bm;
                          for (y = 0; y &lt; height; y++) {
                            for (x = 0; x &lt; width; x++) {
                              cb = cg = cr = ca = sum = 0;
                              read = x - blurRadius;
                              if (read &lt; 0) {
                                bk0 = -read;
                                read = 0;
                              } else {
                                if (read &gt;= width) {
                                  break;
                                }
                                bk0 = 0;
                              }
                              for (i = bk0; i &lt; blurKernelSize; i++) {
                                if (read &gt;= width) {
                                  break;
                                }
                                var c = argb[read + yi];
                                bm = blurMult[i];
                                ca += bm[(c &amp; -16777216) &gt;&gt;&gt; 24];
                                cr += bm[(c &amp; 16711680) &gt;&gt; 16];
                                cg += bm[(c &amp; 65280) &gt;&gt; 8];
                                cb += bm[c &amp; 255];
                                sum += blurKernel[i];
                                read++;
                              }
                              ri = yi + x;
                              a2[ri] = ca / sum;
                              r2[ri] = cr / sum;
                              g2[ri] = cg / sum;
                              b2[ri] = cb / sum;
                            }
                            yi += width;
                          }
                          yi = 0;
                          ym = -blurRadius;
                          ymi = ym * width;
                          for (y = 0; y &lt; height; y++) {
                            for (x = 0; x &lt; width; x++) {
                              cb = cg = cr = ca = sum = 0;
                              if (ym &lt; 0) {
                                bk0 = ri = -ym;
                                read = x;
                              } else {
                                if (ym &gt;= height) {
                                  break;
                                }
                                bk0 = 0;
                                ri = ym;
                                read = x + ymi;
                              }
                              for (i = bk0; i &lt; blurKernelSize; i++) {
                                if (ri &gt;= height) {
                                  break;
                                }
                                bm = blurMult[i];
                                ca += bm[a2[read]];
                                cr += bm[r2[read]];
                                cg += bm[g2[read]];
                                cb += bm[b2[read]];
                                sum += blurKernel[i];
                                ri++;
                                read += width;
                              }
                              argb[x + yi] = (ca/sum)&lt;&lt;24 | (cr/sum)&lt;&lt;16 | (cg/sum)&lt;&lt;8 | (cb/sum);
                            }
                            yi += width;
                            ymi += width;
                            ym++;
                          }
                          Filters._setPixels(pixels, argb);
                        }
                        
                        Filters.blur = function(canvas, radius){
                          blurARGB(canvas, radius);
                        };
                        
                        
                        module.exports = Filters;
                        
                        },{}],66:[function(_dereq_,module,exports){
                        /**
                         * @module Image
                         * @submodule Image
                         * @for p5
                         * @requires core
                         */
                        
                        /**
                         * This module defines the p5 methods for the p5.Image class
                         * for drawing images to the main display canvas.
                         */
                        &#x27;use strict&#x27;;
                        
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        
                        /* global frames:true */// This is not global, but JSHint is not aware that
                        // this module is implicitly enclosed with Browserify: this overrides the
                        // redefined-global error and permits using the name &quot;frames&quot; for the array
                        // of saved animation frames.
                        var frames = [];
                        
                        
                        /**
                         * Creates a new p5.Image (the datatype for storing images). This provides a
                         * fresh buffer of pixels to play with. Set the size of the buffer with the
                         * width and height parameters.
                         * &lt;br&gt;&lt;br&gt;
                         * .pixels gives access to an array containing the values for all the pixels
                         * in the display window.
                         * These values are numbers. This array is the size (including an appropriate
                         * factor for the pixelDensity) of the display window x4,
                         * representing the R, G, B, A values in order for each pixel, moving from
                         * left to right across each row, then down each column. See .pixels for
                         * more info. It may also be simpler to use set() or get().
                         * &lt;br&gt;&lt;br&gt;
                         * Before accessing the pixels of an image, the data must loaded with the
                         * loadPixels() function. After the array data has been modified, the
                         * updatePixels() function must be run to update the changes.
                         *
                         * @method createImage
                         * @param  {Integer} width  width in pixels
                         * @param  {Integer} height height in pixels
                         * @return {p5.Image}       the p5.Image object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * img = createImage(66, 66);
                         * img.loadPixels();
                         * for (i = 0; i &lt; img.width; i++) {
                         *   for (j = 0; j &lt; img.height; j++) {
                         *     img.set(i, j, color(0, 90, 102));
                         *   }
                         * }
                         * img.updatePixels();
                         * image(img, 17, 17);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * img = createImage(66, 66);
                         * img.loadPixels();
                         * for (i = 0; i &lt; img.width; i++) {
                         *   for (j = 0; j &lt; img.height; j++) {
                         *     img.set(i, j, color(0, 90, 102, i % img.width * 2));
                         *   }
                         * }
                         * img.updatePixels();
                         * image(img, 17, 17);
                         * image(img, 34, 34);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var pink = color(255, 102, 204);
                         * img = createImage(66, 66);
                         * img.loadPixels();
                         * var d = pixelDensity;
                         * var halfImage = 4 * (width * d) * (height/2 * d);
                         * for (var i = 0; i &lt; halfImage; i+=4) {
                         *   img.pixels[i] = red(pink);
                         *   img.pixels[i+1] = green(pink);
                         *   img.pixels[i+2] = blue(pink);
                         *   img.pixels[i+3] = alpha(pink);
                         * }
                         * img.updatePixels();
                         * image(img, 17, 17);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.createImage = function(width, height) {
                          return new p5.Image(width, height);
                        };
                        
                        /**
                         *  Save the current canvas as an image. In Safari, this will open the
                         *  image in the window and the user must provide their own
                         *  filename on save-as. Other browsers will either save the
                         *  file immediately, or prompt the user with a dialogue window.
                         *
                         *  @method saveCanvas
                         *  @param  {[selectedCanvas]} canvas a variable representing a
                         *                             specific html5 canvas (optional)
                         *  @param  {[String]} filename
                         *  @param  {[String]} extension &#x27;jpg&#x27; or &#x27;png&#x27;
                         *  @example
                         *  &lt;div class=&#x27;norender&#x27;&gt;&lt;code&gt;
                         *  function setup() {
                         *    var c = createCanvas(100, 100);
                         *    background(255, 0, 0);
                         *    saveCanvas(c, &#x27;myCanvas&#x27;, &#x27;jpg&#x27;);
                         *  }
                         *  &lt;/code&gt;&lt;/div&gt;
                         *  &lt;div class=&#x27;norender&#x27;&gt;&lt;code&gt;
                         *  // note that this example has the same result as above
                         *  // if no canvas is specified, defaults to main canvas
                         *  function setup() {
                         *    createCanvas(100, 100);
                         *    background(255, 0, 0);
                         *    saveCanvas(&#x27;myCanvas&#x27;, &#x27;jpg&#x27;);
                         *  }
                         *  &lt;/code&gt;&lt;/div&gt;
                         *  &lt;div class=&#x27;norender&#x27;&gt;&lt;code&gt;
                         *  // all of the following are valid
                         *  saveCanvas(c, &#x27;myCanvas&#x27;, &#x27;jpg&#x27;);
                         *  saveCanvas(c, &#x27;myCanvas&#x27;);
                         *  saveCanvas(c);
                         *  saveCanvas(&#x27;myCanvas&#x27;, &#x27;png&#x27;);
                         *  saveCanvas(&#x27;myCanvas&#x27;);
                         *  saveCanvas();
                         *  &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.saveCanvas = function() {
                        
                          var cnv, filename, extension;
                          if (arguments.length === 3) {
                            cnv = arguments[0];
                            filename = arguments[1];
                            extension = arguments[2];
                          } else if (arguments.length === 2) {
                            if (typeof arguments[0] === &#x27;object&#x27;) {
                              cnv = arguments[0];
                              filename = arguments[1];
                            } else {
                              filename = arguments[0];
                              extension = arguments[1];
                            }
                          } else if (arguments.length === 1) {
                            if (typeof arguments[0] === &#x27;object&#x27;) {
                              cnv = arguments[0];
                            } else {
                              filename = arguments[0];
                            }
                          }
                        
                          if (cnv instanceof p5.Element) {
                            cnv = cnv.elt;
                          }
                          if (!(cnv instanceof HTMLCanvasElement)) {
                            cnv = null;
                          }
                        
                          if (!extension) {
                            extension = p5.prototype._checkFileExtension(filename, extension)[1];
                            if (extension === &#x27;&#x27;) {
                              extension = &#x27;png&#x27;;
                            }
                          }
                        
                          if (!cnv) {
                            if (this._curElement &amp;&amp; this._curElement.elt) {
                              cnv = this._curElement.elt;
                            }
                          }
                        
                          if ( p5.prototype._isSafari() ) {
                            var aText = &#x27;Hello, Safari user!\n&#x27;;
                            aText += &#x27;Now capturing a screenshot...\n&#x27;;
                            aText += &#x27;To save this image,\n&#x27;;
                            aText += &#x27;go to File --&gt; Save As.\n&#x27;;
                            alert(aText);
                            window.location.href = cnv.toDataURL();
                          } else {
                            var mimeType;
                            if (typeof(extension) === &#x27;undefined&#x27;) {
                              extension = &#x27;png&#x27;;
                              mimeType = &#x27;image/png&#x27;;
                            }
                            else {
                              switch(extension){
                              case &#x27;png&#x27;:
                                mimeType = &#x27;image/png&#x27;;
                                break;
                              case &#x27;jpeg&#x27;:
                                mimeType = &#x27;image/jpeg&#x27;;
                                break;
                              case &#x27;jpg&#x27;:
                                mimeType = &#x27;image/jpeg&#x27;;
                                break;
                              default:
                                mimeType = &#x27;image/png&#x27;;
                                break;
                              }
                            }
                            var downloadMime = &#x27;image/octet-stream&#x27;;
                            var imageData = cnv.toDataURL(mimeType);
                            imageData = imageData.replace(mimeType, downloadMime);
                        
                            p5.prototype.downloadFile(imageData, filename, extension);
                          }
                        };
                        
                        /**
                         *  Capture a sequence of frames that can be used to create a movie.
                         *  Accepts a callback. For example, you may wish to send the frames
                         *  to a server where they can be stored or converted into a movie.
                         *  If no callback is provided, the browser will attempt to download
                         *  all of the images that have just been created.
                         *
                         *  @method saveFrames
                         *  @param  {[type]}   filename  [description]
                         *  @param  {[type]}   extension [description]
                         *  @param  {[type]}   _duration [description]
                         *  @param  {[type]}   _fps      [description]
                         *  @param  {[Function]} callback  [description]
                         *  @return {[type]}             [description]
                         */
                        p5.prototype.saveFrames = function(fName, ext, _duration, _fps, callback) {
                          var duration = _duration || 3;
                          duration = p5.prototype.constrain(duration, 0, 15);
                          duration = duration * 1000;
                          var fps = _fps || 15;
                          fps = p5.prototype.constrain(fps, 0, 22);
                          var count = 0;
                        
                          var makeFrame = p5.prototype._makeFrame;
                          var cnv = this._curElement.elt;
                          var frameFactory = setInterval(function(){
                            makeFrame(fName + count, ext, cnv);
                            count++;
                          },1000/fps);
                        
                          setTimeout(function(){
                            clearInterval(frameFactory);
                            if (callback) {
                              callback(frames);
                            }
                            else {
                              for (var i = 0; i &lt; frames.length; i++) {
                                var f = frames[i];
                                p5.prototype.downloadFile(f.imageData, f.filename, f.ext);
                              }
                            }
                            frames = []; // clear frames
                          }, duration + 0.01);
                        };
                        
                        p5.prototype._makeFrame = function(filename, extension, _cnv) {
                          var cnv;
                          if (this) {
                            cnv = this._curElement.elt;
                          } else {
                            cnv = _cnv;
                          }
                          var mimeType;
                          if (!extension) {
                            extension = &#x27;png&#x27;;
                            mimeType = &#x27;image/png&#x27;;
                          }
                          else {
                            switch(extension.toLowerCase()){
                            case &#x27;png&#x27;:
                              mimeType = &#x27;image/png&#x27;;
                              break;
                            case &#x27;jpeg&#x27;:
                              mimeType = &#x27;image/jpeg&#x27;;
                              break;
                            case &#x27;jpg&#x27;:
                              mimeType = &#x27;image/jpeg&#x27;;
                              break;
                            default:
                              mimeType = &#x27;image/png&#x27;;
                              break;
                            }
                          }
                          var downloadMime = &#x27;image/octet-stream&#x27;;
                          var imageData = cnv.toDataURL(mimeType);
                          imageData = imageData.replace(mimeType, downloadMime);
                        
                          var thisFrame = {};
                          thisFrame.imageData = imageData;
                          thisFrame.filename = filename;
                          thisFrame.ext = extension;
                          frames.push(thisFrame);
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;../core/core&quot;:48}],67:[function(_dereq_,module,exports){
                        /**
                         * @module Image
                         * @submodule Loading &amp; Displaying
                         * @for p5
                         * @requires core
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        var Filters = _dereq_(&#x27;./filters&#x27;);
                        var canvas = _dereq_(&#x27;../core/canvas&#x27;);
                        var constants = _dereq_(&#x27;../core/constants&#x27;);
                        
                        _dereq_(&#x27;../core/error_helpers&#x27;);
                        
                        /**
                         * Loads an image from a path and creates a p5.Image from it.
                         * &lt;br&gt;&lt;br&gt;
                         * The image may not be immediately available for rendering
                         * If you want to ensure that the image is ready before doing
                         * anything with it, place the loadImage() call in preload().
                         * You may also supply a callback function to handle the image when it&#x27;s ready.
                         * &lt;br&gt;&lt;br&gt;
                         * The path to the image should be relative to the HTML file
                         * that links in your sketch. Loading an from a URL or other
                         * remote location may be blocked due to your browser&#x27;s built-in
                         * security.
                         *
                         * @method loadImage
                         * @param  {String} path Path of the image to be loaded
                         * @param  {Function(p5.Image)} [successCallback] Function to be called once
                         *                                the image is loaded. Will be passed the
                         *                                p5.Image.
                         * @param  {Function(Event)}    [failureCallback] called with event error if
                         *                                the image fails to load.
                         * @return {p5.Image}             the p5.Image object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var img;
                         * function preload() {
                         *   img = loadImage(&quot;assets/laDefense.jpg&quot;);
                         * }
                         * function setup() {
                         *   image(img, 0, 0);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * function setup() {
                         *   // here we use a callback to display the image after loading
                         *   loadImage(&quot;assets/laDefense.jpg&quot;, function(img) {
                         *     image(img, 0, 0);
                         *   });
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.loadImage = function(path, successCallback, failureCallback) {
                          var img = new Image();
                          var pImg = new p5.Image(1, 1, this);
                          var decrementPreload = p5._getDecrementPreload.apply(this, arguments);
                        
                          img.onload = function() {
                            pImg.width = pImg.canvas.width = img.width;
                            pImg.height = pImg.canvas.height = img.height;
                        
                            // Draw the image into the backing canvas of the p5.Image
                            pImg.drawingContext.drawImage(img, 0, 0);
                        
                            if (typeof successCallback === &#x27;function&#x27;) {
                              successCallback(pImg);
                            }
                            if (decrementPreload &amp;&amp; (successCallback !== decrementPreload)) {
                              decrementPreload();
                            }
                          };
                          img.onerror = function(e) {
                            p5._friendlyFileLoadError(0,img.src);
                            // don&#x27;t get failure callback mixed up with decrementPreload
                            if ((typeof failureCallback === &#x27;function&#x27;) &amp;&amp;
                              (failureCallback !== decrementPreload)) {
                              failureCallback(e);
                            }
                          };
                        
                          //set crossOrigin in case image is served which CORS headers
                          //this will let us draw to canvas without tainting it.
                          //see https://developer.mozilla.org/en-US/docs/HTML/CORS_Enabled_Image
                          // When using data-uris the file will be loaded locally
                          // so we don&#x27;t need to worry about crossOrigin with base64 file types
                          if(path.indexOf(&#x27;data:image/&#x27;) !== 0) {
                            img.crossOrigin = &#x27;Anonymous&#x27;;
                          }
                        
                          //start loading the image
                          img.src = path;
                        
                          return pImg;
                        };
                        
                        /**
                         * Validates clipping params. Per drawImage spec sWidth and sHight cannot be
                         * negative or greater than image intrinsic width and height
                         * @private
                         * @param {Number} sVal
                         * @param {Number} iVal
                         * @returns {Number}
                         * @private
                         */
                        function _sAssign(sVal, iVal) {
                          if (sVal &gt; 0 &amp;&amp; sVal &lt; iVal) {
                            return sVal;
                          }
                          else {
                            return iVal;
                          }
                        }
                        
                        /**
                         * Draw an image to the main canvas of the p5js sketch
                         *
                         * @method image
                         * @param  {p5.Image} img    the image to display
                         * @param  {Number}   [sx=0]   The X coordinate of the top left corner of the
                         *                             sub-rectangle of the source image to draw into
                         *                             the destination canvas.
                         * @param  {Number}   [sy=0]   The Y coordinate of the top left corner of the
                         *                             sub-rectangle of the source image to draw into
                         *                             the destination canvas.
                         * @param {Number} [sWidth=img.width] The width of the sub-rectangle of the
                         *                                    source image to draw into the destination
                         *                                    canvas.
                         * @param {Number} [sHeight=img.height] The height of the sub-rectangle of the
                         *                                      source image to draw into the
                         *                                      destination context.
                         * @param  {Number}   [dx=0]    The X coordinate in the destination canvas at
                         *                              which to place the top-left corner of the
                         *                              source image.
                         * @param  {Number}   [dy=0]    The Y coordinate in the destination canvas at
                         *                              which to place the top-left corner of the
                         *                              source image.
                         * @param  {Number}   [dWidth]  The width to draw the image in the destination
                         *                              canvas. This allows scaling of the drawn image.
                         * @param  {Number}   [dHeight] The height to draw the image in the destination
                         *                              canvas. This allows scaling of the drawn image.
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var img;
                         * function preload() {
                         *   img = loadImage(&quot;assets/laDefense.jpg&quot;);
                         * }
                         * function setup() {
                         *   image(img, 0, 0);
                         *   image(img, 0, 0, 100, 100);
                         *   image(img, 0, 0, 100, 100, 0, 0, 100, 100);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * function setup() {
                         *   // here we use a callback to display the image after loading
                         *   loadImage(&quot;assets/laDefense.jpg&quot;, function(img) {
                         *     image(img, 0, 0);
                         *   });
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.image =
                          function(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
                          // Temporarily disabling until options for p5.Graphics are added.
                          // var args = new Array(arguments.length);
                          // for (var i = 0; i &lt; args.length; ++i) {
                          //   args[i] = arguments[i];
                          // }
                          // this._validateParameters(
                          //   &#x27;image&#x27;,
                          //   args,
                          //   [
                          //     [&#x27;p5.Image&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;],
                          //     [&#x27;p5.Image&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;]
                          //   ]
                          // );
                        
                          // set defaults per spec: https://goo.gl/3ykfOq
                          if (arguments.length &lt;= 5) {
                            dx = sx || 0;
                            dy = sy || 0;
                            sx = 0;
                            sy = 0;
                            if (img.elt &amp;&amp; img.elt.videoWidth &amp;&amp; !img.canvas) { // video no canvas
                              var actualW = img.elt.videoWidth;
                              var actualH = img.elt.videoHeight;
                              dWidth = sWidth || img.width;
                              dHeight = sHeight || img.width*actualH/actualW;
                              sWidth = actualW;
                              sHeight = actualH;
                            } else {
                              dWidth = sWidth || img.width;
                              dHeight = sHeight || img.height;
                              sWidth = img.width;
                              sHeight = img.height;
                            }
                          } else if (arguments.length === 9) {
                            sx = sx || 0;
                            sy = sy || 0;
                            sWidth = _sAssign(sWidth, img.width);
                            sHeight = _sAssign(sHeight, img.height);
                        
                            dx = dx || 0;
                            dy = dy || 0;
                            dWidth = dWidth || img.width;
                            dHeight = dHeight || img.height;
                          } else {
                            throw &#x27;Wrong number of arguments to image()&#x27;;
                          }
                        
                          var vals = canvas.modeAdjust(dx, dy, dWidth, dHeight,
                            this._renderer._imageMode);
                        
                          // tint the image if there is a tint
                          this._renderer.image(img, sx, sy, sWidth, sHeight, vals.x, vals.y, vals.w,
                            vals.h);
                        };
                        
                        /**
                         * Sets the fill value for displaying images. Images can be tinted to
                         * specified colors or made transparent by including an alpha value.
                         * &lt;br&gt;&lt;br&gt;
                         * To apply transparency to an image without affecting its color, use
                         * white as the tint color and specify an alpha value. For instance,
                         * tint(255, 128) will make an image 50% transparent (assuming the default
                         * alpha range of 0-255, which can be changed with colorMode()).
                         * &lt;br&gt;&lt;br&gt;
                         * The value for the gray parameter must be less than or equal to the current
                         * maximum value as specified by colorMode(). The default maximum value is
                         * 255.
                         *
                         * @method tint
                         * @param {Number|Array} v1   gray value, red or hue value (depending on the
                         *                            current color mode), or color Array
                         * @param {Number|Array} [v2] green or saturation value (depending on the
                         *                            current color mode)
                         * @param {Number|Array} [v3] blue or brightness value (depending on the
                         *                            current color mode)
                         * @param {Number|Array} [a]  opacity of the background
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var img;
                         * function preload() {
                         *   img = loadImage(&quot;assets/laDefense.jpg&quot;);
                         * }
                         * function setup() {
                         *   image(img, 0, 0);
                         *   tint(0, 153, 204);  // Tint blue
                         *   image(img, 50, 0);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var img;
                         * function preload() {
                         *   img = loadImage(&quot;assets/laDefense.jpg&quot;);
                         * }
                         * function setup() {
                         *   image(img, 0, 0);
                         *   tint(0, 153, 204, 126);  // Tint blue and set transparency
                         *   image(img, 50, 0);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var img;
                         * function preload() {
                         *   img = loadImage(&quot;assets/laDefense.jpg&quot;);
                         * }
                         * function setup() {
                         *   image(img, 0, 0);
                         *   tint(255, 126);  // Apply transparency without changing color
                         *   image(img, 50, 0);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.tint = function () {
                          var c = this.color.apply(this, arguments);
                          this._renderer._tint = c.levels;
                        };
                        
                        /**
                         * Removes the current fill value for displaying images and reverts to
                         * displaying images with their original hues.
                         *
                         * @method noTint
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var img;
                         * function preload() {
                         *   img = loadImage(&quot;assets/bricks.jpg&quot;);
                         * }
                         * function setup() {
                         *   tint(0, 153, 204);  // Tint blue
                         *   image(img, 0, 0);
                         *   noTint();  // Disable tint
                         *   image(img, 50, 0);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.noTint = function() {
                          this._renderer._tint = null;
                        };
                        
                        /**
                         * Apply the current tint color to the input image, return the resulting
                         * canvas.
                         *
                         * @param {p5.Image} The image to be tinted
                         * @return {canvas} The resulting tinted canvas
                         *
                         */
                        p5.prototype._getTintedImageCanvas = function(img) {
                          if (!img.canvas) {
                            return img;
                          }
                          var pixels = Filters._toPixels(img.canvas);
                          var tmpCanvas = document.createElement(&#x27;canvas&#x27;);
                          tmpCanvas.width = img.canvas.width;
                          tmpCanvas.height = img.canvas.height;
                          var tmpCtx = tmpCanvas.getContext(&#x27;2d&#x27;);
                          var id = tmpCtx.createImageData(img.canvas.width, img.canvas.height);
                          var newPixels = id.data;
                        
                          for(var i = 0; i &lt; pixels.length; i += 4) {
                            var r = pixels[i];
                            var g = pixels[i+1];
                            var b = pixels[i+2];
                            var a = pixels[i+3];
                        
                            newPixels[i] = r*this._renderer._tint[0]/255;
                            newPixels[i+1] = g*this._renderer._tint[1]/255;
                            newPixels[i+2] = b*this._renderer._tint[2]/255;
                            newPixels[i+3] = a*this._renderer._tint[3]/255;
                          }
                        
                          tmpCtx.putImageData(id, 0, 0);
                          return tmpCanvas;
                        };
                        
                        /**
                         * Set image mode. Modifies the location from which images are drawn by
                         * changing the way in which parameters given to image() are interpreted.
                         * The default mode is imageMode(CORNER), which interprets the second and
                         * third parameters of image() as the upper-left corner of the image. If
                         * two additional parameters are specified, they are used to set the image&#x27;s
                         * width and height.
                         * &lt;br&gt;&lt;br&gt;
                         * imageMode(CORNERS) interprets the second and third parameters of image()
                         * as the location of one corner, and the fourth and fifth parameters as the
                         * opposite corner.
                         * &lt;br&gt;&lt;br&gt;
                         * imageMode(CENTER) interprets the second and third parameters of image()
                         * as the image&#x27;s center point. If two additional parameters are specified,
                         * they are used to set the image&#x27;s width and height.
                         *
                         * @method imageMode
                         * @param {String} m The mode: either CORNER, CORNERS, or CENTER.
                         * @example
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var img;
                         * function preload() {
                         *   img = loadImage(&quot;assets/bricks.jpg&quot;);
                         * }
                         * function setup() {
                         *   imageMode(CORNER);
                         *   image(img, 10, 10, 50, 50);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var img;
                         * function preload() {
                         *   img = loadImage(&quot;assets/bricks.jpg&quot;);
                         * }
                         * function setup() {
                         *   imageMode(CORNERS);
                         *   image(img, 10, 10, 90, 40);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var img;
                         * function preload() {
                         *   img = loadImage(&quot;assets/bricks.jpg&quot;);
                         * }
                         * function setup() {
                         *   imageMode(CENTER);
                         *   image(img, 50, 50, 80, 80);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.imageMode = function(m) {
                          if (m === constants.CORNER ||
                            m === constants.CORNERS ||
                            m === constants.CENTER) {
                            this._renderer._imageMode = m;
                          }
                        };
                        
                        
                        module.exports = p5;
                        
                        },{&quot;../core/canvas&quot;:46,&quot;../core/constants&quot;:47,&quot;../core/core&quot;:48,&quot;../core/error_helpers&quot;:51,&quot;./filters&quot;:65}],68:[function(_dereq_,module,exports){
                        /**
                         * @module Image
                         * @submodule Image
                         * @requires core
                         * @requires constants
                         * @requires filters
                         */
                        
                        /**
                         * This module defines the p5.Image class and P5 methods for
                         * drawing images to the main display canvas.
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        var Filters = _dereq_(&#x27;./filters&#x27;);
                        
                        /*
                         * Class methods
                         */
                        
                        /**
                         * Creates a new p5.Image. A p5.Image is a canvas backed representation of an
                         * image.
                         * &lt;br&gt;&lt;br&gt;
                         * p5 can display .gif, .jpg and .png images. Images may be displayed
                         * in 2D and 3D space. Before an image is used, it must be loaded with the
                         * loadImage() function. The p5.Image class contains fields for the width and
                         * height of the image, as well as an array called pixels[] that contains the
                         * values for every pixel in the image.
                         * &lt;br&gt;&lt;br&gt;
                         * The methods described below allow easy access to the image&#x27;s pixels and
                         * alpha channel and simplify the process of compositing.
                         * &lt;br&gt;&lt;br&gt;
                         * Before using the pixels[] array, be sure to use the loadPixels() method on
                         * the image to make sure that the pixel data is properly loaded.
                         *
                         * @class p5.Image
                         * @constructor
                         * @param {Number} width
                         * @param {Number} height
                         * @param {Object} pInst An instance of a p5 sketch.
                         */
                        p5.Image = function(width, height){
                          /**
                           * Image width.
                           * @property width
                           * @example
                           * &lt;div&gt;&lt;code&gt;
                           * var img;
                           * function preload() {
                           *   img = loadImage(&quot;assets/rockies.jpg&quot;);
                           * }
                           *
                           * function setup() {
                           *   createCanvas(100, 100);
                           *   image(img, 0, 0);
                           *   for (var i=0; i &lt; img.width; i++) {
                           *     var c = img.get(i, img.height/2);
                           *     stroke(c);
                           *     line(i, height/2, i, height);
                           *   }
                           * }
                           * &lt;/code&gt;&lt;/div&gt;
                           */
                          this.width = width;
                          /**
                           * Image height.
                           * @property height
                           * @example
                           * &lt;div&gt;&lt;code&gt;
                           * var img;
                           * function preload() {
                           *   img = loadImage(&quot;assets/rockies.jpg&quot;);
                           * }
                           *
                           * function setup() {
                           *   createCanvas(100, 100);
                           *   image(img, 0, 0);
                           *   for (var i=0; i &lt; img.height; i++) {
                           *     var c = img.get(img.width/2, i);
                           *     stroke(c);
                           *     line(0, i, width/2, i);
                           *   }
                           * }
                           * &lt;/code&gt;&lt;/div&gt;
                           */
                          this.height = height;
                          this.canvas = document.createElement(&#x27;canvas&#x27;);
                          this.canvas.width = this.width;
                          this.canvas.height = this.height;
                          this.drawingContext = this.canvas.getContext(&#x27;2d&#x27;);
                          this._pixelDensity = 1;
                          //used for webgl texturing only
                          this.isTexture = false;
                          /**
                           * Array containing the values for all the pixels in the display window.
                           * These values are numbers. This array is the size (include an appropriate
                           * factor for pixelDensity) of the display window x4,
                           * representing the R, G, B, A values in order for each pixel, moving from
                           * left to right across each row, then down each column. Retina and other
                           * high denisty displays may have more pixels[] (by a factor of
                           * pixelDensity^2).
                           * For example, if the image is 100x100 pixels, there will be 40,000. With
                           * pixelDensity = 2, there will be 160,000. The first four values
                           * (indices 0-3) in the array will be the R, G, B, A values of the pixel at
                           * (0, 0). The second four values (indices 4-7) will contain the R, G, B, A
                           * values of the pixel at (1, 0). More generally, to set values for a pixel
                           * at (x, y):
                           * &lt;code&gt;&lt;pre&gt;var d = pixelDensity;
                           * for (var i = 0; i &lt; d; i++) {
                           *   for (var j = 0; j &lt; d; j++) {
                           *     // loop over
                           *     idx = 4*((y * d + j) * width * d + (x * d + i));
                           *     pixels[idx] = r;
                           *     pixels[idx+1] = g;
                           *     pixels[idx+2] = b;
                           *     pixels[idx+3] = a;
                           *   }
                           * }
                           * &lt;/pre&gt;&lt;/code&gt;
                           * &lt;br&gt;&lt;br&gt;
                           * Before accessing this array, the data must loaded with the loadPixels()
                           * function. After the array data has been modified, the updatePixels()
                           * function must be run to update the changes.
                           * @property pixels[]
                           * @example
                           * &lt;div&gt;
                           * &lt;code&gt;
                           * img = createImage(66, 66);
                           * img.loadPixels();
                           * for (i = 0; i &lt; img.width; i++) {
                           *   for (j = 0; j &lt; img.height; j++) {
                           *     img.set(i, j, color(0, 90, 102));
                           *   }
                           * }
                           * img.updatePixels();
                           * image(img, 17, 17);
                           * &lt;/code&gt;
                           * &lt;/div&gt;
                           * &lt;div&gt;
                           * &lt;code&gt;
                           * var pink = color(255, 102, 204);
                           * img = createImage(66, 66);
                           * img.loadPixels();
                           * for (var i = 0; i &lt; 4*(width*height/2); i+=4) {
                           *   img.pixels[i] = red(pink);
                           *   img.pixels[i+1] = green(pink);
                           *   img.pixels[i+2] = blue(pink);
                           *   img.pixels[i+3] = alpha(pink);
                           * }
                           * img.updatePixels();
                           * image(img, 17, 17);
                           * &lt;/code&gt;
                           * &lt;/div&gt;
                           */
                          this.pixels = [];
                        };
                        
                        /**
                         * Helper fxn for sharing pixel methods
                         *
                         */
                        p5.Image.prototype._setProperty = function (prop, value) {
                          this[prop] = value;
                        };
                        
                        /**
                         * Loads the pixels data for this image into the [pixels] attribute.
                         *
                         * @method loadPixels
                         */
                        p5.Image.prototype.loadPixels = function(){
                          p5.Renderer2D.prototype.loadPixels.call(this);
                        };
                        
                        /**
                         * Updates the backing canvas for this image with the contents of
                         * the [pixels] array.
                         *
                         * @method updatePixels
                         * @param {Integer|undefined} x x-offset of the target update area for the
                         *                              underlying canvas
                         * @param {Integer|undefined} y y-offset of the target update area for the
                         *                              underlying canvas
                         * @param {Integer|undefined} w height of the target update area for the
                         *                              underlying canvas
                         * @param {Integer|undefined} h height of the target update area for the
                         *                              underlying canvas
                         */
                        p5.Image.prototype.updatePixels = function(x, y, w, h){
                          p5.Renderer2D.prototype.updatePixels.call(this, x, y, w, h);
                        };
                        
                        /**
                         * Get a region of pixels from an image.
                         *
                         * If no params are passed, those whole image is returned,
                         * if x and y are the only params passed a single pixel is extracted
                         * if all params are passed a rectangle region is extracted and a p5.Image
                         * is returned.
                         *
                         * Returns undefined if the region is outside the bounds of the image
                         *
                         * @method get
                         * @param  {Number}               [x] x-coordinate of the pixel
                         * @param  {Number}               [y] y-coordinate of the pixel
                         * @param  {Number}               [w] width
                         * @param  {Number}               [h] height
                         * @return {Array/Color | p5.Image}     color of pixel at x,y in array format
                         *                                    [R, G, B, A] or p5.Image
                         */
                        p5.Image.prototype.get = function(x, y, w, h){
                          return p5.Renderer2D.prototype.get.call(this, x, y, w, h);
                        };
                        
                        /**
                         * Set the color of a single pixel or write an image into
                         * this p5.Image.
                         *
                         * Note that for a large number of pixels this will
                         * be slower than directly manipulating the pixels array
                         * and then calling updatePixels().
                         *
                         * @method set
                         * @param {Number}              x x-coordinate of the pixel
                         * @param {Number}              y y-coordinate of the pixel
                         * @param {Number|Array|Object}   a grayscale value | pixel array |
                         *                                a p5.Color | image to copy
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * img = createImage(66, 66);
                         * img.loadPixels();
                         * for (i = 0; i &lt; img.width; i++) {
                         *   for (j = 0; j &lt; img.height; j++) {
                         *     img.set(i, j, color(0, 90, 102, i % img.width * 2));
                         *   }
                         * }
                         * img.updatePixels();
                         * image(img, 17, 17);
                         * image(img, 34, 34);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.Image.prototype.set = function(x, y, imgOrCol){
                          p5.Renderer2D.prototype.set.call(this, x, y, imgOrCol);
                        };
                        
                        /**
                         * Resize the image to a new width and height. To make the image scale
                         * proportionally, use 0 as the value for the wide or high parameter.
                         * For instance, to make the width of an image 150 pixels, and change
                         * the height using the same proportion, use resize(150, 0).
                         *
                         * @method resize
                         * @param {Number} width the resized image width
                         * @param {Number} height the resized image height
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * var img;
                         *
                         * function setup() {
                         *   img = loadImage(&quot;assets/rockies.jpg&quot;);
                         * }
                        
                         * function draw() {
                         *   image(img, 0, 0);
                         * }
                         *
                         * function mousePressed() {
                         *   img.resize(50, 100);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.Image.prototype.resize = function(width, height){
                        
                          // Copy contents to a temporary canvas, resize the original
                          // and then copy back.
                          //
                          // There is a faster approach that involves just one copy and swapping the
                          // this.canvas reference. We could switch to that approach if (as i think
                          // is the case) there an expectation that the user would not hold a
                          // reference to the backing canvas of a p5.Image. But since we do not
                          // enforce that at the moment, I am leaving in the slower, but safer
                          // implementation.
                        
                          // auto-resize
                          if (width === 0 &amp;&amp; height === 0) {
                            width = this.canvas.width;
                            height = this.canvas.height;
                          } else if (width === 0) {
                            width = this.canvas.width * height / this.canvas.height;
                          } else if (height === 0) {
                            height = this.canvas.height * width / this.canvas.width;
                          }
                        
                          var tempCanvas = document.createElement(&#x27;canvas&#x27;);
                          tempCanvas.width = width;
                          tempCanvas.height = height;
                          tempCanvas.getContext(&#x27;2d&#x27;).drawImage(this.canvas,
                            0, 0, this.canvas.width, this.canvas.height,
                            0, 0, tempCanvas.width, tempCanvas.height
                          );
                        
                        
                          // Resize the original canvas, which will clear its contents
                          this.canvas.width = this.width = width;
                          this.canvas.height = this.height = height;
                        
                          //Copy the image back
                        
                          this.drawingContext.drawImage(tempCanvas,
                            0, 0, width, height,
                            0, 0, width, height
                          );
                        
                          if(this.pixels.length &gt; 0){
                            this.loadPixels();
                          }
                        };
                        
                        /**
                         * Copies a region of pixels from one image to another. If no
                         * srcImage is specified this is used as the source. If the source
                         * and destination regions aren&#x27;t the same size, it will
                         * automatically resize source pixels to fit the specified
                         * target region.
                         *
                         * @method copy
                         * @param  {p5.Image|undefined} srcImage source image
                         * @param  {Integer} sx X coordinate of the source&#x27;s upper left corner
                         * @param  {Integer} sy Y coordinate of the source&#x27;s upper left corner
                         * @param  {Integer} sw source image width
                         * @param  {Integer} sh source image height
                         * @param  {Integer} dx X coordinate of the destination&#x27;s upper left corner
                         * @param  {Integer} dy Y coordinate of the destination&#x27;s upper left corner
                         * @param  {Integer} dw destination image width
                         * @param  {Integer} dh destination image height
                         */
                        p5.Image.prototype.copy = function () {
                          p5.prototype.copy.apply(this, arguments);
                        };
                        
                        /**
                         * Masks part of an image from displaying by loading another
                         * image and using it&#x27;s blue channel as an alpha channel for
                         * this image.
                         *
                         * @method mask
                         * @param {p5.Image} srcImage source image
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * var photo, maskImage;
                         * function preload() {
                         *   photo = loadImage(&quot;assets/rockies.jpg&quot;);
                         *   maskImage = loadImage(&quot;assets/mask2.png&quot;);
                         * }
                         *
                         * function setup() {
                         *   createCanvas(100, 100);
                         *   photo.mask(maskImage);
                         *   image(photo, 0, 0);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         *
                         * http://blogs.adobe.com/webplatform/2013/01/28/blending-features-in-canvas/
                         *
                         */
                        // TODO: - Accept an array of alpha values.
                        //       - Use other channels of an image. p5 uses the
                        //       blue channel (which feels kind of arbitrary). Note: at the
                        //       moment this method does not match native processings original
                        //       functionality exactly.
                        p5.Image.prototype.mask = function(p5Image) {
                          if(p5Image === undefined){
                            p5Image = this;
                          }
                          var currBlend = this.drawingContext.globalCompositeOperation;
                        
                          var scaleFactor = 1;
                          if (p5Image instanceof p5.Renderer) {
                            scaleFactor = p5Image._pInst._pixelDensity;
                          }
                        
                          var copyArgs = [
                            p5Image,
                            0,
                            0,
                            scaleFactor*p5Image.width,
                            scaleFactor*p5Image.height,
                            0,
                            0,
                            this.width,
                            this.height
                          ];
                        
                          this.drawingContext.globalCompositeOperation = &#x27;destination-in&#x27;;
                          this.copy.apply(this, copyArgs);
                          this.drawingContext.globalCompositeOperation = currBlend;
                        };
                        
                        /**
                         * Applies an image filter to a p5.Image
                         *
                         * @method filter
                         * @param {String} operation one of threshold, gray, invert, posterize and
                         *                           opaque see Filters.js for docs on each available
                         *                           filter
                         * @param {Number|undefined} value
                         */
                        p5.Image.prototype.filter = function(operation, value) {
                          Filters.apply(this.canvas, Filters[operation.toLowerCase()], value);
                        };
                        
                        /**
                         * Copies a region of pixels from one image to another, using a specified
                         * blend mode to do the operation.
                         *
                         * @method blend
                         * @param  {p5.Image|undefined} srcImage source image
                         * @param  {Integer} sx X coordinate of the source&#x27;s upper left corner
                         * @param  {Integer} sy Y coordinate of the source&#x27;s upper left corner
                         * @param  {Integer} sw source image width
                         * @param  {Integer} sh source image height
                         * @param  {Integer} dx X coordinate of the destination&#x27;s upper left corner
                         * @param  {Integer} dy Y coordinate of the destination&#x27;s upper left corner
                         * @param  {Integer} dw destination image width
                         * @param  {Integer} dh destination image height
                         * @param  {Integer} blendMode the blend mode
                         *
                         * Available blend modes are: normal | multiply | screen | overlay |
                         *            darken | lighten | color-dodge | color-burn | hard-light |
                         *            soft-light | difference | exclusion | hue | saturation |
                         *            color | luminosity
                         *
                         *
                         * http://blogs.adobe.com/webplatform/2013/01/28/blending-features-in-canvas/
                         *
                         */
                        p5.Image.prototype.blend = function() {
                          p5.prototype.blend.apply(this, arguments);
                        };
                        
                        /**
                         * Saves the image to a file and force the browser to download it.
                         * Accepts two strings for filename and file extension
                         * Supports png (default) and jpg.
                         *
                         * @method save
                         * @param {String} filename give your file a name
                         * @param  {String} extension &#x27;png&#x27; or &#x27;jpg&#x27;
                         */
                        p5.Image.prototype.save = function(filename, extension) {
                          var mimeType;
                          if (!extension) {
                            extension = &#x27;png&#x27;;
                            mimeType = &#x27;image/png&#x27;;
                          }
                          else {
                            // en.wikipedia.org/wiki/Comparison_of_web_browsers#Image_format_support
                            switch(extension.toLowerCase()){
                            case &#x27;png&#x27;:
                              mimeType = &#x27;image/png&#x27;;
                              break;
                            case &#x27;jpeg&#x27;:
                              mimeType = &#x27;image/jpeg&#x27;;
                              break;
                            case &#x27;jpg&#x27;:
                              mimeType = &#x27;image/jpeg&#x27;;
                              break;
                            default:
                              mimeType = &#x27;image/png&#x27;;
                              break;
                            }
                          }
                          var downloadMime = &#x27;image/octet-stream&#x27;;
                          var imageData = this.canvas.toDataURL(mimeType);
                          imageData = imageData.replace(mimeType, downloadMime);
                        
                          //Make the browser download the file
                          p5.prototype.downloadFile(imageData, filename, extension);
                        };
                        
                        /**
                         * creates a gl texture
                         * used in WEBGL mode only
                         * @param  {[type]} tex [description]
                         * @return {[type]}     [description]
                         */
                        p5.Image.prototype.createTexture = function(tex){
                          //this.texture = tex;
                          return this;
                        };
                        
                        module.exports = p5.Image;
                        
                        },{&quot;../core/core&quot;:48,&quot;./filters&quot;:65}],69:[function(_dereq_,module,exports){
                        /**
                         * @module Image
                         * @submodule Pixels
                         * @for p5
                         * @requires core
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        var Filters = _dereq_(&#x27;./filters&#x27;);
                        _dereq_(&#x27;../color/p5.Color&#x27;);
                        
                        /**
                         * &lt;a href=&#x27;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference
                         * /Global_Objects/Uint8ClampedArray&#x27; target=&#x27;_blank&#x27;&gt;Uint8ClampedArray&lt;/a&gt;
                         * containing the values for all the pixels in the display window.
                         * These values are numbers. This array is the size (include an appropriate
                         * factor for pixelDensity) of the display window x4,
                         * representing the R, G, B, A values in order for each pixel, moving from
                         * left to right across each row, then down each column. Retina and other
                         * high denisty displays will have more pixels[] (by a factor of
                         * pixelDensity^2).
                         * For example, if the image is 100x100 pixels, there will be 40,000. On a
                         * retina display, there will be 160,000.
                         * &lt;br&gt;&lt;br&gt;
                         * The first four values (indices 0-3) in the array will be the R, G, B, A
                         * values of the pixel at (0, 0). The second four values (indices 4-7) will
                         * contain the R, G, B, A values of the pixel at (1, 0). More generally, to
                         * set values for a pixel at (x, y):
                         * &lt;code&gt;&lt;pre&gt;
                         * var d = pixelDensity;
                         * for (var i = 0; i &lt; d; i++) {
                         *   for (var j = 0; j &lt; d; j++) {
                         *     // loop over
                         *     idx = 4 * ((y * d + j) * width * d + (x * d + i));
                         *     pixels[idx] = r;
                         *     pixels[idx+1] = g;
                         *     pixels[idx+2] = b;
                         *     pixels[idx+3] = a;
                         *   }
                         * }
                         * &lt;/pre&gt;&lt;/code&gt;
                         *
                         * &lt;p&gt;While the above method is complex, it is flexible enough to work with
                         * any pixelDensity. Note that set() will automatically take care of
                         * setting all the appropriate values in pixels[] for a given (x, y) at
                         * any pixelDensity, but the performance may not be as fast when lots of
                         * modifications are made to the pixel array.
                         * &lt;br&gt;&lt;br&gt;
                         * Before accessing this array, the data must loaded with the loadPixels()
                         * function. After the array data has been modified, the updatePixels()
                         * function must be run to update the changes.
                         * &lt;br&gt;&lt;br&gt;
                         * Note that this is not a standard javascript array.  This means that
                         * standard javascript functions such as &lt;code&gt;slice()&lt;/code&gt; or
                         * &lt;code&gt;arrayCopy()&lt;/code&gt; do not
                         * work.&lt;/p&gt;
                         *
                         * @property pixels[]
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var pink = color(255, 102, 204);
                         * loadPixels();
                         * var d = pixelDensity;
                         * var halfImage = 4 * (width * d) * (height/2 * d);
                         * for (var i = 0; i &lt; halfImage; i+=4) {
                         *   pixels[i] = red(pink);
                         *   pixels[i+1] = green(pink);
                         *   pixels[i+2] = blue(pink);
                         *   pixels[i+3] = alpha(pink);
                         * }
                         * updatePixels();
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.pixels = [];
                        
                        /**
                         * Copies a region of pixels from one image to another, using a specified
                         * blend mode to do the operation.&lt;br&gt;&lt;br&gt;
                         * Available blend modes are: BLEND | DARKEST | LIGHTEST | DIFFERENCE |
                         * MULTIPLY| EXCLUSION | SCREEN | REPLACE | OVERLAY | HARD_LIGHT |
                         * SOFT_LIGHT | DODGE | BURN | ADD | NORMAL
                         *
                         *
                         * @method blend
                         * @param  {p5.Image|undefined} srcImage source image
                         * @param  {Integer} sx X coordinate of the source&#x27;s upper left corner
                         * @param  {Integer} sy Y coordinate of the source&#x27;s upper left corner
                         * @param  {Integer} sw source image width
                         * @param  {Integer} sh source image height
                         * @param  {Integer} dx X coordinate of the destination&#x27;s upper left corner
                         * @param  {Integer} dy Y coordinate of the destination&#x27;s upper left corner
                         * @param  {Integer} dw destination image width
                         * @param  {Integer} dh destination image height
                         * @param  {Integer} blendMode the blend mode
                         *
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * var img0;
                         * var img1;
                         *
                         * function preload() {
                         *   img0 = loadImage(&quot;assets/rockies.jpg&quot;);
                         *   img1 = loadImage(&quot;assets/bricks_third.jpg&quot;);
                         * }
                         *
                         * function setup() {
                         *   background(img0);
                         *   image(img1, 0, 0);
                         *   blend(img1, 0, 0, 33, 100, 67, 0, 33, 100, LIGHTEST);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         * &lt;div&gt;&lt;code&gt;
                         * var img0;
                         * var img1;
                         *
                         * function preload() {
                         *   img0 = loadImage(&quot;assets/rockies.jpg&quot;);
                         *   img1 = loadImage(&quot;assets/bricks_third.jpg&quot;);
                         * }
                         *
                         * function setup() {
                         *   background(img0);
                         *   image(img1, 0, 0);
                         *   blend(img1, 0, 0, 33, 100, 67, 0, 33, 100, DARKEST);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         * &lt;div&gt;&lt;code&gt;
                         * var img0;
                         * var img1;
                         *
                         * function preload() {
                         *   img0 = loadImage(&quot;assets/rockies.jpg&quot;);
                         *   img1 = loadImage(&quot;assets/bricks_third.jpg&quot;);
                         * }
                         *
                         * function setup() {
                         *   background(img0);
                         *   image(img1, 0, 0);
                         *   blend(img1, 0, 0, 33, 100, 67, 0, 33, 100, ADD);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.blend = function() {
                          this._renderer.blend.apply(this._renderer, arguments);
                        };
                        
                        /**
                         * Copies a region of the canvas to another region of the canvas
                         * and copies a region of pixels from an image used as the srcImg parameter
                         * into the canvas srcImage is specified this is used as the source. If
                         * the source and destination regions aren&#x27;t the same size, it will
                         * automatically resize source pixels to fit the specified
                         * target region.
                         *
                         * @method copy
                         * @param  {p5.Image|undefined} srcImage source image
                         * @param  {Integer} sx X coordinate of the source&#x27;s upper left corner
                         * @param  {Integer} sy Y coordinate of the source&#x27;s upper left corner
                         * @param  {Integer} sw source image width
                         * @param  {Integer} sh source image height
                         * @param  {Integer} dx X coordinate of the destination&#x27;s upper left corner
                         * @param  {Integer} dy Y coordinate of the destination&#x27;s upper left corner
                         * @param  {Integer} dw destination image width
                         * @param  {Integer} dh destination image height
                         *
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * var img;
                         *
                         * function preload() {
                         *   img = loadImage(&quot;assets/rockies.jpg&quot;);
                         * }
                         *
                         * function setup() {
                         *   background(img);
                         *   copy(img, 7, 22, 10, 10, 35, 25, 50, 50);
                         *   stroke(255);
                         *   noFill();
                         *   // Rectangle shows area being copied
                         *   rect(7, 22, 10, 10);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.copy = function () {
                          p5.Renderer2D._copyHelper.apply(this, arguments);
                        };
                        
                        /**
                         * Applies a filter to the canvas.
                         * &lt;br&gt;&lt;br&gt;
                         *
                         * The presets options are:
                         * &lt;br&gt;&lt;br&gt;
                         *
                         * THRESHOLD
                         * Converts the image to black and white pixels depending if they are above or
                         * below the threshold defined by the level parameter. The parameter must be
                         * between 0.0 (black) and 1.0 (white). If no level is specified, 0.5 is used.
                         * &lt;br&gt;&lt;br&gt;
                         *
                         * GRAY
                         * Converts any colors in the image to grayscale equivalents. No parameter
                         * is used.
                         * &lt;br&gt;&lt;br&gt;
                         *
                         * OPAQUE
                         * Sets the alpha channel to entirely opaque. No parameter is used.
                         * &lt;br&gt;&lt;br&gt;
                         *
                         * INVERT
                         * Sets each pixel to its inverse value. No parameter is used.
                         * &lt;br&gt;&lt;br&gt;
                         *
                         * POSTERIZE
                         * Limits each channel of the image to the number of colors specified as the
                         * parameter. The parameter can be set to values between 2 and 255, but
                         * results are most noticeable in the lower ranges.
                         * &lt;br&gt;&lt;br&gt;
                         *
                         * BLUR
                         * Executes a Guassian blur with the level parameter specifying the extent
                         * of the blurring. If no parameter is used, the blur is equivalent to
                         * Guassian blur of radius 1. Larger values increase the blur.
                         * &lt;br&gt;&lt;br&gt;
                         *
                         * ERODE
                         * Reduces the light areas. No parameter is used.
                         * &lt;br&gt;&lt;br&gt;
                         *
                         * DILATE
                         * Increases the light areas. No parameter is used.
                         *
                         * @method filter
                         * @param  {String} filterType
                         * @param  {Number} filterParam an optional parameter unique
                         *  to each filter, see above
                         *
                         *
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var img;
                         * function preload() {
                         *   img = loadImage(&quot;assets/bricks.jpg&quot;);
                         * }
                         * function setup() {
                         *  image(img, 0, 0);
                         *  filter(THRESHOLD);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var img;
                         * function preload() {
                         *   img = loadImage(&quot;assets/bricks.jpg&quot;);
                         * }
                         * function setup() {
                         *  image(img, 0, 0);
                         *  filter(GRAY);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var img;
                         * function preload() {
                         *   img = loadImage(&quot;assets/bricks.jpg&quot;);
                         * }
                         * function setup() {
                         *  image(img, 0, 0);
                         *  filter(OPAQUE);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var img;
                         * function preload() {
                         *   img = loadImage(&quot;assets/bricks.jpg&quot;);
                         * }
                         * function setup() {
                         *  image(img, 0, 0);
                         *  filter(INVERT);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var img;
                         * function preload() {
                         *   img = loadImage(&quot;assets/bricks.jpg&quot;);
                         * }
                         * function setup() {
                         *  image(img, 0, 0);
                         *  filter(POSTERIZE,3);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var img;
                         * function preload() {
                         *   img = loadImage(&quot;assets/bricks.jpg&quot;);
                         * }
                         * function setup() {
                         *  image(img, 0, 0);
                         *  filter(DILATE);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var img;
                         * function preload() {
                         *   img = loadImage(&quot;assets/bricks.jpg&quot;);
                         * }
                         * function setup() {
                         *  image(img, 0, 0);
                         *  filter(BLUR,3);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var img;
                         * function preload() {
                         *   img = loadImage(&quot;assets/bricks.jpg&quot;);
                         * }
                         * function setup() {
                         *  image(img, 0, 0);
                         *  filter(ERODE);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.filter = function(operation, value) {
                          Filters.apply(this.canvas, Filters[operation.toLowerCase()], value);
                        };
                        
                        /**
                         * Returns an array of [R,G,B,A] values for any pixel or grabs a section of
                         * an image. If no parameters are specified, the entire image is returned.
                         * Use the x and y parameters to get the value of one pixel. Get a section of
                         * the display window by specifying additional w and h parameters. When
                         * getting an image, the x and y parameters define the coordinates for the
                         * upper-left corner of the image, regardless of the current imageMode().
                         * &lt;br&gt;&lt;br&gt;
                         * If the pixel requested is outside of the image window, [0,0,0,255] is
                         * returned. To get the numbers scaled according to the current color ranges
                         * and taking into account colorMode, use getColor instead of get.
                         * &lt;br&gt;&lt;br&gt;
                         * Getting the color of a single pixel with get(x, y) is easy, but not as fast
                         * as grabbing the data directly from pixels[]. The equivalent statement to
                         * get(x, y) using pixels[] with pixel density d is
                         * &lt;code&gt;[pixels[(y*width*d+x)*d],
                         * pixels[(y*width*d+x)*d+1],
                         * pixels[(y*width*d+x)*d+2],
                         * pixels[(y*width*d+x)*d+3]]&lt;/code&gt;.
                         * &lt;br&gt;&lt;br&gt;
                         * See the reference for pixels[] for more information.
                         *
                         * @method get
                         * @param  {Number}         [x] x-coordinate of the pixel
                         * @param  {Number}         [y] y-coordinate of the pixel
                         * @param  {Number}         [w] width
                         * @param  {Number}         [h] height
                         * @return {Array|p5.Image}     values of pixel at x,y in array format
                         *                              [R, G, B, A] or p5.Image
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var img;
                         * function preload() {
                         *   img = loadImage(&quot;assets/rockies.jpg&quot;);
                         * }
                         * function setup() {
                         *   image(img, 0, 0);
                         *   var c = get();
                         *   image(c, width/2, 0);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var img;
                         * function preload() {
                         *   img = loadImage(&quot;assets/rockies.jpg&quot;);
                         * }
                         * function setup() {
                         *   image(img, 0, 0);
                         *   var c = get(50, 90);
                         *   fill(c);
                         *   noStroke();
                         *   rect(25, 25, 50, 50);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.get = function(x, y, w, h){
                          return this._renderer.get(x, y, w, h);
                        };
                        
                        /**
                         * Loads the pixel data for the display window into the pixels[] array. This
                         * function must always be called before reading from or writing to pixels[].
                         *
                         * @method loadPixels
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var img;
                         * function preload() {
                         *   img = loadImage(&quot;assets/rockies.jpg&quot;);
                         * }
                         *
                         * function setup() {
                         *   image(img, 0, 0);
                         *   var d = pixelDensity;
                         *   var halfImage = 4 * (img.width * d) *
                               (img.height/2 * d);
                         *   loadPixels();
                         *   for (var i = 0; i &lt; halfImage; i++) {
                         *     pixels[i+halfImage] = pixels[i];
                         *   }
                         *   updatePixels();
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.loadPixels = function() {
                          this._renderer.loadPixels();
                        };
                        
                        /**
                         * &lt;p&gt;Changes the color of any pixel, or writes an image directly to the
                         * display window.&lt;/p&gt;
                         * &lt;p&gt;The x and y parameters specify the pixel to change and the c parameter
                         * specifies the color value. This can be a p5.Color object, or [R, G, B, A]
                         * pixel array. It can also be a single grayscale value.
                         * When setting an image, the x and y parameters define the coordinates for
                         * the upper-left corner of the image, regardless of the current imageMode().
                         * &lt;/p&gt;
                         * &lt;p&gt;
                         * After using set(), you must call updatePixels() for your changes to
                         * appear.  This should be called once all pixels have been set.
                         * &lt;/p&gt;
                         * &lt;p&gt;Setting the color of a single pixel with set(x, y) is easy, but not as
                         * fast as putting the data directly into pixels[]. Setting the pixels[]
                         * values directly may be complicated when working with a retina display,
                         * but will perform better when lots of pixels need to be set directly on
                         * every loop.&lt;/p&gt;
                         * &lt;p&gt;See the reference for pixels[] for more information.&lt;/p&gt;
                         *
                         * @method set
                         * @param {Number}              x x-coordinate of the pixel
                         * @param {Number}              y y-coordinate of the pixel
                         * @param {Number|Array|Object} c insert a grayscale value | a pixel array |
                         *                                a p5.Color object | a p5.Image to copy
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var black = color(0);
                         * set(30, 20, black);
                         * set(85, 20, black);
                         * set(85, 75, black);
                         * set(30, 75, black);
                         * updatePixels();
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * for (var i = 30; i &lt; width-15; i++) {
                         *   for (var j = 20; j &lt; height-25; j++) {
                         *     var c = color(204-j, 153-i, 0);
                         *     set(i, j, c);
                         *   }
                         * }
                         * updatePixels();
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var img;
                         * function preload() {
                         *   img = loadImage(&quot;assets/rockies.jpg&quot;);
                         * }
                         *
                         * function setup() {
                         *   set(0, 0, img);
                         *   updatePixels();
                         *   line(0, 0, width, height);
                         *   line(0, height, width, 0);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.set = function (x, y, imgOrCol) {
                          this._renderer.set(x, y, imgOrCol);
                        };
                        /**
                         * Updates the display window with the data in the pixels[] array.
                         * Use in conjunction with loadPixels(). If you&#x27;re only reading pixels from
                         * the array, there&#x27;s no need to call updatePixels() — updating is only
                         * necessary to apply changes. updatePixels() should be called anytime the
                         * pixels array is manipulated or set() is called.
                         *
                         * @method updatePixels
                         * @param  {Number} [x]    x-coordinate of the upper-left corner of region
                         *                         to update
                         * @param  {Number} [y]    y-coordinate of the upper-left corner of region
                         *                         to update
                         * @param  {Number} [w]    width of region to update
                         * @param  {Number} [w]    height of region to update
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var img;
                         * function preload() {
                         *   img = loadImage(&quot;assets/rockies.jpg&quot;);
                         * }
                         *
                         * function setup() {
                         *   image(img, 0, 0);
                         *   var halfImage = 4 * (img.width * pixelDensity) *
                         *     (img.height * pixelDensity/2);
                         *   loadPixels();
                         *   for (var i = 0; i &lt; halfImage; i++) {
                         *     pixels[i+halfImage] = pixels[i];
                         *   }
                         *   updatePixels();
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.updatePixels = function (x, y, w, h) {
                          // graceful fail - if loadPixels() or set() has not been called, pixel
                          // array will be empty, ignore call to updatePixels()
                          if (this.pixels.length === 0) {
                            return;
                          }
                          this._renderer.updatePixels(x, y, w, h);
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;../color/p5.Color&quot;:42,&quot;../core/core&quot;:48,&quot;./filters&quot;:65}],70:[function(_dereq_,module,exports){
                        /**
                         * @module IO
                         * @submodule Input
                         * @for p5
                         * @requires core
                         * @requires reqwest
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        var reqwest = _dereq_(&#x27;reqwest&#x27;);
                        var opentype = _dereq_(&#x27;opentype.js&#x27;);
                        _dereq_(&#x27;../core/error_helpers&#x27;);
                        
                        /**
                         * Checks if we are in preload and returns the last arg which will be the
                         * _decrementPreload function if called from a loadX() function.  Should
                         * only be used in loadX() functions.
                         * @private
                         */
                        p5._getDecrementPreload = function () {
                          var decrementPreload = arguments[arguments.length - 1];
                        
                          // when in preload decrementPreload will always be the last arg as it is set
                          // with args.push() before invocation in _wrapPreload
                          if ((window.preload || (this &amp;&amp; this.preload)) &amp;&amp;
                            typeof decrementPreload === &#x27;function&#x27;) {
                            return decrementPreload;
                          } else {
                            return null;
                          }
                        };
                        
                        /**
                         * Loads an opentype font file (.otf, .ttf) from a file or a URL,
                         * and returns a PFont Object. This method is asynchronous,
                         * meaning it may not finish before the next line in your sketch
                         * is executed.
                         * &lt;br&gt;&lt;br&gt;
                         * The path to the font should be relative to the HTML file
                         * that links in your sketch. Loading an from a URL or other
                         * remote location may be blocked due to your browser&#x27;s built-in
                         * security.
                         *
                         * @method loadFont
                         * @param  {String}        path       name of the file or url to load
                         * @param  {Function}      [callback] function to be executed after
                         *                                    loadFont()
                         *                                    completes
                         * @return {Object}                   p5.Font object
                         * @example
                         *
                         * &lt;p&gt;Calling loadFont() inside preload() guarantees that the load
                         * operation will have completed before setup() and draw() are called.&lt;/p&gt;
                         *
                         * &lt;div&gt;&lt;code&gt;
                         * var myFont;
                         * function preload() {
                         *   myFont = loadFont(&#x27;assets/AvenirNextLTPro-Demi.otf&#x27;);
                         * }
                         *
                         * function setup() {
                         *   fill(&#x27;#ED225D&#x27;);
                         *   textFont(myFont);
                         *   textSize(36);
                         *   text(&#x27;p5*js&#x27;, 10, 50);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         *
                         * &lt;p&gt;Outside of preload(), you may supply a callback function to handle the
                         * object:&lt;/p&gt;
                         *
                         * &lt;div&gt;&lt;code&gt;
                         * function setup() {
                         *   loadFont(&#x27;assets/AvenirNextLTPro-Demi.otf&#x27;, drawText);
                         * }
                         *
                         * function drawText(font) {
                         *   fill(&#x27;#ED225D&#x27;);
                         *   textFont(font, 36);
                         *   text(&#x27;p5*js&#x27;, 10, 50);
                         * }
                         *
                         * &lt;/code&gt;&lt;/div&gt;
                         *
                         * &lt;p&gt;You can also use the string name of the font to style other HTML
                         * elements.&lt;/p&gt;
                         *
                         * &lt;div&gt;&lt;code&gt;
                         * var myFont;
                         *
                         * function preload() {
                         *   myFont = loadFont(&#x27;assets/Avenir.otf&#x27;);
                         * }
                         *
                         * function setup() {
                         *   var myDiv = createDiv(&#x27;hello there&#x27;);
                         *   myDiv.style(&#x27;font-family&#x27;, &#x27;Avenir&#x27;);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.loadFont = function (path, onSuccess, onError) {
                        
                          var p5Font = new p5.Font(this);
                          var decrementPreload = p5._getDecrementPreload.apply(this, arguments);
                        
                          opentype.load(path, function (err, font) {
                        
                            if (err) {
                        
                              if ((typeof onError !== &#x27;undefined&#x27;) &amp;&amp; (onError !== decrementPreload)) {
                                return onError(err);
                              }
                              throw err;
                            }
                        
                            p5Font.font = font;
                        
                            if (typeof onSuccess !== &#x27;undefined&#x27;) {
                              onSuccess(p5Font);
                            }
                        
                            if (decrementPreload &amp;&amp; (onSuccess !== decrementPreload)) {
                              decrementPreload();
                            }
                        
                            // check that we have an acceptable font type
                            var validFontTypes = [ &#x27;ttf&#x27;, &#x27;otf&#x27;, &#x27;woff&#x27;, &#x27;woff2&#x27; ],
                              fileNoPath = path.split(&#x27;\\&#x27;).pop().split(&#x27;/&#x27;).pop(),
                              lastDotIdx = fileNoPath.lastIndexOf(&#x27;.&#x27;), fontFamily, newStyle,
                              fileExt = lastDotIdx &lt; 1 ? null : fileNoPath.substr(lastDotIdx + 1);
                        
                            // if so, add it to the DOM (name-only) for use with p5.dom
                            if (validFontTypes.indexOf(fileExt) &gt; -1) {
                        
                              fontFamily = fileNoPath.substr(0, lastDotIdx);
                              newStyle = document.createElement(&#x27;style&#x27;);
                              newStyle.appendChild(document.createTextNode(&#x27;\n@font-face {&#x27; +
                                &#x27;\nfont-family: &#x27; + fontFamily + &#x27;;\nsrc: url(&#x27; + path + &#x27;);\n}\n&#x27;));
                              document.head.appendChild(newStyle);
                            }
                        
                          });
                        
                          return p5Font;
                        };
                        
                        //BufferedReader
                        p5.prototype.createInput = function () {
                          // TODO
                          throw &#x27;not yet implemented&#x27;;
                        };
                        
                        p5.prototype.createReader = function () {
                          // TODO
                          throw &#x27;not yet implemented&#x27;;
                        };
                        
                        p5.prototype.loadBytes = function () {
                          // TODO
                          throw &#x27;not yet implemented&#x27;;
                        };
                        
                        /**
                         * Loads a JSON file from a file or a URL, and returns an Object or Array.
                         * This method is asynchronous, meaning it may not finish before the next
                         * line in your sketch is executed.
                         *
                         * @method loadJSON
                         * @param  {String}        path       name of the file or url to load
                         * @param  {Function}      [callback] function to be executed after
                         *                                    loadJSON() completes, data is passed
                         *                                    in as first argument
                         * @param  {Function}      [errorCallback] function to be executed if
                         *                                    there is an error, response is passed
                         *                                    in as first argument
                         * @param  {String}        [datatype] &quot;json&quot; or &quot;jsonp&quot;
                         * @return {Object|Array}             JSON data
                         * @example
                         *
                         * &lt;p&gt;Calling loadJSON() inside preload() guarantees to complete the
                         * operation before setup() and draw() are called.&lt;/p&gt;
                         *
                         * &lt;div&gt;&lt;code&gt;
                         * var weather;
                         * function preload() {
                         *   var url = &#x27;http://api.openweathermap.org/data/2.5/weather?q=London,UK&#x27;+
                         *    &#x27;&amp;APPID=7bbbb47522848e8b9c26ba35c226c734&#x27;;
                         *   weather = loadJSON(url);
                         * }
                         *
                         * function setup() {
                         *   noLoop();
                         * }
                         *
                         * function draw() {
                         *   background(200);
                         *   // get the humidity value out of the loaded JSON
                         *   var humidity = weather.main.humidity;
                         *   fill(0, humidity); // use the humidity value to set the alpha
                         *   ellipse(width/2, height/2, 50, 50);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         *
                         *
                         * &lt;p&gt;Outside of preload(), you may supply a callback function to handle the
                         * object:&lt;/p&gt;
                         * &lt;div&gt;&lt;code&gt;
                         * function setup() {
                         *   noLoop();
                         *   var url = &#x27;http://api.openweathermap.org/data/2.5/weather?q=NewYork&#x27;+
                         *    &#x27;&amp;APPID=7bbbb47522848e8b9c26ba35c226c734&#x27;;
                         *   loadJSON(url, drawWeather);
                         * }
                         *
                         * function draw() {
                         *   background(200);
                         * }
                         *
                         * function drawWeather(weather) {
                         *   // get the humidity value out of the loaded JSON
                         *   var humidity = weather.main.humidity;
                         *   fill(0, humidity); // use the humidity value to set the alpha
                         *   ellipse(width/2, height/2, 50, 50);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         *
                         */
                        p5.prototype.loadJSON = function () {
                          var path = arguments[0];
                          var callback = arguments[1];
                          var errorCallback;
                          var decrementPreload = p5._getDecrementPreload.apply(this, arguments);
                        
                          var ret = []; // array needed for preload
                          // assume jsonp for URLs
                          var t = &#x27;json&#x27;; //= path.indexOf(&#x27;http&#x27;) === -1 ? &#x27;json&#x27; : &#x27;jsonp&#x27;;
                        
                          // check for explicit data type argument
                          for (var i = 2; i &lt; arguments.length; i++) {
                            var arg = arguments[i];
                            if (typeof arg === &#x27;string&#x27;) {
                              if (arg === &#x27;jsonp&#x27; || arg === &#x27;json&#x27;) {
                                t = arg;
                              }
                            } else if (typeof arg === &#x27;function&#x27;) {
                              errorCallback = arg;
                            }
                          }
                        
                          reqwest({
                            url: path,
                            type: t,
                            crossOrigin: true,
                            error: function (resp) {
                              // pass to error callback if defined
                              if (errorCallback) {
                                errorCallback(resp);
                              } else { // otherwise log error msg
                                console.log(resp.statusText);
                              }
                            },
                            success: function (resp) {
                              for (var k in resp) {
                                ret[k] = resp[k];
                              }
                              if (typeof callback !== &#x27;undefined&#x27;) {
                                callback(resp);
                              }
                              if (decrementPreload &amp;&amp; (callback !== decrementPreload)) {
                                decrementPreload();
                              }
                            }
                          });
                        
                          return ret;
                        };
                        
                        /**
                         * Reads the contents of a file and creates a String array of its individual
                         * lines. If the name of the file is used as the parameter, as in the above
                         * example, the file must be located in the sketch directory/folder.
                         * &lt;br&gt;&lt;br&gt;
                         * Alternatively, the file maybe be loaded from anywhere on the local
                         * computer using an absolute path (something that starts with / on Unix and
                         * Linux, or a drive letter on Windows), or the filename parameter can be a
                         * URL for a file found on a network.
                         * &lt;br&gt;&lt;br&gt;
                         * This method is asynchronous, meaning it may not finish before the next
                         * line in your sketch is executed.
                         *
                         * @method loadStrings
                         * @param  {String}   filename   name of the file or url to load
                         * @param  {Function} [callback] function to be executed after loadStrings()
                         *                               completes, Array is passed in as first
                         *                               argument
                         * @param  {Function} [errorCallback] function to be executed if
                         *                               there is an error, response is passed
                         *                               in as first argument
                         * @return {Array}               Array of Strings
                         * @example
                         *
                         * &lt;p&gt;Calling loadStrings() inside preload() guarantees to complete the
                         * operation before setup() and draw() are called.&lt;/p&gt;
                         *
                         * &lt;div&gt;&lt;code&gt;
                         * var result;
                         * function preload() {
                         *   result = loadStrings(&#x27;assets/test.txt&#x27;);
                         * }
                        
                         * function setup() {
                         *   background(200);
                         *   var ind = floor(random(result.length));
                         *   text(result[ind], 10, 10, 80, 80);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         *
                         * &lt;p&gt;Outside of preload(), you may supply a callback function to handle the
                         * object:&lt;/p&gt;
                         *
                         * &lt;div&gt;&lt;code&gt;
                         * function setup() {
                         *   loadStrings(&#x27;assets/test.txt&#x27;, pickString);
                         * }
                         *
                         * function pickString(result) {
                         *   background(200);
                         *   var ind = floor(random(result.length));
                         *   text(result[ind], 10, 10, 80, 80);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.loadStrings = function (path, callback, errorCallback) {
                          var ret = [];
                          var req = new XMLHttpRequest();
                          var decrementPreload = p5._getDecrementPreload.apply(this, arguments);
                        
                          req.addEventListener(&#x27;error&#x27;, function (resp) {
                            if (errorCallback) {
                              errorCallback(resp);
                            } else {
                              console.log(resp.responseText);
                            }
                          });
                        
                          req.open(&#x27;GET&#x27;, path, true);
                          req.onreadystatechange = function () {
                            if (req.readyState === 4) {
                              if (req.status === 200) {
                                var arr = req.responseText.match(/[^\r\n]+/g);
                                for (var k in arr) {
                                  ret[k] = arr[k];
                                }
                                if (typeof callback !== &#x27;undefined&#x27;) {
                                  callback(ret);
                                }
                                if (decrementPreload &amp;&amp; (callback !== decrementPreload)) {
                                  decrementPreload();
                                }
                              } else {
                                if (errorCallback) {
                                  errorCallback(req);
                                } else {
                                  console.log(req.statusText);
                                }
                                //p5._friendlyFileLoadError(3, path);
                              }
                            }
                          };
                          req.send(null);
                          return ret;
                        };
                        
                        /**
                         * &lt;p&gt;Reads the contents of a file or URL and creates a p5.Table object with
                         * its values. If a file is specified, it must be located in the sketch&#x27;s
                         * &quot;data&quot; folder. The filename parameter can also be a URL to a file found
                         * online. By default, the file is assumed to be comma-separated (in CSV
                         * format). Table only looks for a header row if the &#x27;header&#x27; option is
                         * included.&lt;/p&gt;
                         *
                         * &lt;p&gt;Possible options include:
                         * &lt;ul&gt;
                         * &lt;li&gt;csv - parse the table as comma-separated values&lt;/li&gt;
                         * &lt;li&gt;tsv - parse the table as tab-separated values&lt;/li&gt;
                         * &lt;li&gt;header - this table has a header (title) row&lt;/li&gt;
                         * &lt;/ul&gt;
                         * &lt;/p&gt;
                         *
                         * &lt;p&gt;When passing in multiple options, pass them in as separate parameters,
                         * seperated by commas. For example:
                         * &lt;br&gt;&lt;br&gt;
                         * &lt;code&gt;
                         *   loadTable(&quot;my_csv_file.csv&quot;, &quot;csv&quot;, &quot;header&quot;)
                         * &lt;/code&gt;
                         * &lt;/p&gt;
                         *
                         * &lt;p&gt; All files loaded and saved use UTF-8 encoding.&lt;/p&gt;
                         *
                         * &lt;p&gt;This method is asynchronous, meaning it may not finish before the next
                         * line in your sketch is executed. Calling loadTable() inside preload()
                         * guarantees to complete the operation before setup() and draw() are called.
                         * &lt;p&gt;Outside of preload(), you may supply a callback function to handle the
                         * object:&lt;/p&gt;
                         * &lt;/p&gt;
                         *
                         * @method loadTable
                         * @param  {String}         filename   name of the file or URL to load
                         * @param  {String|Strings} [options]  &quot;header&quot; &quot;csv&quot; &quot;tsv&quot;
                         * @param  {Function}       [callback] function to be executed after
                         *                                     loadTable() completes, Table object is
                         *                                     passed in as first argument
                         * @return {Object}                    Table object containing data
                         *
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * // Given the following CSV file called &quot;mammals.csv&quot;
                         * // located in the project&#x27;s &quot;assets&quot; folder:
                         * //
                         * // id,species,name
                         * // 0,Capra hircus,Goat
                         * // 1,Panthera pardus,Leopard
                         * // 2,Equus zebra,Zebra
                         *
                         * var table;
                         *
                         * function preload() {
                         *   //my table is comma separated value &quot;csv&quot;
                         *   //and has a header specifying the columns labels
                         *   table = loadTable(&quot;assets/mammals.csv&quot;, &quot;csv&quot;, &quot;header&quot;);
                         *   //the file can be remote
                         *   //table = loadTable(&quot;http://p5js.org/reference/assets/mammals.csv&quot;,
                         *   //                  &quot;csv&quot;, &quot;header&quot;);
                         * }
                         *
                         * function setup() {
                         *   //count the columns
                         *   print(table.getRowCount() + &quot; total rows in table&quot;);
                         *   print(table.getColumnCount() + &quot; total columns in table&quot;);
                         *
                         *   print(table.getColumn(&quot;name&quot;));
                         *   //[&quot;Goat&quot;, &quot;Leopard&quot;, &quot;Zebra&quot;]
                         *
                         *   //cycle through the table
                         *   for (var r = 0; r &lt; table.getRowCount(); r++)
                         *     for (var c = 0; c &lt; table.getColumnCount(); c++) {
                         *       print(table.getString(r, c));
                         *     }
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.loadTable = function (path) {
                          var callback = null;
                          var options = [];
                          var header = false;
                          var sep = &#x27;,&#x27;;
                          var separatorSet = false;
                          var decrementPreload = p5._getDecrementPreload.apply(this, arguments);
                        
                          for (var i = 1; i &lt; arguments.length; i++) {
                            if ((typeof (arguments[i]) === &#x27;function&#x27;) &amp;&amp;
                              (arguments[i] !== decrementPreload)) {
                              callback = arguments[i];
                            } else if (typeof (arguments[i]) === &#x27;string&#x27;) {
                              options.push(arguments[i]);
                              if (arguments[i] === &#x27;header&#x27;) {
                                header = true;
                              }
                              if (arguments[i] === &#x27;csv&#x27;) {
                                if (separatorSet) {
                                  throw new Error(&#x27;Cannot set multiple separator types.&#x27;);
                                } else {
                                  sep = &#x27;,&#x27;;
                                  separatorSet = true;
                                }
                              } else if (arguments[i] === &#x27;tsv&#x27;) {
                                if (separatorSet) {
                                  throw new Error(&#x27;Cannot set multiple separator types.&#x27;);
                                } else {
                                  sep = &#x27;\t&#x27;;
                                  separatorSet = true;
                                }
                              }
                            }
                          }
                        
                          var t = new p5.Table();
                          reqwest({
                              url: path,
                              crossOrigin: true,
                              type: &#x27;csv&#x27;
                            })
                            .then(function (resp) {
                              resp = resp.responseText;
                        
                              var state = {};
                        
                              // define constants
                              var PRE_TOKEN = 0,
                                MID_TOKEN = 1,
                                POST_TOKEN = 2,
                                POST_RECORD = 4;
                        
                              var QUOTE = &#x27;\&quot;&#x27;,
                                CR = &#x27;\r&#x27;,
                                LF = &#x27;\n&#x27;;
                        
                              var records = [];
                              var offset = 0;
                              var currentRecord = null;
                              var currentChar;
                        
                              var recordBegin = function () {
                                state.escaped = false;
                                currentRecord = [];
                                tokenBegin();
                              };
                        
                              var recordEnd = function () {
                                state.currentState = POST_RECORD;
                                records.push(currentRecord);
                                currentRecord = null;
                              };
                        
                              var tokenBegin = function () {
                                state.currentState = PRE_TOKEN;
                                state.token = &#x27;&#x27;;
                              };
                        
                              var tokenEnd = function () {
                                currentRecord.push(state.token);
                                tokenBegin();
                              };
                        
                              while (true) {
                                currentChar = resp[offset++];
                        
                                // EOF
                                if (currentChar == null) {
                                  if (state.escaped) {
                                    throw new Error(&#x27;Unclosed quote in file.&#x27;);
                                  }
                                  if (currentRecord) {
                                    tokenEnd();
                                    recordEnd();
                                    break;
                                  }
                                }
                                if (currentRecord === null) {
                                  recordBegin();
                                }
                        
                                // Handle opening quote
                                if (state.currentState === PRE_TOKEN) {
                                  if (currentChar === QUOTE) {
                                    state.escaped = true;
                                    state.currentState = MID_TOKEN;
                                    continue;
                                  }
                                  state.currentState = MID_TOKEN;
                                }
                        
                                // mid-token and escaped, look for sequences and end quote
                                if (state.currentState === MID_TOKEN &amp;&amp; state.escaped) {
                                  if (currentChar === QUOTE) {
                                    if (resp[offset] === QUOTE) {
                                      state.token += QUOTE;
                                      offset++;
                                    } else {
                                      state.escaped = false;
                                      state.currentState = POST_TOKEN;
                                    }
                                  } else {
                                    state.token += currentChar;
                                  }
                                  continue;
                                }
                        
                                // fall-through: mid-token or post-token, not escaped
                                if (currentChar === CR) {
                                  if (resp[offset] === LF) {
                                    offset++;
                                  }
                                  tokenEnd();
                                  recordEnd();
                                } else if (currentChar === LF) {
                                  tokenEnd();
                                  recordEnd();
                                } else if (currentChar === sep) {
                                  tokenEnd();
                                } else if (state.currentState === MID_TOKEN) {
                                  state.token += currentChar;
                                }
                              }
                        
                              // set up column names
                              if (header) {
                                t.columns = records.shift();
                              } else {
                                for (i = 0; i &lt; records.length; i++) {
                                  t.columns[i] = i.toString();
                                }
                              }
                              var row;
                              for (i = 0; i &lt; records.length; i++) {
                                //Handles row of &#x27;undefined&#x27; at end of some CSVs
                                if (i === records.length - 1 &amp;&amp; records[i].length === 1) {
                                  if (records[i][0] === &#x27;undefined&#x27;) {
                                    break;
                                  }
                                }
                                row = new p5.TableRow();
                                row.arr = records[i];
                                row.obj = makeObject(records[i], t.columns);
                                t.addRow(row);
                              }
                              if (callback !== null) {
                                callback(t);
                              }
                              if (decrementPreload &amp;&amp; (callback !== decrementPreload)) {
                                decrementPreload();
                              }
                            })
                            .fail(function (err, msg) {
                              p5._friendlyFileLoadError(2, path);
                              // don&#x27;t get error callback mixed up with decrementPreload
                              if ((typeof callback !== &#x27;undefined&#x27;) &amp;&amp;
                                (callback !== decrementPreload)) {
                                callback(false);
                              }
                            });
                        
                          return t;
                        };
                        
                        // helper function to turn a row into a JSON object
                        function makeObject(row, headers) {
                          var ret = {};
                          headers = headers || [];
                          if (typeof (headers) === &#x27;undefined&#x27;) {
                            for (var j = 0; j &lt; row.length; j++) {
                              headers[j.toString()] = j;
                            }
                          }
                          for (var i = 0; i &lt; headers.length; i++) {
                            var key = headers[i];
                            var val = row[i];
                            ret[key] = val;
                          }
                          return ret;
                        }
                        
                        /**
                         * Reads the contents of a file and creates an XML object with its values.
                         * If the name of the file is used as the parameter, as in the above example,
                         * the file must be located in the sketch directory/folder.
                         * &lt;br&gt;&lt;br&gt;
                         * Alternatively, the file maybe be loaded from anywhere on the local
                         * computer using an absolute path (something that starts with / on Unix and
                         * Linux, or a drive letter on Windows), or the filename parameter can be a
                         * URL for a file found on a network.
                         * &lt;br&gt;&lt;br&gt;
                         * This method is asynchronous, meaning it may not finish before the next
                         * line in your sketch is executed. Calling loadXML() inside preload()
                         * guarantees to complete the operation before setup() and draw() are called.
                         * &lt;br&gt;&lt;br&gt;
                         * Outside of preload(), you may supply a callback function to handle the
                         * object:
                         *
                         * @method loadXML
                         * @param  {String}   filename   name of the file or URL to load
                         * @param  {Function} [callback] function to be executed after loadXML()
                         *                               completes, XML object is passed in as
                         *                               first argument
                         * @param  {Function} [errorCallback] function to be executed if
                         *                               there is an error, response is passed
                         *                               in as first argument
                         * @return {Object}              XML object containing data
                         */
                        p5.prototype.loadXML = function (path, callback, errorCallback) {
                          var ret = document.implementation.createDocument(null, null);
                          var decrementPreload = p5._getDecrementPreload.apply(this, arguments);
                        
                          reqwest({
                              url: path,
                              type: &#x27;xml&#x27;,
                              crossOrigin: true,
                              error: function (resp) {
                                // pass to error callback if defined
                                if (errorCallback) {
                                  errorCallback(resp);
                                } else { // otherwise log error msg
                                  console.log(resp.statusText);
                                }
                                //p5._friendlyFileLoadError(1,path);
                              }
                            })
                            .then(function (resp) {
                              var x = resp.documentElement;
                              ret.appendChild(x);
                              if (typeof callback !== &#x27;undefined&#x27;) {
                                callback(ret);
                              }
                              if (decrementPreload &amp;&amp; (callback !== decrementPreload)) {
                                decrementPreload();
                              }
                            });
                          return ret;
                        };
                        
                        // name clash with window.open
                        // p5.prototype.open = function() {
                        //   // TODO
                        
                        // };
                        
                        p5.prototype.parseXML = function () {
                          // TODO
                          throw &#x27;not yet implemented&#x27;;
                        
                        };
                        
                        p5.prototype.selectFolder = function () {
                          // TODO
                          throw &#x27;not yet implemented&#x27;;
                        
                        };
                        
                        p5.prototype.selectInput = function () {
                          // TODO
                          throw &#x27;not yet implemented&#x27;;
                        
                        };
                        
                        /**
                         * Method for executing an HTTP GET request. If data type is not specified,
                         * p5 will try to guess based on the URL, defaulting to text.
                         *
                         * @method httpGet
                         * @param  {String}        path       name of the file or url to load
                         * @param  {Object}        [data]     param data passed sent with request
                         * @param  {String}        [datatype] &quot;json&quot;, &quot;jsonp&quot;, &quot;xml&quot;, or &quot;text&quot;
                         * @param  {Function}      [callback] function to be executed after
                         *                                    httpGet() completes, data is passed in
                         *                                    as first argument
                         * @param  {Function}      [errorCallback] function to be executed if
                         *                                    there is an error, response is passed
                         *                                    in as first argument
                         */
                        p5.prototype.httpGet = function () {
                          var args = Array.prototype.slice.call(arguments);
                          args.push(&#x27;GET&#x27;);
                          p5.prototype.httpDo.apply(this, args);
                        };
                        
                        /**
                         * Method for executing an HTTP POST request. If data type is not specified,
                         * p5 will try to guess based on the URL, defaulting to text.
                         *
                         * @method httpPost
                         * @param  {String}        path       name of the file or url to load
                         * @param  {Object}        [data]     param data passed sent with request
                         * @param  {String}        [datatype] &quot;json&quot;, &quot;jsonp&quot;, &quot;xml&quot;, or &quot;text&quot;
                         * @param  {Function}      [callback] function to be executed after
                         *                                    httpGet() completes, data is passed in
                         *                                    as first argument
                         * @param  {Function}      [errorCallback] function to be executed if
                         *                                    there is an error, response is passed
                         *                                    in as first argument
                         */
                        p5.prototype.httpPost = function () {
                          var args = Array.prototype.slice.call(arguments);
                          args.push(&#x27;POST&#x27;);
                          p5.prototype.httpDo.apply(this, args);
                        };
                        
                        /**
                         * Method for executing an HTTP request. If data type is not specified,
                         * p5 will try to guess based on the URL, defaulting to text.&lt;br&gt;&lt;br&gt;
                         * You may also pass a single object specifying all parameters for the
                         * request following the examples inside the reqwest() calls here:
                         * &lt;a href=&#x27;https://github.com/ded/reqwest#api&#x27;
                         * &gt;https://github.com/ded/reqwest#api&lt;/a&gt;
                         *
                         * @method httpDo
                         * @param  {String}        path       name of the file or url to load
                         * @param  {String}        [method]   either &quot;GET&quot;, &quot;POST&quot;, or &quot;PUT&quot;,
                         *                                    defaults to &quot;GET&quot;
                         * @param  {Object}        [data]     param data passed sent with request
                         * @param  {String}        [datatype] &quot;json&quot;, &quot;jsonp&quot;, &quot;xml&quot;, or &quot;text&quot;
                         * @param  {Function}      [callback] function to be executed after
                         *                                    httpGet() completes, data is passed in
                         *                                    as first argument
                         * @param  {Function}      [errorCallback] function to be executed if
                         *                                    there is an error, response is passed
                         *                                    in as first argument
                         */
                        p5.prototype.httpDo = function () {
                          if (typeof arguments[0] === &#x27;object&#x27;) {
                            reqwest(arguments[0]);
                          } else {
                            var method = &#x27;GET&#x27;;
                            var path = arguments[0];
                            var data = {};
                            var type = &#x27;&#x27;;
                            var callback;
                            var errorCallback;
                        
                            for (var i = 1; i &lt; arguments.length; i++) {
                              var a = arguments[i];
                              if (typeof a === &#x27;string&#x27;) {
                                if (a === &#x27;GET&#x27; || a === &#x27;POST&#x27; || a === &#x27;PUT&#x27;) {
                                  method = a;
                                } else {
                                  type = a;
                                }
                              } else if (typeof a === &#x27;object&#x27;) {
                                data = a;
                              } else if (typeof a === &#x27;function&#x27;) {
                                if (!callback) {
                                  callback = a;
                                } else {
                                  errorCallback = a;
                                }
                              }
                            }
                        
                            // do some sort of smart type checking
                            if (type === &#x27;&#x27;) {
                              if (path.indexOf(&#x27;json&#x27;) !== -1) {
                                type = &#x27;json&#x27;;
                              } else if (path.indexOf(&#x27;xml&#x27;) !== -1) {
                                type = &#x27;xml&#x27;;
                              } else {
                                type = &#x27;text&#x27;;
                              }
                            }
                        
                            reqwest({
                              url: path,
                              method: method,
                              data: data,
                              type: type,
                              crossOrigin: true,
                              success: function (resp) {
                                if (typeof callback !== &#x27;undefined&#x27;) {
                                  if (type === &#x27;text&#x27;) {
                                    callback(resp.response);
                                  } else {
                                    callback(resp);
                                  }
                                }
                              },
                              error: function (resp) {
                                if (errorCallback) {
                                  errorCallback(resp);
                                } else {
                                  console.log(resp.statusText);
                                }
                              }
                            });
                          }
                        };
                        
                        /**
                         * @module IO
                         * @submodule Output
                         * @for p5
                         */
                        
                        window.URL = window.URL || window.webkitURL;
                        
                        // private array of p5.PrintWriter objects
                        p5.prototype._pWriters = [];
                        
                        p5.prototype.beginRaw = function () {
                          // TODO
                          throw &#x27;not yet implemented&#x27;;
                        
                        };
                        
                        p5.prototype.beginRecord = function () {
                          // TODO
                          throw &#x27;not yet implemented&#x27;;
                        
                        };
                        
                        p5.prototype.createOutput = function () {
                          // TODO
                        
                          throw &#x27;not yet implemented&#x27;;
                        };
                        
                        p5.prototype.createWriter = function (name, extension) {
                          var newPW;
                          // check that it doesn&#x27;t already exist
                          for (var i in p5.prototype._pWriters) {
                            if (p5.prototype._pWriters[i].name === name) {
                              // if a p5.PrintWriter w/ this name already exists...
                              // return p5.prototype._pWriters[i]; // return it w/ contents intact.
                              // or, could return a new, empty one with a unique name:
                              newPW = new p5.PrintWriter(name + window.millis(), extension);
                              p5.prototype._pWriters.push(newPW);
                              return newPW;
                            }
                          }
                          newPW = new p5.PrintWriter(name, extension);
                          p5.prototype._pWriters.push(newPW);
                          return newPW;
                        };
                        
                        p5.prototype.endRaw = function () {
                          // TODO
                        
                          throw &#x27;not yet implemented&#x27;;
                        };
                        
                        p5.prototype.endRecord = function () {
                          // TODO
                          throw &#x27;not yet implemented&#x27;;
                        
                        };
                        
                        p5.PrintWriter = function (filename, extension) {
                          var self = this;
                          this.name = filename;
                          this.content = &#x27;&#x27;;
                          this.print = function (data) {
                            this.content += data;
                          };
                          this.println = function (data) {
                            this.content += data + &#x27;\n&#x27;;
                          };
                          this.flush = function () {
                            this.content = &#x27;&#x27;;
                          };
                          this.close = function () {
                            // convert String to Array for the writeFile Blob
                            var arr = [];
                            arr.push(this.content);
                            p5.prototype.writeFile(arr, filename, extension);
                            // remove from _pWriters array and delete self
                            for (var i in p5.prototype._pWriters) {
                              if (p5.prototype._pWriters[i].name === this.name) {
                                // remove from _pWriters array
                                p5.prototype._pWriters.splice(i, 1);
                              }
                            }
                            self.flush();
                            self = {};
                          };
                        };
                        
                        p5.prototype.saveBytes = function () {
                          // TODO
                          throw &#x27;not yet implemented&#x27;;
                        
                        };
                        
                        // object, filename, options --&gt; saveJSON, saveStrings, saveTable
                        // filename, [extension] [canvas] --&gt; saveImage
                        
                        /**
                         *  &lt;p&gt;Save an image, text, json, csv, wav, or html. Prompts download to
                         *  the client&#x27;s computer. &lt;b&gt;Note that it is not recommended to call save()
                         *  within draw if it&#x27;s looping, as the save() function will open a new save
                         *  dialog every frame.&lt;/b&gt;&lt;/p&gt;
                         *  &lt;p&gt;The default behavior is to save the canvas as an image. You can
                         *  optionally specify a filename.
                         *  For example:&lt;/p&gt;
                         *  &lt;pre class=&#x27;language-javascript&#x27;&gt;&lt;code&gt;
                         *  save();
                         *  save(&#x27;myCanvas.jpg&#x27;); // save a specific canvas with a filename
                         *  &lt;/code&gt;&lt;/pre&gt;
                         *
                         *  &lt;p&gt;Alternately, the first parameter can be a pointer to a canvas
                         *  p5.Element, an Array of Strings,
                         *  an Array of JSON, a JSON object, a p5.Table, a p5.Image, or a
                         *  p5.SoundFile (requires p5.sound). The second parameter is a filename
                         *  (including extension). The third parameter is for options specific
                         *  to this type of object. This method will save a file that fits the
                         *  given paramaters. For example:&lt;/p&gt;
                         *
                         *  &lt;pre class=&#x27;language-javascript&#x27;&gt;&lt;code&gt;
                         *
                         *  save(&#x27;myCanvas.jpg&#x27;);           // Saves canvas as an image
                         *
                         *  var cnv = createCanvas(100, 100);
                         *  save(cnv, &#x27;myCanvas.jpg&#x27;);      // Saves canvas as an image
                         *
                         *  var gb = createGraphics(100, 100);
                         *  save(gb, &#x27;myGraphics.jpg&#x27;);      // Saves p5.Renderer object as an image
                         *
                         *  save(myTable, &#x27;myTable.html&#x27;);  // Saves table as html file
                         *  save(myTable, &#x27;myTable.csv&#x27;,);  // Comma Separated Values
                         *  save(myTable, &#x27;myTable.tsv&#x27;);   // Tab Separated Values
                         *
                         *  save(myJSON, &#x27;my.json&#x27;);        // Saves pretty JSON
                         *  save(myJSON, &#x27;my.json&#x27;, true);  // Optimizes JSON filesize
                         *
                         *  save(img, &#x27;my.png&#x27;);            // Saves pImage as a png image
                         *
                         *  save(arrayOfStrings, &#x27;my.txt&#x27;); // Saves strings to a text file with line
                         *                                  // breaks after each item in the array
                         *  &lt;/code&gt;&lt;/pre&gt;
                         *
                         *  @method save
                         *  @param  {[Object|String]} objectOrFilename  If filename is provided, will
                         *                                             save canvas as an image with
                         *                                             either png or jpg extension
                         *                                             depending on the filename.
                         *                                             If object is provided, will
                         *                                             save depending on the object
                         *                                             and filename (see examples
                         *                                             above).
                         *  @param  {[String]} filename If an object is provided as the first
                         *                               parameter, then the second parameter
                         *                               indicates the filename,
                         *                               and should include an appropriate
                         *                               file extension (see examples above).
                         *  @param  {[Boolean/String]} options  Additional options depend on
                         *                            filetype. For example, when saving JSON,
                         *                            &lt;code&gt;true&lt;/code&gt; indicates that the
                         *                            output will be optimized for filesize,
                         *                            rather than readability.
                         */
                        p5.prototype.save = function (object, _filename, _options) {
                          // parse the arguments and figure out which things we are saving
                          var args = arguments;
                          // =================================================
                          // OPTION 1: saveCanvas...
                        
                          // if no arguments are provided, save canvas
                          var cnv = this._curElement.elt;
                          if (args.length === 0) {
                            p5.prototype.saveCanvas(cnv);
                            return;
                          }
                          // otherwise, parse the arguments
                        
                          // if first param is a p5Graphics, then saveCanvas
                          else if (args[0] instanceof p5.Renderer ||
                            args[0] instanceof p5.Graphics) {
                            p5.prototype.saveCanvas(args[0].elt, args[1], args[2]);
                            return;
                          }
                        
                          // if 1st param is String and only one arg, assume it is canvas filename
                          else if (args.length === 1 &amp;&amp; typeof (args[0]) === &#x27;string&#x27;) {
                            p5.prototype.saveCanvas(cnv, args[0]);
                          }
                        
                          // =================================================
                          // OPTION 2: extension clarifies saveStrings vs. saveJSON
                          else {
                            var extension = _checkFileExtension(args[1], args[2])[1];
                            switch (extension) {
                            case &#x27;json&#x27;:
                              p5.prototype.saveJSON(args[0], args[1], args[2]);
                              return;
                            case &#x27;txt&#x27;:
                              p5.prototype.saveStrings(args[0], args[1], args[2]);
                              return;
                              // =================================================
                              // OPTION 3: decide based on object...
                            default:
                              if (args[0] instanceof Array) {
                                p5.prototype.saveStrings(args[0], args[1], args[2]);
                              } else if (args[0] instanceof p5.Table) {
                                p5.prototype.saveTable(args[0], args[1], args[2], args[3]);
                              } else if (args[0] instanceof p5.Image) {
                                p5.prototype.saveCanvas(args[0].canvas, args[1]);
                              } else if (args[0] instanceof p5.SoundFile) {
                                p5.prototype.saveSound(args[0], args[1], args[2], args[3]);
                              }
                            }
                          }
                        };
                        
                        /**
                         *  Writes the contents of an Array or a JSON object to a .json file.
                         *  The file saving process and location of the saved file will
                         *  vary between web browsers.
                         *
                         *  @method saveJSON
                         *  @param  {Array|Object} json
                         *  @param  {String} filename
                         *  @param  {Boolean} [optimize]   If true, removes line breaks
                         *                                 and spaces from the output
                         *                                 file to optimize filesize
                         *                                 (but not readability).
                         *  @example
                         *  &lt;div&gt;&lt;code&gt;
                         *  var json;
                         *
                         *  function setup() {
                         *
                         *    json = {}; // new JSON Object
                         *
                         *    json.id = 0;
                         *    json.species = &#x27;Panthera leo&#x27;;
                         *    json.name = &#x27;Lion&#x27;;
                         *
                         *  // To save, un-comment the line below, then click &#x27;run&#x27;
                         *  // saveJSONObject(json, &#x27;lion.json&#x27;);
                         *  }
                         *
                         *  // Saves the following to a file called &quot;lion.json&quot;:
                         *  // {
                         *  //   &quot;id&quot;: 0,
                         *  //   &quot;species&quot;: &quot;Panthera leo&quot;,
                         *  //   &quot;name&quot;: &quot;Lion&quot;
                         *  // }
                         *  &lt;/div&gt;&lt;/code&gt;
                         */
                        p5.prototype.saveJSON = function (json, filename, opt) {
                          var stringify;
                          if (opt) {
                            stringify = JSON.stringify(json);
                          } else {
                            stringify = JSON.stringify(json, undefined, 2);
                          }
                          console.log(stringify);
                          this.saveStrings(stringify.split(&#x27;\n&#x27;), filename, &#x27;json&#x27;);
                        };
                        
                        p5.prototype.saveJSONObject = p5.prototype.saveJSON;
                        p5.prototype.saveJSONArray = p5.prototype.saveJSON;
                        
                        p5.prototype.saveStream = function () {
                          // TODO
                          throw &#x27;not yet implemented&#x27;;
                        
                        };
                        
                        /**
                         *  Writes an array of Strings to a text file, one line per String.
                         *  The file saving process and location of the saved file will
                         *  vary between web browsers.
                         *
                         *  @method saveStrings
                         *  @param  {Array} list      string array to be written
                         *  @param  {String} filename filename for output
                         *  @example
                         *  &lt;div&gt;&lt;code&gt;
                         *  var words = &#x27;apple bear cat dog&#x27;;
                         *
                         *  // .split() outputs an Array
                         *  var list = split(words, &#x27; &#x27;);
                         *
                         *  // To save the file, un-comment next line and click &#x27;run&#x27;
                         *  // saveStrings(list, &#x27;nouns.txt&#x27;);
                         *
                         *  // Saves the following to a file called &#x27;nouns.txt&#x27;:
                         *  //
                         *  // apple
                         *  // bear
                         *  // cat
                         *  // dog
                         *  &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.saveStrings = function (list, filename, extension) {
                          var ext = extension || &#x27;txt&#x27;;
                          var pWriter = this.createWriter(filename, ext);
                          for (var i = 0; i &lt; list.length; i++) {
                            if (i &lt; list.length - 1) {
                              pWriter.println(list[i]);
                            } else {
                              pWriter.print(list[i]);
                            }
                          }
                          pWriter.close();
                          pWriter.flush();
                        };
                        
                        p5.prototype.saveXML = function () {
                          // TODO
                          throw &#x27;not yet implemented&#x27;;
                        
                        };
                        
                        p5.prototype.selectOutput = function () {
                          // TODO
                          throw &#x27;not yet implemented&#x27;;
                        
                        };
                        
                        // =======
                        // HELPERS
                        // =======
                        
                        function escapeHelper(content) {
                          return content
                            .replace(/&amp;/g, &#x27;&amp;amp;&#x27;)
                            .replace(/&lt;/g, &#x27;&amp;lt;&#x27;)
                            .replace(/&gt;/g, &#x27;&amp;gt;&#x27;)
                            .replace(/&quot;/g, &#x27;&amp;quot;&#x27;)
                            .replace(/&#x27;/g, &#x27;&amp;#039;&#x27;);
                        }
                        
                        /**
                         *  Writes the contents of a Table object to a file. Defaults to a
                         *  text file with comma-separated-values (&#x27;csv&#x27;) but can also
                         *  use tab separation (&#x27;tsv&#x27;), or generate an HTML table (&#x27;html&#x27;).
                         *  The file saving process and location of the saved file will
                         *  vary between web browsers.
                         *
                         *  @method saveTable
                         *  @param  {p5.Table} Table  the Table object to save to a file
                         *  @param  {String} filename the filename to which the Table should be saved
                         *  @param  {[String]} options  can be one of &quot;tsv&quot;, &quot;csv&quot;, or &quot;html&quot;
                         *  @example
                         *  &lt;div&gt;&lt;code&gt;
                         *  var table;
                         *
                         *  function setup() {
                         *    table = new p5.Table();
                         *
                         *    table.addColumn(&#x27;id&#x27;);
                         *    table.addColumn(&#x27;species&#x27;);
                         *    table.addColumn(&#x27;name&#x27;);
                         *
                         *    var newRow = table.addRow();
                         *    newRow.setNum(&#x27;id&#x27;, table.getRowCount() - 1);
                         *    newRow.setString(&#x27;species&#x27;, &#x27;Panthera leo&#x27;);
                         *    newRow.setString(&#x27;name&#x27;, &#x27;Lion&#x27;);
                         *
                         *    // To save, un-comment next line then click &#x27;run&#x27;
                         *    // saveTable(table, &#x27;new.csv&#x27;);
                         *    }
                         *
                         *    // Saves the following to a file called &#x27;new.csv&#x27;:
                         *    // id,species,name
                         *    // 0,Panthera leo,Lion
                         *  &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.saveTable = function (table, filename, options) {
                          var pWriter = this.createWriter(filename, options);
                        
                          var header = table.columns;
                        
                          var sep = &#x27;,&#x27;; // default to CSV
                          if (options === &#x27;tsv&#x27;) {
                            sep = &#x27;\t&#x27;;
                          }
                          if (options !== &#x27;html&#x27;) {
                            // make header if it has values
                            if (header[0] !== &#x27;0&#x27;) {
                              for (var h = 0; h &lt; header.length; h++) {
                                if (h &lt; header.length - 1) {
                                  pWriter.print(header[h] + sep);
                                } else {
                                  pWriter.println(header[h]);
                                }
                              }
                            }
                        
                            // make rows
                            for (var i = 0; i &lt; table.rows.length; i++) {
                              var j;
                              for (j = 0; j &lt; table.rows[i].arr.length; j++) {
                                if (j &lt; table.rows[i].arr.length - 1) {
                                  pWriter.print(table.rows[i].arr[j] + sep);
                                } else if (i &lt; table.rows.length - 1) {
                                  pWriter.println(table.rows[i].arr[j]);
                                } else {
                                  pWriter.print(table.rows[i].arr[j]); // no line break
                                }
                              }
                            }
                          }
                        
                          // otherwise, make HTML
                          else {
                            pWriter.println(&#x27;&lt;html&gt;&#x27;);
                            pWriter.println(&#x27;&lt;head&gt;&#x27;);
                            var str = &#x27;  &lt;meta http-equiv=\&quot;content-type\&quot; content&#x27;;
                            str += &#x27;=\&quot;text/html;charset=utf-8\&quot; /&gt;&#x27;;
                            pWriter.println(str);
                            pWriter.println(&#x27;&lt;/head&gt;&#x27;);
                        
                            pWriter.println(&#x27;&lt;body&gt;&#x27;);
                            pWriter.println(&#x27;  &lt;table&gt;&#x27;);
                        
                            // make header if it has values
                            if (header[0] !== &#x27;0&#x27;) {
                              pWriter.println(&#x27;    &lt;tr&gt;&#x27;);
                              for (var k = 0; k &lt; header.length; k++) {
                                var e = escapeHelper(header[k]);
                                pWriter.println(&#x27;      &lt;td&gt;&#x27; + e);
                                pWriter.println(&#x27;      &lt;/td&gt;&#x27;);
                              }
                              pWriter.println(&#x27;    &lt;/tr&gt;&#x27;);
                            }
                        
                            // make rows
                            for (var row = 0; row &lt; table.rows.length; row++) {
                              pWriter.println(&#x27;    &lt;tr&gt;&#x27;);
                              for (var col = 0; col &lt; table.columns.length; col++) {
                                var entry = table.rows[row].getString(col);
                                var htmlEntry = escapeHelper(entry);
                                pWriter.println(&#x27;      &lt;td&gt;&#x27; + htmlEntry);
                                pWriter.println(&#x27;      &lt;/td&gt;&#x27;);
                              }
                              pWriter.println(&#x27;    &lt;/tr&gt;&#x27;);
                            }
                            pWriter.println(&#x27;  &lt;/table&gt;&#x27;);
                            pWriter.println(&#x27;&lt;/body&gt;&#x27;);
                            pWriter.print(&#x27;&lt;/html&gt;&#x27;);
                          }
                          // close and flush the pWriter
                          pWriter.close();
                          pWriter.flush();
                        }; // end saveTable()
                        
                        /**
                         *  Generate a blob of file data as a url to prepare for download.
                         *  Accepts an array of data, a filename, and an extension (optional).
                         *  This is a private function because it does not do any formatting,
                         *  but it is used by saveStrings, saveJSON, saveTable etc.
                         *
                         *  @param  {Array} dataToDownload
                         *  @param  {String} filename
                         *  @param  {[String]} extension
                         *  @private
                         */
                        p5.prototype.writeFile = function (dataToDownload, filename, extension) {
                          var type = &#x27;application\/octet-stream&#x27;;
                          if (p5.prototype._isSafari()) {
                            type = &#x27;text\/plain&#x27;;
                          }
                          var blob = new Blob(dataToDownload, {
                            &#x27;type&#x27;: type
                          });
                          var href = window.URL.createObjectURL(blob);
                          p5.prototype.downloadFile(href, filename, extension);
                        };
                        
                        /**
                         *  Forces download. Accepts a url to filedata/blob, a filename,
                         *  and an extension (optional).
                         *  This is a private function because it does not do any formatting,
                         *  but it is used by saveStrings, saveJSON, saveTable etc.
                         *
                         *  @param  {String} href      i.e. an href generated by createObjectURL
                         *  @param  {[String]} filename
                         *  @param  {[String]} extension
                         */
                        p5.prototype.downloadFile = function (href, fName, extension) {
                          var fx = _checkFileExtension(fName, extension);
                          var filename = fx[0];
                          var ext = fx[1];
                        
                          var a = document.createElement(&#x27;a&#x27;);
                          a.href = href;
                          a.download = filename;
                        
                          // Firefox requires the link to be added to the DOM before click()
                          a.onclick = destroyClickedElement;
                          a.style.display = &#x27;none&#x27;;
                          document.body.appendChild(a);
                        
                          // Safari will open this file in the same page as a confusing Blob.
                          if (p5.prototype._isSafari()) {
                            var aText = &#x27;Hello, Safari user! To download this file...\n&#x27;;
                            aText += &#x27;1. Go to File --&gt; Save As.\n&#x27;;
                            aText += &#x27;2. Choose &quot;Page Source&quot; as the Format.\n&#x27;;
                            aText += &#x27;3. Name it with this extension: .\&quot;&#x27; + ext + &#x27;\&quot;&#x27;;
                            alert(aText);
                          }
                          a.click();
                          href = null;
                        };
                        
                        /**
                         *  Returns a file extension, or another string
                         *  if the provided parameter has no extension.
                         *
                         *  @param   {String} filename
                         *  @return  {Array} [fileName, fileExtension]
                         *
                         *  @private
                         */
                        function _checkFileExtension(filename, extension) {
                          if (!extension || extension === true || extension === &#x27;true&#x27;) {
                            extension = &#x27;&#x27;;
                          }
                          if (!filename) {
                            filename = &#x27;untitled&#x27;;
                          }
                          var ext = &#x27;&#x27;;
                          // make sure the file will have a name, see if filename needs extension
                          if (filename &amp;&amp; filename.indexOf(&#x27;.&#x27;) &gt; -1) {
                            ext = filename.split(&#x27;.&#x27;).pop();
                          }
                          // append extension if it doesn&#x27;t exist
                          if (extension) {
                            if (ext !== extension) {
                              ext = extension;
                              filename = filename + &#x27;.&#x27; + ext;
                            }
                          }
                          return [filename, ext];
                        }
                        p5.prototype._checkFileExtension = _checkFileExtension;
                        
                        /**
                         *  Returns true if the browser is Safari, false if not.
                         *  Safari makes trouble for downloading files.
                         *
                         *  @return  {Boolean} [description]
                         *  @private
                         */
                        p5.prototype._isSafari = function () {
                          var x = Object.prototype.toString.call(window.HTMLElement);
                          return x.indexOf(&#x27;Constructor&#x27;) &gt; 0;
                        };
                        
                        /**
                         *  Helper function, a callback for download that deletes
                         *  an invisible anchor element from the DOM once the file
                         *  has been automatically downloaded.
                         *
                         *  @private
                         */
                        function destroyClickedElement(event) {
                          document.body.removeChild(event.target);
                        }
                        
                        module.exports = p5;
                        
                        },{&quot;../core/core&quot;:48,&quot;../core/error_helpers&quot;:51,&quot;opentype.js&quot;:8,&quot;reqwest&quot;:27}],71:[function(_dereq_,module,exports){
                        /**
                         * @module IO
                         * @submodule Table
                         * @requires core
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        
                        
                        /**
                         *  Table Options
                         *  &lt;p&gt;Generic class for handling tabular data, typically from a
                         *  CSV, TSV, or other sort of spreadsheet file.&lt;/p&gt;
                         *  &lt;p&gt;CSV files are
                         *  &lt;a href=&quot;http://en.wikipedia.org/wiki/Comma-separated_values&quot;&gt;
                         *  comma separated values&lt;/a&gt;, often with the data in quotes. TSV
                         *  files use tabs as separators, and usually don&#x27;t bother with the
                         *  quotes.&lt;/p&gt;
                         *  &lt;p&gt;File names should end with .csv if they&#x27;re comma separated.&lt;/p&gt;
                         *  &lt;p&gt;A rough &quot;spec&quot; for CSV can be found
                         *  &lt;a href=&quot;http://tools.ietf.org/html/rfc4180&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
                         *  &lt;p&gt;To load files, use the loadTable method.&lt;/p&gt;
                         *  &lt;p&gt;To save tables to your computer, use the save method
                         *   or the saveTable method.&lt;/p&gt;
                         *
                         *  Possible options include:
                         *  &lt;ul&gt;
                         *  &lt;li&gt;csv - parse the table as comma-separated values
                         *  &lt;li&gt;tsv - parse the table as tab-separated values
                         *  &lt;li&gt;header - this table has a header (title) row
                         *  &lt;/ul&gt;
                         */
                        
                        /**
                         *  Table objects store data with multiple rows and columns, much
                         *  like in a traditional spreadsheet. Tables can be generated from
                         *  scratch, dynamically, or using data from an existing file.
                         *
                         *  @class p5.Table
                         *  @constructor
                         *  @param  {Array}     [rows] An array of p5.TableRow objects
                         *  @return {p5.Table}         p5.Table generated
                         */
                        p5.Table = function (rows) {
                          /**
                           *  @property columns
                           *  @type {Array}
                           */
                          this.columns = [];
                        
                          /**
                           *  @property rows
                           *  @type {Array}
                           */
                          this.rows = [];
                        };
                        
                        /**
                         *  Use addRow() to add a new row of data to a p5.Table object. By default,
                         *  an empty row is created. Typically, you would store a reference to
                         *  the new row in a TableRow object (see newRow in the example above),
                         *  and then set individual values using set().
                         *
                         *  If a p5.TableRow object is included as a parameter, then that row is
                         *  duplicated and added to the table.
                         *
                         *  @method  addRow
                         *  @param   {p5.TableRow} [row] row to be added to the table
                         *
                         * @example
                            * &lt;div class=&quot;norender&quot;&gt;
                            * &lt;code&gt;
                            * // Given the CSV file &quot;mammals.csv&quot;
                            * // in the project&#x27;s &quot;assets&quot; folder:
                            * //
                            * // id,species,name
                            * // 0,Capra hircus,Goat
                            * // 1,Panthera pardus,Leopard
                            * // 2,Equus zebra,Zebra
                            *
                            * var table;
                            *
                            * function preload() {
                            *   //my table is comma separated value &quot;csv&quot;
                            *   //and has a header specifying the columns labels
                            *   table = loadTable(&quot;assets/mammals.csv&quot;, &quot;csv&quot;, &quot;header&quot;);
                            * }
                            *
                            * function setup() {
                            *   //add a row
                            *   var newRow = table.addRow();
                            *   newRow.setString(&quot;id&quot;, table.getRowCount() - 1);
                            *   newRow.setString(&quot;species&quot;, &quot;Canis Lupus&quot;);
                            *   newRow.setString(&quot;name&quot;, &quot;Wolf&quot;);
                            *
                            *   //print the results
                            *   for (var r = 0; r &lt; table.getRowCount(); r++)
                            *     for (var c = 0; c &lt; table.getColumnCount(); c++)
                            *       print(table.getString(r, c));
                            * }
                            * &lt;/code&gt;
                            * &lt;/div&gt;
                         */
                        p5.Table.prototype.addRow = function(row) {
                          // make sure it is a valid TableRow
                          var r = row || new p5.TableRow();
                        
                          if (typeof(r.arr) === &#x27;undefined&#x27; || typeof(r.obj) === &#x27;undefined&#x27;) {
                            //r = new p5.prototype.TableRow(r);
                            throw &#x27;invalid TableRow: &#x27; + r;
                          }
                          r.table = this;
                          this.rows.push(r);
                          return r;
                        };
                        
                        /**
                         * Removes a row from the table object.
                         *
                         * @method  removeRow
                         * @param   {Number} id ID number of the row to remove
                         *
                         * @example
                            * &lt;div class=&quot;norender&quot;&gt;
                            * &lt;code&gt;
                            * // Given the CSV file &quot;mammals.csv&quot;
                            * // in the project&#x27;s &quot;assets&quot; folder:
                            * //
                            * // id,species,name
                            * // 0,Capra hircus,Goat
                            * // 1,Panthera pardus,Leopard
                            * // 2,Equus zebra,Zebra
                            *
                            * var table;
                            *
                            * function preload() {
                            *   //my table is comma separated value &quot;csv&quot;
                            *   //and has a header specifying the columns labels
                            *   table = loadTable(&quot;assets/mammals.csv&quot;, &quot;csv&quot;, &quot;header&quot;);
                            * }
                            *
                            * function setup() {
                            *   //remove the first row
                            *   var r = table.removeRow(0);
                            *
                            *   //print the results
                            *   for (var r = 0; r &lt; table.getRowCount(); r++)
                            *     for (var c = 0; c &lt; table.getColumnCount(); c++)
                            *       print(table.getString(r, c));
                            * }
                            * &lt;/code&gt;
                            * &lt;/div&gt;
                         */
                        p5.Table.prototype.removeRow = function(id) {
                          this.rows[id].table = null; // remove reference to table
                          var chunk = this.rows.splice(id+1, this.rows.length);
                          this.rows.pop();
                          this.rows = this.rows.concat(chunk);
                        };
                        
                        
                        /**
                         * Returns a reference to the specified p5.TableRow. The reference
                         * can then be used to get and set values of the selected row.
                         *
                         * @method  getRow
                         * @param  {Number}   rowID ID number of the row to get
                         * @return {TableRow} p5.TableRow object
                         *
                         * @example
                            * &lt;div class=&quot;norender&quot;&gt;
                            * &lt;code&gt;
                            * // Given the CSV file &quot;mammals.csv&quot;
                            * // in the project&#x27;s &quot;assets&quot; folder:
                            * //
                            * // id,species,name
                            * // 0,Capra hircus,Goat
                            * // 1,Panthera pardus,Leopard
                            * // 2,Equus zebra,Zebra
                            *
                            * var table;
                            *
                            * function preload() {
                            *   //my table is comma separated value &quot;csv&quot;
                            *   //and has a header specifying the columns labels
                            *   table = loadTable(&quot;assets/mammals.csv&quot;, &quot;csv&quot;, &quot;header&quot;);
                            * }
                            *
                            * function setup() {
                            *   var row = table.getRow(1);
                            *   //print it column by column
                            *   //note: a row is an object, not an array
                            *   for (var c = 0; c &lt; table.getColumnCount(); c++)
                            *     print(row.getString(c));
                            * }
                            * &lt;/code&gt;
                            * &lt;/div&gt;
                         */
                        p5.Table.prototype.getRow = function(r) {
                          return this.rows[r];
                        };
                        
                        /**
                         *  Gets all rows from the table. Returns an array of p5.TableRows.
                         *
                         *  @method  getRows
                         *  @return {Array}   Array of p5.TableRows
                         *
                         * @example
                            * &lt;div class=&quot;norender&quot;&gt;
                            * &lt;code&gt;
                            * // Given the CSV file &quot;mammals.csv&quot;
                            * // in the project&#x27;s &quot;assets&quot; folder:
                            * //
                            * // id,species,name
                            * // 0,Capra hircus,Goat
                            * // 1,Panthera pardus,Leopard
                            * // 2,Equus zebra,Zebra
                            *
                            * var table;
                            *
                            * function preload() {
                            *   //my table is comma separated value &quot;csv&quot;
                            *   //and has a header specifying the columns labels
                            *   table = loadTable(&quot;assets/mammals.csv&quot;, &quot;csv&quot;, &quot;header&quot;);
                            * }
                            *
                            * function setup() {
                            *   var rows = table.getRows();
                            *
                            *   //warning: rows is an array of objects
                            *   for (var r = 0; r &lt; rows.length; r++)
                            *     rows[r].set(&quot;name&quot;, &quot;Unicorn&quot;);
                            *
                            *   //print the results
                            *   for (var r = 0; r &lt; table.getRowCount(); r++)
                            *     for (var c = 0; c &lt; table.getColumnCount(); c++)
                            *       print(table.getString(r, c));
                            * }
                            * &lt;/code&gt;
                            * &lt;/div&gt;
                         */
                        p5.Table.prototype.getRows = function() {
                          return this.rows;
                        };
                        
                        /**
                         *  Finds the first row in the Table that contains the value
                         *  provided, and returns a reference to that row. Even if
                         *  multiple rows are possible matches, only the first matching
                         *  row is returned. The column to search may be specified by
                         *  either its ID or title.
                         *
                         *  @method  findRow
                         *  @param  {String} value  The value to match
                         *  @param  {Number|String} column ID number or title of the
                         *                                 column to search
                         *  @return {TableRow}
                         *
                         * @example
                            * &lt;div class=&quot;norender&quot;&gt;
                            * &lt;code&gt;
                            * // Given the CSV file &quot;mammals.csv&quot;
                            * // in the project&#x27;s &quot;assets&quot; folder:
                            * //
                            * // id,species,name
                            * // 0,Capra hircus,Goat
                            * // 1,Panthera pardus,Leopard
                            * // 2,Equus zebra,Zebra
                            *
                            * var table;
                            *
                            * function preload() {
                            *   //my table is comma separated value &quot;csv&quot;
                            *   //and has a header specifying the columns labels
                            *   table = loadTable(&quot;assets/mammals.csv&quot;, &quot;csv&quot;, &quot;header&quot;);
                            * }
                            *
                            * function setup() {
                            *   //find the animal named zebra
                            *   var row = table.findRow(&quot;Zebra&quot;, &quot;name&quot;);
                            *   //find the corresponding species
                            *   print(row.getString(&quot;species&quot;));
                            * }
                            * &lt;/code&gt;
                            * &lt;/div&gt;
                         */
                        p5.Table.prototype.findRow = function(value, column) {
                          // try the Object
                          if (typeof(column) === &#x27;string&#x27;) {
                            for (var i = 0; i &lt; this.rows.length; i++){
                              if (this.rows[i].obj[column] === value) {
                                return this.rows[i];
                              }
                            }
                          }
                          // try the Array
                          else {
                            for (var j = 0; j &lt; this.rows.length; j++){
                              if (this.rows[j].arr[column] === value) {
                                return this.rows[j];
                              }
                            }
                          }
                          // otherwise...
                          return null;
                        };
                        
                        /**
                         *  Finds the rows in the Table that contain the value
                         *  provided, and returns references to those rows. Returns an
                         *  Array, so for must be used to iterate through all the rows,
                         *  as shown in the example above. The column to search may be
                         *  specified by either its ID or title.
                         *
                         *  @method  findRows
                         *  @param  {String} value  The value to match
                         *  @param  {Number|String} column ID number or title of the
                         *                                 column to search
                         *  @return {Array}        An Array of TableRow objects
                         *
                         * @example
                            * &lt;div class=&quot;norender&quot;&gt;
                            * &lt;code&gt;
                            * // Given the CSV file &quot;mammals.csv&quot;
                            * // in the project&#x27;s &quot;assets&quot; folder:
                            * //
                            * // id,species,name
                            * // 0,Capra hircus,Goat
                            * // 1,Panthera pardus,Leopard
                            * // 2,Equus zebra,Zebra
                            *
                            * var table;
                            *
                            * function preload() {
                            *   //my table is comma separated value &quot;csv&quot;
                            *   //and has a header specifying the columns labels
                            *   table = loadTable(&quot;assets/mammals.csv&quot;, &quot;csv&quot;, &quot;header&quot;);
                            * }
                            *
                            * function setup() {
                            *   //add another goat
                            *   var newRow = table.addRow();
                            *   newRow.setString(&quot;id&quot;, table.getRowCount() - 1);
                            *   newRow.setString(&quot;species&quot;, &quot;Scape Goat&quot;);
                            *   newRow.setString(&quot;name&quot;, &quot;Goat&quot;);
                            *
                            *   //find the rows containing animals named Goat
                            *   var rows = table.findRows(&quot;Goat&quot;, &quot;name&quot;);
                            *   print(rows.length + &quot; Goats found&quot;);
                            * }
                            * &lt;/code&gt;
                            * &lt;/div&gt;
                         */
                        p5.Table.prototype.findRows = function(value, column) {
                          var ret = [];
                          if (typeof(column) === &#x27;string&#x27;) {
                            for (var i = 0; i &lt; this.rows.length; i++){
                              if (this.rows[i].obj[column] === value) {
                                ret.push( this.rows[i] );
                              }
                            }
                          }
                          // try the Array
                          else {
                            for (var j = 0; j &lt; this.rows.length; j++){
                              if (this.rows[j].arr[column] === value) {
                                ret.push( this.rows[j] );
                              }
                            }
                          }
                          return ret;
                        };
                        
                        /**
                         *  Finds the first row in the Table that matches the regular
                         *  expression provided, and returns a reference to that row.
                         *  Even if multiple rows are possible matches, only the first
                         *  matching row is returned. The column to search may be
                         *  specified by either its ID or title.
                         *
                         *  @method  matchRow
                         *  @param  {String} regexp The regular expression to match
                         *  @param  {String|Number} column The column ID (number) or
                         *                                   title (string)
                         *  @return {TableRow}        TableRow object
                         */
                        p5.Table.prototype.matchRow = function(regexp, column) {
                          if (typeof(column) === &#x27;number&#x27;) {
                            for (var j = 0; j &lt; this.rows.length; j++) {
                              if ( this.rows[j].arr[column].match(regexp) ) {
                                return this.rows[j];
                              }
                            }
                          }
                        
                          else {
                            for (var i = 0; i &lt; this.rows.length; i++) {
                              if ( this.rows[i].obj[column].match(regexp) ) {
                                return this.rows[i];
                              }
                            }
                          }
                          return null;
                        };
                        
                        /**
                         *  Finds the first row in the Table that matches the regular
                         *  expression provided, and returns a reference to that row.
                         *  Even if multiple rows are possible matches, only the first
                         *  matching row is returned. The column to search may be specified
                         *  by either its ID or title.
                         *
                         *  @method  matchRows
                         *  @param  {String} regexp The regular expression to match
                         *  @param  {String|Number} [column] The column ID (number) or
                         *                                   title (string)
                         *  @return {Array}        An Array of TableRow objects
                         */
                        p5.Table.prototype.matchRows = function(regexp, column) {
                          var ret = [];
                          if (typeof(column) === &#x27;number&#x27;) {
                            for (var j = 0; j &lt; this.rows.length; j++) {
                              if ( this.rows[j].arr[column].match(regexp) ) {
                                ret.push( this.rows[j] );
                              }
                            }
                          }
                        
                          else {
                            for (var i = 0; i &lt; this.rows.length; i++) {
                              if ( this.rows[i].obj[column].match(regexp) ) {
                                ret.push( this.rows[i] );
                              }
                            }
                          }
                          return ret;
                        };
                        
                        
                        /**
                         *  Retrieves all values in the specified column, and returns them
                         *  as an array. The column may be specified by either its ID or title.
                         *
                         *  @method  getColumn
                         *  @param  {String|Number} column String or Number of the column to return
                         *  @return {Array}       Array of column values
                         *
                         * @example
                            * &lt;div class=&quot;norender&quot;&gt;
                            * &lt;code&gt;
                            * // Given the CSV file &quot;mammals.csv&quot;
                            * // in the project&#x27;s &quot;assets&quot; folder:
                            * //
                            * // id,species,name
                            * // 0,Capra hircus,Goat
                            * // 1,Panthera pardus,Leopard
                            * // 2,Equus zebra,Zebra
                            *
                            * var table;
                            *
                            * function preload() {
                            *   //my table is comma separated value &quot;csv&quot;
                            *   //and has a header specifying the columns labels
                            *   table = loadTable(&quot;assets/mammals.csv&quot;, &quot;csv&quot;, &quot;header&quot;);
                            * }
                            *
                            * function setup() {
                            *   //getColumn returns an array that can be printed directly
                            *   print(table.getColumn(&quot;species&quot;));
                            *   //outputs [&quot;Capra hircus&quot;, &quot;Panthera pardus&quot;, &quot;Equus zebra&quot;]
                            * }
                            * &lt;/code&gt;
                            * &lt;/div&gt;
                         */
                        p5.Table.prototype.getColumn = function(value) {
                          var ret = [];
                          if (typeof(value) === &#x27;string&#x27;){
                            for (var i = 0; i &lt; this.rows.length; i++){
                              ret.push (this.rows[i].obj[value]);
                            }
                          } else {
                            for (var j = 0; j &lt; this.rows.length; j++){
                              ret.push (this.rows[j].arr[value]);
                            }
                          }
                          return ret;
                        };
                        
                        /**
                         *  Removes all rows from a Table. While all rows are removed,
                         *  columns and column titles are maintained.
                         *
                         *  @method  clearRows
                         *
                         * @example
                            * &lt;div class=&quot;norender&quot;&gt;
                            * &lt;code&gt;
                            * // Given the CSV file &quot;mammals.csv&quot;
                            * // in the project&#x27;s &quot;assets&quot; folder:
                            * //
                            * // id,species,name
                            * // 0,Capra hircus,Goat
                            * // 1,Panthera pardus,Leopard
                            * // 2,Equus zebra,Zebra
                            *
                            * var table;
                            *
                            * function preload() {
                            *   //my table is comma separated value &quot;csv&quot;
                            *   //and has a header specifying the columns labels
                            *   table = loadTable(&quot;assets/mammals.csv&quot;, &quot;csv&quot;, &quot;header&quot;);
                            * }
                            *
                            * function setup() {
                            *   table.clearRows();
                            *   print(table.getRowCount() + &quot; total rows in table&quot;);
                            *   print(table.getColumnCount() + &quot; total columns in table&quot;);
                            * }
                            * &lt;/code&gt;
                            * &lt;/div&gt;
                         */
                        p5.Table.prototype.clearRows = function() {
                          delete this.rows;
                          this.rows = [];
                        };
                        
                        /**
                         *  Use addColumn() to add a new column to a Table object.
                         *  Typically, you will want to specify a title, so the column
                         *  may be easily referenced later by name. (If no title is
                         *  specified, the new column&#x27;s title will be null.)
                         *
                         *  @method  addColumn
                         *  @param {String} [title] title of the given column
                         *
                         * @example
                            * &lt;div class=&quot;norender&quot;&gt;
                            * &lt;code&gt;
                            * // Given the CSV file &quot;mammals.csv&quot;
                            * // in the project&#x27;s &quot;assets&quot; folder:
                            * //
                            * // id,species,name
                            * // 0,Capra hircus,Goat
                            * // 1,Panthera pardus,Leopard
                            * // 2,Equus zebra,Zebra
                            *
                            * var table;
                            *
                            * function preload() {
                            *   //my table is comma separated value &quot;csv&quot;
                            *   //and has a header specifying the columns labels
                            *   table = loadTable(&quot;assets/mammals.csv&quot;, &quot;csv&quot;, &quot;header&quot;);
                            * }
                            *
                            * function setup() {
                            *   table.addColumn(&quot;carnivore&quot;);
                            *   table.set(0, &quot;carnivore&quot;, &quot;no&quot;);
                            *   table.set(1, &quot;carnivore&quot;, &quot;yes&quot;);
                            *   table.set(2, &quot;carnivore&quot;, &quot;no&quot;);
                            *
                            *   //print the results
                            *   for (var r = 0; r &lt; table.getRowCount(); r++)
                            *     for (var c = 0; c &lt; table.getColumnCount(); c++)
                            *       print(table.getString(r, c));
                            * }
                            * &lt;/code&gt;
                            * &lt;/div&gt;
                         */
                        p5.Table.prototype.addColumn = function(title) {
                          var t = title || null;
                          this.columns.push(t);
                        };
                        
                        /**
                         *  Returns the total number of columns in a Table.
                         *
                         *  @return {Number} Number of columns in this table
                         */
                        p5.Table.prototype.getColumnCount = function() {
                          return this.columns.length;
                        };
                        
                        /**
                         *  Returns the total number of rows in a Table.
                         *
                         *  @method  getRowCount
                         *  @return {Number} Number of rows in this table
                        
                         */
                        p5.Table.prototype.getRowCount = function() {
                          return this.rows.length;
                        };
                        
                        /**
                         *  &lt;p&gt;Removes any of the specified characters (or &quot;tokens&quot;).&lt;/p&gt;
                         *
                         *  &lt;p&gt;If no column is specified, then the values in all columns and
                         *  rows are processed. A specific column may be referenced by
                         *  either its ID or title.&lt;/p&gt;
                         *
                         *  @method  removeTokens
                         *  @param  {String} chars  String listing characters to be removed
                         *  @param  {String|Number} [column] Column ID (number)
                         *                                   or name (string)
                         */
                        p5.Table.prototype.removeTokens = function(chars, column) {
                          var escape= function(s) {
                            return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, &#x27;\\$&amp;&#x27;);
                          };
                          var charArray = [];
                          for (var i = 0; i &lt; chars.length; i++) {
                            charArray.push( escape( chars.charAt(i) ) );
                          }
                          var regex = new RegExp(charArray.join(&#x27;|&#x27;), &#x27;g&#x27;);
                        
                          if (typeof(column) === &#x27;undefined&#x27;){
                            for (var c = 0; c &lt; this.columns.length; c++) {
                              for (var d = 0; d &lt; this.rows.length; d++) {
                                var s = this.rows[d].arr[c];
                                s = s.replace(regex, &#x27;&#x27;);
                                this.rows[d].arr[c] = s;
                                this.rows[d].obj[this.columns[c]] = s;
                              }
                            }
                          }
                          else if (typeof(column) === &#x27;string&#x27;){
                            for (var j = 0; j &lt; this.rows.length; j++) {
                              var val = this.rows[j].obj[column];
                              val = val.replace(regex, &#x27;&#x27;);
                              this.rows[j].obj[column] = val;
                              var pos = this.columns.indexOf(column);
                              this.rows[j].arr[pos] = val;
                            }
                          }
                          else {
                            for (var k = 0; k &lt; this.rows.length; k++) {
                              var str = this.rows[k].arr[column];
                              str = str.replace(regex, &#x27;&#x27;);
                              this.rows[k].arr[column] = str;
                              this.rows[k].obj[this.columns[column]] = str;
                            }
                          }
                        };
                        
                        /**
                         *  Trims leading and trailing whitespace, such as spaces and tabs,
                         *  from String table values. If no column is specified, then the
                         *  values in all columns and rows are trimmed. A specific column
                         *  may be referenced by either its ID or title.
                         *
                         *  @method  trim
                         *  @param  {String|Number} column Column ID (number)
                         *                                   or name (string)
                         */
                        p5.Table.prototype.trim = function(column) {
                          var regex = new RegExp( (&#x27; &#x27;), &#x27;g&#x27;);
                        
                          if (typeof(column) === &#x27;undefined&#x27;){
                            for (var c = 0; c &lt; this.columns.length; c++) {
                              for (var d = 0; d &lt; this.rows.length; d++) {
                                var s = this.rows[d].arr[c];
                                s = s.replace(regex, &#x27;&#x27;);
                                this.rows[d].arr[c] = s;
                                this.rows[d].obj[this.columns[c]] = s;
                              }
                            }
                          }
                          else if (typeof(column) === &#x27;string&#x27;){
                            for (var j = 0; j &lt; this.rows.length; j++) {
                              var val = this.rows[j].obj[column];
                              val = val.replace(regex, &#x27;&#x27;);
                              this.rows[j].obj[column] = val;
                              var pos = this.columns.indexOf(column);
                              this.rows[j].arr[pos] = val;
                            }
                          }
                          else {
                            for (var k = 0; k &lt; this.rows.length; k++) {
                              var str = this.rows[k].arr[column];
                              str = str.replace(regex, &#x27;&#x27;);
                              this.rows[k].arr[column] = str;
                              this.rows[k].obj[this.columns[column]] = str;
                            }
                          }
                        };
                        
                        /**
                         *  Use removeColumn() to remove an existing column from a Table
                         *  object. The column to be removed may be identified by either
                         *  its title (a String) or its index value (an int).
                         *  removeColumn(0) would remove the first column, removeColumn(1)
                         *  would remove the second column, and so on.
                         *
                         *  @method  removeColumn
                         *  @param  {String|Number} column columnName (string) or ID (number)
                         *
                         * @example
                            * &lt;div class=&quot;norender&quot;&gt;
                            * &lt;code&gt;
                            * // Given the CSV file &quot;mammals.csv&quot;
                            * // in the project&#x27;s &quot;assets&quot; folder:
                            * //
                            * // id,species,name
                            * // 0,Capra hircus,Goat
                            * // 1,Panthera pardus,Leopard
                            * // 2,Equus zebra,Zebra
                            *
                            * var table;
                            *
                            * function preload() {
                            *   //my table is comma separated value &quot;csv&quot;
                            *   //and has a header specifying the columns labels
                            *   table = loadTable(&quot;assets/mammals.csv&quot;, &quot;csv&quot;, &quot;header&quot;);
                            * }
                            *
                            * function setup() {
                            *   table.removeColumn(&quot;id&quot;);
                            *   print(table.getColumnCount());
                            * }
                            * &lt;/code&gt;
                            * &lt;/div&gt;
                         */
                        p5.Table.prototype.removeColumn = function(c) {
                          var cString;
                          var cNumber;
                          if (typeof(c) === &#x27;string&#x27;) {
                            // find the position of c in the columns
                            cString = c;
                            cNumber = this.columns.indexOf(c);
                            console.log(&#x27;string&#x27;);
                          }
                          else{
                            cNumber = c;
                            cString = this.columns[c];
                          }
                        
                          var chunk = this.columns.splice(cNumber+1, this.columns.length);
                          this.columns.pop();
                          this.columns = this.columns.concat(chunk);
                        
                          for (var i = 0; i &lt; this.rows.length; i++){
                            var tempR = this.rows[i].arr;
                            var chip = tempR.splice(cNumber+1, tempR.length);
                            tempR.pop();
                            this.rows[i].arr = tempR.concat(chip);
                            delete this.rows[i].obj[cString];
                          }
                        
                        };
                        
                        
                        /**
                         * Stores a value in the Table&#x27;s specified row and column.
                         * The row is specified by its ID, while the column may be specified
                         * by either its ID or title.
                         *
                         * @method  set
                         * @param {String|Number} column column ID (Number)
                         *                               or title (String)
                         * @param {String|Number} value  value to assign
                         *
                         * @example
                            * &lt;div class=&quot;norender&quot;&gt;
                            * &lt;code&gt;
                            * // Given the CSV file &quot;mammals.csv&quot;
                            * // in the project&#x27;s &quot;assets&quot; folder:
                            * //
                            * // id,species,name
                            * // 0,Capra hircus,Goat
                            * // 1,Panthera pardus,Leopard
                            * // 2,Equus zebra,Zebra
                            *
                            * var table;
                            *
                            * function preload() {
                            *   //my table is comma separated value &quot;csv&quot;
                            *   //and has a header specifying the columns labels
                            *   table = loadTable(&quot;assets/mammals.csv&quot;, &quot;csv&quot;, &quot;header&quot;);
                            * }
                            *
                            * function setup() {
                            *   table.set(0, &quot;species&quot;, &quot;Canis Lupus&quot;);
                            *   table.set(0, &quot;name&quot;, &quot;Wolf&quot;);
                            *
                            *   //print the results
                            *   for (var r = 0; r &lt; table.getRowCount(); r++)
                            *     for (var c = 0; c &lt; table.getColumnCount(); c++)
                            *       print(table.getString(r, c));
                            * }
                            * &lt;/code&gt;
                            * &lt;/div&gt;
                         */
                        p5.Table.prototype.set = function(row, column, value) {
                          this.rows[row].set(column, value);
                        };
                        
                        /**
                         * Stores a Float value in the Table&#x27;s specified row and column.
                         * The row is specified by its ID, while the column may be specified
                         * by either its ID or title.
                         *
                         * @method setNum
                         * @param {Number} row row ID
                         * @param {String|Number} column column ID (Number)
                         *                               or title (String)
                         * @param {Number} value  value to assign
                         *
                         * @example
                            * &lt;div class=&quot;norender&quot;&gt;
                            * &lt;code&gt;
                            * // Given the CSV file &quot;mammals.csv&quot;
                            * // in the project&#x27;s &quot;assets&quot; folder:
                            * //
                            * // id,species,name
                            * // 0,Capra hircus,Goat
                            * // 1,Panthera pardus,Leopard
                            * // 2,Equus zebra,Zebra
                            *
                            * var table;
                            *
                            * function preload() {
                            *   //my table is comma separated value &quot;csv&quot;
                            *   //and has a header specifying the columns labels
                            *   table = loadTable(&quot;assets/mammals.csv&quot;, &quot;csv&quot;, &quot;header&quot;);
                            * }
                            *
                            * function setup() {
                            *   table.setNum(1, &quot;id&quot;, 1);
                            *
                            *   print(table.getColumn(0));
                            *   //[&quot;0&quot;, 1, &quot;2&quot;]
                            * }
                            * &lt;/code&gt;
                            * &lt;/div&gt;
                         */
                        p5.Table.prototype.setNum = function(row, column, value){
                          this.rows[row].setNum(column, value);
                        };
                        
                        
                        /**
                         * Stores a String value in the Table&#x27;s specified row and column.
                         * The row is specified by its ID, while the column may be specified
                         * by either its ID or title.
                         *
                         * @method  setString
                         * @param {Number} row row ID
                         * @param {String|Number} column column ID (Number)
                         *                               or title (String)
                         * @param {String} value  value to assign
                         */
                        p5.Table.prototype.setString = function(row, column, value){
                          this.rows[row].setString(column, value);
                        };
                        
                        /**
                         * Retrieves a value from the Table&#x27;s specified row and column.
                         * The row is specified by its ID, while the column may be specified by
                         * either its ID or title.
                         *
                         * @method  get
                         * @param {Number} row row ID
                         * @param  {String|Number} column columnName (string) or
                         *                                   ID (number)
                         * @return {String|Number}
                         *
                         * @example
                            * &lt;div class=&quot;norender&quot;&gt;
                            * &lt;code&gt;
                            * // Given the CSV file &quot;mammals.csv&quot;
                            * // in the project&#x27;s &quot;assets&quot; folder:
                            * //
                            * // id,species,name
                            * // 0,Capra hircus,Goat
                            * // 1,Panthera pardus,Leopard
                            * // 2,Equus zebra,Zebra
                            *
                            * var table;
                            *
                            * function preload() {
                            *   //my table is comma separated value &quot;csv&quot;
                            *   //and has a header specifying the columns labels
                            *   table = loadTable(&quot;assets/mammals.csv&quot;, &quot;csv&quot;, &quot;header&quot;);
                            * }
                            *
                            * function setup() {
                            *   print(table.get(0, 1));
                            *   //Capra hircus
                            *   print(table.get(0, &quot;species&quot;));
                            *   //Capra hircus
                            * }
                            * &lt;/code&gt;
                            * &lt;/div&gt;
                         */
                        p5.Table.prototype.get = function(row, column) {
                          return this.rows[row].get(column);
                        };
                        
                        /**
                         * Retrieves a Float value from the Table&#x27;s specified row and column.
                         * The row is specified by its ID, while the column may be specified by
                         * either its ID or title.
                         *
                         * @method  getNum
                         * @param {Number} row row ID
                         * @param  {String|Number} column columnName (string) or
                         *                                   ID (number)
                         * @return {Number}
                         *
                         * @example
                            * &lt;div class=&quot;norender&quot;&gt;
                            * &lt;code&gt;
                            * // Given the CSV file &quot;mammals.csv&quot;
                            * // in the project&#x27;s &quot;assets&quot; folder:
                            * //
                            * // id,species,name
                            * // 0,Capra hircus,Goat
                            * // 1,Panthera pardus,Leopard
                            * // 2,Equus zebra,Zebra
                            *
                            * var table;
                            *
                            * function preload() {
                            *   //my table is comma separated value &quot;csv&quot;
                            *   //and has a header specifying the columns labels
                            *   table = loadTable(&quot;assets/mammals.csv&quot;, &quot;csv&quot;, &quot;header&quot;);
                            * }
                            *
                            * function setup() {
                            *   print(table.getNum(1, 0) + 100);
                            *   //id 1 + 100 = 101
                            * }
                            * &lt;/code&gt;
                            * &lt;/div&gt;
                         */
                        p5.Table.prototype.getNum = function(row, column) {
                          return this.rows[row].getNum(column);
                        };
                        
                        /**
                         * Retrieves a String value from the Table&#x27;s specified row and column.
                         * The row is specified by its ID, while the column may be specified by
                         * either its ID or title.
                         *
                         * @method  getString
                         * @param {Number} row row ID
                         * @param  {String|Number} column columnName (string) or
                         *                                   ID (number)
                         * @return {String}
                         *
                         * @example
                            * &lt;div class=&quot;norender&quot;&gt;
                            * &lt;code&gt;
                            * // Given the CSV file &quot;mammals.csv&quot;
                            * // in the project&#x27;s &quot;assets&quot; folder:
                            * //
                            * // id,species,name
                            * // 0,Capra hircus,Goat
                            * // 1,Panthera pardus,Leopard
                            * // 2,Equus zebra,Zebra
                            *
                            * var table;
                            *
                            * function preload() {
                            *   //my table is comma separated value &quot;csv&quot;
                            *   //and has a header specifying the columns labels
                            *   table = loadTable(&quot;assets/mammals.csv&quot;, &quot;csv&quot;, &quot;header&quot;);
                            * }
                            *
                            * function setup() {
                            *   var tableArray = table.getArray();
                            *
                            *   //output each row as array
                            *   for (var i = 0; i &lt; tableArray.length; i++)
                            *     print(tableArray[i]);
                            * }
                            * &lt;/code&gt;
                            * &lt;/div&gt;
                         */
                        p5.Table.prototype.getString = function(row, column) {
                          return this.rows[row].getString(column);
                        };
                        
                        /**
                         * Retrieves all table data and returns as an object. If a column name is
                         * passed in, each row object will be stored with that attribute as its
                         * title.
                         *
                         * @method  getObject
                         * @param {String} headerColumn Name of the column which should be used to
                         *                              title each row object (optional)
                         * @return {Object}
                         *
                         * @example
                            * &lt;div class=&quot;norender&quot;&gt;
                            * &lt;code&gt;
                            * // Given the CSV file &quot;mammals.csv&quot;
                            * // in the project&#x27;s &quot;assets&quot; folder:
                            * //
                            * // id,species,name
                            * // 0,Capra hircus,Goat
                            * // 1,Panthera pardus,Leopard
                            * // 2,Equus zebra,Zebra
                            *
                            * var table;
                            *
                            * function preload() {
                            *   //my table is comma separated value &quot;csv&quot;
                            *   //and has a header specifying the columns labels
                            *   table = loadTable(&quot;assets/mammals.csv&quot;, &quot;csv&quot;, &quot;header&quot;);
                            * }
                            *
                            * function setup() {
                            *   var tableObject = table.getObject();
                            *
                            *   print(tableObject);
                            *   //outputs an object
                            * }
                            * &lt;/code&gt;
                            * &lt;/div&gt;
                        
                         */
                        p5.Table.prototype.getObject = function (headerColumn) {
                          var tableObject = {};
                          var obj, cPos, index;
                        
                          for(var i = 0; i &lt; this.rows.length; i++) {
                            obj = this.rows[i].obj;
                        
                            if (typeof(headerColumn) === &#x27;string&#x27;){
                              cPos = this.columns.indexOf(headerColumn); // index of columnID
                              if (cPos &gt;= 0) {
                                index = obj[headerColumn];
                                tableObject[index] = obj;
                              } else {
                                throw &#x27;This table has no column named &quot;&#x27; + headerColumn +&#x27;&quot;&#x27;;
                              }
                            } else {
                              tableObject[i] = this.rows[i].obj;
                            }
                          }
                          return tableObject;
                        };
                        
                        /**
                         * Retrieves all table data and returns it as a multidimensional array.
                         *
                         * @method  getArray
                         * @return {Array}
                         */
                        p5.Table.prototype.getArray = function () {
                          var tableArray = [];
                          for(var i = 0; i &lt; this.rows.length; i++) {
                            tableArray.push(this.rows[i].arr);
                          }
                          return tableArray;
                        };
                        
                        module.exports = p5.Table;
                        
                        },{&quot;../core/core&quot;:48}],72:[function(_dereq_,module,exports){
                        /**
                         * @module IO
                         * @submodule Table
                         * @requires core
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        
                        /**
                         *  A TableRow object represents a single row of data values,
                         *  stored in columns, from a table.
                         *
                         *  A Table Row contains both an ordered array, and an unordered
                         *  JSON object.
                         *
                         *  @class p5.TableRow
                         *  @constructor
                         *  @param {String} [str]       optional: populate the row with a
                         *                              string of values, separated by the
                         *                              separator
                         *  @param {String} [separator] comma separated values (csv) by default
                         */
                        p5.TableRow = function (str, separator) {
                          var arr = [];
                          var obj = {};
                          if (str){
                            separator = separator || &#x27;,&#x27;;
                            arr = str.split(separator);
                          }
                          for (var i = 0; i &lt; arr.length; i++){
                            var key = i;
                            var val = arr[i];
                            obj[key] = val;
                          }
                          this.arr = arr;
                          this.obj = obj;
                          this.table = null;
                        };
                        
                        /**
                         *  Stores a value in the TableRow&#x27;s specified column.
                         *  The column may be specified by either its ID or title.
                         *
                         *  @method  set
                         *  @param {String|Number} column Column ID (Number)
                         *                                or Title (String)
                         *  @param {String|Number} value  The value to be stored
                         */
                        p5.TableRow.prototype.set = function(column, value) {
                          // if typeof column is string, use .obj
                          if (typeof(column) === &#x27;string&#x27;){
                            var cPos = this.table.columns.indexOf(column); // index of columnID
                            if (cPos &gt;= 0) {
                              this.obj[column] = value;
                              this.arr[cPos] = value;
                            }
                            else {
                              throw &#x27;This table has no column named &quot;&#x27; + column +&#x27;&quot;&#x27;;
                            }
                          }
                        
                          // if typeof column is number, use .arr
                          else {
                            if (column &lt; this.table.columns.length) {
                              this.arr[column] = value;
                              var cTitle = this.table.columns[column];
                              this.obj[cTitle] = value;
                            }
                            else {
                              throw &#x27;Column #&#x27; + column + &#x27; is out of the range of this table&#x27;;
                            }
                          }
                        };
                        
                        
                        /**
                         *  Stores a Float value in the TableRow&#x27;s specified column.
                         *  The column may be specified by either its ID or title.
                         *
                         *  @method  setNum
                         *  @param {String|Number} column Column ID (Number)
                         *                                or Title (String)
                         *  @param {Number} value  The value to be stored
                         *                                as a Float
                         */
                        p5.TableRow.prototype.setNum = function(column, value){
                          var floatVal = parseFloat(value, 10);
                          this.set(column, floatVal);
                        };
                        
                        
                        /**
                         *  Stores a String value in the TableRow&#x27;s specified column.
                         *  The column may be specified by either its ID or title.
                         *
                         *  @method  setString
                         *  @param {String|Number} column Column ID (Number)
                         *                                or Title (String)
                         *  @param {String} value  The value to be stored
                         *                                as a String
                         */
                        p5.TableRow.prototype.setString = function(column, value){
                          var stringVal = value.toString();
                          this.set(column, stringVal);
                        };
                        
                        /**
                         *  Retrieves a value from the TableRow&#x27;s specified column.
                         *  The column may be specified by either its ID or title.
                         *
                         *  @method  get
                         *  @param  {String|Number} column columnName (string) or
                         *                                   ID (number)
                         *  @return {String|Number}
                         */
                        p5.TableRow.prototype.get = function(column) {
                          if (typeof(column) === &#x27;string&#x27;){
                            return this.obj[column];
                          } else {
                            return this.arr[column];
                          }
                        };
                        
                        /**
                         *  Retrieves a Float value from the TableRow&#x27;s specified
                         *  column. The column may be specified by either its ID or
                         *  title.
                         *
                         *  @method  getNum
                         *  @param  {String|Number} column columnName (string) or
                         *                                   ID (number)
                         *  @return {Number}  Float Floating point number
                         */
                        p5.TableRow.prototype.getNum = function(column) {
                          var ret;
                          if (typeof(column) === &#x27;string&#x27;){
                            ret = parseFloat(this.obj[column], 10);
                          } else {
                            ret = parseFloat(this.arr[column], 10);
                          }
                        
                          if (ret.toString() === &#x27;NaN&#x27;) {
                            throw &#x27;Error: &#x27; + this.obj[column]+ &#x27; is NaN (Not a Number)&#x27;;
                          }
                          return ret;
                        };
                        
                        /**
                         *  Retrieves an String value from the TableRow&#x27;s specified
                         *  column. The column may be specified by either its ID or
                         *  title.
                         *
                         *  @method  getString
                         *  @param  {String|Number} column columnName (string) or
                         *                                   ID (number)
                         *  @return {String}  String
                         */
                        p5.TableRow.prototype.getString = function(column) {
                          if (typeof(column) === &#x27;string&#x27;){
                            return this.obj[column].toString();
                          } else {
                            return this.arr[column].toString();
                          }
                        };
                        
                        module.exports = p5.TableRow;
                        
                        },{&quot;../core/core&quot;:48}],73:[function(_dereq_,module,exports){
                        /**
                         * @module Math
                         * @submodule Calculation
                         * @for p5
                         * @requires core
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        
                        /**
                         * Calculates the absolute value (magnitude) of a number. Maps to Math.abs().
                         * The absolute value of a number is always positive.
                         *
                         * @method abs
                         * @param  {Number} n number to compute
                         * @return {Number}   absolute value of given number
                         * @example
                         * &lt;div class = &quot;norender&quot;&gt;&lt;code&gt;
                         * function setup() {
                         *   var x = -3;
                         *   var y = abs(x);
                         *
                         *   print(x); // -3
                         *   print(y); // 3
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.abs = Math.abs;
                        
                        /**
                         * Calculates the closest int value that is greater than or equal to the
                         * value of the parameter. Maps to Math.ceil(). For example, ceil(9.03)
                         * returns the value 10.
                         *
                         * @method ceil
                         * @param  {Number} n number to round up
                         * @return {Number}   rounded up number
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * function draw() {
                         *   background(200);
                         *   // map, mouseX between 0 and 5.
                         *   var ax = map(mouseX, 0, 100, 0, 5);
                         *   var ay = 66;
                         *
                         *   //Get the ceiling of the mapped number.
                         *   var bx = ceil(map(mouseX, 0, 100, 0,5));
                         *   var by = 33;
                         *
                         *   // Multiply the mapped numbers by 20 to more easily
                         *   // see the changes.
                         *   stroke(0);
                         *   fill(0);
                         *   line(0, ay, ax * 20, ay);
                         *   line(0, by, bx * 20, by);
                         *
                         *   // Reformat the float returned by map and draw it.
                         *   noStroke();
                         *   text(nfc(ax, 2,2), ax, ay - 5);
                         *   text(nfc(bx,1,1), bx, by - 5);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.ceil = Math.ceil;
                        
                        /**
                         * Constrains a value between a minimum and maximum value.
                         *
                         * @method constrain
                         * @param  {Number} n    number to constrain
                         * @param  {Number} low  minimum limit
                         * @param  {Number} high maximum limit
                         * @return {Number}      constrained number
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * function draw() {
                         *   background(200);
                         *
                         *   var leftWall = 25;
                         *   var rightWall = 75;
                         *
                         *   // xm is just the mouseX, while
                         *   // xc is the mouseX, but constrained
                         *   // between the leftWall and rightWall!
                         *   var xm = mouseX;
                         *   var xc = constrain(mouseX, leftWall, rightWall);
                         *
                         *   // Draw the walls.
                         *   stroke(150);
                         *   line(leftWall, 0, leftWall, height);
                         *   line(rightWall, 0, rightWall, height);
                         *
                         *   // Draw xm and xc as circles.
                         *   noStroke();
                         *   fill(150);
                         *   ellipse(xm, 33, 9,9); // Not Constrained
                         *   fill(0);
                         *   ellipse(xc, 66, 9,9); // Constrained
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.constrain = function(n, low, high) {
                          return Math.max(Math.min(n, high), low);
                        };
                        
                        /**
                         * Calculates the distance between two points.
                         *
                         * @method dist
                         * @param  {Number} x1 x-coordinate of the first point
                         * @param  {Number} y1 y-coordinate of the first point
                         * @param  {Number} [z1] z-coordinate of the first point
                         * @param  {Number} x2 x-coordinate of the second point
                         * @param  {Number} y2 y-coordinate of the second point
                         * @param  {Number} [z2] z-coordinate of the second point
                         * @return {Number}    distance between the two points
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * // Move your mouse inside the canvas to see the
                         * // change in distance between two points!
                         * function draw() {
                         *   background(200);
                         *   fill(0);
                         *
                         *   var x1 = 10;
                         *   var y1 = 90;
                         *   var x2 = mouseX;
                         *   var y2 = mouseY;
                         *
                         *   line(x1, y1, x2, y2);
                         *   ellipse(x1, y1, 7, 7);
                         *   ellipse(x2, y2, 7, 7);
                         *
                         *   // d is the length of the line
                         *   // the distance from point 1 to point 2.
                         *   var d = int(dist(x1, y1, x2, y2));
                         *
                         *   // Let&#x27;s write d along the line we are drawing!
                         *   push();
                         *   translate( (x1+x2)/2, (y1+y2)/2 );
                         *   rotate( atan2(y2-y1,x2-x1) );
                         *   text(nfc(d,1,1), 0, -5);
                         *   pop();
                         *   // Fancy!
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.dist = function(x1, y1, z1, x2, y2, z2) {
                          if (arguments.length === 4) {
                            // In the case of 2d: z1 means x2 and x2 means y2
                            return Math.sqrt( (z1-x1)*(z1-x1) + (x2-y1)*(x2-y1) );
                          } else if (arguments.length === 6) {
                            return Math.sqrt( (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) + (z2-z1)*(z2-z1) );
                          }
                        };
                        
                        /**
                         * Returns Euler&#x27;s number e (2.71828...) raised to the power of the n
                         * parameter. Maps to Math.exp().
                         *
                         * @method exp
                         * @param  {Number} n exponent to raise
                         * @return {Number}   e^n
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * function draw() {
                         *   background(200);
                         *
                         *   // Compute the exp() function with a value between 0 and 2
                         *   var xValue = map(mouseX, 0, width, 0, 2);
                         *   var yValue = exp(xValue);
                         *
                         *   var y = map(yValue, 0, 8, height, 0);
                         *
                         *   var legend = &quot;exp (&quot; + nfc(xValue, 3) +&quot;)\n= &quot; + nf(yValue, 1, 4);
                         *   stroke(150);
                         *   line(mouseX, y, mouseX, height);
                         *   fill(0);
                         *   text(legend, 5, 15);
                         *   noStroke();
                         *   ellipse (mouseX,y, 7, 7);
                         *
                         *   // Draw the exp(x) curve,
                         *   // over the domain of x from 0 to 2
                         *   noFill();
                         *   stroke(0);
                         *   beginShape();
                         *   for (var x = 0; x &lt; width; x++) {
                         *     xValue = map(x, 0, width, 0, 2);
                         *     yValue = exp(xValue);
                         *     y = map(yValue, 0, 8, height, 0);
                         *     vertex(x, y);
                         *   }
                         *
                         *   endShape();
                         *   line(0, 0, 0, height);
                         *   line(0, height-1, width, height-1);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.exp = Math.exp;
                        
                        /**
                         * Calculates the closest int value that is less than or equal to the
                         * value of the parameter. Maps to Math.floor().
                         *
                         * @method floor
                         * @param  {Number} n number to round down
                         * @return {Number}   rounded down number
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * function draw() {
                         *   background(200);
                         *   //map, mouseX between 0 and 5.
                         *   var ax = map(mouseX, 0, 100, 0, 5);
                         *   var ay = 66;
                         *
                         *   //Get the floor of the mapped number.
                         *   var bx = floor(map(mouseX, 0, 100, 0,5));
                         *   var by = 33;
                         *
                         *   // Multiply the mapped numbers by 20 to more easily
                         *   // see the changes.
                         *   stroke(0);
                         *   fill(0);
                         *   line(0, ay, ax * 20, ay);
                         *   line(0, by, bx * 20, by);
                         *
                         *   // Reformat the float returned by map and draw it.
                         *   noStroke();
                         *   text(nfc(ax, 2,2), ax, ay - 5);
                         *   text(nfc(bx,1,1), bx, by - 5);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.floor = Math.floor;
                        
                        /**
                         * Calculates a number between two numbers at a specific increment. The amt
                         * parameter is the amount to interpolate between the two values where 0.0
                         * equal to the first point, 0.1 is very near the first point, 0.5 is
                         * half-way in between, etc. The lerp function is convenient for creating
                         * motion along a straight path and for drawing dotted lines.
                         *
                         * @method lerp
                         * @param  {Number} start first value
                         * @param  {Number} stop  second value
                         * @param  {Number} amt   number between 0.0 and 1.0
                         * @return {Number}       lerped value
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * function setup() {
                         *   background(200);
                         *   var a = 20;
                         *   var b = 80;
                         *   var c = lerp(a,b, .2);
                         *   var d = lerp(a,b, .5);
                         *   var e = lerp(a,b, .8);
                         *
                         *   var y = 50
                         *
                         *   strokeWeight(5);
                         *   stroke(0); // Draw the original points in black
                         *   point(a, y);
                         *   point(b, y);
                         *
                         *   stroke(100); // Draw the lerp points in gray
                         *   point(c, y);
                         *   point(d, y);
                         *   point(e, y);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.lerp = function(start, stop, amt) {
                          return amt*(stop-start)+start;
                        };
                        
                        /**
                         * Calculates the natural logarithm (the base-e logarithm) of a number. This
                         * function expects the n parameter to be a value greater than 0.0. Maps to
                         * Math.log().
                         *
                         * @method log
                         * @param  {Number} n number greater than 0
                         * @return {Number}   natural logarithm of n
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * function draw() {
                         *   background(200);
                         *   var maxX = 2.8;
                         *   var maxY = 1.5;
                         *
                         *   // Compute the natural log of a value between 0 and maxX
                         *   var xValue = map(mouseX, 0, width, 0, maxX);
                         *   if (xValue &gt; 0) { // Cannot take the log of a negative number.
                         *     var yValue = log(xValue);
                         *     var y = map(yValue, -maxY, maxY, height, 0);
                         *
                         *     // Display the calculation occurring.
                         *     var legend = &quot;log(&quot; + nf(xValue, 1, 2) + &quot;)\n= &quot; + nf(yValue, 1, 3);
                         *     stroke(150);
                         *     line(mouseX, y, mouseX, height);
                         *     fill(0);
                         *     text (legend, 5, 15);
                         *     noStroke();
                         *     ellipse (mouseX, y, 7, 7);
                         *   }
                         *
                         *   // Draw the log(x) curve,
                         *   // over the domain of x from 0 to maxX
                         *   noFill();
                         *   stroke(0);
                         *   beginShape();
                         *   for(var x=0; x &lt; width; x++) {
                         *     xValue = map(x, 0, width, 0, maxX);
                         *     yValue = log(xValue);
                         *     y = map(yValue, -maxY, maxY, height, 0);
                         *     vertex(x, y);
                         *   }
                         *   endShape();
                         *   line(0,0,0,height);
                         *   line(0,height/2,width, height/2);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.log = Math.log;
                        
                        /**
                         * Calculates the magnitude (or length) of a vector. A vector is a direction
                         * in space commonly used in computer graphics and linear algebra. Because it
                         * has no &quot;start&quot; position, the magnitude of a vector can be thought of as
                         * the distance from the coordinate 0,0 to its x,y value. Therefore, mag() is
                         * a shortcut for writing dist(0, 0, x, y).
                         *
                         * @method mag
                         * @param  {Number} a first value
                         * @param  {Number} b second value
                         * @return {Number}   magnitude of vector from (0,0) to (a,b)
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * function setup() {
                         *   var x1 = 20;
                         *   var x2 = 80;
                         *   var y1 = 30;
                         *   var y2 = 70;
                         *
                         *   line(0, 0, x1, y1);
                         *   print(mag(x1, y1));  // Prints &quot;36.05551&quot;
                         *   line(0, 0, x2, y1);
                         *   print(mag(x2, y1));  // Prints &quot;85.44004&quot;
                         *   line(0, 0, x1, y2);
                         *   print(mag(x1, y2));  // Prints &quot;72.8011&quot;
                         *   line(0, 0, x2, y2);
                         *   print(mag(x2, y2));  // Prints &quot;106.30146&quot;
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.mag = function(x, y) {
                          return Math.sqrt(x*x+y*y);
                        };
                        
                        /**
                         * Re-maps a number from one range to another.
                         * &lt;br&gt;&lt;br&gt;
                         * In the first example above, the number 25 is converted from a value in the
                         * range of 0 to 100 into a value that ranges from the left edge of the
                         * window (0) to the right edge (width).
                         *
                         * @method map
                         * @param  {Number} value  the incoming value to be converted
                         * @param  {Number} start1 lower bound of the value&#x27;s current range
                         * @param  {Number} stop1  upper bound of the value&#x27;s current range
                         * @param  {Number} start2 lower bound of the value&#x27;s target range
                         * @param  {Number} stop   upper bound of the value&#x27;s target range
                         * @return {Number}        remapped number
                         * @example
                         *   &lt;div&gt;&lt;code&gt;
                         *     var value = 25;
                         *     var m = map(value, 0, 100, 0, width);
                         *     ellipse(m, 50, 10, 10);
                         *   &lt;/code&gt;&lt;/div&gt;
                         *
                         *   &lt;div&gt;&lt;code&gt;
                         *     function setup() {
                         *       noStroke();
                         *     }
                         *
                         *     function draw() {
                         *       background(204);
                         *       var x1 = map(mouseX, 0, width, 25, 75);
                         *       ellipse(x1, 25, 25, 25);
                         *       var x2 = map(mouseX, 0, width, 0, 100);
                         *       ellipse(x2, 75, 25, 25);
                         *     }
                         *   &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.map = function(n, start1, stop1, start2, stop2) {
                          return ((n-start1)/(stop1-start1))*(stop2-start2)+start2;
                        };
                        
                        /**
                         * Determines the largest value in a sequence of numbers, and then returns
                         * that value. max() accepts any number of Number parameters, or an Array
                         * of any length.
                         *
                         * @method max
                         * @param  {Number|Array} n0 Numbers to compare
                         * @return {Number}          maximum Number
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * function setup() {
                         *   // Change the elements in the array and run the sketch
                         *   // to show how max() works!
                         *   numArray = new Array(2,1,5,4,8,9);
                         *   fill(0);
                         *   noStroke();
                         *   text(&quot;Array Elements&quot;, 0, 10);
                         *   // Draw all numbers in the array
                         *   var spacing = 15;
                         *   var elemsY = 25;
                         *   for(var i = 0; i &lt; numArray.length; i++) {
                         *     text(numArray[i], i * spacing, elemsY);
                         *   }
                         *   maxX = 33;
                         *   maxY = 80;
                         *   // Draw the Maximum value in the array.
                         *   textSize(32);
                         *   text(max(numArray), maxX, maxY);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.max = function() {
                          if (arguments[0] instanceof Array) {
                            return Math.max.apply(null,arguments[0]);
                          } else {
                            return Math.max.apply(null,arguments);
                          }
                        };
                        
                        /**
                         * Determines the smallest value in a sequence of numbers, and then returns
                         * that value. min() accepts any number of Number parameters, or an Array
                         * of any length.
                         *
                         * @method min
                         * @param  {Number|Array} n0 Numbers to compare
                         * @return {Number}          minimum Number
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * function setup() {
                         *   // Change the elements in the array and run the sketch
                         *   // to show how min() works!
                         *   numArray = new Array(2,1,5,4,8,9);
                         *   fill(0);
                         *   noStroke();
                         *   text(&quot;Array Elements&quot;, 0, 10);
                         *   // Draw all numbers in the array
                         *   var spacing = 15;
                         *   var elemsY = 25;
                         *   for(var i = 0; i &lt; numArray.length; i++) {
                         *     text(numArray[i], i * spacing, elemsY);
                         *   }
                         *   maxX = 33;
                         *   maxY = 80;
                         *   // Draw the Minimum value in the array.
                         *   textSize(32);
                         *   text(min(numArray), maxX, maxY);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.min = function() {
                          if (arguments[0] instanceof Array) {
                            return Math.min.apply(null,arguments[0]);
                          } else {
                            return Math.min.apply(null,arguments);
                          }
                        };
                        
                        /**
                         * Normalizes a number from another range into a value between 0 and 1.
                         * Identical to map(value, low, high, 0, 1).
                         * Numbers outside of the range are not clamped to 0 and 1, because
                         * out-of-range values are often intentional and useful. (See the second
                         * example above.)
                         *
                         * @method norm
                         * @param  {Number} value incoming value to be normalized
                         * @param  {Number} start lower bound of the value&#x27;s current range
                         * @param  {Number} stop  upper bound of the value&#x27;s current range
                         * @return {Number}       normalized number
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * function draw() {
                         *   background(200);
                         *   currentNum = mouseX;
                         *   lowerBound = 0;
                         *   upperBound = width; //100;
                         *   normalized = norm(currentNum, lowerBound, upperBound);
                         *   lineY = 70
                         *   line(0, lineY, width, lineY);
                         *   //Draw an ellipse mapped to the non-normalized value.
                         *   noStroke();
                         *   fill(50)
                         *   var s = 7; // ellipse size
                         *   ellipse(currentNum, lineY, s, s);
                         *
                         *   // Draw the guide
                         *   guideY = lineY + 15;
                         *   text(&quot;0&quot;, 0, guideY);
                         *   textAlign(RIGHT);
                         *   text(&quot;100&quot;, width, guideY);
                         *
                         *   // Draw the normalized value
                         *   textAlign(LEFT);
                         *   fill(0);
                         *   textSize(32);
                         *   normalY = 40;
                         *   normalX = 20;
                         *   text(normalized, normalX, normalY);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.norm = function(n, start, stop) {
                          return this.map(n, start, stop, 0, 1);
                        };
                        
                        /**
                         * Facilitates exponential expressions. The pow() function is an efficient
                         * way of multiplying numbers by themselves (or their reciprocals) in large
                         * quantities. For example, pow(3, 5) is equivalent to the expression
                         * 3*3*3*3*3 and pow(3, -5) is equivalent to 1 / 3*3*3*3*3. Maps to
                         * Math.pow().
                         *
                         * @method pow
                         * @param  {Number} n base of the exponential expression
                         * @param  {Number} e power by which to raise the base
                         * @return {Number}   n^e
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * function setup() {
                         *   //Exponentially increase the size of an ellipse.
                         *   eSize = 3; // Original Size
                         *   eLoc = 10; // Original Location
                         *
                         *   ellipse(eLoc, eLoc, eSize, eSize);
                         *
                         *   ellipse(eLoc*2, eLoc*2, pow(eSize, 2), pow(eSize, 2));
                         *
                         *   ellipse(eLoc*4, eLoc*4, pow(eSize, 3), pow(eSize, 3));
                         *
                         *   ellipse(eLoc*8, eLoc*8, pow(eSize, 4), pow(eSize, 4));
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.pow = Math.pow;
                        
                        /**
                         * Calculates the integer closest to the n parameter. For example,
                         * round(133.8) returns the value 134. Maps to Math.round().
                         *
                         * @method round
                         * @param  {Number} n number to round
                         * @return {Number}   rounded number
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * function draw() {
                         *   background(200);
                         *   //map, mouseX between 0 and 5.
                         *   var ax = map(mouseX, 0, 100, 0, 5);
                         *   var ay = 66;
                         *
                         *   // Round the mapped number.
                         *   var bx = round(map(mouseX, 0, 100, 0,5));
                         *   var by = 33;
                         *
                         *   // Multiply the mapped numbers by 20 to more easily
                         *   // see the changes.
                         *   stroke(0);
                         *   fill(0);
                         *   line(0, ay, ax * 20, ay);
                         *   line(0, by, bx * 20, by);
                         *
                         *   // Reformat the float returned by map and draw it.
                         *   noStroke();
                         *   text(nfc(ax, 2,2), ax, ay - 5);
                         *   text(nfc(bx,1,1), bx, by - 5);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.round = Math.round;
                        
                        /**
                         * Squares a number (multiplies a number by itself). The result is always a
                         * positive number, as multiplying two negative numbers always yields a
                         * positive result. For example, -1 * -1 = 1.
                         *
                         * @method sq
                         * @param  {Number} n number to square
                         * @return {Number}   squared number
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * function draw() {
                         *   background(200);
                         *   eSize = 7;
                         *   x1 = map(mouseX, 0, width, 0, 10);
                         *   y1 = 80;
                         *   x2 = sq(x1);
                         *   y2 = 20;
                         *
                         *   // Draw the non-squared.
                         *   line(0, y1, width, y1);
                         *   ellipse(x1, y1, eSize, eSize);
                         *
                         *   // Draw the squared.
                         *   line(0, y2, width, y2);
                         *   ellipse(x2, y2, eSize, eSize);
                         *
                         *   // Draw dividing line.
                         *   stroke(100)
                         *   line(0, height/2, width, height/2);
                         *
                         *   // Draw text.
                         *   var spacing = 15;
                         *   noStroke();
                         *   fill(0);
                         *   text(&quot;x = &quot; + x1, 0, y1 + spacing);
                         *   text(&quot;sq(x) = &quot; + x2, 0, y2 + spacing);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.sq = function(n) { return n*n; };
                        
                        /**
                         * Calculates the square root of a number. The square root of a number is
                         * always positive, even though there may be a valid negative root. The
                         * square root s of number a is such that s*s = a. It is the opposite of
                         * squaring. Maps to Math.sqrt().
                         *
                         * @method sqrt
                         * @param  {Number} n non-negative number to square root
                         * @return {Number}   square root of number
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * function draw() {
                         *   background(200);
                         *   eSize = 7;
                         *   x1 = mouseX;
                         *   y1 = 80;
                         *   x2 = sqrt(x1);
                         *   y2 = 20;
                         *
                         *   // Draw the non-squared.
                         *   line(0, y1, width, y1);
                         *   ellipse(x1, y1, eSize, eSize);
                         *
                         *   // Draw the squared.
                         *   line(0, y2, width, y2);
                         *   ellipse(x2, y2, eSize, eSize);
                         *
                         *   // Draw dividing line.
                         *   stroke(100)
                         *   line(0, height/2, width, height/2);
                         *
                         *   // Draw text.
                         *   noStroke();
                         *   fill(0);
                         *   var spacing = 15;
                         *   text(&quot;x = &quot; + x1, 0, y1 + spacing);
                         *   text(&quot;sqrt(x) = &quot; + x2, 0, y2 + spacing);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.sqrt = Math.sqrt;
                        
                        module.exports = p5;
                        
                        },{&quot;../core/core&quot;:48}],74:[function(_dereq_,module,exports){
                        /**
                         * @module Math
                         * @submodule Math
                         * @for p5
                         * @requires core
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        
                        
                        /**
                         * Creates a new p5.Vector (the datatype for storing vectors). This provides a
                         * two or three dimensional vector, specifically a Euclidean (also known as
                         * geometric) vector. A vector is an entity that has both magnitude and
                         * direction.
                         *
                         * @method createVector
                         * @param {Number} [x] x component of the vector
                         * @param {Number} [y] y component of the vector
                         * @param {Number} [z] z component of the vector
                         */
                        p5.prototype.createVector = function (x, y, z) {
                          if (this instanceof p5) {
                            return new p5.Vector(this, arguments);
                          } else {
                            return new p5.Vector(x, y, z);
                          }
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;../core/core&quot;:48}],75:[function(_dereq_,module,exports){
                        //////////////////////////////////////////////////////////////
                        
                        // http://mrl.nyu.edu/~perlin/noise/
                        // Adapting from PApplet.java
                        // which was adapted from toxi
                        // which was adapted from the german demo group farbrausch
                        // as used in their demo &quot;art&quot;: http://www.farb-rausch.de/fr010src.zip
                        
                        // someday we might consider using &quot;improved noise&quot;
                        // http://mrl.nyu.edu/~perlin/paper445.pdf
                        // See: https://github.com/shiffman/The-Nature-of-Code-Examples-p5.js/
                        //      blob/master/introduction/Noise1D/noise.js
                        
                        /**
                         * @module Math
                         * @submodule Noise
                         * @for p5
                         * @requires core
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        
                        var PERLIN_YWRAPB = 4;
                        var PERLIN_YWRAP = 1&lt;&lt;PERLIN_YWRAPB;
                        var PERLIN_ZWRAPB = 8;
                        var PERLIN_ZWRAP = 1&lt;&lt;PERLIN_ZWRAPB;
                        var PERLIN_SIZE = 4095;
                        
                        var perlin_octaves = 4; // default to medium smooth
                        var perlin_amp_falloff = 0.5; // 50% reduction/octave
                        
                        var scaled_cosine = function(i) {
                          return 0.5*(1.0-Math.cos(i*Math.PI));
                        };
                        
                        var perlin; // will be initialized lazily by noise() or noiseSeed()
                        
                        
                        /**
                         * Returns the Perlin noise value at specified coordinates. Perlin noise is
                         * a random sequence generator producing a more natural ordered, harmonic
                         * succession of numbers compared to the standard &lt;b&gt;random()&lt;/b&gt; function.
                         * It was invented by Ken Perlin in the 1980s and been used since in
                         * graphical applications to produce procedural textures, natural motion,
                         * shapes, terrains etc.&lt;br /&gt;&lt;br /&gt; The main difference to the
                         * &lt;b&gt;random()&lt;/b&gt; function is that Perlin noise is defined in an infinite
                         * n-dimensional space where each pair of coordinates corresponds to a
                         * fixed semi-random value (fixed only for the lifespan of the program; see
                         * the noiseSeed() function). p5.js can compute 1D, 2D and 3D noise,
                         * depending on the number of coordinates given. The resulting value will
                         * always be between 0.0 and 1.0. The noise value can be animated by moving
                         * through the noise space as demonstrated in the example above. The 2nd
                         * and 3rd dimension can also be interpreted as time.&lt;br /&gt;&lt;br /&gt;The actual
                         * noise is structured similar to an audio signal, in respect to the
                         * function&#x27;s use of frequencies. Similar to the concept of harmonics in
                         * physics, perlin noise is computed over several octaves which are added
                         * together for the final result. &lt;br /&gt;&lt;br /&gt;Another way to adjust the
                         * character of the resulting sequence is the scale of the input
                         * coordinates. As the function works within an infinite space the value of
                         * the coordinates doesn&#x27;t matter as such, only the distance between
                         * successive coordinates does (eg. when using &lt;b&gt;noise()&lt;/b&gt; within a
                         * loop). As a general rule the smaller the difference between coordinates,
                         * the smoother the resulting noise sequence will be. Steps of 0.005-0.03
                         * work best for most applications, but this will differ depending on use.
                         *
                         *
                         * @method noise
                         * @param  {Number} x   x-coordinate in noise space
                         * @param  {Number} y   y-coordinate in noise space
                         * @param  {Number} z   z-coordinate in noise space
                         * @return {Number}     Perlin noise value (between 0 and 1) at specified
                         *                      coordinates
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;var xoff = 0.0;
                         *
                         * function draw() {
                         *   background(204);
                         *   xoff = xoff + .01;
                         *   var n = noise(xoff) * width;
                         *   line(n, 0, n, height);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         * &lt;div&gt;
                         * &lt;code&gt;var noiseScale=0.02;
                         *
                         * function draw() {
                         *   background(0);
                         *   for (var x=0; x &lt; width; x++) {
                         *     var noiseVal = noise((mouseX+x)*noiseScale, mouseY*noiseScale);
                         *     stroke(noiseVal*255);
                         *     line(x, mouseY+noiseVal*80, x, height);
                         *   }
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.noise = function(x,y,z) {
                          y = y || 0;
                          z = z || 0;
                        
                          if (perlin == null) {
                            perlin = new Array(PERLIN_SIZE + 1);
                            for (var i = 0; i &lt; PERLIN_SIZE + 1; i++) {
                              perlin[i] = Math.random();
                            }
                          }
                        
                          if (x&lt;0) { x=-x; }
                          if (y&lt;0) { y=-y; }
                          if (z&lt;0) { z=-z; }
                        
                          var xi=Math.floor(x), yi=Math.floor(y), zi=Math.floor(z);
                          var xf = x - xi;
                          var yf = y - yi;
                          var zf = z - zi;
                          var rxf, ryf;
                        
                          var r=0;
                          var ampl=0.5;
                        
                          var n1,n2,n3;
                        
                          for (var o=0; o&lt;perlin_octaves; o++) {
                            var of=xi+(yi&lt;&lt;PERLIN_YWRAPB)+(zi&lt;&lt;PERLIN_ZWRAPB);
                        
                            rxf = scaled_cosine(xf);
                            ryf = scaled_cosine(yf);
                        
                            n1  = perlin[of&amp;PERLIN_SIZE];
                            n1 += rxf*(perlin[(of+1)&amp;PERLIN_SIZE]-n1);
                            n2  = perlin[(of+PERLIN_YWRAP)&amp;PERLIN_SIZE];
                            n2 += rxf*(perlin[(of+PERLIN_YWRAP+1)&amp;PERLIN_SIZE]-n2);
                            n1 += ryf*(n2-n1);
                        
                            of += PERLIN_ZWRAP;
                            n2  = perlin[of&amp;PERLIN_SIZE];
                            n2 += rxf*(perlin[(of+1)&amp;PERLIN_SIZE]-n2);
                            n3  = perlin[(of+PERLIN_YWRAP)&amp;PERLIN_SIZE];
                            n3 += rxf*(perlin[(of+PERLIN_YWRAP+1)&amp;PERLIN_SIZE]-n3);
                            n2 += ryf*(n3-n2);
                        
                            n1 += scaled_cosine(zf)*(n2-n1);
                        
                            r += n1*ampl;
                            ampl *= perlin_amp_falloff;
                            xi&lt;&lt;=1;
                            xf*=2;
                            yi&lt;&lt;=1;
                            yf*=2;
                            zi&lt;&lt;=1;
                            zf*=2;
                        
                            if (xf&gt;=1.0) { xi++; xf--; }
                            if (yf&gt;=1.0) { yi++; yf--; }
                            if (zf&gt;=1.0) { zi++; zf--; }
                          }
                          return r;
                        };
                        
                        
                        /**
                         *
                         * Adjusts the character and level of detail produced by the Perlin noise
                         * function. Similar to harmonics in physics, noise is computed over
                         * several octaves. Lower octaves contribute more to the output signal and
                         * as such define the overall intensity of the noise, whereas higher octaves
                         * create finer grained details in the noise sequence.
                         * &lt;br&gt;&lt;br&gt;
                         * By default, noise is computed over 4 octaves with each octave contributing
                         * exactly half than its predecessor, starting at 50% strength for the 1st
                         * octave. This falloff amount can be changed by adding an additional function
                         * parameter. Eg. a falloff factor of 0.75 means each octave will now have
                         * 75% impact (25% less) of the previous lower octave. Any value between
                         * 0.0 and 1.0 is valid, however note that values greater than 0.5 might
                         * result in greater than 1.0 values returned by &lt;b&gt;noise()&lt;/b&gt;.
                         * &lt;br&gt;&lt;br&gt;
                         * By changing these parameters, the signal created by the &lt;b&gt;noise()&lt;/b&gt;
                         * function can be adapted to fit very specific needs and characteristics.
                         *
                         * @method noiseDetail
                         * @param {Number} lod number of octaves to be used by the noise
                         * @param {Number} falloff falloff factor for each octave
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         *
                         * var noiseVal;
                         * var noiseScale=0.02;
                         *
                         * function setup() {
                         *   createCanvas(100,100);
                         * }
                         *
                         * function draw() {
                         *   background(0);
                         *   for (var y = 0; y &lt; height; y++) {
                         *     for (var x = 0; x &lt; width/2; x++) {
                         *       noiseDetail(2,0.2);
                         *       noiseVal = noise((mouseX+x) * noiseScale,
                         *                        (mouseY+y) * noiseScale);
                         *       stroke(noiseVal*255);
                         *       point(x,y);
                         *       noiseDetail(8,0.65);
                         *       noiseVal = noise((mouseX + x + width/2) * noiseScale,
                         *                        (mouseY + y) * noiseScale);
                         *       stroke(noiseVal*255);
                         *       point(x + width/2, y);
                         *     }
                         *   }
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.noiseDetail = function(lod, falloff) {
                          if (lod&gt;0)     { perlin_octaves=lod; }
                          if (falloff&gt;0) { perlin_amp_falloff=falloff; }
                        };
                        
                        /**
                         * Sets the seed value for &lt;b&gt;noise()&lt;/b&gt;. By default, &lt;b&gt;noise()&lt;/b&gt;
                         * produces different results each time the program is run. Set the
                         * &lt;b&gt;value&lt;/b&gt; parameter to a constant to return the same pseudo-random
                         * numbers each time the software is run.
                         *
                         * @method noiseSeed
                         * @param {Number} seed   the seed value
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;var xoff = 0.0;
                         *
                         * function setup() {
                         *   noiseSeed(99);
                         *   stroke(0, 10);
                         * }
                         *
                         * function draw() {
                         *   xoff = xoff + .01;
                         *   var n = noise(xoff) * width;
                         *   line(n, 0, n, height);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.noiseSeed = function(seed) {
                          // Linear Congruential Generator
                          // Variant of a Lehman Generator
                          var lcg = (function() {
                            // Set to values from http://en.wikipedia.org/wiki/Numerical_Recipes
                            // m is basically chosen to be large (as it is the max period)
                            // and for its relationships to a and c
                            var m = 4294967296,
                            // a - 1 should be divisible by m&#x27;s prime factors
                            a = 1664525,
                             // c and m should be co-prime
                            c = 1013904223,
                            seed, z;
                            return {
                              setSeed : function(val) {
                                // pick a random seed if val is undefined or null
                                // the &gt;&gt;&gt; 0 casts the seed to an unsigned 32-bit integer
                                z = seed = (val == null ? Math.random() * m : val) &gt;&gt;&gt; 0;
                              },
                              getSeed : function() {
                                return seed;
                              },
                              rand : function() {
                                // define the recurrence relationship
                                z = (a * z + c) % m;
                                // return a float in [0, 1)
                                // if z = m then z / m = 0 therefore (z % m) / m &lt; 1 always
                                return z / m;
                              }
                            };
                          }());
                        
                          lcg.setSeed(seed);
                          perlin = new Array(PERLIN_SIZE + 1);
                          for (var i = 0; i &lt; PERLIN_SIZE + 1; i++) {
                            perlin[i] = lcg.rand();
                          }
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;../core/core&quot;:48}],76:[function(_dereq_,module,exports){
                        /**
                         * @module Math
                         * @submodule Math
                         * @requires constants
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        var polarGeometry = _dereq_(&#x27;./polargeometry&#x27;);
                        var constants = _dereq_(&#x27;../core/constants&#x27;);
                        
                        /**
                         * A class to describe a two or three dimensional vector, specifically
                         * a Euclidean (also known as geometric) vector. A vector is an entity
                         * that has both magnitude and direction. The datatype, however, stores
                         * the components of the vector (x, y for 2D, and x, y, z for 3D). The magnitude
                         * and direction can be accessed via the methods mag() and heading().
                         * &lt;br&gt;&lt;br&gt;
                         * In many of the p5.js examples, you will see p5.Vector used to describe a
                         * position, velocity, or acceleration. For example, if you consider a rectangle
                         * moving across the screen, at any given instant it has a position (a vector
                         * that points from the origin to its location), a velocity (the rate at which
                         * the object&#x27;s position changes per time unit, expressed as a vector), and
                         * acceleration (the rate at which the object&#x27;s velocity changes per time
                         * unit, expressed as a vector).
                         * &lt;br&gt;&lt;br&gt;
                         * Since vectors represent groupings of values, we cannot simply use
                         * traditional addition/multiplication/etc. Instead, we&#x27;ll need to do some
                         * &quot;vector&quot; math, which is made easy by the methods inside the p5.Vector class.
                         *
                         * @class p5.Vector
                         * @constructor
                         * @param {Number} [x] x component of the vector
                         * @param {Number} [y] y component of the vector
                         * @param {Number} [z] z component of the vector
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var v1 = createVector(40, 50);
                         * var v2 = createVector(40, 50);
                         *
                         * ellipse(v1.x, v1.y, 50, 50);
                         * ellipse(v2.x, v2.y, 50, 50);
                         * v1.add(v2);
                         * ellipse(v1.x, v1.y, 50, 50);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.Vector = function() {
                          var x,y,z;
                          // This is how it comes in with createVector()
                          if(arguments[0] instanceof p5) {
                            // save reference to p5 if passed in
                            this.p5 = arguments[0];
                            x  = arguments[1][0] || 0;
                            y  = arguments[1][1] || 0;
                            z  = arguments[1][2] || 0;
                          // This is what we&#x27;ll get with new p5.Vector()
                          } else {
                            x = arguments[0] || 0;
                            y = arguments[1] || 0;
                            z = arguments[2] || 0;
                          }
                          /**
                           * The x component of the vector
                           * @property x
                           * @type {Number}
                           */
                          this.x = x;
                          /**
                           * The y component of the vector
                           * @property y
                           * @type {Number}
                           */
                          this.y = y;
                          /**
                           * The z component of the vector
                           * @property z
                           * @type {Number}
                           */
                          this.z = z;
                        };
                        
                        /**
                         * Returns a string representation of a vector v by calling String(v)
                         * or v.toString(). This method is useful for logging vectors in the
                         * console.
                         * @method  toString
                         * @example
                         * &lt;div class = &quot;norender&quot;&gt;&lt;code&gt;
                         * function setup() {
                         *   var v = createVector(20,30);
                         *   print(String(v)); // prints &quot;p5.Vector Object : [20, 30, 0]&quot;
                         * }
                         * &lt;/div&gt;&lt;/code&gt;
                         *
                         */
                        p5.Vector.prototype.toString = function p5VectorToString() {
                          return &#x27;p5.Vector Object : [&#x27;+ this.x +&#x27;, &#x27;+ this.y +&#x27;, &#x27;+ this.z + &#x27;]&#x27;;
                        };
                        
                        /**
                         * Sets the x, y, and z component of the vector using two or three separate
                         * variables, the data from a p5.Vector, or the values from a float array.
                         * @method set
                         *
                         * @param {Number|p5.Vector|Array} [x] the x component of the vector or a
                         *                                     p5.Vector or an Array
                         * @param {Number}                 [y] the y component of the vector
                         * @param {Number}                 [z] the z component of the vector
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * function setup() {
                         *    var v = createVector(1, 2, 3);
                         *    v.set(4,5,6); // Sets vector to [4, 5, 6]
                         *
                         *    var v1 = createVector(0, 0, 0);
                         *    var arr = [1, 2, 3];
                         *    v1.set(arr); // Sets vector to [1, 2, 3]
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.Vector.prototype.set = function (x, y, z) {
                          if (x instanceof p5.Vector) {
                            this.x = x.x || 0;
                            this.y = x.y || 0;
                            this.z = x.z || 0;
                            return this;
                          }
                          if (x instanceof Array) {
                            this.x = x[0] || 0;
                            this.y = x[1] || 0;
                            this.z = x[2] || 0;
                            return this;
                          }
                          this.x = x || 0;
                          this.y = y || 0;
                          this.z = z || 0;
                          return this;
                        };
                        
                        /**
                         * Gets a copy of the vector, returns a p5.Vector object.
                         *
                         * @method copy
                         * @return {p5.Vector} the copy of the p5.Vector object
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * var v1 = createVector(1, 2, 3);
                         * var v2 = v.copy();
                         * print(v1.x == v2.x &amp;&amp; v1.y == v2.y &amp;&amp; v1.z == v2.z);
                         * // Prints &quot;true&quot;
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.Vector.prototype.copy = function () {
                          if (this.p5) {
                            return new p5.Vector(this.p5,[this.x, this.y, this.z]);
                          } else {
                            return new p5.Vector(this.x,this.y,this.z);
                          }
                        };
                        
                        /**
                         * Adds x, y, and z components to a vector, adds one vector to another, or
                         * adds two independent vectors together. The version of the method that adds
                         * two vectors together is a static method and returns a p5.Vector, the others
                         * acts directly on the vector. See the examples for more context.
                         *
                         * @method add
                         * @chainable
                         * @param  {Number|p5.Vector|Array} x   the x component of the vector to be
                         *                                      added or a p5.Vector or an Array
                         * @param  {Number}                 [y] the y component of the vector to be
                         *                                      added
                         * @param  {Number}                 [z] the z component of the vector to be
                         *                                      added
                         * @return {p5.Vector}                  the p5.Vector object.
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * var v = createVector(1, 2, 3);
                         * v.add(4,5,6);
                         * // v&#x27;s compnents are set to [5, 7, 9]
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * // Static method
                         * var v1 = createVector(1, 2, 3);
                         * var v2 = createVector(2, 3, 4);
                         *
                         * var v3 = p5.Vector.add(v1, v2);
                         * // v3 has components [3, 5, 7]
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.Vector.prototype.add = function (x, y, z) {
                          if (x instanceof p5.Vector) {
                            this.x += x.x || 0;
                            this.y += x.y || 0;
                            this.z += x.z || 0;
                            return this;
                          }
                          if (x instanceof Array) {
                            this.x += x[0] || 0;
                            this.y += x[1] || 0;
                            this.z += x[2] || 0;
                            return this;
                          }
                          this.x += x || 0;
                          this.y += y || 0;
                          this.z += z || 0;
                          return this;
                        };
                        
                        /**
                         * Subtracts x, y, and z components from a vector, subtracts one vector from
                         * another, or subtracts two independent vectors. The version of the method
                         * that subtracts two vectors is a static method and returns a p5.Vector, the
                         * other acts directly on the vector. See the examples for more context.
                         *
                         * @method sub
                         * @chainable
                         * @param  {Number|p5.Vector|Array} x   the x component of the vector or a
                         *                                      p5.Vector or an Array
                         * @param  {Number}                 [y] the y component of the vector
                         * @param  {Number}                 [z] the z component of the vector
                         * @return {p5.Vector}                  p5.Vector object.
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * var v = createVector(4, 5, 6);
                         * v.sub(1, 1, 1);
                         * // v&#x27;s compnents are set to [3, 4, 5]
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * // Static method
                         * var v1 = createVector(2, 3, 4);
                         * var v2 = createVector(1, 2, 3);
                         *
                         * var v3 = p5.Vector.sub(v1, v2);
                         * // v3 has compnents [1, 1, 1]
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.Vector.prototype.sub = function (x, y, z) {
                          if (x instanceof p5.Vector) {
                            this.x -= x.x || 0;
                            this.y -= x.y || 0;
                            this.z -= x.z || 0;
                            return this;
                          }
                          if (x instanceof Array) {
                            this.x -= x[0] || 0;
                            this.y -= x[1] || 0;
                            this.z -= x[2] || 0;
                            return this;
                          }
                          this.x -= x || 0;
                          this.y -= y || 0;
                          this.z -= z || 0;
                          return this;
                        };
                        
                        /**
                         * Multiply the vector by a scalar. The static version of this method
                         * creates a new p5.Vector while the non static version acts on the vector
                         * directly. See the examples for more context.
                         *
                         * @method mult
                         * @chainable
                         * @param  {Number}    n the number to multiply with the vector
                         * @return {p5.Vector} a reference to the p5.Vector object (allow chaining)
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * var v = createVector(1, 2, 3);
                         * v.mult(2);
                         * // v&#x27;s compnents are set to [2, 4, 6]
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * // Static method
                         * var v1 = createVector(1, 2, 3);
                         * var v2 = p5.Vector.mult(v1, 2);
                         * // v2 has compnents [2, 4, 6]
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.Vector.prototype.mult = function (n) {
                          this.x *= n || 0;
                          this.y *= n || 0;
                          this.z *= n || 0;
                          return this;
                        };
                        
                        /**
                         * Divide the vector by a scalar. The static version of this method creates a
                         * new p5.Vector while the non static version acts on the vector directly.
                         * See the examples for more context.
                         *
                         * @method div
                         * @chainable
                         * @param  {number}    n the number to divide the vector by
                         * @return {p5.Vector} a reference to the p5.Vector object (allow chaining)
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * var v = createVector(6, 4, 2);
                         * v.div(2); //v&#x27;s compnents are set to [3, 2, 1]
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * // Static method
                         * var v1  = createVector(6, 4, 2);
                         * var v2 = p5.Vector.div(v, 2);
                         * // v2 has compnents [3, 2, 1]
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.Vector.prototype.div = function (n) {
                          this.x /= n;
                          this.y /= n;
                          this.z /= n;
                          return this;
                        };
                        
                        /**
                         * Calculates the magnitude (length) of the vector and returns the result as
                         * a float (this is simply the equation sqrt(x*x + y*y + z*z).)
                         *
                         * @method mag
                         * @return {Number} magnitude of the vector
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * var v = createVector(20.0, 30.0, 40.0);
                         * var m = v.mag(10);
                         * print(m); // Prints &quot;53.85164807134504&quot;
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.Vector.prototype.mag = function () {
                          return Math.sqrt(this.magSq());
                        };
                        
                        /**
                         * Calculates the squared magnitude of the vector and returns the result
                         * as a float (this is simply the equation &lt;em&gt;(x*x + y*y + z*z)&lt;/em&gt;.)
                         * Faster if the real length is not required in the
                         * case of comparing vectors, etc.
                         *
                         * @method magSq
                         * @return {number} squared magnitude of the vector
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * // Static method
                         * var v1 = createVector(6, 4, 2);
                         * print(v1.magSq()); // Prints &quot;56&quot;
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.Vector.prototype.magSq = function () {
                          var x = this.x, y = this.y, z = this.z;
                          return (x * x + y * y + z * z);
                        };
                        
                        /**
                         * Calculates the dot product of two vectors. The version of the method
                         * that computes the dot product of two independent vectors is a static
                         * method. See the examples for more context.
                         *
                         *
                         * @method dot
                         * @param  {Number|p5.Vector} x   x component of the vector or a p5.Vector
                         * @param  {Number}           [y] y component of the vector
                         * @param  {Number}           [z] z component of the vector
                         * @return {Number}                 the dot product
                         *
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * var v1 = createVector(1, 2, 3);
                         * var v2 = createVector(2, 3, 4);
                         *
                         * print(v1.dot(v2)); // Prints &quot;20&quot;
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * //Static method
                         * var v1 = createVector(1, 2, 3);
                         * var v2 = createVector(3, 2, 1);
                         * print (p5.Vector.dot(v1, v2)); // Prints &quot;10&quot;
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.Vector.prototype.dot = function (x, y, z) {
                          if (x instanceof p5.Vector) {
                            return this.dot(x.x, x.y, x.z);
                          }
                          return this.x * (x || 0) +
                                 this.y * (y || 0) +
                                 this.z * (z || 0);
                        };
                        
                        /**
                         * Calculates and returns a vector composed of the cross product between
                         * two vectors. Both the static and non static methods return a new p5.Vector.
                         * See the examples for more context.
                         *
                         * @method cross
                         * @param  {p5.Vector} v p5.Vector to be crossed
                         * @return {p5.Vector}   p5.Vector composed of cross product
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * var v1 = createVector(1, 2, 3);
                         * var v2 = createVector(1, 2, 3);
                         *
                         * v1.cross(v2); // v&#x27;s components are [0, 0, 0]
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * // Static method
                         * var v1 = createVector(1, 0, 0);
                         * var v2 = createVector(0, 1, 0);
                         *
                         * var crossProduct = p5.Vector.cross(v1, v2);
                         * // crossProduct has components [0, 0, 1]
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.Vector.prototype.cross = function (v) {
                          var x = this.y * v.z - this.z * v.y;
                          var y = this.z * v.x - this.x * v.z;
                          var z = this.x * v.y - this.y * v.x;
                          if (this.p5) {
                            return new p5.Vector(this.p5,[x,y,z]);
                          } else {
                            return new p5.Vector(x,y,z);
                          }
                        };
                        
                        /**
                         * Calculates the Euclidean distance between two points (considering a
                         * point as a vector object).
                         *
                         * @method dist
                         * @param  {p5.Vector} v the x, y, and z coordinates of a p5.Vector
                         * @return {Number}      the distance
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * var v1 = createVector(1, 0, 0);
                         * var v2 = createVector(0, 1, 0);
                         *
                         * var distance = v1.dist(v2); // distance is 1.4142...
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * // Static method
                         * var v1 = createVector(1, 0, 0);
                         * var v2 = createVector(0, 1, 0);
                         *
                         * var distance = p5.Vector.dist(v1,v2);
                         * // distance is 1.4142...
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.Vector.prototype.dist = function (v) {
                          var d = v.copy().sub(this);
                          return d.mag();
                        };
                        
                        /**
                         * Normalize the vector to length 1 (make it a unit vector).
                         *
                         * @method normalize
                         * @return {p5.Vector} normalized p5.Vector
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * var v = createVector(10, 20, 2);
                         * // v has compnents [10.0, 20.0, 2.0]
                         * v.normalize();
                         * // v&#x27;s compnents are set to
                         * // [0.4454354, 0.8908708, 0.089087084]
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         */
                        p5.Vector.prototype.normalize = function () {
                          return this.div(this.mag());
                        };
                        
                        /**
                         * Limit the magnitude of this vector to the value used for the &lt;b&gt;max&lt;/b&gt;
                         * parameter.
                         *
                         * @method limit
                         * @param  {Number}    max the maximum magnitude for the vector
                         * @return {p5.Vector}     the modified p5.Vector
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * var v = createVector(10, 20, 2);
                         * // v has compnents [10.0, 20.0, 2.0]
                         * v.limit(5);
                         * // v&#x27;s compnents are set to
                         * // [2.2271771, 4.4543543, 0.4454354]
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.Vector.prototype.limit = function (l) {
                          var mSq = this.magSq();
                          if(mSq &gt; l*l) {
                            this.div(Math.sqrt(mSq)); //normalize it
                            this.mult(l);
                          }
                          return this;
                        };
                        
                        /**
                         * Set the magnitude of this vector to the value used for the &lt;b&gt;len&lt;/b&gt;
                         * parameter.
                         *
                         * @method setMag
                         * @param  {number}    len the new length for this vector
                         * @return {p5.Vector}     the modified p5.Vector
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * var v1 = createVector(10, 20, 2);
                         * // v has compnents [10.0, 20.0, 2.0]
                         * v1.setMag(10);
                         * // v&#x27;s compnents are set to [6.0, 8.0, 0.0]
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.Vector.prototype.setMag = function (n) {
                          return this.normalize().mult(n);
                        };
                        
                        /**
                         * Calculate the angle of rotation for this vector (only 2D vectors)
                         *
                         * @method heading
                         * @return {Number} the angle of rotation
                         * @example
                         * &lt;div class = &quot;norender&quot;&gt;&lt;code&gt;
                         * function setup() {
                         *   var v1 = createVector(30,50);
                         *   print(v1.heading()); // 1.0303768265243125
                         *
                         *   var v1 = createVector(40,50);
                         *   print(v1.heading()); // 0.8960553845713439
                         *
                         *   var v1 = createVector(30,70);
                         *   print(v1.heading()); // 1.1659045405098132
                         * }
                         * &lt;/div&gt;&lt;/code&gt;
                         */
                        p5.Vector.prototype.heading = function () {
                          var h = Math.atan2(this.y, this.x);
                          if (this.p5) {
                            if (this.p5._angleMode === constants.RADIANS) {
                              return h;
                            } else {
                              return polarGeometry.radiansToDegrees(h);
                            }
                          } else {
                            return h;
                          }
                        };
                        
                        /**
                         * Rotate the vector by an angle (only 2D vectors), magnitude remains the
                         * same
                         *
                         * @method rotate
                         * @param  {number}    angle the angle of rotation
                         * @return {p5.Vector} the modified p5.Vector
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * var v = createVector(10.0, 20.0);
                         * // v has compnents [10.0, 20.0, 0.0]
                         * v.rotate(HALF_PI);
                         * // v&#x27;s compnents are set to [-20.0, 9.999999, 0.0]
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.Vector.prototype.rotate = function (a) {
                          if (this.p5) {
                            if (this.p5._angleMode === constants.DEGREES) {
                              a = polarGeometry.degreesToRadians(a);
                            }
                          }
                          var newHeading = this.heading() + a;
                          var mag = this.mag();
                          this.x = Math.cos(newHeading) * mag;
                          this.y = Math.sin(newHeading) * mag;
                          return this;
                        };
                        
                        /**
                         * Linear interpolate the vector to another vector
                         *
                         * @method lerp
                         * @param  {p5.Vector} x   the x component or the p5.Vector to lerp to
                         * @param  {p5.Vector} [y] y the y component
                         * @param  {p5.Vector} [z] z the z component
                         * @param  {Number}    amt the amount of interpolation; some value between 0.0
                         *                         (old vector) and 1.0 (new vector). 0.1 is very near
                         *                         the new vector. 0.5 is halfway in between.
                         * @return {p5.Vector}     the modified p5.Vector
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * var v = createVector(1, 1, 0);
                         *
                         * v.lerp(3, 3, 0, 0.5); // v now has components [2,2,0]
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * var v1 = createVector(0, 0, 0);
                         * var v2 = createVector(100, 100, 0);
                         *
                         * var v3 = p5.Vector.lerp(v1, v2, 0.5);
                         * // v3 has components [50,50,0]
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.Vector.prototype.lerp = function (x, y, z, amt) {
                          if (x instanceof p5.Vector) {
                            return this.lerp(x.x, x.y, x.z, y);
                          }
                          this.x += (x - this.x) * amt || 0;
                          this.y += (y - this.y) * amt || 0;
                          this.z += (z - this.z) * amt || 0;
                          return this;
                        };
                        
                        /**
                         * Return a representation of this vector as a float array. This is only
                         * for temporary use. If used in any other fashion, the contents should be
                         * copied by using the &lt;b&gt;p5.Vector.copy()&lt;/b&gt; method to copy into your own
                         * array.
                         *
                         * @method array
                         * @return {Array} an Array with the 3 values
                         * @example
                         * &lt;div class = &quot;norender&quot;&gt;&lt;code&gt;
                         * function setup() {
                         *   var v = createVector(20,30);
                         *   print(v.array()); // Prints : Array [20, 30, 0]
                         * }
                         * &lt;/div&gt;&lt;/code&gt;
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * var v = createVector(10.0, 20.0, 30.0);
                         * var f = v.array();
                         * print(f[0]); // Prints &quot;10.0&quot;
                         * print(f[1]); // Prints &quot;20.0&quot;
                         * print(f[2]); // Prints &quot;30.0&quot;
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.Vector.prototype.array = function () {
                          return [this.x || 0, this.y || 0, this.z || 0];
                        };
                        
                        /**
                         * Equality check against a p5.Vector
                         *
                         * @method equals
                         * @param {Number|p5.Vector|Array} [x] the x component of the vector or a
                         *                                     p5.Vector or an Array
                         * @param {Number}                 [y] the y component of the vector
                         * @param {Number}                 [z] the z component of the vector
                         * @return {Boolean} whether the vectors are equals
                         * @example
                         * &lt;div class = &quot;norender&quot;&gt;&lt;code&gt;
                         * v1 = createVector(5,10,20);
                         * v2 = createVector(5,10,20);
                         * v3 = createVector(13,10,19);
                         *
                         * print(v1.equals(v2.x,v2.y,v2.z)); // true
                         * print(v1.equals(v3.x,v3.y,v3.z)); // false
                         * &lt;/div&gt;&lt;/code&gt;
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * var v1 = createVector(10.0, 20.0, 30.0);
                         * var v2 = createVector(10.0, 20.0, 30.0);
                         * var v3 = createVector(0.0, 0.0, 0.0);
                         * print (v1.equals(v2)) // true
                         * print (v1.equals(v3)) // false
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.Vector.prototype.equals = function (x, y, z) {
                          var a, b, c;
                          if (x instanceof p5.Vector) {
                            a = x.x || 0;
                            b = x.y || 0;
                            c = x.z || 0;
                          } else if (x instanceof Array) {
                            a = x[0] || 0;
                            b = x[1] || 0;
                            c = x[2] || 0;
                          } else {
                            a = x || 0;
                            b = y || 0;
                            c = z || 0;
                          }
                          return this.x === a &amp;&amp; this.y === b &amp;&amp; this.z === c;
                        };
                        
                        
                        // Static Methods
                        
                        
                        /**
                         * Make a new 2D unit vector from an angle
                         *
                         * @method fromAngle
                         * @static
                         * @param {Number}     angle the desired angle
                         * @return {p5.Vector}       the new p5.Vector object
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * function draw() {
                         *   background (200);
                         *
                         *   // Create a variable, proportional to the mouseX,
                         *   // varying from 0-360, to represent an angle in degrees.
                         *   angleMode(DEGREES);
                         *   var myDegrees = map(mouseX, 0,width, 0,360);
                         *
                         *   // Display that variable in an onscreen text.
                         *   // (Note the nfc() function to truncate additional decimal places,
                         *   // and the &quot;\xB0&quot; character for the degree symbol.)
                         *   var readout = &quot;angle = &quot; + nfc(myDegrees,1,1) + &quot;\xB0&quot;
                         *   noStroke();
                         *   fill (0);
                         *   text (readout, 5, 15);
                         *
                         *   // Create a p5.Vector using the fromAngle function,
                         *   // and extract its x and y components.
                         *   var v = p5.Vector.fromAngle(radians(myDegrees));
                         *   var vx = v.x;
                         *   var vy = v.y;
                         *
                         *   push();
                         *   translate (width/2, height/2);
                         *   noFill();
                         *   stroke (150);
                         *   line (0,0, 30,0);
                         *   stroke (0);
                         *   line (0,0, 30*vx, 30*vy);
                         *   pop()
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.Vector.fromAngle = function(angle) {
                          if (this.p5) {
                            if (this.p5._angleMode === constants.DEGREES) {
                              angle = polarGeometry.degreesToRadians(angle);
                            }
                          }
                          if (this.p5) {
                            return new p5.Vector(this.p5,[Math.cos(angle),Math.sin(angle),0]);
                          } else {
                            return new p5.Vector(Math.cos(angle),Math.sin(angle),0);
                          }
                        };
                        
                        /**
                         * Make a new 2D unit vector from a random angle
                         *
                         * @method random2D
                         * @static
                         * @return {p5.Vector} the new p5.Vector object
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * var v = p5.Vector.random2D();
                         * // May make v&#x27;s attributes something like:
                         * // [0.61554617, -0.51195765, 0.0] or
                         * // [-0.4695841, -0.14366731, 0.0] or
                         * // [0.6091097, -0.22805278, 0.0]
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.Vector.random2D = function () {
                          var angle;
                          // A lot of nonsense to determine if we know about a
                          // p5 sketch and whether we should make a random angle in degrees or radians
                          if (this.p5) {
                            if (this.p5._angleMode === constants.DEGREES) {
                              angle = this.p5.random(360);
                            } else {
                              angle = this.p5.random(constants.TWO_PI);
                            }
                          } else {
                            angle = Math.random()*Math.PI*2;
                          }
                          return this.fromAngle(angle);
                        };
                        
                        /**
                         * Make a new random 3D unit vector.
                         *
                         * @method random3D
                         * @static
                         * @return {p5.Vector} the new p5.Vector object
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * var v = p5.Vector.random3D();
                         * // May make v&#x27;s attributes something like:
                         * // [0.61554617, -0.51195765, 0.599168] or
                         * // [-0.4695841, -0.14366731, -0.8711202] or
                         * // [0.6091097, -0.22805278, -0.7595902]
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.Vector.random3D = function () {
                          var angle,vz;
                          // If we know about p5
                          if (this.p5) {
                            angle = this.p5.random(0,constants.TWO_PI);
                            vz = this.p5.random(-1,1);
                          } else {
                            angle = Math.random()*Math.PI*2;
                            vz = Math.random()*2-1;
                          }
                          var vx = Math.sqrt(1-vz*vz)*Math.cos(angle);
                          var vy = Math.sqrt(1-vz*vz)*Math.sin(angle);
                          if (this.p5) {
                            return new p5.Vector(this.p5,[vx,vy,vz]);
                          } else {
                            return new p5.Vector(vx,vy,vz);
                          }
                        };
                        
                        
                        /**
                         * Adds two vectors together and returns a new one.
                         *
                         * @static
                         * @param  {p5.Vector} v1 a p5.Vector to add
                         * @param  {p5.Vector} v2 a p5.Vector to add
                         * @param  {p5.Vector} target if undefined a new vector will be created
                         * @return {p5.Vector} the resulting p5.Vector
                         *
                         */
                        
                        p5.Vector.add = function (v1, v2, target) {
                          if (!target) {
                            target = v1.copy();
                          } else {
                            target.set(v1);
                          }
                          target.add(v2);
                          return target;
                        };
                        
                        /**
                         * Subtracts one p5.Vector from another and returns a new one.  The second
                         * vector (v2) is subtracted from the first (v1), resulting in v1-v2.
                         *
                         * @static
                         * @param  {p5.Vector} v1 a p5.Vector to subtract from
                         * @param  {p5.Vector} v2 a p5.Vector to subtract
                         * @param  {p5.Vector} target if undefined a new vector will be created
                         * @return {p5.Vector} the resulting p5.Vector
                         */
                        
                        p5.Vector.sub = function (v1, v2, target) {
                          if (!target) {
                            target = v1.copy();
                          } else {
                            target.set(v1);
                          }
                          target.sub(v2);
                          return target;
                        };
                        
                        
                        /**
                         * Multiplies a vector by a scalar and returns a new vector.
                         *
                         * @static
                         * @param  {p5.Vector} v the p5.Vector to multiply
                         * @param  {Number}  n the scalar
                         * @param  {p5.Vector} target if undefined a new vector will be created
                         * @return {p5.Vector}  the resulting new p5.Vector
                         */
                        p5.Vector.mult = function (v, n, target) {
                          if (!target) {
                            target = v.copy();
                          } else {
                            target.set(v);
                          }
                          target.mult(n);
                          return target;
                        };
                        
                        /**
                         * Divides a vector by a scalar and returns a new vector.
                         *
                         * @static
                         * @param  {p5.Vector} v the p5.Vector to divide
                         * @param  {Number}  n the scalar
                         * @param  {p5.Vector} target if undefined a new vector will be created
                         * @return {p5.Vector} the resulting new p5.Vector
                         */
                        p5.Vector.div = function (v, n, target) {
                          if (!target) {
                            target = v.copy();
                          } else {
                            target.set(v);
                          }
                          target.div(n);
                          return target;
                        };
                        
                        
                        /**
                         * Calculates the dot product of two vectors.
                         *
                         * @static
                         * @param  {p5.Vector} v1 the first p5.Vector
                         * @param  {p5.Vector} v2 the second p5.Vector
                         * @return {Number}     the dot product
                         */
                        p5.Vector.dot = function (v1, v2) {
                          return v1.dot(v2);
                        };
                        
                        /**
                         * Calculates the cross product of two vectors.
                         *
                         * @static
                         * @param  {p5.Vector} v1 the first p5.Vector
                         * @param  {p5.Vector} v2 the second p5.Vector
                         * @return {Number}     the cross product
                         */
                        p5.Vector.cross = function (v1, v2) {
                          return v1.cross(v2);
                        };
                        
                        /**
                         * Calculates the Euclidean distance between two points (considering a
                         * point as a vector object).
                         *
                         * @static
                         * @param  {p5.Vector} v1 the first p5.Vector
                         * @param  {p5.Vector} v2 the second p5.Vector
                         * @return {Number}     the distance
                         */
                        p5.Vector.dist = function (v1,v2) {
                          return v1.dist(v2);
                        };
                        
                        /**
                         * Linear interpolate a vector to another vector and return the result as a
                         * new vector.
                         *
                         * @static
                         * @param {p5.Vector} v1 a starting p5.Vector
                         * @param {p5.Vector} v2 the p5.Vector to lerp to
                         * @param {Number}       the amount of interpolation; some value between 0.0
                         *                       (old vector) and 1.0 (new vector). 0.1 is very near
                         *                       the new vector. 0.5 is halfway in between.
                         */
                        p5.Vector.lerp = function (v1, v2, amt, target) {
                          if (!target) {
                            target = v1.copy();
                          } else {
                            target.set(v1);
                          }
                          target.lerp(v2, amt);
                          return target;
                        };
                        
                        /**
                         * Calculates and returns the angle (in radians) between two vectors.
                         * @method angleBetween
                         * @static
                         * @param  {p5.Vector} v1 the x, y, and z components of a p5.Vector
                         * @param  {p5.Vector} v2 the x, y, and z components of a p5.Vector
                         * @return {Number}       the angle between (in radians)
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * var v1 = createVector(1, 0, 0);
                         * var v2 = createVector(0, 1, 0);
                         *
                         * var angle = p5.Vector.angleBetween(v1, v2);
                         * // angle is PI/2
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.Vector.angleBetween = function (v1, v2) {
                          var angle = Math.acos(v1.dot(v2) / (v1.mag() * v2.mag()));
                          if (this.p5) {
                            if (this.p5._angleMode === constants.DEGREES) {
                              angle = polarGeometry.radiansToDegrees(angle);
                            }
                          }
                          return angle;
                        };
                        
                        module.exports = p5.Vector;
                        
                        },{&quot;../core/constants&quot;:47,&quot;../core/core&quot;:48,&quot;./polargeometry&quot;:77}],77:[function(_dereq_,module,exports){
                        
                        module.exports = {
                        
                          degreesToRadians: function(x) {
                            return 2 * Math.PI * x / 360;
                          },
                        
                          radiansToDegrees: function(x) {
                            return 360 * x / (2 * Math.PI);
                          }
                        
                        };
                        
                        },{}],78:[function(_dereq_,module,exports){
                        /**
                         * @module Math
                         * @submodule Random
                         * @for p5
                         * @requires core
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        
                        var seeded = false;
                        
                        // Linear Congruential Generator
                        // Variant of a Lehman Generator
                        var lcg = (function() {
                          // Set to values from http://en.wikipedia.org/wiki/Numerical_Recipes
                          // m is basically chosen to be large (as it is the max period)
                          // and for its relationships to a and c
                          var m = 4294967296,
                            // a - 1 should be divisible by m&#x27;s prime factors
                            a = 1664525,
                            // c and m should be co-prime
                            c = 1013904223,
                            seed, z;
                          return {
                            setSeed : function(val) {
                              // pick a random seed if val is undefined or null
                              // the &gt;&gt;&gt; 0 casts the seed to an unsigned 32-bit integer
                              z = seed = (val == null ? Math.random() * m : val) &gt;&gt;&gt; 0;
                            },
                            getSeed : function() {
                              return seed;
                            },
                            rand : function() {
                              // define the recurrence relationship
                              z = (a * z + c) % m;
                              // return a float in [0, 1)
                              // if z = m then z / m = 0 therefore (z % m) / m &lt; 1 always
                              return z / m;
                            }
                          };
                        }());
                        
                        /**
                         * Sets the seed value for random().
                         *
                         * By default, random() produces different results each time the program
                         * is run. Set the seed parameter to a constant to return the same
                         * pseudo-random numbers each time the software is run.
                         *
                         * @method randomSeed
                         * @param {Number} seed   the seed value
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * randomSeed(99);
                         * for (var i=0; i &lt; 100; i++) {
                         *   var r = random(0, 255);
                         *   stroke(r);
                         *   line(i, 0, i, 100);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.randomSeed = function(seed) {
                          lcg.setSeed(seed);
                          seeded = true;
                        };
                        
                        /**
                         * Return a random number.
                         *
                         * Takes either 0, 1 or 2 arguments.
                         * If no argument is given, returns a random number between 0 and 1.
                         * If one argument is given, returns a random number between 0 and the number.
                         * If two arguments are given, returns a random number between them,
                         * inclusive.
                         *
                         * @method random
                         * @param  {Number} min   the lower bound
                         * @param  {Number} max   the upper bound
                         * @return {Number} the random number
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * for (var i = 0; i &lt; 100; i++) {
                         *   var r = random(50);
                         *   stroke(r*5);
                         *   line(50, i, 50+r, i);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * for (var i = 0; i &lt; 100; i++) {
                         *   var r = random(-50, 50);
                         *   line(50,i,50+r,i);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Get a random element from an array
                         * var words = [ &quot;apple&quot;, &quot;bear&quot;, &quot;cat&quot;, &quot;dog&quot; ];
                         * var index = floor(random(words.length));  // Convert to integer
                         * text(words[index],10,50);  // Displays one of the four words
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.random = function (min, max) {
                        
                          var rand;
                        
                          if (seeded) {
                            rand  = lcg.rand();
                          } else {
                            rand = Math.random();
                          }
                        
                          if (arguments.length === 0) {
                            return rand;
                          } else
                          if (arguments.length === 1) {
                            return rand * min;
                          } else {
                            if (min &gt; max) {
                              var tmp = min;
                              min = max;
                              max = tmp;
                            }
                        
                            return rand * (max-min) + min;
                          }
                        };
                        
                        
                        /**
                         *
                         * Returns a random number fitting a Gaussian, or
                         * normal, distribution. There is theoretically no minimum or maximum
                         * value that randomGaussian() might return. Rather, there is
                         * just a very low probability that values far from the mean will be
                         * returned; and a higher probability that numbers near the mean will
                         * be returned.
                         * &lt;br&gt;&lt;br&gt;
                         * Takes either 0, 1 or 2 arguments.&lt;br&gt;
                         * If no args, returns a mean of 0 and standard deviation of 1.&lt;br&gt;
                         * If one arg, that arg is the mean (standard deviation is 1).&lt;br&gt;
                         * If two args, first is mean, second is standard deviation.
                         *
                         * @method randomGaussian
                         * @param  {Number} mean  the mean
                         * @param  {Number} sd    the standard deviation
                         * @return {Number} the random number
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;for (var y = 0; y &lt; 100; y++) {
                         *  var x = randomGaussian(50,15);
                         *  line(50, y, x, y);
                         *}
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         * &lt;div&gt;
                         * &lt;code&gt;
                         *var distribution = new Array(360);
                         *
                         *function setup() {
                         *  createCanvas(100, 100);
                         *  for (var i = 0; i &lt; distribution.length; i++) {
                         *    distribution[i] = floor(randomGaussian(0,15));
                         *  }
                         *}
                         *
                         *function draw() {
                         *  background(204);
                         *
                         *  translate(width/2, width/2);
                         *
                         *  for (var i = 0; i &lt; distribution.length; i++) {
                         *    rotate(TWO_PI/distribution.length);
                         *    stroke(0);
                         *    var dist = abs(distribution[i]);
                         *    line(0, 0, dist, 0);
                         *  }
                         *}
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        var y2;
                        var previous = false;
                        p5.prototype.randomGaussian = function(mean, sd)  {
                          var y1,x1,x2,w;
                          if (previous) {
                            y1 = y2;
                            previous = false;
                          } else {
                            do {
                              x1 = this.random(2) - 1;
                              x2 = this.random(2) - 1;
                              w = x1 * x1 + x2 * x2;
                            } while (w &gt;= 1);
                            w = Math.sqrt((-2 * Math.log(w))/w);
                            y1 = x1 * w;
                            y2 = x2 * w;
                            previous = true;
                          }
                        
                          var m = mean || 0;
                          var s = sd || 1;
                          return y1*s + m;
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;../core/core&quot;:48}],79:[function(_dereq_,module,exports){
                        /**
                         * @module Math
                         * @submodule Trigonometry
                         * @for p5
                         * @requires core
                         * @requires polargeometry
                         * @requires constants
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        var polarGeometry = _dereq_(&#x27;./polargeometry&#x27;);
                        var constants = _dereq_(&#x27;../core/constants&#x27;);
                        
                        p5.prototype._angleMode = constants.RADIANS;
                        
                        /**
                         * The inverse of cos(), returns the arc cosine of a value. This function
                         * expects the values in the range of -1 to 1 and values are returned in
                         * the range 0 to PI (3.1415927).
                         *
                         * @method acos
                         * @param  {Number} value the value whose arc cosine is to be returned
                         * @return {Number}       the arc cosine of the given value
                         *
                         * @example
                         * &lt;div class= “norender&quot;&gt;
                         * &lt;code&gt;
                         * var a = PI;
                         * var c = cos(a);
                         * var ac = acos(c);
                         * // Prints: &quot;3.1415927 : -1.0 : 3.1415927&quot;
                         * println(a + &quot; : &quot; + c + &quot; : &quot; +  ac);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div class= “norender&quot;&gt;
                         * &lt;code&gt;
                         * var a = PI + PI/4.0;
                         * var c = cos(a);
                         * var ac = acos(c);
                         * // Prints: &quot;3.926991 : -0.70710665 : 2.3561943&quot;
                         * println(a + &quot; : &quot; + c + &quot; : &quot; +  ac);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.acos = function(ratio) {
                          if (this._angleMode === constants.RADIANS) {
                            return Math.acos(ratio);
                          } else {
                            return polarGeometry.radiansToDegrees(Math.acos(ratio));
                          }
                        };
                        
                        /**
                         * The inverse of sin(), returns the arc sine of a value. This function
                         * expects the values in the range of -1 to 1 and values are returned
                         * in the range -PI/2 to PI/2.
                         *
                         * @method asin
                         * @param  {Number} value the value whose arc sine is to be returned
                         * @return {Number}       the arc sine of the given value
                         *
                         * @example
                         * &lt;div class= “norender&quot;&gt;
                         * &lt;code&gt;
                         * var a = PI + PI/3;
                         * var s = sin(a);
                         * var as = asin(s);
                         * // Prints: &quot;1.0471976 : 0.86602545 : 1.0471976&quot;
                         * println(a + &quot; : &quot; + s + &quot; : &quot; +  as);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div class= “norender&quot;&gt;
                         * &lt;code&gt;
                         * var a = PI + PI/3.0;
                         * var s = sin(a);
                         * var as = asin(s);
                         * // Prints: &quot;4.1887903 : -0.86602545 : -1.0471976&quot;
                         * println(a + &quot; : &quot; + s + &quot; : &quot; +  as);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         */
                        p5.prototype.asin = function(ratio) {
                          if (this._angleMode === constants.RADIANS) {
                            return Math.asin(ratio);
                          } else {
                            return polarGeometry.radiansToDegrees(Math.asin(ratio));
                          }
                        };
                        
                        /**
                         * The inverse of tan(), returns the arc tangent of a value. This function
                         * expects the values in the range of -Infinity to Infinity (exclusive) and
                         * values are returned in the range -PI/2 to PI/2.
                         *
                         * @method atan
                         * @param  {Number} value the value whose arc tangent is to be returned
                         * @return {Number}       the arc tangent of the given value
                         *
                         * @example
                         * &lt;div class= “norender&quot;&gt;
                         * &lt;code&gt;
                         * var a = PI + PI/3;
                         * var t = tan(a);
                         * var at = atan(t);
                         * // Prints: &quot;1.0471976 : 1.7320509 : 1.0471976&quot;
                         * println(a + &quot; : &quot; + t + &quot; : &quot; +  at);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         * &lt;div class= “norender&quot;&gt;
                         * &lt;code&gt;
                         * var a = PI + PI/3.0;
                         * var t = tan(a);
                         * var at = atan(t);
                         * // Prints: &quot;4.1887903 : 1.7320513 : 1.0471977&quot;
                         * println(a + &quot; : &quot; + t + &quot; : &quot; +  at);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         */
                        p5.prototype.atan = function(ratio) {
                          if (this._angleMode === constants.RADIANS) {
                            return Math.atan(ratio);
                          } else {
                            return polarGeometry.radiansToDegrees(Math.atan(ratio));
                          }
                        };
                        
                        /**
                         * Calculates the angle (in radians) from a specified point to the coordinate
                         * origin as measured from the positive x-axis. Values are returned as a
                         * float in the range from PI to -PI. The atan2() function is most often used
                         * for orienting geometry to the position of the cursor.
                         * &lt;br&gt;&lt;br&gt;
                         * Note: The y-coordinate of the point is the first parameter, and the
                         * x-coordinate is the second parameter, due the the structure of calculating
                         * the tangent.
                         *
                         * @method atan2
                         * @param  {Number} y y-coordinate of the point
                         * @param  {Number} x x-coordinate of the point
                         * @return {Number}   the arc tangent of the given point
                         *
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * function draw() {
                         *   background(204);
                         *   translate(width/2, height/2);
                         *   var a = atan2(mouseY-height/2, mouseX-width/2);
                         *   rotate(a);
                         *   rect(-30, -5, 60, 10);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.atan2 = function (y, x) {
                          if (this._angleMode === constants.RADIANS) {
                            return Math.atan2(y, x);
                          } else {
                            return polarGeometry.radiansToDegrees(Math.atan2(y, x));
                          }
                        };
                        
                        /**
                         * Calculates the cosine of an angle. This function takes into account the
                         * current angleMode. Values are returned in the range -1 to 1.
                         *
                         * @method cos
                         * @param  {Number} angle the angle
                         * @return {Number}       the cosine of the angle
                         *
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var a = 0.0;
                         * var inc = TWO_PI/25.0;
                         * for (var i = 0; i &lt; 25; i++) {
                         *   line(i*4, 50, i*4, 50+cos(a)*40.0);
                         *   a = a + inc;
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         */
                        p5.prototype.cos = function(angle) {
                          if (this._angleMode === constants.RADIANS) {
                            return Math.cos(angle);
                          } else {
                            return Math.cos(this.radians(angle));
                          }
                        };
                        
                        /**
                         * Calculates the sine of an angle. This function takes into account the
                         * current angleMode. Values are returned in the range -1 to 1.
                         *
                         * @method sin
                         * @param  {Number} angle the angle
                         * @return {Number}       the sine of the angle
                         *
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var a = 0.0;
                         * var inc = TWO_PI/25.0;
                         * for (var i = 0; i &lt; 25; i++) {
                         *   line(i*4, 50, i*4, 50+sin(a)*40.0);
                         *   a = a + inc;
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.sin = function(angle) {
                          if (this._angleMode === constants.RADIANS) {
                            return Math.sin(angle);
                          } else {
                            return Math.sin(this.radians(angle));
                          }
                        };
                        
                        /**
                         * Calculates the tangent of an angle. This function takes into account
                         * the current angleMode. Values are returned in the range -1 to 1.
                         *
                         * @method tan
                         * @param  {Number} angle the angle
                         * @return {Number}       the tangent of the angle
                         *
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         *   var a = 0.0;
                         *   var inc = TWO_PI/50.0;
                         *   for (var i = 0; i &lt; 100; i = i+2) {
                         *     line(i, 50, i, 50+tan(a)*2.0);
                         *     a = a + inc;
                         *   }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         */
                        p5.prototype.tan = function(angle) {
                          if (this._angleMode === constants.RADIANS) {
                            return Math.tan(angle);
                          } else {
                            return Math.tan(this.radians(angle));
                          }
                        };
                        
                        /**
                         * Converts a radian measurement to its corresponding value in degrees.
                         * Radians and degrees are two ways of measuring the same thing. There are
                         * 360 degrees in a circle and 2*PI radians in a circle. For example,
                         * 90° = PI/2 = 1.5707964.
                         *
                         * @method degrees
                         * @param  {Number} radians the radians value to convert to degrees
                         * @return {Number}         the converted angle
                         *
                         *
                         * @example
                         * &lt;div class= “norender&quot;&gt;
                         * &lt;code&gt;
                         * var rad = PI/4;
                         * var deg = degrees(rad);
                         * println(rad + &quot; radians is &quot; + deg + &quot; degrees&quot;);
                         * // Prints: 45 degrees is 0.7853981633974483 radians
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         */
                        p5.prototype.degrees = function(angle) {
                          return polarGeometry.radiansToDegrees(angle);
                        };
                        
                        /**
                         * Converts a degree measurement to its corresponding value in radians.
                         * Radians and degrees are two ways of measuring the same thing. There are
                         * 360 degrees in a circle and 2*PI radians in a circle. For example,
                         * 90° = PI/2 = 1.5707964.
                         *
                         * @method radians
                         * @param  {Number} degrees the degree value to convert to radians
                         * @return {Number}         the converted angle
                         *
                         * @example
                         * &lt;div class= “norender&quot;&gt;
                         * &lt;code&gt;
                         * var deg = 45.0;
                         * var rad = radians(deg);
                         * println(deg + &quot; degrees is &quot; + rad + &quot; radians&quot;);
                         * // Prints: 45 degrees is 0.7853981633974483 radians
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.radians = function(angle) {
                          return polarGeometry.degreesToRadians(angle);
                        };
                        
                        /**
                         * Sets the current mode of p5 to given mode. Default mode is RADIANS.
                         *
                         * @method angleMode
                         * @param {Number/Constant} mode either RADIANS or DEGREES
                         *
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * function draw(){
                         *   background(204);
                         *   angleMode(DEGREES); // Change the mode to DEGREES
                         *   var a = atan2(mouseY-height/2, mouseX-width/2);
                         *   translate(width/2, height/2);
                         *   push();
                         *   rotate(a);
                         *   rect(-20, -5, 40, 10); // Larger rectangle is rotating in degrees
                         *   pop();
                         *   angleMode(RADIANS); // Change the mode to RADIANS
                         *   rotate(a); // var a stays the same
                         *   rect(-40, -5, 20, 10); // Smaller rectangle is rotating in radians
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         *
                         */
                        p5.prototype.angleMode = function(mode) {
                          if (mode === constants.DEGREES || mode === constants.RADIANS) {
                            this._angleMode = mode;
                          }
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;../core/constants&quot;:47,&quot;../core/core&quot;:48,&quot;./polargeometry&quot;:77}],80:[function(_dereq_,module,exports){
                        /**
                         * @module Typography
                         * @submodule Attributes
                         * @for p5
                         * @requires core
                         * @requires constants
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        
                        /**
                         * Sets the current alignment for drawing text. The parameters LEFT, CENTER,
                         * and RIGHT set the alignment of text in relation to the values for
                         * the x and y parameters of the text() function.
                         *
                         * @method textAlign
                         * @param {Number/Constant} horizAlign horizontal alignment, either LEFT,
                         *                            CENTER, or RIGHT
                         * @param {Number/Constant} vertAlign vertical alignment, either TOP,
                         *                            BOTTOM, CENTER, or BASELINE
                         * @return {Number}
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * textSize(16);
                         * textAlign(RIGHT);
                         * text(&quot;ABCD&quot;, 50, 30);
                         * textAlign(CENTER);
                         * text(&quot;EFGH&quot;, 50, 50);
                         * textAlign(LEFT);
                         * text(&quot;IJKL&quot;, 50, 70);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.textAlign = function(horizAlign, vertAlign) {
                          return this._renderer.textAlign.apply(this._renderer, arguments);
                        };
                        
                        /**
                         * Sets/gets the spacing, in pixels, between lines of text. This
                         * setting will be used in all subsequent calls to the text() function.
                         *
                         * @method textLeading
                         * @param {Number} leading the size in pixels for spacing between lines
                         * @return {Object|Number}
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * // Text to display. The &quot;\n&quot; is a &quot;new line&quot; character
                         * lines = &quot;L1\nL2\nL3&quot;;
                         * textSize(12);
                         *
                         * textLeading(10);  // Set leading to 10
                         * text(lines, 10, 25);
                         *
                         * textLeading(20);  // Set leading to 20
                         * text(lines, 40, 25);
                         *
                         * textLeading(30);  // Set leading to 30
                         * text(lines, 70, 25);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.textLeading = function(theLeading) {
                          return this._renderer.textLeading.apply(this._renderer, arguments);
                        };
                        
                        /**
                         * Sets/gets the current font size. This size will be used in all subsequent
                         * calls to the text() function. Font size is measured in pixels.
                         *
                         * @method textSize
                         * @param {Number} theSize the size of the letters in units of pixels
                         * @return {Object|Number}
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * textSize(12);
                         * text(&quot;Font Size 12&quot;, 10, 30);
                         * textSize(14);
                         * text(&quot;Font Size 14&quot;, 10, 60);
                         * textSize(16);
                         * text(&quot;Font Size 16&quot;, 10, 90);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.textSize = function(theSize) {
                          return this._renderer.textSize.apply(this._renderer, arguments);
                        };
                        
                        /**
                         * Sets/gets the style of the text for system fonts to NORMAL, ITALIC, or BOLD.
                         * Note: this may be is overridden by CSS styling. For non-system fonts
                         * (opentype, truetype, etc.) please load styled fonts instead.
                         *
                         * @method textStyle
                         * @param {Number/Constant} theStyle styling for text, either NORMAL,
                         *                            ITALIC, or BOLD
                         * @return {Object|String}
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * strokeWeight(0);
                         * textSize(12);
                         * textStyle(NORMAL);
                         * text(&quot;Font Style Normal&quot;, 10, 30);
                         * textStyle(ITALIC);
                         * text(&quot;Font Style Italic&quot;, 10, 60);
                         * textStyle(BOLD);
                         * text(&quot;Font Style Bold&quot;, 10, 90);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.textStyle = function(theStyle) {
                          return this._renderer.textStyle.apply(this._renderer, arguments);
                        };
                        
                        /**
                         * Calculates and returns the width of any character or text string.
                         *
                         * @method textWidth
                         * @param {String} theText the String of characters to measure
                         * @return {Number}
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * textSize(28);
                         *
                         * var aChar = &#x27;P&#x27;;
                         * var cWidth = textWidth(aChar);
                         * text(aChar, 0, 40);
                         * line(cWidth, 0, cWidth, 50);
                         *
                         * var aString = &quot;p5.js&quot;;
                         * var sWidth = textWidth(aString);
                         * text(aString, 0, 85);
                         * line(sWidth, 50, sWidth, 100);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.textWidth = function(theText) {
                          return this._renderer.textWidth.apply(this._renderer, arguments);
                        };
                        
                        /**
                         * Returns the ascent of the current font at its current size. The ascent
                         * represents the distance, in pixels, of the tallest character above
                         * the baseline.
                         *
                         * @return {Number}
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var base = height * 0.75;
                         * var scalar = 0.8; // Different for each font
                         *
                         * textSize(32);  // Set initial text size
                         * var asc = textAscent() * scalar;  // Calc ascent
                         * line(0, base - asc, width, base - asc);
                         * text(&quot;dp&quot;, 0, base);  // Draw text on baseline
                         *
                         * textSize(64);  // Increase text size
                         * asc = textAscent() * scalar;  // Recalc ascent
                         * line(40, base - asc, width, base - asc);
                         * text(&quot;dp&quot;, 40, base);  // Draw text on baseline
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.textAscent = function() {
                          return this._renderer.textAscent();
                        };
                        
                        /**
                         * Returns the descent of the current font at its current size. The descent
                         * represents the distance, in pixels, of the character with the longest
                         * descender below the baseline.
                         *
                         * @return {Number}
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var base = height * 0.75;
                         * var scalar = 0.8; // Different for each font
                         *
                         * textSize(32);  // Set initial text size
                         * var desc = textDescent() * scalar;  // Calc ascent
                         * line(0, base+desc, width, base+desc);
                         * text(&quot;dp&quot;, 0, base);  // Draw text on baseline
                         *
                         * textSize(64);  // Increase text size
                         * desc = textDescent() * scalar;  // Recalc ascent
                         * line(40, base + desc, width, base + desc);
                         * text(&quot;dp&quot;, 40, base);  // Draw text on baseline
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.textDescent = function() {
                          return this._renderer.textDescent();
                        };
                        
                        /**
                         * Helper function to measure ascent and descent.
                         */
                        p5.prototype._updateTextMetrics = function() {
                          return this._renderer._updateTextMetrics();
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;../core/core&quot;:48}],81:[function(_dereq_,module,exports){
                        /**
                         * @module Typography
                         * @submodule Loading &amp; Displaying
                         * @for p5
                         * @requires core
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        var constants = _dereq_(&#x27;../core/constants&#x27;);
                        
                        _dereq_(&#x27;../core/error_helpers&#x27;);
                        
                        
                        /**
                         * Draws text to the screen. Displays the information specified in the first
                         * parameter on the screen in the position specified by the additional
                         * parameters. A default font will be used unless a font is set with the
                         * textFont() function and a default size will be used unless a font is set
                         * with textSize(). Change the color of the text with the fill() function.
                         * Change the outline of the text with the stroke() and strokeWeight()
                         * functions.
                         * &lt;br&gt;&lt;br&gt;
                         * The text displays in relation to the textAlign() function, which gives the
                         * option to draw to the left, right, and center of the coordinates.
                         * &lt;br&gt;&lt;br&gt;
                         * The x2 and y2 parameters define a rectangular area to display within and
                         * may only be used with string data. When these parameters are specified,
                         * they are interpreted based on the current rectMode() setting. Text that
                         * does not fit completely within the rectangle specified will not be drawn
                         * to the screen.
                         *
                         * @method text
                         * @param {String} str the alphanumeric symbols to be displayed
                         * @param {Number} x   x-coordinate of text
                         * @param {Number} y   y-coordinate of text
                         * @param {Number} x2  by default, the width of the text box,
                         *                     see rectMode() for more info
                         * @param {Number} y2  by default, the height of the text box,
                         *                     see rectMode() for more info
                         * @return {Object} this
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * textSize(32);
                         * text(&quot;word&quot;, 10, 30);
                         * fill(0, 102, 153);
                         * text(&quot;word&quot;, 10, 60);
                         * fill(0, 102, 153, 51);
                         * text(&quot;word&quot;, 10, 90);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * s = &quot;The quick brown fox jumped over the lazy dog.&quot;;
                         * fill(50);
                         * text(s, 10, 10, 70, 80); // Text wraps within text box
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.text = function(str, x, y, maxWidth, maxHeight) {
                          var args = new Array(arguments.length);
                          for (var i = 0; i &lt; args.length; ++i) {
                            args[i] = arguments[i];
                          }
                          this._validateParameters(
                            &#x27;text&#x27;,
                            args,
                            [
                              [&#x27;*&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;],
                              [&#x27;*&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;, &#x27;Number&#x27;]
                            ]
                          );
                        
                          return (!(this._renderer._doFill || this._renderer._doStroke)) ? this :
                            this._renderer.text.apply(this._renderer, arguments);
                        };
                        
                        /**
                         * Sets the current font that will be drawn with the text() function.
                         *
                         * @method textFont
                         * @param {Object|String} f a font loaded via loadFont(), or a String
                         *  representing a browser-based dfault font.
                         * @return {Object} this
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * fill(0);
                         * textSize(12);
                         * textFont(&quot;Georgia&quot;);
                         * text(&quot;Georgia&quot;, 12, 30);
                         * textFont(&quot;Helvetica&quot;);
                         * text(&quot;Helvetica&quot;, 12, 60);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var fontRegular, fontItalic, fontBold;
                         * function preload() {
                         *    fontRegular = loadFont(&quot;assets/Regular.otf&quot;);
                         *    fontItalic = loadFont(&quot;assets/Italic.ttf&quot;);
                         *    fontBold = loadFont(&quot;assets/Bold.ttf&quot;);
                         * }
                         * function setup() {
                         *    background(210);
                         *    fill(0).strokeWeight(0).textSize(10);
                         *    textFont(fontRegular);
                         *    text(&quot;Font Style Normal&quot;, 10, 30);
                         *    textFont(fontItalic);
                         *    text(&quot;Font Style Italic&quot;, 10, 50);
                         *    textFont(fontBold);
                         *    text(&quot;Font Style Bold&quot;, 10, 70);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.textFont = function(theFont, theSize) {
                        
                          if (arguments.length) {
                        
                            if (!theFont) {
                        
                              throw Error(&#x27;null font passed to textFont&#x27;);
                            }
                        
                            this._renderer._setProperty(&#x27;_textFont&#x27;, theFont);
                        
                            if (theSize) {
                        
                              this._renderer._setProperty(&#x27;_textSize&#x27;, theSize);
                              this._renderer._setProperty(&#x27;_textLeading&#x27;,
                                theSize * constants._DEFAULT_LEADMULT);
                            }
                        
                            return this._renderer._applyTextProperties();
                          }
                        
                          return this;
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;../core/constants&quot;:47,&quot;../core/core&quot;:48,&quot;../core/error_helpers&quot;:51}],82:[function(_dereq_,module,exports){
                        /**
                         * This module defines the p5.Font class and functions for
                         * drawing text to the display canvas.
                         * @module Typography
                         * @submodule Font
                         * @requires core
                         * @requires constants
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        var constants = _dereq_(&#x27;../core/constants&#x27;);
                        
                        /*
                         * TODO:
                         *
                         * API:
                         * -- textBounds()
                         * -- getPath()
                         * -- getPoints()
                         *
                         * ===========================================
                         * -- PFont functions:
                         *    PFont.list()
                         *
                         * -- kerning
                         * -- alignment: justified?
                         * -- integrate p5.dom? (later)
                         */
                        
                        /**
                         * Base class for font handling
                         * @class p5.Font
                         * @constructor
                         * @param {Object} [pInst] pointer to p5 instance
                         */
                        p5.Font = function(p) {
                        
                          this.parent = p;
                        
                          this.cache = {};
                        
                          /**
                           * Underlying opentype font implementation
                           * @property font
                           */
                          this.font = undefined;
                        };
                        
                        p5.Font.prototype.list = function() {
                        
                          // TODO
                          throw &#x27;not yet implemented&#x27;;
                        };
                        
                        /**
                         * Returns a tight bounding box for the given text string using this
                         * font (currently only supports single lines)
                         *
                         * @method textBounds
                         * @param  {String} line     a line of text
                         * @param  {Number} x        x-position
                         * @param  {Number} y        y-position
                         * @param  {Number} fontSize font size to use (optional)
                         * @param  {Object} options opentype options (optional)
                         *
                         * @return {Object}          a rectangle object with properties: x, y, w, h
                         *
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var font;
                         * var textString = &#x27;Lorem ipsum dolor sit amet.&#x27;;
                         * function preload() {
                         *    font = loadFont(&#x27;./assets/Regular.otf&#x27;);
                         * };
                         * function setup() {
                         *    background(210);
                         *
                         *    var bbox = font.textBounds(textString, 10, 30, 12);
                         *    fill(255);
                         *    stroke(0);
                         *    rect(bbox.x, bbox.y, bbox.w, bbox.h);
                         *    fill(0);
                         *    noStroke();
                         *
                         *    textFont(font);
                         *    textSize(12);
                         *    text(textString, 10, 30);
                         * };
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.Font.prototype.textBounds = function(str, x, y, fontSize, options) {
                        
                          x = x !== undefined ? x : 0;
                          y = y !== undefined ? y : 0;
                          fontSize = fontSize || this.parent._renderer._textSize;
                        
                          var result = this.cache[cacheKey(&#x27;textBounds&#x27;, str, x, y, fontSize)];
                          if (!result) {
                        
                            var xCoords = [], yCoords = [], self = this,
                              scale = this._scale(fontSize), minX, minY, maxX, maxY;
                        
                            this.font.forEachGlyph(str, x, y, fontSize, options,
                              function(glyph, gX, gY, gFontSize) {
                        
                                xCoords.push(gX);
                                yCoords.push(gY);
                        
                                var gm = glyph.getMetrics();
                        
                                if (glyph.name !== &#x27;space&#x27;) {
                        
                                  xCoords.push(gX + (gm.xMax * scale));
                                  yCoords.push(gY + (-gm.yMin * scale));
                                  yCoords.push(gY + (-gm.yMax * scale));
                        
                                } else { // NOTE: deals with broken metrics for spaces in opentype.js
                        
                                  xCoords.push(gX + self.font.charToGlyph(&#x27; &#x27;).advanceWidth *
                                    self._scale(fontSize));
                                }
                              });
                        
                            minX = Math.max(0, Math.min.apply(null, xCoords));
                            minY = Math.max(0, Math.min.apply(null, yCoords));
                            maxX = Math.max(0, Math.max.apply(null, xCoords));
                            maxY = Math.max(0, Math.max.apply(null, yCoords));
                        
                            result = {
                              x: minX,
                              y: minY,
                              h: maxY - minY,
                              w: maxX - minX,
                              advance: minX - x
                            };
                        
                            this.cache[cacheKey(&#x27;textBounds&#x27;, str, x, y, fontSize)] = result;
                          }
                          //else console.log(&#x27;cache-hit&#x27;);
                        
                          return result;
                        };
                        
                        
                        /**
                         * Computes an array of points following the path for specified text
                         *
                         * @param  {String} txt     a line of text
                         * @param  {Number} x        x-position
                         * @param  {Number} y        y-position
                         * @param  {Number} fontSize font size to use (optional)
                         * @param  {Object} options  an (optional) object that can contain:
                         *
                         * &lt;br&gt;sampleFactor - the ratio of path-length to number of samples
                         * (default=.25); higher values yield more points and are therefore
                         * more precise
                         *
                         * &lt;br&gt;simplifyThreshold - if set to a non-zero value, collinear points will be
                         * be removed from the polygon; the value represents the threshold angle to use
                         * when determining whether two edges are collinear
                         *
                         * @return {Array}  an array of points, each with x, y, alpha (the path angle)
                         */
                        p5.Font.prototype.textToPoints = function(txt, x, y, fontSize, options) {
                        
                          var xoff = 0, result = [], glyphs = this._getGlyphs(txt);
                        
                          fontSize = fontSize || this.parent._renderer._textSize;
                        
                          for (var i = 0; i &lt; glyphs.length; i++) {
                        
                            var gpath = glyphs[i].getPath(x, y, fontSize),
                              paths = splitPaths(gpath.commands);
                        
                            for (var j = 0; j &lt; paths.length; j++) {
                        
                              var pts = pathToPoints(paths[j], options);
                        
                              for (var k = 0; k &lt; pts.length; k++) {
                                pts[k].x += xoff;
                                result.push(pts[k]);
                              }
                            }
                        
                            xoff += glyphs[i].advanceWidth * this._scale(fontSize);
                          }
                        
                          return result;
                        };
                        
                        // ----------------------------- End API ------------------------------
                        
                        /**
                         * Returns the set of opentype glyphs for the supplied string.
                         *
                         * Note that there is not a strict one-to-one mapping between characters
                         * and glyphs, so the list of returned glyphs can be larger or smaller
                         *  than the length of the given string.
                         *
                         * @param  {String} str the string to be converted
                         * @return {array}     the opentype glyphs
                         */
                        p5.Font.prototype._getGlyphs = function(str) {
                        
                          return this.font.stringToGlyphs(str);
                        };
                        
                        /**
                         * Returns an opentype path for the supplied string and position.
                         *
                         * @param  {String} line     a line of text
                         * @param  {Number} x        x-position
                         * @param  {Number} y        y-position
                         * @param  {Object} options opentype options (optional)
                         * @return {Object}     the opentype path
                         */
                        p5.Font.prototype._getPath = function(line, x, y, options) {
                        
                          var p = this.parent,
                            ctx = p._renderer.drawingContext,
                            pos = this._handleAlignment(p, ctx, line, x, y);
                        
                          return this.font.getPath(line, pos.x, pos.y, p._renderer._textSize, options);
                        };
                        
                        /*
                         * Creates an SVG-formatted path-data string
                         * (See http://www.w3.org/TR/SVG/paths.html#PathData)
                         * from the given opentype path or string/position
                         *
                         * @param  {Object} path    an opentype path, OR the following:
                         *
                         * @param  {String} line     a line of text
                         * @param  {Number} x        x-position
                         * @param  {Number} y        y-position
                         * @param  {Object} options opentype options (optional), set options.decimals
                         * to set the decimal precision of the path-data
                         *
                         * @return {Object}     this p5.Font object
                         */
                        p5.Font.prototype._getPathData = function(line, x, y, options) {
                        
                          var decimals = 3;
                        
                          // create path from string/position
                          if (typeof line === &#x27;string&#x27; &amp;&amp; arguments.length &gt; 2) {
                        
                            line = this._getPath(line, x, y, options);
                          }
                          // handle options specified in 2nd arg
                          else if (typeof x === &#x27;object&#x27;) {
                        
                            options = x;
                          }
                        
                          // handle svg arguments
                          if (options &amp;&amp; typeof options.decimals === &#x27;number&#x27;) {
                        
                            decimals = options.decimals;
                          }
                        
                          return line.toPathData(decimals);
                        };
                        
                        /*
                         * Creates an SVG &lt;path&gt; element, as a string,
                         * from the given opentype path or string/position
                         *
                         * @param  {Object} path    an opentype path, OR the following:
                         *
                         * @param  {String} line     a line of text
                         * @param  {Number} x        x-position
                         * @param  {Number} y        y-position
                         * @param  {Object} options opentype options (optional), set options.decimals
                         * to set the decimal precision of the path-data in the &lt;path&gt; element,
                         *  options.fill to set the fill color for the &lt;path&gt; element,
                         *  options.stroke to set the stroke color for the &lt;path&gt; element,
                         *  options.strokeWidth to set the strokeWidth for the &lt;path&gt; element.
                         *
                         * @return {Object}     this p5.Font object
                         */
                        p5.Font.prototype._getSVG = function(line, x, y, options) {
                        
                          var decimals = 3;
                        
                          // create path from string/position
                          if (typeof line === &#x27;string&#x27; &amp;&amp; arguments.length &gt; 2) {
                        
                            line = this._getPath(line, x, y, options);
                          }
                          // handle options specified in 2nd arg
                          else if (typeof x === &#x27;object&#x27;) {
                        
                            options = x;
                          }
                        
                          // handle svg arguments
                          if (options) {
                            if (typeof options.decimals === &#x27;number&#x27;) {
                              decimals = options.decimals;
                            }
                            if (typeof options.strokeWidth === &#x27;number&#x27;) {
                              line.strokeWidth = options.strokeWidth;
                            }
                            if (typeof options.fill !== &#x27;undefined&#x27;) {
                              line.fill = options.fill;
                            }
                            if (typeof options.stroke !== &#x27;undefined&#x27;) {
                              line.stroke = options.stroke;
                            }
                          }
                        
                          return line.toSVG(decimals);
                        };
                        
                        /*
                         * Renders an opentype path or string/position
                         * to the current graphics context
                         *
                         * @param  {Object} path    an opentype path, OR the following:
                         *
                         * @param  {String} line     a line of text
                         * @param  {Number} x        x-position
                         * @param  {Number} y        y-position
                         * @param  {Object} options opentype options (optional)
                         *
                         * @return {Object}     this p5.Font object
                         */
                        p5.Font.prototype._renderPath = function(line, x, y, options) {
                        
                          var pdata, pg = (options &amp;&amp; options.renderer) || this.parent._renderer,
                            ctx = pg.drawingContext;
                        
                          if (typeof line === &#x27;object&#x27; &amp;&amp; line.commands) {
                        
                            pdata = line.commands;
                          } else {
                        
                            //pos = handleAlignment(p, ctx, line, x, y);
                            pdata = this._getPath(line, x, y, pg._textSize, options).commands;
                          }
                        
                          ctx.beginPath();
                          for (var i = 0; i &lt; pdata.length; i += 1) {
                        
                            var cmd = pdata[i];
                            if (cmd.type === &#x27;M&#x27;) {
                              ctx.moveTo(cmd.x, cmd.y);
                            } else if (cmd.type === &#x27;L&#x27;) {
                              ctx.lineTo(cmd.x, cmd.y);
                            } else if (cmd.type === &#x27;C&#x27;) {
                              ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                            } else if (cmd.type === &#x27;Q&#x27;) {
                              ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
                            } else if (cmd.type === &#x27;Z&#x27;) {
                              ctx.closePath();
                            }
                          }
                        
                          // only draw stroke if manually set by user
                          if (pg._doStroke &amp;&amp; pg._strokeSet) {
                        
                            ctx.stroke();
                          }
                        
                          if (pg._doFill) {
                        
                            // if fill hasn&#x27;t been set by user, use default-text-fill
                            ctx.fillStyle = pg._fillSet ? ctx.fillStyle : constants._DEFAULT_TEXT_FILL;
                            ctx.fill();
                          }
                        
                          return this;
                        };
                        
                        p5.Font.prototype._textWidth = function(str, fontSize) {
                        
                          if (str === &#x27; &#x27;) { // special case for now
                        
                            return this.font.charToGlyph(&#x27; &#x27;).advanceWidth * this._scale(fontSize);
                          }
                        
                          var bounds = this.textBounds(str, 0, 0, fontSize);
                          return bounds.w + bounds.advance;
                        };
                        
                        p5.Font.prototype._textAscent = function(fontSize) {
                        
                          return this.font.ascender * this._scale(fontSize);
                        };
                        
                        p5.Font.prototype._textDescent = function(fontSize) {
                        
                          return -this.font.descender * this._scale(fontSize);
                        };
                        
                        p5.Font.prototype._scale = function(fontSize) {
                        
                          return (1 / this.font.unitsPerEm) * (fontSize ||
                            this.parent._renderer._textSize);
                        };
                        
                        p5.Font.prototype._handleAlignment = function(p, ctx, line, x, y) {
                        
                          var textWidth = this._textWidth(line),
                            textAscent = this._textAscent(),
                            textDescent = this._textDescent(),
                            textHeight = textAscent + textDescent;
                        
                          if (ctx.textAlign === constants.CENTER) {
                            x -= textWidth / 2;
                          } else if (ctx.textAlign === constants.RIGHT) {
                            x -= textWidth;
                          }
                        
                          if (ctx.textBaseline === constants.TOP) {
                            y += textHeight;
                          } else if (ctx.textBaseline === constants._CTX_MIDDLE) {
                            y += textHeight / 2 - textDescent;
                          } else if (ctx.textBaseline === constants.BOTTOM) {
                            y -= textDescent;
                          }
                        
                          return { x: x, y: y };
                        };
                        
                        // path-utils
                        
                        function pathToPoints(cmds, options) {
                        
                          var opts = parseOpts(options, {
                            sampleFactor: 0.1,
                            simplifyThreshold: 0,
                          });
                        
                          var len = pointAtLength(cmds,0,1), // total-length
                            t = len / (len * opts.sampleFactor),
                            pts = [];
                        
                          for (var i = 0; i &lt; len; i += t) {
                            pts.push(pointAtLength(cmds, i));
                          }
                        
                          if (opts.simplifyThreshold) {
                            /*var count = */simplify(pts, opts.simplifyThreshold);
                            //console.log(&#x27;Simplify: removed &#x27; + count + &#x27; pts&#x27;);
                          }
                        
                          return pts;
                        }
                        
                        function simplify(pts, angle) {
                        
                          angle = (typeof angle === &#x27;undefined&#x27;) ? 0 : angle;
                        
                          var num = 0;
                          for (var i = pts.length - 1; pts.length &gt; 3 &amp;&amp; i &gt;= 0; --i) {
                        
                            if (collinear(at(pts, i - 1), at(pts, i), at(pts, i + 1), angle)) {
                        
                              // Remove the middle point
                              pts.splice(i % pts.length, 1);
                              num++;
                            }
                          }
                          return num;
                        }
                        
                        function splitPaths(cmds) {
                        
                          var paths = [], current;
                          for (var i = 0; i &lt; cmds.length; i++) {
                            if (cmds[i].type === &#x27;M&#x27;) {
                              if (current) {
                                paths.push(current);
                              }
                              current = [];
                            }
                            current.push(cmdToArr(cmds[i]));
                          }
                          paths.push(current);
                        
                          return paths;
                        }
                        
                        function cmdToArr(cmd) {
                        
                          var arr = [ cmd.type ];
                          if (cmd.type === &#x27;M&#x27; || cmd.type === &#x27;L&#x27;) { // moveto or lineto
                            arr.push(cmd.x, cmd.y);
                          } else if (cmd.type === &#x27;C&#x27;) {
                            arr.push(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                          } else if (cmd.type === &#x27;Q&#x27;) {
                            arr.push(cmd.x1, cmd.y1, cmd.x, cmd.y);
                          }
                          // else if (cmd.type === &#x27;Z&#x27;) { /* no-op */ }
                          return arr;
                        }
                        
                        function parseOpts(options, defaults) {
                        
                          if (typeof options !== &#x27;object&#x27;) {
                            options = defaults;
                          }
                          else {
                            for (var key in defaults) {
                              if (typeof options[key] === &#x27;undefined&#x27;) {
                                options[key] = defaults[key];
                              }
                            }
                          }
                          return options;
                        }
                        
                        //////////////////////// Helpers ////////////////////////////
                        
                        function at(v, i) {
                          var s = v.length;
                          return v[i &lt; 0 ? i % s + s : i % s];
                        }
                        
                        function collinear(a, b, c, thresholdAngle) {
                        
                          if (!thresholdAngle) {
                            return areaTriangle(a, b, c) === 0;
                          }
                        
                          if (typeof collinear.tmpPoint1 === &#x27;undefined&#x27;) {
                            collinear.tmpPoint1 = [];
                            collinear.tmpPoint2 = [];
                          }
                        
                          var ab = collinear.tmpPoint1, bc = collinear.tmpPoint2;
                          ab.x = b.x - a.x;
                          ab.y = b.y - a.y;
                          bc.x = c.x - b.x;
                          bc.y = c.y - b.y;
                        
                          var dot = ab.x * bc.x + ab.y * bc.y,
                            magA = Math.sqrt(ab.x * ab.x + ab.y * ab.y),
                            magB = Math.sqrt(bc.x * bc.x + bc.y * bc.y),
                            angle = Math.acos(dot / (magA * magB));
                        
                          return angle &lt; thresholdAngle;
                        }
                        
                        function areaTriangle(a, b, c) {
                          return (((b[0] - a[0]) * (c[1] - a[1])) - ((c[0] - a[0]) * (b[1] - a[1])));
                        }
                        
                        // Portions of below code copyright 2008 Dmitry Baranovskiy (via MIT license)
                        
                        function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
                        
                          var t1 = 1 - t, t13 = Math.pow(t1, 3), t12 = Math.pow(t1, 2), t2 = t * t,
                            t3 = t2 * t, x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x +
                            t3 * p2x, y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y +
                            t3 * p2y, mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
                            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
                            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
                            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
                            ax = t1 * p1x + t * c1x, ay = t1 * p1y + t * c1y,
                            cx = t1 * c2x + t * p2x, cy = t1 * c2y + t * p2y,
                            alpha = (90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI);
                        
                          if (mx &gt; nx || my &lt; ny) { alpha += 180; }
                        
                          return { x: x, y: y, m: { x: mx, y: my }, n: { x: nx, y: ny },
                            start: { x: ax, y: ay }, end: { x: cx, y: cy }, alpha: alpha
                          };
                        }
                        
                        function getPointAtSegmentLength(p1x,p1y,c1x,c1y,c2x,c2y,p2x,p2y,length) {
                          return (length == null) ? bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) :
                            findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y,
                              getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
                        }
                        
                        function pointAtLength(path, length, istotal) {
                          path = path2curve(path);
                          var x, y, p, l, sp = &#x27;&#x27;, subpaths = {}, point, len = 0;
                          for (var i = 0, ii = path.length; i &lt; ii; i++) {
                            p = path[i];
                            if (p[0] === &#x27;M&#x27;) {
                              x = +p[1];
                              y = +p[2];
                            } else {
                              l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                              if (len + l &gt; length) {
                                if (!istotal) {
                                  point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5],
                                    p[6], length - len);
                                  return { x: point.x, y: point.y, alpha: point.alpha };
                                }
                              }
                              len += l;
                              x = +p[5];
                              y = +p[6];
                            }
                            sp += p.shift() + p;
                          }
                          subpaths.end = sp;
                        
                          point = istotal ? len : findDotsAtSegment
                            (x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
                        
                          if (point.alpha) {
                            point = { x: point.x, y: point.y, alpha: point.alpha };
                          }
                        
                          return point;
                        }
                        
                        function pathToAbsolute(pathArray) {
                        
                          var res = [], x = 0, y = 0, mx = 0, my = 0, start = 0;
                          if (pathArray[0][0] === &#x27;M&#x27;) {
                            x = +pathArray[0][1];
                            y = +pathArray[0][2];
                            mx = x;
                            my = y;
                            start++;
                            res[0] = [&#x27;M&#x27;, x, y];
                          }
                        
                          var dots,crz = pathArray.length===3 &amp;&amp; pathArray[0][0]===&#x27;M&#x27; &amp;&amp;
                            pathArray[1][0].toUpperCase()===&#x27;R&#x27; &amp;&amp; pathArray[2][0].toUpperCase()===&#x27;Z&#x27;;
                        
                          for (var r, pa, i = start, ii = pathArray.length; i &lt; ii; i++) {
                            res.push(r = []);
                            pa = pathArray[i];
                            if (pa[0] !== String.prototype.toUpperCase.call(pa[0])) {
                              r[0] = String.prototype.toUpperCase.call(pa[0]);
                              switch (r[0]) {
                                case &#x27;A&#x27;:
                                  r[1] = pa[1];
                                  r[2] = pa[2];
                                  r[3] = pa[3];
                                  r[4] = pa[4];
                                  r[5] = pa[5];
                                  r[6] = +(pa[6] + x);
                                  r[7] = +(pa[7] + y);
                                  break;
                                case &#x27;V&#x27;:
                                  r[1] = +pa[1] + y;
                                  break;
                                case &#x27;H&#x27;:
                                  r[1] = +pa[1] + x;
                                  break;
                                case &#x27;R&#x27;:
                                  dots = [x, y].concat(pa.slice(1));
                                  for (var j = 2, jj = dots.length; j &lt; jj; j++) {
                                    dots[j] = +dots[j] + x;
                                    dots[++j] = +dots[j] + y;
                                  }
                                  res.pop();
                                  res = res.concat(catmullRom2bezier(dots, crz));
                                  break;
                                case &#x27;M&#x27;:
                                  mx = +pa[1] + x;
                                  my = +pa[2] + y;
                                  break;
                                default:
                                  for (j = 1, jj = pa.length; j &lt; jj; j++) {
                                    r[j] = +pa[j] + ((j % 2) ? x : y);
                                  }
                              }
                            } else if (pa[0] === &#x27;R&#x27;) {
                              dots = [x, y].concat(pa.slice(1));
                              res.pop();
                              res = res.concat(catmullRom2bezier(dots, crz));
                              r = [&#x27;R&#x27;].concat(pa.slice(-2));
                            } else {
                              for (var k = 0, kk = pa.length; k &lt; kk; k++) {
                                r[k] = pa[k];
                              }
                            }
                            switch (r[0]) {
                              case &#x27;Z&#x27;:
                                x = mx;
                                y = my;
                                break;
                              case &#x27;H&#x27;:
                                x = r[1];
                                break;
                              case &#x27;V&#x27;:
                                y = r[1];
                                break;
                              case &#x27;M&#x27;:
                                mx = r[r.length - 2];
                                my = r[r.length - 1];
                                break;
                              default:
                                x = r[r.length - 2];
                                y = r[r.length - 1];
                            }
                          }
                          return res;
                        }
                        
                        function path2curve(path, path2) {
                        
                          var p = pathToAbsolute(path), p2 = path2 &amp;&amp; pathToAbsolute(path2),
                            attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null },
                            attrs2 = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null },
                        
                            processPath = function(path, d, pcom) {
                              var nx, ny, tq = { T: 1, Q: 1 };
                              if (!path) { return [&#x27;C&#x27;, d.x, d.y, d.x, d.y, d.x, d.y]; }
                              if (!(path[0] in tq)) { d.qx = d.qy = null; }
                              switch (path[0]) {
                                case &#x27;M&#x27;:
                                  d.X = path[1];
                                  d.Y = path[2];
                                  break;
                                case &#x27;A&#x27;:
                                  path = [&#x27;C&#x27;].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
                                  break;
                                case &#x27;S&#x27;:
                                  if (pcom === &#x27;C&#x27; || pcom === &#x27;S&#x27;) {
                                    nx = d.x * 2 - d.bx;
                                    ny = d.y * 2 - d.by;
                                  } else {
                                    nx = d.x;
                                    ny = d.y;
                                  }
                                  path = [&#x27;C&#x27;, nx, ny].concat(path.slice(1));
                                  break;
                                case &#x27;T&#x27;:
                                  if (pcom === &#x27;Q&#x27; || pcom === &#x27;T&#x27;) {
                                    d.qx = d.x * 2 - d.qx;
                                    d.qy = d.y * 2 - d.qy;
                                  } else {
                                    d.qx = d.x;
                                    d.qy = d.y;
                                  }
                                  path = [&#x27;C&#x27;].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                                  break;
                                case &#x27;Q&#x27;:
                                  d.qx = path[1];
                                  d.qy = path[2];
                                  path = [&#x27;C&#x27;].concat(q2c(d.x,d.y,path[1],path[2],path[3],path[4]));
                                  break;
                                case &#x27;L&#x27;:
                                  path = [&#x27;C&#x27;].concat(l2c(d.x, d.y, path[1], path[2]));
                                  break;
                                case &#x27;H&#x27;:
                                  path = [&#x27;C&#x27;].concat(l2c(d.x, d.y, path[1], d.y));
                                  break;
                                case &#x27;V&#x27;:
                                  path = [&#x27;C&#x27;].concat(l2c(d.x, d.y, d.x, path[1]));
                                  break;
                                case &#x27;Z&#x27;:
                                  path = [&#x27;C&#x27;].concat(l2c(d.x, d.y, d.X, d.Y));
                                  break;
                              }
                              return path;
                            },
                        
                            fixArc = function(pp, i) {
                              if (pp[i].length &gt; 7) {
                                pp[i].shift();
                                var pi = pp[i];
                                while (pi.length) {
                                  pcoms1[i] = &#x27;A&#x27;;
                                  if (p2) { pcoms2[i] = &#x27;A&#x27;; }
                                  pp.splice(i++, 0, [&#x27;C&#x27;].concat(pi.splice(0, 6)));
                                }
                                pp.splice(i, 1);
                                ii = Math.max(p.length, p2 &amp;&amp; p2.length || 0);
                              }
                            },
                        
                            fixM = function(path1, path2, a1, a2, i) {
                              if (path1 &amp;&amp; path2 &amp;&amp; path1[i][0] === &#x27;M&#x27; &amp;&amp; path2[i][0] !== &#x27;M&#x27;) {
                                path2.splice(i, 0, [&#x27;M&#x27;, a2.x, a2.y]);
                                a1.bx = 0;
                                a1.by = 0;
                                a1.x = path1[i][1];
                                a1.y = path1[i][2];
                                ii = Math.max(p.length, p2 &amp;&amp; p2.length || 0);
                              }
                            },
                        
                            pcoms1 = [], // path commands of original path p
                            pcoms2 = [], // path commands of original path p2
                            pfirst = &#x27;&#x27;, // temporary holder for original path command
                            pcom = &#x27;&#x27;; // holder for previous path command of original path
                        
                          for (var i = 0, ii = Math.max(p.length, p2 &amp;&amp; p2.length || 0); i &lt; ii; i++) {
                            if (p[i]) { pfirst = p[i][0]; } // save current path command
                        
                            if (pfirst !== &#x27;C&#x27;) {
                              pcoms1[i] = pfirst; // Save current path command
                              if (i) { pcom = pcoms1[i - 1]; } // Get previous path command pcom
                            }
                            p[i] = processPath(p[i], attrs, pcom);
                        
                            if (pcoms1[i] !== &#x27;A&#x27; &amp;&amp; pfirst === &#x27;C&#x27;) { pcoms1[i] = &#x27;C&#x27;; }
                        
                            fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1
                        
                            if (p2) { // the same procedures is done to p2
                              if (p2[i]) { pfirst = p2[i][0]; }
                              if (pfirst !== &#x27;C&#x27;) {
                                pcoms2[i] = pfirst;
                                if (i) { pcom = pcoms2[i - 1]; }
                              }
                              p2[i] = processPath(p2[i], attrs2, pcom);
                        
                              if (pcoms2[i] !== &#x27;A&#x27; &amp;&amp; pfirst === &#x27;C&#x27;) { pcoms2[i] = &#x27;C&#x27;; }
                        
                              fixArc(p2, i);
                            }
                            fixM(p, p2, attrs, attrs2, i);
                            fixM(p2, p, attrs2, attrs, i);
                            var seg = p[i], seg2 = p2 &amp;&amp; p2[i], seglen = seg.length,
                              seg2len = p2 &amp;&amp; seg2.length;
                            attrs.x = seg[seglen - 2];
                            attrs.y = seg[seglen - 1];
                            attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
                            attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
                            attrs2.bx = p2 &amp;&amp; (parseFloat(seg2[seg2len - 4]) || attrs2.x);
                            attrs2.by = p2 &amp;&amp; (parseFloat(seg2[seg2len - 3]) || attrs2.y);
                            attrs2.x = p2 &amp;&amp; seg2[seg2len - 2];
                            attrs2.y = p2 &amp;&amp; seg2[seg2len - 1];
                          }
                        
                          return p2 ? [p, p2] : p;
                        }
                        
                        function a2c(x1, y1, rx, ry, angle, lac, sweep_flag, x2, y2, recursive) {
                          // for more information of where this Math came from visit:
                          // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
                          var PI = Math.PI, _120 = PI * 120 / 180, f1, f2, cx, cy,
                            rad = PI / 180 * (+angle || 0), res = [], xy,
                            rotate = function (x, y, rad) {
                              var X = x * Math.cos(rad) - y * Math.sin(rad),
                                Y = x * Math.sin(rad) + y * Math.cos(rad);
                              return { x: X, y: Y };
                            };
                          if (!recursive) {
                            xy = rotate(x1, y1, -rad);
                            x1 = xy.x;
                            y1 = xy.y;
                            xy = rotate(x2, y2, -rad);
                            x2 = xy.x;
                            y2 = xy.y;
                            var x = (x1 - x2) / 2, y = (y1 - y2) / 2,
                              h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
                            if (h &gt; 1) {
                              h = Math.sqrt(h);
                              rx = h * rx;
                              ry = h * ry;
                            }
                            var rx2 = rx * rx, ry2 = ry * ry,
                              k = (lac === sweep_flag ? -1 : 1) * Math.sqrt(Math.abs
                                ((rx2 * ry2 - rx2 * y * y - ry2 * x * x)/(rx2 * y * y + ry2 * x * x)));
                        
                            cx = k * rx * y / ry + (x1 + x2) / 2;
                            cy = k * -ry * x / rx + (y1 + y2) / 2;
                            f1 = Math.asin(((y1 - cy) / ry).toFixed(9));
                            f2 = Math.asin(((y2 - cy) / ry).toFixed(9));
                        
                            f1 = x1 &lt; cx ? PI - f1 : f1;
                            f2 = x2 &lt; cx ? PI - f2 : f2;
                        
                            if (f1 &lt; 0) { f1 = PI * 2 + f1; }
                            if (f2 &lt; 0) { f2 = PI * 2 + f2; }
                        
                            if (sweep_flag &amp;&amp; f1 &gt; f2) {
                              f1 = f1 - PI * 2;
                            }
                            if (!sweep_flag &amp;&amp; f2 &gt; f1) {
                              f2 = f2 - PI * 2;
                            }
                          } else {
                            f1 = recursive[0];
                            f2 = recursive[1];
                            cx = recursive[2];
                            cy = recursive[3];
                          }
                          var df = f2 - f1;
                          if (Math.abs(df) &gt; _120) {
                            var f2old = f2, x2old = x2, y2old = y2;
                            f2 = f1 + _120 * (sweep_flag &amp;&amp; f2 &gt; f1 ? 1 : -1);
                            x2 = cx + rx * Math.cos(f2);
                            y2 = cy + ry * Math.sin(f2);
                            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old,
                              [f2, f2old, cx, cy]);
                          }
                          df = f2 - f1;
                          var c1 = Math.cos(f1),
                            s1 = Math.sin(f1),
                            c2 = Math.cos(f2),
                            s2 = Math.sin(f2),
                            t = Math.tan(df / 4),
                            hx = 4 / 3 * rx * t,
                            hy = 4 / 3 * ry * t,
                            m1 = [x1, y1],
                            m2 = [x1 + hx * s1, y1 - hy * c1],
                            m3 = [x2 + hx * s2, y2 - hy * c2],
                            m4 = [x2, y2];
                          m2[0] = 2 * m1[0] - m2[0];
                          m2[1] = 2 * m1[1] - m2[1];
                          if (recursive) {
                            return [m2, m3, m4].concat(res);
                          } else {
                            res = [m2, m3, m4].concat(res).join().split(&#x27;,&#x27;);
                            var newres = [];
                            for (var i = 0, ii = res.length; i &lt; ii; i++) {
                              newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i],
                                res[i + 1], rad).x;
                            }
                            return newres;
                          }
                        }
                        
                        // http://schepers.cc/getting-to-the-point
                        function catmullRom2bezier(crp, z) {
                          var d = [];
                          for (var i = 0, iLen = crp.length; iLen - 2 * !z &gt; i; i += 2) {
                            var p = [{
                              x: +crp[i - 2],
                              y: +crp[i - 1]
                            }, {
                              x: +crp[i],
                              y: +crp[i + 1]
                            }, {
                              x: +crp[i + 2],
                              y: +crp[i + 3]
                            }, {
                              x: +crp[i + 4],
                              y: +crp[i + 5]
                            }];
                            if (z) {
                              if (!i) {
                                p[0] = {
                                  x: +crp[iLen - 2],
                                  y: +crp[iLen - 1]
                                };
                              } else if (iLen - 4 === i) {
                                p[3] = {
                                  x: +crp[0],
                                  y: +crp[1]
                                };
                              } else if (iLen - 2 === i) {
                                p[2] = {
                                  x: +crp[0],
                                  y: +crp[1]
                                };
                                p[3] = {
                                  x: +crp[2],
                                  y: +crp[3]
                                };
                              }
                            } else {
                              if (iLen - 4 === i) {
                                p[3] = p[2];
                              } else if (!i) {
                                p[0] = {
                                  x: +crp[i],
                                  y: +crp[i + 1]
                                };
                              }
                            }
                            d.push([&#x27;C&#x27;, (-p[0].x + 6 * p[1].x + p[2].x) / 6, (-p[0].y + 6 * p[1].y +
                              p[2].y) / 6, (p[1].x + 6 * p[2].x - p[3].x) / 6, (p[1].y + 6 * p[2].y -
                              p[3].y) / 6, p[2].x, p[2].y ]);
                          }
                        
                          return d;
                        }
                        
                        function l2c(x1, y1, x2, y2) { return [x1, y1, x2, y2, x2, y2]; }
                        
                        function q2c(x1, y1, ax, ay, x2, y2) {
                          var _13 = 1 / 3, _23 = 2 / 3;
                          return [
                            _13 * x1 + _23 * ax, _13 * y1 + _23 * ay,
                            _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2
                          ];
                        }
                        
                        function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
                          if (z == null) { z = 1; }
                          z = z &gt; 1 ? 1 : z &lt; 0 ? 0 : z;
                          var z2 = z / 2,
                            n = 12, Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873,
                               -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816],
                            sum = 0, Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032,
                              0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472 ];
                          for (var i = 0; i &lt; n; i++) {
                            var ct = z2 * Tvalues[i] + z2,
                              xbase = base3(ct, x1, x2, x3, x4),
                              ybase = base3(ct, y1, y2, y3, y4),
                              comb = xbase * xbase + ybase * ybase;
                            sum += Cvalues[i] * Math.sqrt(comb);
                          }
                          return z2 * sum;
                        }
                        
                        function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
                          if (ll &lt; 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) &lt; ll) {
                            return;
                          }
                          var t = 1, step = t / 2, t2 = t - step, l, e = 0.01;
                          l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
                          while (Math.abs(l - ll) &gt; e) {
                            step /= 2;
                            t2 += (l &lt; ll ? 1 : -1) * step;
                            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
                          }
                          return t2;
                        }
                        
                        function base3(t, p1, p2, p3, p4) {
                          var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
                            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
                          return t * t2 - 3 * p1 + 3 * p2;
                        }
                        
                        function cacheKey() {
                          var args = new Array(arguments.length);
                          for (var i = 0; i &lt; args.length; ++i) {
                            args[i] = arguments[i];
                          }
                          i = args.length;
                          var hash = &#x27;&#x27;;
                          while (i--) {
                            hash += (args[i] === Object(args[i])) ?
                              JSON.stringify(args[i]) : args[i];
                          }
                          return hash;
                        }
                        
                        module.exports = p5.Font;
                        
                        },{&quot;../core/constants&quot;:47,&quot;../core/core&quot;:48}],83:[function(_dereq_,module,exports){
                        /**
                         * @module Data
                         * @submodule Array Functions
                         * @for p5
                         * @requires core
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        
                        /**
                         * Adds a value to the end of an array. Extends the length of
                         * the array by one. Maps to Array.push().
                         *
                         * @method append
                         * @param {Array} array Array to append
                         * @param {any} value to be added to the Array
                         * @example
                         * &lt;div class = &quot;norender&quot;&gt;&lt;code&gt;
                         * function setup() {
                         *
                         * var myArray = new Array(&quot;Mango&quot;, &quot;Apple&quot;, &quot;Papaya&quot;)
                         * print(myArray) // [&quot;Mango&quot;, &quot;Apple&quot;, &quot;Papaya&quot;]
                         *
                         * append(myArray, &quot;Peach&quot;)
                         * print(myArray) // [&quot;Mango&quot;, &quot;Apple&quot;, &quot;Papaya&quot;, &quot;Peach&quot;]
                         *
                         * }
                         * &lt;/div&gt;&lt;/code&gt;
                         */
                        p5.prototype.append = function(array, value) {
                          array.push(value);
                          return array;
                        };
                        
                        /**
                         * Copies an array (or part of an array) to another array. The src array is
                         * copied to the dst array, beginning at the position specified by
                         * srcPosition and into the position specified by dstPosition. The number of
                         * elements to copy is determined by length. Note that copying values
                         * overwrites existing values in the destination array. To append values
                         * instead of overwriting them, use concat().
                         * &lt;br&gt;&lt;br&gt;
                         * The simplified version with only two arguments, arrayCopy(src, dst),
                         * copies an entire array to another of the same size. It is equivalent to
                         * arrayCopy(src, 0, dst, 0, src.length).
                         * &lt;br&gt;&lt;br&gt;
                         * Using this function is far more efficient for copying array data than
                         * iterating through a for() loop and copying each element individually.
                         *
                         * @method arrayCopy
                         * @param {Array}  src           the source Array
                         * @param {Number} [srcPosition] starting position in the source Array
                         * @param {Array}  dst           the destination Array
                         * @param {Number} [dstPosition] starting position in the destination Array
                         * @param {Nimber} [length]      number of Array elements to be copied
                         *
                         * @example
                         *  &lt;div class=&quot;norender&quot;&gt;&lt;code&gt;
                         *  function setup() {
                         *
                         *    var src = new Array(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);
                         *    var dst = new Array( 1 ,  2 ,  3 );
                         *    var srcPosition = 1;
                         *    var dstPosition = 0;
                         *    var length = 2;
                         *
                         *    print(src); // [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]
                         *    print(dst); // [ 1 ,  2 ,  3 ]
                         *
                         *    arrayCopy(src, srcPosition, dst, dstPosition, length);
                         *    print(dst); // [&quot;B&quot;, &quot;C&quot;, 3]
                         *
                         *    }
                         *  &lt;/div&gt;&lt;/code&gt;
                         */
                        p5.prototype.arrayCopy = function(
                          src,
                          srcPosition,
                          dst,
                          dstPosition,
                          length) {
                        
                          // the index to begin splicing from dst array
                          var start,
                              end;
                        
                          if (typeof length !== &#x27;undefined&#x27;) {
                        
                            end = Math.min(length, src.length);
                            start = dstPosition;
                            src = src.slice(srcPosition, end + srcPosition);
                        
                          } else {
                        
                            if (typeof dst !== &#x27;undefined&#x27;) { // src, dst, length
                              // rename  so we don&#x27;t get confused
                              end = dst;
                              end = Math.min(end, src.length);
                            } else { // src, dst
                              end = src.length;
                            }
                        
                            start = 0;
                            // rename  so we don&#x27;t get confused
                            dst = srcPosition;
                            src = src.slice(0, end);
                          }
                        
                          // Since we are not returning the array and JavaScript is pass by reference
                          // we must modify the actual values of the array
                          // instead of reassigning arrays
                          Array.prototype.splice.apply(dst, [start, end].concat(src));
                        
                        };
                        
                        /**
                         * Concatenates two arrays, maps to Array.concat(). Does not modify the
                         * input arrays.
                         *
                         * @method concat
                         * @param {Array} a first Array to concatenate
                         * @param {Array} b second Array to concatenate
                         * @return {Array} concatenated array
                         *
                         * @example
                         * &lt;div class = &quot;norender&quot;&gt;&lt;code&gt;
                         * function setup() {
                         *   var arr1 = new Array(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);
                         *   var arr2 = new Array( 1 ,  2 ,  3 );
                         *
                         *   print(arr1); // [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]
                         *   print(arr2); // [1,2,3]
                         *
                         *   var arr3 = concat(arr1, arr2);
                         *
                         *   print(arr1); // [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]
                         *   print(arr2); // [1,2,3]
                         *   print(arr3); // [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,1,2,3]
                         *
                         * }
                         * &lt;/div&gt;&lt;/code&gt;
                         */
                        p5.prototype.concat = function(list0, list1) {
                          return list0.concat(list1);
                        };
                        
                        /**
                         * Reverses the order of an array, maps to Array.reverse()
                         *
                         * @method reverse
                         * @param {Array} list Array to reverse
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;&lt;code&gt;
                         * function setup() {
                         *   var myArray = new Array(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);
                         *   print(myArray); // [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]
                         *
                         *   reverse(myArray);
                         *   print(myArray); // [&quot;C&quot;,&quot;B&quot;,&quot;A&quot;]
                         * }
                         * &lt;/div&gt;&lt;/code&gt;
                         */
                        p5.prototype.reverse = function(list) {
                          return list.reverse();
                        };
                        
                        /**
                         * Decreases an array by one element and returns the shortened array,
                         * maps to Array.pop().
                         *
                         * @method shorten
                         * @param  {Array} list Array to shorten
                         * @return {Array} shortened Array
                         * @example
                         * &lt;div class = &quot;norender&quot;&gt;&lt;code&gt;
                         * function setup() {
                         *   var myArray = new Array(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);
                         *   print(myArray); // [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]
                         *
                         *   var newArray = shorten(myArray);
                         *   print(myArray); // [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]
                         *   print(newArray); // [&quot;A&quot;,&quot;B&quot;]
                         * }
                         * &lt;/div&gt;&lt;/code&gt;
                         */
                        p5.prototype.shorten = function(list) {
                          list.pop();
                          return list;
                        };
                        
                        /**
                         * Randomizes the order of the elements of an array. Implements
                         * &lt;a href=&quot;http://Bost.Ocks.org/mike/shuffle/&quot; target=_blank&gt;
                         * Fisher-Yates Shuffle Algorithm&lt;/a&gt;.
                         *
                         * @method shuffle
                         * @param  {Array}   array  Array to shuffle
                         * @param  {Boolean} [bool] modify passed array
                         * @return {Array}   shuffled Array
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * function setup() {
                         *   var regularArr = [&#x27;ABC&#x27;, &#x27;def&#x27;, createVector(), TAU, Math.E];
                         *   print(regularArr);
                         *   shuffle(regularArr, true); // force modifications to passed array
                         *   print(regularArr);
                         *
                         *   // By default shuffle() returns a shuffled cloned array:
                         *   var newArr = shuffle(regularArr);
                         *   print(regularArr);
                         *   print(newArr);
                         * }
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.shuffle = function(arr, bool) {
                          var isView = ArrayBuffer &amp;&amp; ArrayBuffer.isView &amp;&amp; ArrayBuffer.isView(arr);
                          arr = bool || isView ? arr : arr.slice();
                        
                          var rnd, tmp, idx = arr.length;
                          while (idx &gt; 1) {
                            rnd = Math.random()*idx | 0;
                        
                            tmp = arr[--idx];
                            arr[idx] = arr[rnd];
                            arr[rnd] = tmp;
                          }
                        
                          return arr;
                        };
                        
                        /**
                         * Sorts an array of numbers from smallest to largest, or puts an array of
                         * words in alphabetical order. The original array is not modified; a
                         * re-ordered array is returned. The count parameter states the number of
                         * elements to sort. For example, if there are 12 elements in an array and
                         * count is set to 5, only the first 5 elements in the array will be sorted.
                         *
                         * @method sort
                         * @param {Array} list Array to sort
                         * @param {Number} [count] number of elements to sort, starting from 0
                         *
                         * @example
                         * &lt;div class = &quot;norender&quot;&gt;&lt;code&gt;
                         * function setup() {
                         *   var words = new Array(&quot;banana&quot;, &quot;apple&quot;, &quot;pear&quot;,&quot;lime&quot;);
                         *   print(words); // [&quot;banana&quot;, &quot;apple&quot;, &quot;pear&quot;, &quot;lime&quot;]
                         *   var count = 4; // length of array
                         *
                         *   sort(words, count);
                         *   print(words); // [&quot;apple&quot;, &quot;banana&quot;, &quot;lime&quot;, &quot;pear&quot;]
                         * }
                         * &lt;/div&gt;&lt;/code&gt;
                         * &lt;div class = &quot;norender&quot;&gt;&lt;code&gt;
                         * function setup() {
                         *   var numbers = new Array(2,6,1,5,14,9,8,12);
                         *   print(numbers); // [2,6,1,5,14,9,8,12]
                         *   var count = 5; // Less than the length of the array
                         *
                         *   sort(numbers, count);
                         *   print(numbers); // [1,2,5,6,14,9,8,12]
                         * }
                         * &lt;/div&gt;&lt;/code&gt;
                         */
                        p5.prototype.sort = function(list, count) {
                          var arr = count ? list.slice(0, Math.min(count, list.length)) : list;
                          var rest = count ? list.slice(Math.min(count, list.length)) : [];
                          if (typeof arr[0] === &#x27;string&#x27;) {
                            arr = arr.sort();
                          } else {
                            arr = arr.sort(function(a,b){return a-b;});
                          }
                          return arr.concat(rest);
                        };
                        
                        /**
                         * Inserts a value or an array of values into an existing array. The first
                         * parameter specifies the initial array to be modified, and the second
                         * parameter defines the data to be inserted. The third parameter is an index
                         * value which specifies the array position from which to insert data.
                         * (Remember that array index numbering starts at zero, so the first position
                         * is 0, the second position is 1, and so on.)
                         *
                         * @method splice
                         * @param {Array}  list Array to splice into
                         * @param {any}    value value to be spliced in
                         * @param {Number} position in the array from which to insert data
                         *
                         * @example
                         * &lt;div class = &quot;norender&quot;&gt;&lt;code&gt;
                         * function setup() {
                         *   var myArray = new Array(0,1,2,3,4);
                         *   var insArray = new Array(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;);
                         *   print(myArray); // [0,1,2,3,4]
                         *   print(insArray); // [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]
                         *
                         *   splice(myArray, insArray, 3);
                         *   print(myArray); // [0,1,2,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,3,4]
                         * }
                         * &lt;/div&gt;&lt;/code&gt;
                         */
                        p5.prototype.splice = function(list, value, index) {
                        
                          // note that splice returns spliced elements and not an array
                          Array.prototype.splice.apply(list, [index, 0].concat(value));
                        
                          return list;
                        };
                        
                        /**
                         * Extracts an array of elements from an existing array. The list parameter
                         * defines the array from which the elements will be copied, and the start
                         * and count parameters specify which elements to extract. If no count is
                         * given, elements will be extracted from the start to the end of the array.
                         * When specifying the start, remember that the first array element is 0.
                         * This function does not change the source array.
                         *
                         * @method subset
                         * @param  {Array}  list    Array to extract from
                         * @param  {Number} start   position to begin
                         * @param  {Number} [count] number of values to extract
                         * @return {Array}          Array of extracted elements
                         *
                         * @example
                         * &lt;div class = &quot;norender&quot;&gt;&lt;code&gt;
                         * function setup() {
                         *   var myArray = new Array(1,2,3,4,5);
                         *   print(myArray); // [1,2,3,4,5]
                         *
                         *   var sub1 = subset(myArray, 0, 3);
                         *   var sub2 = subset(myArray, 2, 2);
                         *   print(sub1); // [1,2,3]
                         *   print(sub2); // [3,4]
                         * }
                         * &lt;/div&gt;&lt;/code&gt;
                         */
                        p5.prototype.subset = function(list, start, count) {
                          if (typeof count !== &#x27;undefined&#x27;) {
                            return list.slice(start, start + count);
                          } else {
                            return list.slice(start, list.length);
                          }
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;../core/core&quot;:48}],84:[function(_dereq_,module,exports){
                        /**
                         * @module Data
                         * @submodule Conversion
                         * @for p5
                         * @requires core
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        
                        /**
                         * Converts a string to its floating point representation. The contents of a
                         * string must resemble a number, or NaN (not a number) will be returned.
                         * For example, float(&quot;1234.56&quot;) evaluates to 1234.56, but float(&quot;giraffe&quot;)
                         * will return NaN.
                         *
                         * @method float
                         * @param {String}  str float string to parse
                         * @return {Number}     floating point representation of string
                         * @example
                         * &lt;div&gt;&lt;code&gt;
                         * var str = &#x27;20&#x27;;
                         * var diameter = float(str);
                         * ellipse(width/2, height/2, diameter, diameter);
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.float = function(str) {
                          return parseFloat(str);
                        };
                        
                        /**
                         * Converts a boolean, string, or float to its integer representation.
                         * When an array of values is passed in, then an int array of the same length
                         * is returned.
                         *
                         * @method int
                         * @param {String|Boolean|Number|Array} n value to parse
                         * @return {Number}                     integer representation of value
                         * @example
                         * &lt;div class=&#x27;norender&#x27;&gt;&lt;code&gt;
                         * print(int(&quot;10&quot;)); // 10
                         * print(int(10.31)); // 10
                         * print(int(-10)); // -10
                         * print(int(true)); // 1
                         * print(int(false)); // 0
                         * print(int([false, true, &quot;10.3&quot;, 9.8])); // [0, 1, 10, 9]
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.int = function(n, radix) {
                          if (typeof n === &#x27;string&#x27;) {
                            radix = radix || 10;
                            return parseInt(n, radix);
                          } else if (typeof n === &#x27;number&#x27;) {
                            return n | 0;
                          } else if (typeof n === &#x27;boolean&#x27;) {
                            return n ? 1 : 0;
                          } else if (n instanceof Array) {
                            return n.map(function(n) { return p5.prototype.int(n, radix); });
                          }
                        };
                        
                        /**
                         * Converts a boolean, string or number to its string representation.
                         * When an array of values is passed in, then an array of strings of the same
                         * length is returned.
                         *
                         * @method str
                         * @param {String|Boolean|Number|Array} n value to parse
                         * @return {String}                     string representation of value
                         * @example
                         * &lt;div class=&#x27;norender&#x27;&gt;&lt;code&gt;
                         * print(str(&quot;10&quot;));  // &quot;10&quot;
                         * print(str(10.31)); // &quot;10.31&quot;
                         * print(str(-10));   // &quot;-10&quot;
                         * print(str(true));  // &quot;true&quot;
                         * print(str(false)); // &quot;false&quot;
                         * print(str([true, &quot;10.3&quot;, 9.8])); // [ &quot;true&quot;, &quot;10.3&quot;, &quot;9.8&quot; ]
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.str = function(n) {
                          if (n instanceof Array) {
                            return n.map(p5.prototype.str);
                          } else {
                            return String(n);
                          }
                        };
                        
                        /**
                         * Converts a number or string to its boolean representation.
                         * For a number, any non-zero value (positive or negative) evaluates to true,
                         * while zero evaluates to false. For a string, the value &quot;true&quot; evaluates to
                         * true, while any other value evaluates to false. When an array of number or
                         * string values is passed in, then a array of booleans of the same length is
                         * returned.
                         *
                         * @method boolean
                         * @param {String|Boolean|Number|Array} n value to parse
                         * @return {Boolean}                    boolean representation of value
                         * @example
                         * &lt;div class=&#x27;norender&#x27;&gt;&lt;code&gt;
                         * print(boolean(0));               // false
                         * print(boolean(1));               // true
                         * print(boolean(&quot;true&quot;));          // true
                         * print(boolean(&quot;abcd&quot;));          // false
                         * print(boolean([0, 12, &quot;true&quot;])); // [false, true, false]
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.boolean = function(n) {
                          if (typeof n === &#x27;number&#x27;) {
                            return n !== 0;
                          } else if (typeof n === &#x27;string&#x27;) {
                            return n.toLowerCase() === &#x27;true&#x27;;
                          } else if (typeof n === &#x27;boolean&#x27;) {
                            return n;
                          } else if (n instanceof Array) {
                            return n.map(p5.prototype.boolean);
                          }
                        };
                        
                        /**
                         * Converts a number, string or boolean to its byte representation.
                         * A byte can be only a whole number between -128 and 127, so when a value
                         * outside of this range is converted, it wraps around to the corresponding
                         * byte representation. When an array of number, string or boolean values is
                         * passed in, then an array of bytes the same length is returned.
                         *
                         * @method byte
                         * @param {String|Boolean|Number|Array} n value to parse
                         * @return {Number}                     byte representation of value
                         * @example
                         * &lt;div class=&#x27;norender&#x27;&gt;&lt;code&gt;
                         * print(byte(127));               // 127
                         * print(byte(128));               // -128
                         * print(byte(23.4));              // 23
                         * print(byte(&quot;23.4&quot;));            // 23
                         * print(byte(true));              // 1
                         * print(byte([0, 255, &quot;100&quot;]));   // [0, -1, 100]
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.byte = function(n) {
                          var nn = p5.prototype.int(n, 10);
                          if (typeof nn === &#x27;number&#x27;) {
                            return ((nn + 128) % 256) - 128;
                          } else if (nn instanceof Array) {
                            return nn.map(p5.prototype.byte);
                          }
                        };
                        
                        /**
                         * Converts a number or string to its corresponding single-character
                         * string representation. If a string parameter is provided, it is first
                         * parsed as an integer and then translated into a single-character string.
                         * When an array of number or string values is passed in, then an array of
                         * single-character strings of the same length is returned.
                         *
                         * @method char
                         * @param {String|Number|Array} n value to parse
                         * @return {String}             string representation of value
                         * @example
                         * &lt;div class=&#x27;norender&#x27;&gt;&lt;code&gt;
                         * print(char(65));                     // &quot;A&quot;
                         * print(char(&quot;65&quot;));                   // &quot;A&quot;
                         * print(char([65, 66, 67]));           // [ &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ]
                         * print(join(char([65, 66, 67]), &#x27;&#x27;)); // &quot;ABC&quot;
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.char = function(n) {
                          if (typeof n === &#x27;number&#x27; &amp;&amp; !isNaN(n)) {
                            return String.fromCharCode(n);
                          } else if (n instanceof Array) {
                            return n.map(p5.prototype.char);
                          } else if (typeof n === &#x27;string&#x27;) {
                            return p5.prototype.char(parseInt(n, 10));
                          }
                        };
                        
                        /**
                         * Converts a single-character string to its corresponding integer
                         * representation. When an array of single-character string values is passed
                         * in, then an array of integers of the same length is returned.
                         *
                         * @method unchar
                         * @param {String|Array} n value to parse
                         * @return {Number}      integer representation of value
                         * @example
                         * &lt;div class=&#x27;norender&#x27;&gt;&lt;code&gt;
                         * print(unchar(&quot;A&quot;));               // 65
                         * print(unchar([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]));   // [ 65, 66, 67 ]
                         * print(unchar(split(&quot;ABC&quot;, &quot;&quot;)));  // [ 65, 66, 67 ]
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.unchar = function(n) {
                          if (typeof n === &#x27;string&#x27; &amp;&amp; n.length === 1) {
                            return n.charCodeAt(0);
                          } else if (n instanceof Array) {
                            return n.map(p5.prototype.unchar);
                          }
                        };
                        
                        /**
                         * Converts a number to a string in its equivalent hexadecimal notation. If a
                         * second parameter is passed, it is used to set the number of characters to
                         * generate in the hexadecimal notation. When an array is passed in, an
                         * array of strings in hexadecimal notation of the same length is returned.
                         *
                         * @method hex
                         * @param {Number|Array} n value to parse
                         * @return {String}      hexadecimal string representation of value
                         * @example
                         * &lt;div class=&#x27;norender&#x27;&gt;&lt;code&gt;
                         * print(hex(255));               // &quot;000000FF&quot;
                         * print(hex(255, 6));            // &quot;0000FF&quot;
                         * print(hex([0, 127, 255], 6));  // [ &quot;000000&quot;, &quot;00007F&quot;, &quot;0000FF&quot; ]
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.hex = function(n, digits) {
                          digits = (digits === undefined || digits === null) ? digits = 8 : digits;
                          if (n instanceof Array) {
                            return n.map(function(n) { return p5.prototype.hex(n, digits); });
                          } else if (typeof n === &#x27;number&#x27;) {
                            if (n &lt; 0) {
                              n = 0xFFFFFFFF + n + 1;
                            }
                            var hex = Number(n).toString(16).toUpperCase();
                            while (hex.length &lt; digits) {
                              hex = &#x27;0&#x27; + hex;
                            }
                            if (hex.length &gt;= digits) {
                              hex = hex.substring(hex.length - digits, hex.length);
                            }
                            return hex;
                          }
                        };
                        
                        /**
                         * Converts a string representation of a hexadecimal number to its equivalent
                         * integer value. When an array of strings in hexadecimal notation is passed
                         * in, an array of integers of the same length is returned.
                         *
                         * @method unhex
                         * @param {String|Array} n value to parse
                         * @return {Number}      integer representation of hexadecimal value
                         * @example
                         * &lt;div class=&#x27;norender&#x27;&gt;&lt;code&gt;
                         * print(unhex(&quot;A&quot;));                // 10
                         * print(unhex(&quot;FF&quot;));               // 255
                         * print(unhex([&quot;FF&quot;, &quot;AA&quot;, &quot;00&quot;])); // [ 255, 170, 0 ]
                         * &lt;/code&gt;&lt;/div&gt;
                         */
                        p5.prototype.unhex = function(n) {
                          if (n instanceof Array) {
                            return n.map(p5.prototype.unhex);
                          } else {
                            return parseInt(&#x27;0x&#x27; + n, 16);
                          }
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;../core/core&quot;:48}],85:[function(_dereq_,module,exports){
                        /**
                         * @module Data
                         * @submodule String Functions
                         * @for p5
                         * @requires core
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        
                        //return p5; //LM is this a mistake?
                        
                        /**
                         * Combines an array of Strings into one String, each separated by the
                         * character(s) used for the separator parameter. To join arrays of ints or
                         * floats, it&#x27;s necessary to first convert them to Strings using nf() or
                         * nfs().
                         *
                         * @method join
                         * @param  {Array}  list      array of Strings to be joined
                         * @param  {String} separator String to be placed between each item
                         * @return {String}           joined String
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var array = [&quot;Hello&quot;, &quot;world!&quot;]
                         * var separator = &quot; &quot;
                         * var message = join(array, separator);
                         * text(message, 5, 50);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.join = function(list, separator) {
                          return list.join(separator);
                        };
                        
                        /**
                         * This function is used to apply a regular expression to a piece of text,
                         * and return matching groups (elements found inside parentheses) as a
                         * String array. If there are no matches, a null value will be returned.
                         * If no groups are specified in the regular expression, but the sequence
                         * matches, an array of length 1 (with the matched text as the first element
                         * of the array) will be returned.
                         * &lt;br&gt;&lt;br&gt;
                         * To use the function, first check to see if the result is null. If the
                         * result is null, then the sequence did not match at all. If the sequence
                         * did match, an array is returned.
                         * &lt;br&gt;&lt;br&gt;
                         * If there are groups (specified by sets of parentheses) in the regular
                         * expression, then the contents of each will be returned in the array.
                         * Element [0] of a regular expression match returns the entire matching
                         * string, and the match groups start at element [1] (the first group is [1],
                         * the second [2], and so on).
                         *
                         * @method match
                         * @param  {String} str    the String to be searched
                         * @param  {String} regexp the regexp to be used for matching
                         * @return {Array}         Array of Strings found
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var string = &quot;Hello p5js*!&quot;
                         * var regexp = &quot;p5js\\*&quot;
                         * var match = match(string, regexp);
                         * text(match, 5, 50);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.match =  function(str, reg) {
                          return str.match(reg);
                        };
                        
                        /**
                         * This function is used to apply a regular expression to a piece of text,
                         * and return a list of matching groups (elements found inside parentheses)
                         * as a two-dimensional String array. If there are no matches, a null value
                         * will be returned. If no groups are specified in the regular expression,
                         * but the sequence matches, a two dimensional array is still returned, but
                         * the second dimension is only of length one.
                         * &lt;br&gt;&lt;br&gt;
                         * To use the function, first check to see if the result is null. If the
                         * result is null, then the sequence did not match at all. If the sequence
                         * did match, a 2D array is returned.
                         * &lt;br&gt;&lt;br&gt;
                         * If there are groups (specified by sets of parentheses) in the regular
                         * expression, then the contents of each will be returned in the array.
                         * Assuming a loop with counter variable i, element [i][0] of a regular
                         * expression match returns the entire matching string, and the match groups
                         * start at element [i][1] (the first group is [i][1], the second [i][2],
                         * and so on).
                         *
                         * @method matchAll
                         * @param  {String} str    the String to be searched
                         * @param  {String} regexp the regexp to be used for matching
                         * @return {Array}         2d Array of Strings found
                         * @example
                         * &lt;div class=&quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * var string = &quot;Hello p5js*! Hello world!&quot;
                         * var regexp = &quot;Hello&quot;
                         * matchAll(string, regexp);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                        
                         */
                        p5.prototype.matchAll = function(str, reg) {
                          var re = new RegExp(reg, &#x27;g&#x27;);
                          var match = re.exec(str);
                          var matches = [];
                          while (match !== null) {
                            matches.push(match);
                            // matched text: match[0]
                            // match start: match.index
                            // capturing group n: match[n]
                            match = re.exec(str);
                          }
                          return matches;
                        };
                        
                        /**
                         * Utility function for formatting numbers into strings. There are two
                         * versions: one for formatting floats, and one for formatting ints.
                         * The values for the digits, left, and right parameters should always
                         * be positive integers.
                         *
                         * @method nf
                         * @param {Number|Array} num      the Number to format
                         * @param {Number}       [left]   number of digits to the left of the
                         *                                decimal point
                         * @param {Number}       [right]  number of digits to the right of the
                         *                                decimal point
                         * @return {String|Array}         formatted String
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * function setup() {
                         *   background(200);
                         *   var num = 112.53106115;
                         *
                         *   noStroke();
                         *   fill(0);
                         *   textSize(14);
                         *   // Draw formatted numbers
                         *   text(nf(num, 5, 2), 10, 20);
                         *
                         *   text(nf(num, 4, 3), 10, 55);
                         *
                         *   text(nf(num, 3, 6), 10, 85);
                         *
                         *   // Draw dividing lines
                         *   stroke(120);
                         *   line(0, 30, width, 30);
                         *   line(0, 65, width, 65);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.nf = function () {
                          if (arguments[0] instanceof Array) {
                            var a = arguments[1];
                            var b = arguments[2];
                            return arguments[0].map(function (x) {
                              return doNf(x, a, b);
                            });
                          }
                          else{
                            var typeOfFirst = Object.prototype.toString.call(arguments[0]);
                            if(typeOfFirst === &#x27;[object Arguments]&#x27;){
                              if(arguments[0].length===3){
                                return this.nf(arguments[0][0],arguments[0][1],arguments[0][2]);
                              }
                              else if(arguments[0].length===2){
                                return this.nf(arguments[0][0],arguments[0][1]);
                              }
                              else{
                                return this.nf(arguments[0][0]);
                              }
                            }
                            else {
                              return doNf.apply(this, arguments);
                            }
                          }
                        };
                        
                        function doNf() {
                          var num = arguments[0];
                          var neg = num &lt; 0;
                          var n = neg ? num.toString().substring(1) : num.toString();
                          var decimalInd = n.indexOf(&#x27;.&#x27;);
                          var intPart = decimalInd !== -1 ? n.substring(0, decimalInd) : n;
                          var decPart = decimalInd !== -1 ? n.substring(decimalInd + 1) : &#x27;&#x27;;
                          var str = neg ? &#x27;-&#x27; : &#x27;&#x27;;
                          if (arguments.length === 3) {
                            var decimal = &#x27;&#x27;;
                            if(decimalInd !== -1 || arguments[2] - decPart.length &gt; 0){
                              decimal = &#x27;.&#x27;;
                            }
                            if (decPart.length &gt; arguments[2]) {
                              decPart = decPart.substring(0, arguments[2]);
                            }
                            for (var i = 0; i &lt; arguments[1] - intPart.length; i++) {
                              str += &#x27;0&#x27;;
                            }
                            str += intPart;
                            str += decimal;
                            str += decPart;
                            for (var j = 0; j &lt; arguments[2] - decPart.length; j++) {
                              str += &#x27;0&#x27;;
                            }
                            return str;
                          }
                          else {
                            for (var k = 0; k &lt; Math.max(arguments[1] - intPart.length, 0); k++) {
                              str += &#x27;0&#x27;;
                            }
                            str += n;
                            return str;
                          }
                        }
                        
                        /**
                         * Utility function for formatting numbers into strings and placing
                         * appropriate commas to mark units of 1000. There are two versions: one
                         * for formatting ints, and one for formatting an array of ints. The value
                         * for the right parameter should always be a positive integer.
                         *
                         * @method nfc
                         * @param  {Number|Array}   num     the Number to format
                         * @param  {Number}         [right] number of digits to the right of the
                         *                                  decimal point
                         * @return {String|Array}           formatted String
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * function setup() {
                         *   background(200);
                         *   var num = 11253106.115;
                         *   var numArr = new Array(1,1,2);
                         *
                         *   noStroke();
                         *   fill(0);
                         *   textSize(12);
                         *
                         *   // Draw formatted numbers
                         *   text(nfc(num, 4, 2), 10, 30);
                         *   text(nfc(numArr, 2, 1), 10, 80);
                         *
                         *   // Draw dividing line
                         *   stroke(120);
                         *   line(0, 50, width, 50);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.nfc = function () {
                          if (arguments[0] instanceof Array) {
                            var a = arguments[1];
                            return arguments[0].map(function (x) {
                              return doNfc(x, a);
                            });
                          } else {
                            return doNfc.apply(this, arguments);
                          }
                        };
                        function doNfc() {
                          var num = arguments[0].toString();
                          var dec = num.indexOf(&#x27;.&#x27;);
                          var rem = dec !== -1 ? num.substring(dec) : &#x27;&#x27;;
                          var n = dec !== -1 ? num.substring(0, dec) : num;
                          n = n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, &#x27;,&#x27;);
                          if (arguments[1] === 0) {
                            rem = &#x27;&#x27;;
                          }
                          else if(arguments[1] !== undefined){
                            if(arguments[1] &gt; rem.length){
                              rem+= dec === -1 ? &#x27;.&#x27; : &#x27;&#x27;;
                              var len = arguments[1] - rem.length + 1;
                              for(var i =0; i&lt; len; i++){
                                rem += &#x27;0&#x27;;
                              }
                            }
                            else{
                              rem = rem.substring(0, arguments[1] + 1);
                            }
                          }
                          return n + rem;
                        }
                        
                        /**
                         * Utility function for formatting numbers into strings. Similar to nf() but
                         * puts a &quot;+&quot; in front of positive numbers and a &quot;-&quot; in front of negative
                         * numbers. There are two versions: one for formatting floats, and one for
                         * formatting ints. The values for left, and right parameters
                         * should always be positive integers.
                         *
                         * @method nfp
                         * @param {Number|Array} num      the Number to format
                         * @param {Number}       [left]   number of digits to the left of the decimal
                         *                                point
                         * @param {Number}       [right]  number of digits to the right of the
                         *                                decimal point
                         * @return {String|Array}         formatted String
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * function setup() {
                         *   background(200);
                         *   var num1 = 11253106.115;
                         *   var num2 = -11253106.115;
                         *
                         *   noStroke();
                         *   fill(0);
                         *   textSize(12);
                         *
                         *   // Draw formatted numbers
                         *   text(nfp(num1, 4, 2), 10, 30);
                         *   text(nfp(num2, 4, 2), 10, 80);
                         *
                         *   // Draw dividing line
                         *   stroke(120);
                         *   line(0, 50, width, 50);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.nfp = function() {
                          var nfRes = this.nf.apply(this, arguments);
                          if (nfRes instanceof Array) {
                            return nfRes.map(addNfp);
                          } else {
                            return addNfp(nfRes);
                          }
                        };
                        
                        function addNfp() {
                          return (
                            parseFloat(arguments[0]) &gt; 0) ?
                            &#x27;+&#x27;+arguments[0].toString() :
                            arguments[0].toString();
                        }
                        
                        /**
                         * Utility function for formatting numbers into strings. Similar to nf() but
                         * puts a &quot; &quot; (space) in front of positive numbers and a &quot;-&quot; in front of
                         * negative numbers. There are two versions: one for formatting floats, and
                         * one for formatting ints. The values for the digits, left, and right
                         * parameters should always be positive integers.
                         *
                         * @method nfs
                         * @param {Number|Array} num      the Number to format
                         * @param {Number}       [left]   number of digits to the left of the decimal
                         *                                point
                         * @param {Number}       [right]  number of digits to the right of the
                         *                                decimal point
                         * @return {String|Array}         formatted String
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * function setup() {
                         *   background(200);
                         *   var num1 = 11253106.115;
                         *   var num2 = -11253106.115;
                         *
                         *   noStroke();
                         *   fill(0);
                         *   textSize(12);
                         *   // Draw formatted numbers
                         *   text(nfs(num1, 4, 2), 10, 30);
                         *
                         *   text(nfs(num2, 4, 2), 10, 80);
                         *
                         *   // Draw dividing line
                         *   stroke(120);
                         *   line(0, 50, width, 50);
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.nfs = function() {
                          var nfRes = this.nf.apply(this, arguments);
                          if (nfRes instanceof Array) {
                            return nfRes.map(addNfs);
                          } else {
                            return addNfs(nfRes);
                          }
                        };
                        
                        function addNfs() {
                          return (
                            parseFloat(arguments[0]) &gt; 0) ?
                            &#x27; &#x27;+arguments[0].toString() :
                            arguments[0].toString();
                        }
                        
                        /**
                         * The split() function maps to String.split(), it breaks a String into
                         * pieces using a character or string as the delimiter. The delim parameter
                         * specifies the character or characters that mark the boundaries between
                         * each piece. A String[] array is returned that contains each of the pieces.
                         *
                         * The splitTokens() function works in a similar fashion, except that it
                         * splits using a range of characters instead of a specific character or
                         * sequence.
                         *
                         * @method split
                         * @param  {String} value the String to be split
                         * @param  {String} delim the String used to separate the data
                         * @return {Array}  Array of Strings
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var names = &quot;Pat,Xio,Alex&quot;
                         * var splitString = split(names, &quot;,&quot;);
                         * text(splitString[0], 5, 30);
                         * text(splitString[1], 5, 50);
                         * text(splitString[2], 5, 70);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.split = function(str, delim) {
                          return str.split(delim);
                        };
                        
                        /**
                         * The splitTokens() function splits a String at one or many character
                         * delimiters or &quot;tokens.&quot; The delim parameter specifies the character or
                         * characters to be used as a boundary.
                         * &lt;br&gt;&lt;br&gt;
                         * If no delim characters are specified, any whitespace character is used to
                         * split. Whitespace characters include tab (\t), line feed (\n), carriage
                         * return (\r), form feed (\f), and space.
                         *
                         * @method splitTokens
                         * @param  {String} value   the String to be split
                         * @param  {String} [delim] list of individual Strings that will be used as
                         *                          separators
                         * @return {Array}          Array of Strings
                         * @example
                         * &lt;div class = &quot;norender&quot;&gt;
                         * &lt;code&gt;
                         * function setup() {
                         *   var myStr = &quot;Mango, Banana, Lime&quot;;
                         *   var myStrArr = splitTokens(myStr, &quot;,&quot;);
                         *
                         *   print(myStrArr); // prints : [&quot;Mango&quot;,&quot; Banana&quot;,&quot; Lime&quot;]
                         * }
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.splitTokens = function() {
                          var d,sqo,sqc,str;
                          str = arguments[1];
                          if (arguments.length &gt; 1) {
                            sqc = /\]/g.exec(str);
                            sqo = /\[/g.exec(str);
                            if ( sqo &amp;&amp; sqc ) {
                              str = str.slice(0, sqc.index) + str.slice(sqc.index+1);
                              sqo = /\[/g.exec(str);
                              str = str.slice(0, sqo.index) + str.slice(sqo.index+1);
                              d = new RegExp(&#x27;[\\[&#x27;+str+&#x27;\\]]&#x27;,&#x27;g&#x27;);
                            } else if ( sqc ) {
                              str = str.slice(0, sqc.index) + str.slice(sqc.index+1);
                              d = new RegExp(&#x27;[&#x27; + str + &#x27;\\]]&#x27;, &#x27;g&#x27;);
                            } else if(sqo) {
                              str = str.slice(0, sqo.index) + str.slice(sqo.index+1);
                              d = new RegExp(&#x27;[&#x27; + str + &#x27;\\[]&#x27;, &#x27;g&#x27;);
                            } else {
                              d = new RegExp(&#x27;[&#x27; + str + &#x27;]&#x27;, &#x27;g&#x27;);
                            }
                          } else {
                            d = /\s/g;
                          }
                          return arguments[0].split(d).filter(function(n){return n;});
                        };
                        
                        /**
                         * Removes whitespace characters from the beginning and end of a String. In
                         * addition to standard whitespace characters such as space, carriage return,
                         * and tab, this function also removes the Unicode &quot;nbsp&quot; character.
                         *
                         * @method trim
                         * @param  {String|Array} [str] a String or Array of Strings to be trimmed
                         * @return {String|Array}       a trimmed String or Array of Strings
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var string = trim(&quot;  No new lines\n   &quot;);
                         * text(string +&quot; here&quot;, 2, 50);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.trim = function(str) {
                          if (str instanceof Array) {
                            return str.map(this.trim);
                          } else {
                            return str.trim();
                          }
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;../core/core&quot;:48}],86:[function(_dereq_,module,exports){
                        /**
                         * @module Input
                         * @submodule Time &amp; Date
                         * @for p5
                         * @requires core
                         */
                        
                        &#x27;use strict&#x27;;
                        
                        var p5 = _dereq_(&#x27;../core/core&#x27;);
                        
                        /**
                         * p5.js communicates with the clock on your computer. The day() function
                         * returns the current day as a value from 1 - 31.
                         *
                         * @method day
                         * @return {Number} the current day
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var day = day();
                         * text(&quot;Current day: \n&quot; + day, 5, 50);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.day = function() {
                          return new Date().getDate();
                        };
                        
                        /**
                         * p5.js communicates with the clock on your computer. The hour() function
                         * returns the current hour as a value from 0 - 23.
                         *
                         * @method hour
                         * @return {Number} the current hour
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var hour = hour();
                         * text(&quot;Current hour:\n&quot; + hour, 5, 50);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.hour = function() {
                          return new Date().getHours();
                        };
                        
                        /**
                         * p5.js communicates with the clock on your computer. The minute() function
                         * returns the current minute as a value from 0 - 59.
                         *
                         * @method minute
                         * @return {Number} the current minute
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var minute = minute();
                         * text(&quot;Current minute: \n&quot; + minute, 5, 50);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.minute = function() {
                          return new Date().getMinutes();
                        };
                        
                        /**
                         * Returns the number of milliseconds (thousandths of a second) since
                         * starting the program. This information is often used for timing events and
                         * animation sequences.
                         *
                         * @method millis
                         * @return {Number} the number of milliseconds since starting the program
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var millisecond = millis();
                         * text(&quot;Milliseconds \nrunning: \n&quot; + millisecond, 5, 40);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.millis = function() {
                          return window.performance.now();
                        };
                        
                        /**
                         * p5.js communicates with the clock on your computer. The month() function
                         * returns the current month as a value from 1 - 12.
                         *
                         * @method month
                         * @return {Number} the current month
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var month = month();
                         * text(&quot;Current month: \n&quot; + month, 5, 50);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.month = function() {
                          return new Date().getMonth() + 1; //January is 0!
                        };
                        
                        /**
                         * p5.js communicates with the clock on your computer. The second() function
                         * returns the current second as a value from 0 - 59.
                         *
                         * @method second
                         * @return {Number} the current second
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var second = second();
                         * text(&quot;Current second: \n&quot; + second, 5, 50);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.second = function() {
                          return new Date().getSeconds();
                        };
                        
                        /**
                         * p5.js communicates with the clock on your computer. The year() function
                         * returns the current year as an integer (2014, 2015, 2016, etc).
                         *
                         * @method year
                         * @return {Number} the current year
                         * @example
                         * &lt;div&gt;
                         * &lt;code&gt;
                         * var year = year();
                         * text(&quot;Current year: \n&quot; + year, 5, 50);
                         * &lt;/code&gt;
                         * &lt;/div&gt;
                         */
                        p5.prototype.year = function() {
                          return new Date().getFullYear();
                        };
                        
                        module.exports = p5;
                        
                        },{&quot;../core/core&quot;:48}]},{},[39])(39)
                        });
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
