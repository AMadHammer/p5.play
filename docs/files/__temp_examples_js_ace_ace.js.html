<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>__temp_examples/js/ace/ace.js - p5.play</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/css/lucid.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
	    <img alt="p5.play" src="../../asterisk.png" style="max-height: 65%;" title="p5.play">
            p5.play
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>1.0.0</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/Animation", "classes/Camera", "classes/Group", "classes/p5", "classes/p5.Color", "classes/p5.Element", "classes/p5.Font", "classes/p5.Graphics", "classes/p5.Image", "classes/p5.play", "classes/p5.Renderer", "classes/p5.Table", "classes/p5.TableRow", "classes/p5.Vector", "classes/Sprite", "classes/SpriteSheet", "modules/2D Primitives", "modules/3D Primitives", "modules/Acceleration", "modules/Array Functions", "modules/Attributes", "modules/Calculation", "modules/Camera", "modules/Color", "modules/Constants", "modules/Conversion", "modules/Creating & Reading", "modules/Curves", "modules/Data", "modules/DOM", "modules/Environment", "modules/Events", "modules/Font", "modules/Image", "modules/Input", "modules/IO", "modules/Keyboard", "modules/Lights", "modules/Lights, Camera", "modules/Loading & Displaying", "modules/Material", "modules/Math", "modules/Mouse", "modules/Noise", "modules/Output", "modules/p5.play", "modules/Pixels", "modules/Random", "modules/Rendering", "modules/Setting", "modules/Shape", "modules/String Functions", "modules/Structure", "modules/Table", "modules/Time & Date", "modules/Touch", "modules/Transform", "modules/Trigonometry", "modules/Typography", "modules/Vertex"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
	    <div>
	        <div id="sidebar">
	        <div id="classes">
	            <ul id="api-classes" class="nav nav-list">
	                    <li><a href="../classes/Animation.html">Animation</a></li>
	                    <li><a href="../classes/Camera.html">Camera</a></li>
	                    <li><a href="../classes/Group.html">Group</a></li>
	                    <li><a href="../classes/p5.html">p5</a></li>
	                    <li><a href="../classes/p5.Color.html">p5.Color</a></li>
	                    <li><a href="../classes/p5.Element.html">p5.Element</a></li>
	                    <li><a href="../classes/p5.Font.html">p5.Font</a></li>
	                    <li><a href="../classes/p5.Graphics.html">p5.Graphics</a></li>
	                    <li><a href="../classes/p5.Image.html">p5.Image</a></li>
	                    <li><a href="../classes/p5.play.html">p5.play</a></li>
	                    <li><a href="../classes/p5.Renderer.html">p5.Renderer</a></li>
	                    <li><a href="../classes/p5.Table.html">p5.Table</a></li>
	                    <li><a href="../classes/p5.TableRow.html">p5.TableRow</a></li>
	                    <li><a href="../classes/p5.Vector.html">p5.Vector</a></li>
	                    <li><a href="../classes/Sprite.html">Sprite</a></li>
	                    <li><a href="../classes/SpriteSheet.html">SpriteSheet</a></li>
	            </ul>
	        </div>
	        </div>
	    </div>
        </div>
        <div class="span9">
                <form id="options-form" class="form-inline pull-right">
                    Show:
                    <label for="api-show-inherited" class="checkbox">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected" class="checkbox">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private" class="checkbox">
                        <input type="checkbox" id="api-show-private" checked>
                        Private
                    </label>
                    <label for="api-show-deprecated" class="checkbox">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </form>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <div class="page-header">
                            <h1>__temp_examples/js/ace/ace.js <small>File</small></h1>
                        </div>
                        
                        <div class="file">
                            <pre class="prettyprint linenums">
                        /* ***** BEGIN LICENSE BLOCK *****
                         * Distributed under the BSD license:
                         *
                         * Copyright (c) 2010, Ajax.org B.V.
                         * All rights reserved.
                         *
                         * Redistribution and use in source and binary forms, with or without
                         * modification, are permitted provided that the following conditions are met:
                         *     * Redistributions of source code must retain the above copyright
                         *       notice, this list of conditions and the following disclaimer.
                         *     * Redistributions in binary form must reproduce the above copyright
                         *       notice, this list of conditions and the following disclaimer in the
                         *       documentation and/or other materials provided with the distribution.
                         *     * Neither the name of Ajax.org B.V. nor the
                         *       names of its contributors may be used to endorse or promote products
                         *       derived from this software without specific prior written permission.
                         *
                         * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
                         * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
                         * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                         * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
                         * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
                         * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
                         * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
                         * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                         * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                         * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                         *
                         * ***** END LICENSE BLOCK ***** */
                        
                        /**
                         * Define a module along with a payload
                         * @param module a name for the payload
                         * @param payload a function to call with (require, exports, module) params
                         */
                        
                        (function() {
                        
                        var ACE_NAMESPACE = &quot;&quot;;
                        
                        var global = (function() { return this; })();
                        if (!global &amp;&amp; typeof window != &quot;undefined&quot;) global = window; // strict mode
                        
                        
                        if (!ACE_NAMESPACE &amp;&amp; typeof requirejs !== &quot;undefined&quot;)
                            return;
                        
                        
                        var define = function(module, deps, payload) {
                            if (typeof module !== &quot;string&quot;) {
                                if (define.original)
                                    define.original.apply(this, arguments);
                                else {
                                    console.error(&quot;dropping module because define wasn\&#x27;t a string.&quot;);
                                    console.trace();
                                }
                                return;
                            }
                            if (arguments.length == 2)
                                payload = deps;
                            if (!define.modules[module]) {
                                define.payloads[module] = payload;
                                define.modules[module] = null;
                            }
                        };
                        
                        define.modules = {};
                        define.payloads = {};
                        
                        /**
                         * Get at functionality define()ed using the function above
                         */
                        var _require = function(parentId, module, callback) {
                            if (typeof module === &quot;string&quot;) {
                                var payload = lookup(parentId, module);
                                if (payload != undefined) {
                                    callback &amp;&amp; callback();
                                    return payload;
                                }
                            } else if (Object.prototype.toString.call(module) === &quot;[object Array]&quot;) {
                                var params = [];
                                for (var i = 0, l = module.length; i &lt; l; ++i) {
                                    var dep = lookup(parentId, module[i]);
                                    if (dep == undefined &amp;&amp; require.original)
                                        return;
                                    params.push(dep);
                                }
                                return callback &amp;&amp; callback.apply(null, params) || true;
                            }
                        };
                        
                        var require = function(module, callback) {
                            var packagedModule = _require(&quot;&quot;, module, callback);
                            if (packagedModule == undefined &amp;&amp; require.original)
                                return require.original.apply(this, arguments);
                            return packagedModule;
                        };
                        
                        var normalizeModule = function(parentId, moduleName) {
                            // normalize plugin requires
                            if (moduleName.indexOf(&quot;!&quot;) !== -1) {
                                var chunks = moduleName.split(&quot;!&quot;);
                                return normalizeModule(parentId, chunks[0]) + &quot;!&quot; + normalizeModule(parentId, chunks[1]);
                            }
                            // normalize relative requires
                            if (moduleName.charAt(0) == &quot;.&quot;) {
                                var base = parentId.split(&quot;/&quot;).slice(0, -1).join(&quot;/&quot;);
                                moduleName = base + &quot;/&quot; + moduleName;
                        
                                while(moduleName.indexOf(&quot;.&quot;) !== -1 &amp;&amp; previous != moduleName) {
                                    var previous = moduleName;
                                    moduleName = moduleName.replace(/\/\.\//, &quot;/&quot;).replace(/[^\/]+\/\.\.\//, &quot;&quot;);
                                }
                            }
                            return moduleName;
                        };
                        
                        /**
                         * Internal function to lookup moduleNames and resolve them by calling the
                         * definition function if needed.
                         */
                        var lookup = function(parentId, moduleName) {
                            moduleName = normalizeModule(parentId, moduleName);
                        
                            var module = define.modules[moduleName];
                            if (!module) {
                                module = define.payloads[moduleName];
                                if (typeof module === &#x27;function&#x27;) {
                                    var exports = {};
                                    var mod = {
                                        id: moduleName,
                                        uri: &#x27;&#x27;,
                                        exports: exports,
                                        packaged: true
                                    };
                        
                                    var req = function(module, callback) {
                                        return _require(moduleName, module, callback);
                                    };
                        
                                    var returnValue = module(req, exports, mod);
                                    exports = returnValue || mod.exports;
                                    define.modules[moduleName] = exports;
                                    delete define.payloads[moduleName];
                                }
                                module = define.modules[moduleName] = exports || module;
                            }
                            return module;
                        };
                        
                        function exportAce(ns) {
                            var root = global;
                            if (ns) {
                                if (!global[ns])
                                    global[ns] = {};
                                root = global[ns];
                            }
                        
                            if (!root.define || !root.define.packaged) {
                                define.original = root.define;
                                root.define = define;
                                root.define.packaged = true;
                            }
                        
                            if (!root.require || !root.require.packaged) {
                                require.original = root.require;
                                root.require = require;
                                root.require.packaged = true;
                            }
                        }
                        
                        exportAce(ACE_NAMESPACE);
                        
                        })();
                        
                        define(&quot;ace/lib/regexp&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                            var real = {
                                    exec: RegExp.prototype.exec,
                                    test: RegExp.prototype.test,
                                    match: String.prototype.match,
                                    replace: String.prototype.replace,
                                    split: String.prototype.split
                                },
                                compliantExecNpcg = real.exec.call(/()??/, &quot;&quot;)[1] === undefined, // check &#x60;exec&#x60; handling of nonparticipating capturing groups
                                compliantLastIndexIncrement = function () {
                                    var x = /^/g;
                                    real.test.call(x, &quot;&quot;);
                                    return !x.lastIndex;
                                }();
                        
                            if (compliantLastIndexIncrement &amp;&amp; compliantExecNpcg)
                                return;
                            RegExp.prototype.exec = function (str) {
                                var match = real.exec.apply(this, arguments),
                                    name, r2;
                                if ( typeof(str) == &#x27;string&#x27; &amp;&amp; match) {
                                    if (!compliantExecNpcg &amp;&amp; match.length &gt; 1 &amp;&amp; indexOf(match, &quot;&quot;) &gt; -1) {
                                        r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), &quot;g&quot;, &quot;&quot;));
                                        real.replace.call(str.slice(match.index), r2, function () {
                                            for (var i = 1; i &lt; arguments.length - 2; i++) {
                                                if (arguments[i] === undefined)
                                                    match[i] = undefined;
                                            }
                                        });
                                    }
                                    if (this._xregexp &amp;&amp; this._xregexp.captureNames) {
                                        for (var i = 1; i &lt; match.length; i++) {
                                            name = this._xregexp.captureNames[i - 1];
                                            if (name)
                                               match[name] = match[i];
                                        }
                                    }
                                    if (!compliantLastIndexIncrement &amp;&amp; this.global &amp;&amp; !match[0].length &amp;&amp; (this.lastIndex &gt; match.index))
                                        this.lastIndex--;
                                }
                                return match;
                            };
                            if (!compliantLastIndexIncrement) {
                                RegExp.prototype.test = function (str) {
                                    var match = real.exec.call(this, str);
                                    if (match &amp;&amp; this.global &amp;&amp; !match[0].length &amp;&amp; (this.lastIndex &gt; match.index))
                                        this.lastIndex--;
                                    return !!match;
                                };
                            }
                        
                            function getNativeFlags (regex) {
                                return (regex.global     ? &quot;g&quot; : &quot;&quot;) +
                                       (regex.ignoreCase ? &quot;i&quot; : &quot;&quot;) +
                                       (regex.multiline  ? &quot;m&quot; : &quot;&quot;) +
                                       (regex.extended   ? &quot;x&quot; : &quot;&quot;) + // Proposed for ES4; included in AS3
                                       (regex.sticky     ? &quot;y&quot; : &quot;&quot;);
                            }
                        
                            function indexOf (array, item, from) {
                                if (Array.prototype.indexOf) // Use the native array method if available
                                    return array.indexOf(item, from);
                                for (var i = from || 0; i &lt; array.length; i++) {
                                    if (array[i] === item)
                                        return i;
                                }
                                return -1;
                            }
                        
                        });
                        
                        define(&quot;ace/lib/es5-shim&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module) {
                        
                        function Empty() {}
                        
                        if (!Function.prototype.bind) {
                            Function.prototype.bind = function bind(that) { // .length is 1
                                var target = this;
                                if (typeof target != &quot;function&quot;) {
                                    throw new TypeError(&quot;Function.prototype.bind called on incompatible &quot; + target);
                                }
                                var args = slice.call(arguments, 1); // for normal call
                                var bound = function () {
                        
                                    if (this instanceof bound) {
                        
                                        var result = target.apply(
                                            this,
                                            args.concat(slice.call(arguments))
                                        );
                                        if (Object(result) === result) {
                                            return result;
                                        }
                                        return this;
                        
                                    } else {
                                        return target.apply(
                                            that,
                                            args.concat(slice.call(arguments))
                                        );
                        
                                    }
                        
                                };
                                if(target.prototype) {
                                    Empty.prototype = target.prototype;
                                    bound.prototype = new Empty();
                                    Empty.prototype = null;
                                }
                                return bound;
                            };
                        }
                        var call = Function.prototype.call;
                        var prototypeOfArray = Array.prototype;
                        var prototypeOfObject = Object.prototype;
                        var slice = prototypeOfArray.slice;
                        var _toString = call.bind(prototypeOfObject.toString);
                        var owns = call.bind(prototypeOfObject.hasOwnProperty);
                        var defineGetter;
                        var defineSetter;
                        var lookupGetter;
                        var lookupSetter;
                        var supportsAccessors;
                        if ((supportsAccessors = owns(prototypeOfObject, &quot;__defineGetter__&quot;))) {
                            defineGetter = call.bind(prototypeOfObject.__defineGetter__);
                            defineSetter = call.bind(prototypeOfObject.__defineSetter__);
                            lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
                            lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
                        }
                        if ([1,2].splice(0).length != 2) {
                            if(function() { // test IE &lt; 9 to splice bug - see issue #138
                                function makeArray(l) {
                                    var a = new Array(l+2);
                                    a[0] = a[1] = 0;
                                    return a;
                                }
                                var array = [], lengthBefore;
                                
                                array.splice.apply(array, makeArray(20));
                                array.splice.apply(array, makeArray(26));
                        
                                lengthBefore = array.length; //46
                                array.splice(5, 0, &quot;XXX&quot;); // add one element
                        
                                lengthBefore + 1 == array.length
                        
                                if (lengthBefore + 1 == array.length) {
                                    return true;// has right splice implementation without bugs
                                }
                            }()) {//IE 6/7
                                var array_splice = Array.prototype.splice;
                                Array.prototype.splice = function(start, deleteCount) {
                                    if (!arguments.length) {
                                        return [];
                                    } else {
                                        return array_splice.apply(this, [
                                            start === void 0 ? 0 : start,
                                            deleteCount === void 0 ? (this.length - start) : deleteCount
                                        ].concat(slice.call(arguments, 2)))
                                    }
                                };
                            } else {//IE8
                                Array.prototype.splice = function(pos, removeCount){
                                    var length = this.length;
                                    if (pos &gt; 0) {
                                        if (pos &gt; length)
                                            pos = length;
                                    } else if (pos == void 0) {
                                        pos = 0;
                                    } else if (pos &lt; 0) {
                                        pos = Math.max(length + pos, 0);
                                    }
                        
                                    if (!(pos+removeCount &lt; length))
                                        removeCount = length - pos;
                        
                                    var removed = this.slice(pos, pos+removeCount);
                                    var insert = slice.call(arguments, 2);
                                    var add = insert.length;            
                                    if (pos === length) {
                                        if (add) {
                                            this.push.apply(this, insert);
                                        }
                                    } else {
                                        var remove = Math.min(removeCount, length - pos);
                                        var tailOldPos = pos + remove;
                                        var tailNewPos = tailOldPos + add - remove;
                                        var tailCount = length - tailOldPos;
                                        var lengthAfterRemove = length - remove;
                        
                                        if (tailNewPos &lt; tailOldPos) { // case A
                                            for (var i = 0; i &lt; tailCount; ++i) {
                                                this[tailNewPos+i] = this[tailOldPos+i];
                                            }
                                        } else if (tailNewPos &gt; tailOldPos) { // case B
                                            for (i = tailCount; i--; ) {
                                                this[tailNewPos+i] = this[tailOldPos+i];
                                            }
                                        } // else, add == remove (nothing to do)
                        
                                        if (add &amp;&amp; pos === lengthAfterRemove) {
                                            this.length = lengthAfterRemove; // truncate array
                                            this.push.apply(this, insert);
                                        } else {
                                            this.length = lengthAfterRemove + add; // reserves space
                                            for (i = 0; i &lt; add; ++i) {
                                                this[pos+i] = insert[i];
                                            }
                                        }
                                    }
                                    return removed;
                                };
                            }
                        }
                        if (!Array.isArray) {
                            Array.isArray = function isArray(obj) {
                                return _toString(obj) == &quot;[object Array]&quot;;
                            };
                        }
                        var boxedString = Object(&quot;a&quot;),
                            splitString = boxedString[0] != &quot;a&quot; || !(0 in boxedString);
                        
                        if (!Array.prototype.forEach) {
                            Array.prototype.forEach = function forEach(fun /*, thisp*/) {
                                var object = toObject(this),
                                    self = splitString &amp;&amp; _toString(this) == &quot;[object String]&quot; ?
                                        this.split(&quot;&quot;) :
                                        object,
                                    thisp = arguments[1],
                                    i = -1,
                                    length = self.length &gt;&gt;&gt; 0;
                                if (_toString(fun) != &quot;[object Function]&quot;) {
                                    throw new TypeError(); // TODO message
                                }
                        
                                while (++i &lt; length) {
                                    if (i in self) {
                                        fun.call(thisp, self[i], i, object);
                                    }
                                }
                            };
                        }
                        if (!Array.prototype.map) {
                            Array.prototype.map = function map(fun /*, thisp*/) {
                                var object = toObject(this),
                                    self = splitString &amp;&amp; _toString(this) == &quot;[object String]&quot; ?
                                        this.split(&quot;&quot;) :
                                        object,
                                    length = self.length &gt;&gt;&gt; 0,
                                    result = Array(length),
                                    thisp = arguments[1];
                                if (_toString(fun) != &quot;[object Function]&quot;) {
                                    throw new TypeError(fun + &quot; is not a function&quot;);
                                }
                        
                                for (var i = 0; i &lt; length; i++) {
                                    if (i in self)
                                        result[i] = fun.call(thisp, self[i], i, object);
                                }
                                return result;
                            };
                        }
                        if (!Array.prototype.filter) {
                            Array.prototype.filter = function filter(fun /*, thisp */) {
                                var object = toObject(this),
                                    self = splitString &amp;&amp; _toString(this) == &quot;[object String]&quot; ?
                                        this.split(&quot;&quot;) :
                                            object,
                                    length = self.length &gt;&gt;&gt; 0,
                                    result = [],
                                    value,
                                    thisp = arguments[1];
                                if (_toString(fun) != &quot;[object Function]&quot;) {
                                    throw new TypeError(fun + &quot; is not a function&quot;);
                                }
                        
                                for (var i = 0; i &lt; length; i++) {
                                    if (i in self) {
                                        value = self[i];
                                        if (fun.call(thisp, value, i, object)) {
                                            result.push(value);
                                        }
                                    }
                                }
                                return result;
                            };
                        }
                        if (!Array.prototype.every) {
                            Array.prototype.every = function every(fun /*, thisp */) {
                                var object = toObject(this),
                                    self = splitString &amp;&amp; _toString(this) == &quot;[object String]&quot; ?
                                        this.split(&quot;&quot;) :
                                        object,
                                    length = self.length &gt;&gt;&gt; 0,
                                    thisp = arguments[1];
                                if (_toString(fun) != &quot;[object Function]&quot;) {
                                    throw new TypeError(fun + &quot; is not a function&quot;);
                                }
                        
                                for (var i = 0; i &lt; length; i++) {
                                    if (i in self &amp;&amp; !fun.call(thisp, self[i], i, object)) {
                                        return false;
                                    }
                                }
                                return true;
                            };
                        }
                        if (!Array.prototype.some) {
                            Array.prototype.some = function some(fun /*, thisp */) {
                                var object = toObject(this),
                                    self = splitString &amp;&amp; _toString(this) == &quot;[object String]&quot; ?
                                        this.split(&quot;&quot;) :
                                        object,
                                    length = self.length &gt;&gt;&gt; 0,
                                    thisp = arguments[1];
                                if (_toString(fun) != &quot;[object Function]&quot;) {
                                    throw new TypeError(fun + &quot; is not a function&quot;);
                                }
                        
                                for (var i = 0; i &lt; length; i++) {
                                    if (i in self &amp;&amp; fun.call(thisp, self[i], i, object)) {
                                        return true;
                                    }
                                }
                                return false;
                            };
                        }
                        if (!Array.prototype.reduce) {
                            Array.prototype.reduce = function reduce(fun /*, initial*/) {
                                var object = toObject(this),
                                    self = splitString &amp;&amp; _toString(this) == &quot;[object String]&quot; ?
                                        this.split(&quot;&quot;) :
                                        object,
                                    length = self.length &gt;&gt;&gt; 0;
                                if (_toString(fun) != &quot;[object Function]&quot;) {
                                    throw new TypeError(fun + &quot; is not a function&quot;);
                                }
                                if (!length &amp;&amp; arguments.length == 1) {
                                    throw new TypeError(&quot;reduce of empty array with no initial value&quot;);
                                }
                        
                                var i = 0;
                                var result;
                                if (arguments.length &gt;= 2) {
                                    result = arguments[1];
                                } else {
                                    do {
                                        if (i in self) {
                                            result = self[i++];
                                            break;
                                        }
                                        if (++i &gt;= length) {
                                            throw new TypeError(&quot;reduce of empty array with no initial value&quot;);
                                        }
                                    } while (true);
                                }
                        
                                for (; i &lt; length; i++) {
                                    if (i in self) {
                                        result = fun.call(void 0, result, self[i], i, object);
                                    }
                                }
                        
                                return result;
                            };
                        }
                        if (!Array.prototype.reduceRight) {
                            Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {
                                var object = toObject(this),
                                    self = splitString &amp;&amp; _toString(this) == &quot;[object String]&quot; ?
                                        this.split(&quot;&quot;) :
                                        object,
                                    length = self.length &gt;&gt;&gt; 0;
                                if (_toString(fun) != &quot;[object Function]&quot;) {
                                    throw new TypeError(fun + &quot; is not a function&quot;);
                                }
                                if (!length &amp;&amp; arguments.length == 1) {
                                    throw new TypeError(&quot;reduceRight of empty array with no initial value&quot;);
                                }
                        
                                var result, i = length - 1;
                                if (arguments.length &gt;= 2) {
                                    result = arguments[1];
                                } else {
                                    do {
                                        if (i in self) {
                                            result = self[i--];
                                            break;
                                        }
                                        if (--i &lt; 0) {
                                            throw new TypeError(&quot;reduceRight of empty array with no initial value&quot;);
                                        }
                                    } while (true);
                                }
                        
                                do {
                                    if (i in this) {
                                        result = fun.call(void 0, result, self[i], i, object);
                                    }
                                } while (i--);
                        
                                return result;
                            };
                        }
                        if (!Array.prototype.indexOf || ([0, 1].indexOf(1, 2) != -1)) {
                            Array.prototype.indexOf = function indexOf(sought /*, fromIndex */ ) {
                                var self = splitString &amp;&amp; _toString(this) == &quot;[object String]&quot; ?
                                        this.split(&quot;&quot;) :
                                        toObject(this),
                                    length = self.length &gt;&gt;&gt; 0;
                        
                                if (!length) {
                                    return -1;
                                }
                        
                                var i = 0;
                                if (arguments.length &gt; 1) {
                                    i = toInteger(arguments[1]);
                                }
                                i = i &gt;= 0 ? i : Math.max(0, length + i);
                                for (; i &lt; length; i++) {
                                    if (i in self &amp;&amp; self[i] === sought) {
                                        return i;
                                    }
                                }
                                return -1;
                            };
                        }
                        if (!Array.prototype.lastIndexOf || ([0, 1].lastIndexOf(0, -3) != -1)) {
                            Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {
                                var self = splitString &amp;&amp; _toString(this) == &quot;[object String]&quot; ?
                                        this.split(&quot;&quot;) :
                                        toObject(this),
                                    length = self.length &gt;&gt;&gt; 0;
                        
                                if (!length) {
                                    return -1;
                                }
                                var i = length - 1;
                                if (arguments.length &gt; 1) {
                                    i = Math.min(i, toInteger(arguments[1]));
                                }
                                i = i &gt;= 0 ? i : length - Math.abs(i);
                                for (; i &gt;= 0; i--) {
                                    if (i in self &amp;&amp; sought === self[i]) {
                                        return i;
                                    }
                                }
                                return -1;
                            };
                        }
                        if (!Object.getPrototypeOf) {
                            Object.getPrototypeOf = function getPrototypeOf(object) {
                                return object.__proto__ || (
                                    object.constructor ?
                                    object.constructor.prototype :
                                    prototypeOfObject
                                );
                            };
                        }
                        if (!Object.getOwnPropertyDescriptor) {
                            var ERR_NON_OBJECT = &quot;Object.getOwnPropertyDescriptor called on a &quot; +
                                                 &quot;non-object: &quot;;
                            Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
                                if ((typeof object != &quot;object&quot; &amp;&amp; typeof object != &quot;function&quot;) || object === null)
                                    throw new TypeError(ERR_NON_OBJECT + object);
                                if (!owns(object, property))
                                    return;
                        
                                var descriptor, getter, setter;
                                descriptor =  { enumerable: true, configurable: true };
                                if (supportsAccessors) {
                                    var prototype = object.__proto__;
                                    object.__proto__ = prototypeOfObject;
                        
                                    var getter = lookupGetter(object, property);
                                    var setter = lookupSetter(object, property);
                                    object.__proto__ = prototype;
                        
                                    if (getter || setter) {
                                        if (getter) descriptor.get = getter;
                                        if (setter) descriptor.set = setter;
                                        return descriptor;
                                    }
                                }
                                descriptor.value = object[property];
                                return descriptor;
                            };
                        }
                        if (!Object.getOwnPropertyNames) {
                            Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
                                return Object.keys(object);
                            };
                        }
                        if (!Object.create) {
                            var createEmpty;
                            if (Object.prototype.__proto__ === null) {
                                createEmpty = function () {
                                    return { &quot;__proto__&quot;: null };
                                };
                            } else {
                                createEmpty = function () {
                                    var empty = {};
                                    for (var i in empty)
                                        empty[i] = null;
                                    empty.constructor =
                                    empty.hasOwnProperty =
                                    empty.propertyIsEnumerable =
                                    empty.isPrototypeOf =
                                    empty.toLocaleString =
                                    empty.toString =
                                    empty.valueOf =
                                    empty.__proto__ = null;
                                    return empty;
                                }
                            }
                        
                            Object.create = function create(prototype, properties) {
                                var object;
                                if (prototype === null) {
                                    object = createEmpty();
                                } else {
                                    if (typeof prototype != &quot;object&quot;)
                                        throw new TypeError(&quot;typeof prototype[&quot;+(typeof prototype)+&quot;] != &#x27;object&#x27;&quot;);
                                    var Type = function () {};
                                    Type.prototype = prototype;
                                    object = new Type();
                                    object.__proto__ = prototype;
                                }
                                if (properties !== void 0)
                                    Object.defineProperties(object, properties);
                                return object;
                            };
                        }
                        
                        function doesDefinePropertyWork(object) {
                            try {
                                Object.defineProperty(object, &quot;sentinel&quot;, {});
                                return &quot;sentinel&quot; in object;
                            } catch (exception) {
                            }
                        }
                        if (Object.defineProperty) {
                            var definePropertyWorksOnObject = doesDefinePropertyWork({});
                            var definePropertyWorksOnDom = typeof document == &quot;undefined&quot; ||
                                doesDefinePropertyWork(document.createElement(&quot;div&quot;));
                            if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
                                var definePropertyFallback = Object.defineProperty;
                            }
                        }
                        
                        if (!Object.defineProperty || definePropertyFallback) {
                            var ERR_NON_OBJECT_DESCRIPTOR = &quot;Property description must be an object: &quot;;
                            var ERR_NON_OBJECT_TARGET = &quot;Object.defineProperty called on non-object: &quot;
                            var ERR_ACCESSORS_NOT_SUPPORTED = &quot;getters &amp; setters can not be defined &quot; +
                                                              &quot;on this javascript engine&quot;;
                        
                            Object.defineProperty = function defineProperty(object, property, descriptor) {
                                if ((typeof object != &quot;object&quot; &amp;&amp; typeof object != &quot;function&quot;) || object === null)
                                    throw new TypeError(ERR_NON_OBJECT_TARGET + object);
                                if ((typeof descriptor != &quot;object&quot; &amp;&amp; typeof descriptor != &quot;function&quot;) || descriptor === null)
                                    throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
                                if (definePropertyFallback) {
                                    try {
                                        return definePropertyFallback.call(Object, object, property, descriptor);
                                    } catch (exception) {
                                    }
                                }
                                if (owns(descriptor, &quot;value&quot;)) {
                        
                                    if (supportsAccessors &amp;&amp; (lookupGetter(object, property) ||
                                                              lookupSetter(object, property)))
                                    {
                                        var prototype = object.__proto__;
                                        object.__proto__ = prototypeOfObject;
                                        delete object[property];
                                        object[property] = descriptor.value;
                                        object.__proto__ = prototype;
                                    } else {
                                        object[property] = descriptor.value;
                                    }
                                } else {
                                    if (!supportsAccessors)
                                        throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
                                    if (owns(descriptor, &quot;get&quot;))
                                        defineGetter(object, property, descriptor.get);
                                    if (owns(descriptor, &quot;set&quot;))
                                        defineSetter(object, property, descriptor.set);
                                }
                        
                                return object;
                            };
                        }
                        if (!Object.defineProperties) {
                            Object.defineProperties = function defineProperties(object, properties) {
                                for (var property in properties) {
                                    if (owns(properties, property))
                                        Object.defineProperty(object, property, properties[property]);
                                }
                                return object;
                            };
                        }
                        if (!Object.seal) {
                            Object.seal = function seal(object) {
                                return object;
                            };
                        }
                        if (!Object.freeze) {
                            Object.freeze = function freeze(object) {
                                return object;
                            };
                        }
                        try {
                            Object.freeze(function () {});
                        } catch (exception) {
                            Object.freeze = (function freeze(freezeObject) {
                                return function freeze(object) {
                                    if (typeof object == &quot;function&quot;) {
                                        return object;
                                    } else {
                                        return freezeObject(object);
                                    }
                                };
                            })(Object.freeze);
                        }
                        if (!Object.preventExtensions) {
                            Object.preventExtensions = function preventExtensions(object) {
                                return object;
                            };
                        }
                        if (!Object.isSealed) {
                            Object.isSealed = function isSealed(object) {
                                return false;
                            };
                        }
                        if (!Object.isFrozen) {
                            Object.isFrozen = function isFrozen(object) {
                                return false;
                            };
                        }
                        if (!Object.isExtensible) {
                            Object.isExtensible = function isExtensible(object) {
                                if (Object(object) === object) {
                                    throw new TypeError(); // TODO message
                                }
                                var name = &#x27;&#x27;;
                                while (owns(object, name)) {
                                    name += &#x27;?&#x27;;
                                }
                                object[name] = true;
                                var returnValue = owns(object, name);
                                delete object[name];
                                return returnValue;
                            };
                        }
                        if (!Object.keys) {
                            var hasDontEnumBug = true,
                                dontEnums = [
                                    &quot;toString&quot;,
                                    &quot;toLocaleString&quot;,
                                    &quot;valueOf&quot;,
                                    &quot;hasOwnProperty&quot;,
                                    &quot;isPrototypeOf&quot;,
                                    &quot;propertyIsEnumerable&quot;,
                                    &quot;constructor&quot;
                                ],
                                dontEnumsLength = dontEnums.length;
                        
                            for (var key in {&quot;toString&quot;: null}) {
                                hasDontEnumBug = false;
                            }
                        
                            Object.keys = function keys(object) {
                        
                                if (
                                    (typeof object != &quot;object&quot; &amp;&amp; typeof object != &quot;function&quot;) ||
                                    object === null
                                ) {
                                    throw new TypeError(&quot;Object.keys called on a non-object&quot;);
                                }
                        
                                var keys = [];
                                for (var name in object) {
                                    if (owns(object, name)) {
                                        keys.push(name);
                                    }
                                }
                        
                                if (hasDontEnumBug) {
                                    for (var i = 0, ii = dontEnumsLength; i &lt; ii; i++) {
                                        var dontEnum = dontEnums[i];
                                        if (owns(object, dontEnum)) {
                                            keys.push(dontEnum);
                                        }
                                    }
                                }
                                return keys;
                            };
                        
                        }
                        if (!Date.now) {
                            Date.now = function now() {
                                return new Date().getTime();
                            };
                        }
                        var ws = &quot;\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003&quot; +
                            &quot;\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028&quot; +
                            &quot;\u2029\uFEFF&quot;;
                        if (!String.prototype.trim || ws.trim()) {
                            ws = &quot;[&quot; + ws + &quot;]&quot;;
                            var trimBeginRegexp = new RegExp(&quot;^&quot; + ws + ws + &quot;*&quot;),
                                trimEndRegexp = new RegExp(ws + ws + &quot;*$&quot;);
                            String.prototype.trim = function trim() {
                                return String(this).replace(trimBeginRegexp, &quot;&quot;).replace(trimEndRegexp, &quot;&quot;);
                            };
                        }
                        
                        function toInteger(n) {
                            n = +n;
                            if (n !== n) { // isNaN
                                n = 0;
                            } else if (n !== 0 &amp;&amp; n !== (1/0) &amp;&amp; n !== -(1/0)) {
                                n = (n &gt; 0 || -1) * Math.floor(Math.abs(n));
                            }
                            return n;
                        }
                        
                        function isPrimitive(input) {
                            var type = typeof input;
                            return (
                                input === null ||
                                type === &quot;undefined&quot; ||
                                type === &quot;boolean&quot; ||
                                type === &quot;number&quot; ||
                                type === &quot;string&quot;
                            );
                        }
                        
                        function toPrimitive(input) {
                            var val, valueOf, toString;
                            if (isPrimitive(input)) {
                                return input;
                            }
                            valueOf = input.valueOf;
                            if (typeof valueOf === &quot;function&quot;) {
                                val = valueOf.call(input);
                                if (isPrimitive(val)) {
                                    return val;
                                }
                            }
                            toString = input.toString;
                            if (typeof toString === &quot;function&quot;) {
                                val = toString.call(input);
                                if (isPrimitive(val)) {
                                    return val;
                                }
                            }
                            throw new TypeError();
                        }
                        var toObject = function (o) {
                            if (o == null) { // this matches both null and undefined
                                throw new TypeError(&quot;can&#x27;t convert &quot;+o+&quot; to object&quot;);
                            }
                            return Object(o);
                        };
                        
                        });
                        
                        define(&quot;ace/lib/fixoldbrowsers&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/regexp&quot;,&quot;ace/lib/es5-shim&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        require(&quot;./regexp&quot;);
                        require(&quot;./es5-shim&quot;);
                        
                        });
                        
                        define(&quot;ace/lib/dom&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var XHTML_NS = &quot;http://www.w3.org/1999/xhtml&quot;;
                        
                        exports.getDocumentHead = function(doc) {
                            if (!doc)
                                doc = document;
                            return doc.head || doc.getElementsByTagName(&quot;head&quot;)[0] || doc.documentElement;
                        }
                        
                        exports.createElement = function(tag, ns) {
                            return document.createElementNS ?
                                   document.createElementNS(ns || XHTML_NS, tag) :
                                   document.createElement(tag);
                        };
                        
                        exports.hasCssClass = function(el, name) {
                            var classes = (el.className || &quot;&quot;).split(/\s+/g);
                            return classes.indexOf(name) !== -1;
                        };
                        exports.addCssClass = function(el, name) {
                            if (!exports.hasCssClass(el, name)) {
                                el.className += &quot; &quot; + name;
                            }
                        };
                        exports.removeCssClass = function(el, name) {
                            var classes = el.className.split(/\s+/g);
                            while (true) {
                                var index = classes.indexOf(name);
                                if (index == -1) {
                                    break;
                                }
                                classes.splice(index, 1);
                            }
                            el.className = classes.join(&quot; &quot;);
                        };
                        
                        exports.toggleCssClass = function(el, name) {
                            var classes = el.className.split(/\s+/g), add = true;
                            while (true) {
                                var index = classes.indexOf(name);
                                if (index == -1) {
                                    break;
                                }
                                add = false;
                                classes.splice(index, 1);
                            }
                            if(add)
                                classes.push(name);
                        
                            el.className = classes.join(&quot; &quot;);
                            return add;
                        };
                        exports.setCssClass = function(node, className, include) {
                            if (include) {
                                exports.addCssClass(node, className);
                            } else {
                                exports.removeCssClass(node, className);
                            }
                        };
                        
                        exports.hasCssString = function(id, doc) {
                            var index = 0, sheets;
                            doc = doc || document;
                        
                            if (doc.createStyleSheet &amp;&amp; (sheets = doc.styleSheets)) {
                                while (index &lt; sheets.length)
                                    if (sheets[index++].owningElement.id === id) return true;
                            } else if ((sheets = doc.getElementsByTagName(&quot;style&quot;))) {
                                while (index &lt; sheets.length)
                                    if (sheets[index++].id === id) return true;
                            }
                        
                            return false;
                        };
                        
                        exports.importCssString = function importCssString(cssText, id, doc) {
                            doc = doc || document;
                            if (id &amp;&amp; exports.hasCssString(id, doc))
                                return null;
                            
                            var style;
                            
                            if (doc.createStyleSheet) {
                                style = doc.createStyleSheet();
                                style.cssText = cssText;
                                if (id)
                                    style.owningElement.id = id;
                            } else {
                                style = doc.createElementNS
                                    ? doc.createElementNS(XHTML_NS, &quot;style&quot;)
                                    : doc.createElement(&quot;style&quot;);
                        
                                style.appendChild(doc.createTextNode(cssText));
                                if (id)
                                    style.id = id;
                        
                                exports.getDocumentHead(doc).appendChild(style);
                            }
                        };
                        
                        exports.importCssStylsheet = function(uri, doc) {
                            if (doc.createStyleSheet) {
                                doc.createStyleSheet(uri);
                            } else {
                                var link = exports.createElement(&#x27;link&#x27;);
                                link.rel = &#x27;stylesheet&#x27;;
                                link.href = uri;
                        
                                exports.getDocumentHead(doc).appendChild(link);
                            }
                        };
                        
                        exports.getInnerWidth = function(element) {
                            return (
                                parseInt(exports.computedStyle(element, &quot;paddingLeft&quot;), 10) +
                                parseInt(exports.computedStyle(element, &quot;paddingRight&quot;), 10) + 
                                element.clientWidth
                            );
                        };
                        
                        exports.getInnerHeight = function(element) {
                            return (
                                parseInt(exports.computedStyle(element, &quot;paddingTop&quot;), 10) +
                                parseInt(exports.computedStyle(element, &quot;paddingBottom&quot;), 10) +
                                element.clientHeight
                            );
                        };
                        
                        
                        if (typeof document == &quot;undefined&quot;)
                            return;
                        
                        if (window.pageYOffset !== undefined) {
                            exports.getPageScrollTop = function() {
                                return window.pageYOffset;
                            };
                        
                            exports.getPageScrollLeft = function() {
                                return window.pageXOffset;
                            };
                        }
                        else {
                            exports.getPageScrollTop = function() {
                                return document.body.scrollTop;
                            };
                        
                            exports.getPageScrollLeft = function() {
                                return document.body.scrollLeft;
                            };
                        }
                        
                        if (window.getComputedStyle)
                            exports.computedStyle = function(element, style) {
                                if (style)
                                    return (window.getComputedStyle(element, &quot;&quot;) || {})[style] || &quot;&quot;;
                                return window.getComputedStyle(element, &quot;&quot;) || {};
                            };
                        else
                            exports.computedStyle = function(element, style) {
                                if (style)
                                    return element.currentStyle[style];
                                return element.currentStyle;
                            };
                        
                        exports.scrollbarWidth = function(document) {
                            var inner = exports.createElement(&quot;ace_inner&quot;);
                            inner.style.width = &quot;100%&quot;;
                            inner.style.minWidth = &quot;0px&quot;;
                            inner.style.height = &quot;200px&quot;;
                            inner.style.display = &quot;block&quot;;
                        
                            var outer = exports.createElement(&quot;ace_outer&quot;);
                            var style = outer.style;
                        
                            style.position = &quot;absolute&quot;;
                            style.left = &quot;-10000px&quot;;
                            style.overflow = &quot;hidden&quot;;
                            style.width = &quot;200px&quot;;
                            style.minWidth = &quot;0px&quot;;
                            style.height = &quot;150px&quot;;
                            style.display = &quot;block&quot;;
                        
                            outer.appendChild(inner);
                        
                            var body = document.documentElement;
                            body.appendChild(outer);
                        
                            var noScrollbar = inner.offsetWidth;
                        
                            style.overflow = &quot;scroll&quot;;
                            var withScrollbar = inner.offsetWidth;
                        
                            if (noScrollbar == withScrollbar) {
                                withScrollbar = outer.clientWidth;
                            }
                        
                            body.removeChild(outer);
                        
                            return noScrollbar-withScrollbar;
                        };
                        exports.setInnerHtml = function(el, innerHtml) {
                            var element = el.cloneNode(false);//document.createElement(&quot;div&quot;);
                            element.innerHTML = innerHtml;
                            el.parentNode.replaceChild(element, el);
                            return element;
                        };
                        
                        if (&quot;textContent&quot; in document.documentElement) {
                            exports.setInnerText = function(el, innerText) {
                                el.textContent = innerText;
                            };
                        
                            exports.getInnerText = function(el) {
                                return el.textContent;
                            };
                        }
                        else {
                            exports.setInnerText = function(el, innerText) {
                                el.innerText = innerText;
                            };
                        
                            exports.getInnerText = function(el) {
                                return el.innerText;
                            };
                        }
                        
                        exports.getParentWindow = function(document) {
                            return document.defaultView || document.parentWindow;
                        };
                        
                        });
                        
                        define(&quot;ace/lib/oop&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        exports.inherits = function(ctor, superCtor) {
                            ctor.super_ = superCtor;
                            ctor.prototype = Object.create(superCtor.prototype, {
                                constructor: {
                                    value: ctor,
                                    enumerable: false,
                                    writable: true,
                                    configurable: true
                                }
                            });
                        };
                        
                        exports.mixin = function(obj, mixin) {
                            for (var key in mixin) {
                                obj[key] = mixin[key];
                            }
                            return obj;
                        };
                        
                        exports.implement = function(proto, mixin) {
                            exports.mixin(proto, mixin);
                        };
                        
                        });
                        
                        define(&quot;ace/lib/keys&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/fixoldbrowsers&quot;,&quot;ace/lib/oop&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        require(&quot;./fixoldbrowsers&quot;);
                        
                        var oop = require(&quot;./oop&quot;);
                        var Keys = (function() {
                            var ret = {
                                MODIFIER_KEYS: {
                                    16: &#x27;Shift&#x27;, 17: &#x27;Ctrl&#x27;, 18: &#x27;Alt&#x27;, 224: &#x27;Meta&#x27;
                                },
                        
                                KEY_MODS: {
                                    &quot;ctrl&quot;: 1, &quot;alt&quot;: 2, &quot;option&quot; : 2, &quot;shift&quot;: 4,
                                    &quot;super&quot;: 8, &quot;meta&quot;: 8, &quot;command&quot;: 8, &quot;cmd&quot;: 8
                                },
                        
                                FUNCTION_KEYS : {
                                    8  : &quot;Backspace&quot;,
                                    9  : &quot;Tab&quot;,
                                    13 : &quot;Return&quot;,
                                    19 : &quot;Pause&quot;,
                                    27 : &quot;Esc&quot;,
                                    32 : &quot;Space&quot;,
                                    33 : &quot;PageUp&quot;,
                                    34 : &quot;PageDown&quot;,
                                    35 : &quot;End&quot;,
                                    36 : &quot;Home&quot;,
                                    37 : &quot;Left&quot;,
                                    38 : &quot;Up&quot;,
                                    39 : &quot;Right&quot;,
                                    40 : &quot;Down&quot;,
                                    44 : &quot;Print&quot;,
                                    45 : &quot;Insert&quot;,
                                    46 : &quot;Delete&quot;,
                                    96 : &quot;Numpad0&quot;,
                                    97 : &quot;Numpad1&quot;,
                                    98 : &quot;Numpad2&quot;,
                                    99 : &quot;Numpad3&quot;,
                                    100: &quot;Numpad4&quot;,
                                    101: &quot;Numpad5&quot;,
                                    102: &quot;Numpad6&quot;,
                                    103: &quot;Numpad7&quot;,
                                    104: &quot;Numpad8&quot;,
                                    105: &quot;Numpad9&quot;,
                                    &#x27;-13&#x27;: &quot;NumpadEnter&quot;,
                                    112: &quot;F1&quot;,
                                    113: &quot;F2&quot;,
                                    114: &quot;F3&quot;,
                                    115: &quot;F4&quot;,
                                    116: &quot;F5&quot;,
                                    117: &quot;F6&quot;,
                                    118: &quot;F7&quot;,
                                    119: &quot;F8&quot;,
                                    120: &quot;F9&quot;,
                                    121: &quot;F10&quot;,
                                    122: &quot;F11&quot;,
                                    123: &quot;F12&quot;,
                                    144: &quot;Numlock&quot;,
                                    145: &quot;Scrolllock&quot;
                                },
                        
                                PRINTABLE_KEYS: {
                                   32: &#x27; &#x27;,  48: &#x27;0&#x27;,  49: &#x27;1&#x27;,  50: &#x27;2&#x27;,  51: &#x27;3&#x27;,  52: &#x27;4&#x27;, 53:  &#x27;5&#x27;,
                                   54: &#x27;6&#x27;,  55: &#x27;7&#x27;,  56: &#x27;8&#x27;,  57: &#x27;9&#x27;,  59: &#x27;;&#x27;,  61: &#x27;=&#x27;, 65:  &#x27;a&#x27;,
                                   66: &#x27;b&#x27;,  67: &#x27;c&#x27;,  68: &#x27;d&#x27;,  69: &#x27;e&#x27;,  70: &#x27;f&#x27;,  71: &#x27;g&#x27;, 72:  &#x27;h&#x27;,
                                   73: &#x27;i&#x27;,  74: &#x27;j&#x27;,  75: &#x27;k&#x27;,  76: &#x27;l&#x27;,  77: &#x27;m&#x27;,  78: &#x27;n&#x27;, 79:  &#x27;o&#x27;,
                                   80: &#x27;p&#x27;,  81: &#x27;q&#x27;,  82: &#x27;r&#x27;,  83: &#x27;s&#x27;,  84: &#x27;t&#x27;,  85: &#x27;u&#x27;, 86:  &#x27;v&#x27;,
                                   87: &#x27;w&#x27;,  88: &#x27;x&#x27;,  89: &#x27;y&#x27;,  90: &#x27;z&#x27;, 107: &#x27;+&#x27;, 109: &#x27;-&#x27;, 110: &#x27;.&#x27;,
                                  186: &#x27;;&#x27;, 187: &#x27;=&#x27;, 188: &#x27;,&#x27;, 189: &#x27;-&#x27;, 190: &#x27;.&#x27;, 191: &#x27;/&#x27;, 192: &#x27;&#x60;&#x27;,
                                  219: &#x27;[&#x27;, 220: &#x27;\\&#x27;,221: &#x27;]&#x27;, 222: &#x27;\&#x27;&#x27;
                                }
                            };
                            var name, i;
                            for (i in ret.FUNCTION_KEYS) {
                                name = ret.FUNCTION_KEYS[i].toLowerCase();
                                ret[name] = parseInt(i, 10);
                            }
                            for (i in ret.PRINTABLE_KEYS) {
                                name = ret.PRINTABLE_KEYS[i].toLowerCase();
                                ret[name] = parseInt(i, 10);
                            }
                            oop.mixin(ret, ret.MODIFIER_KEYS);
                            oop.mixin(ret, ret.PRINTABLE_KEYS);
                            oop.mixin(ret, ret.FUNCTION_KEYS);
                            ret.enter = ret[&quot;return&quot;];
                            ret.escape = ret.esc;
                            ret.del = ret[&quot;delete&quot;];
                            ret[173] = &#x27;-&#x27;;
                            
                            (function() {
                                var mods = [&quot;cmd&quot;, &quot;ctrl&quot;, &quot;alt&quot;, &quot;shift&quot;];
                                for (var i = Math.pow(2, mods.length); i--;) {            
                                    ret.KEY_MODS[i] = mods.filter(function(x) {
                                        return i &amp; ret.KEY_MODS[x];
                                    }).join(&quot;-&quot;) + &quot;-&quot;;
                                }
                            })();
                        
                            ret.KEY_MODS[0] = &quot;&quot;;
                            ret.KEY_MODS[-1] = &quot;input-&quot;;
                        
                            return ret;
                        })();
                        oop.mixin(exports, Keys);
                        
                        exports.keyCodeToString = function(keyCode) {
                            var keyString = Keys[keyCode];
                            if (typeof keyString != &quot;string&quot;)
                                keyString = String.fromCharCode(keyCode);
                            return keyString.toLowerCase();
                        };
                        
                        });
                        
                        define(&quot;ace/lib/useragent&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        exports.OS = {
                            LINUX: &quot;LINUX&quot;,
                            MAC: &quot;MAC&quot;,
                            WINDOWS: &quot;WINDOWS&quot;
                        };
                        exports.getOS = function() {
                            if (exports.isMac) {
                                return exports.OS.MAC;
                            } else if (exports.isLinux) {
                                return exports.OS.LINUX;
                            } else {
                                return exports.OS.WINDOWS;
                            }
                        };
                        if (typeof navigator != &quot;object&quot;)
                            return;
                        
                        var os = (navigator.platform.match(/mac|win|linux/i) || [&quot;other&quot;])[0].toLowerCase();
                        var ua = navigator.userAgent;
                        exports.isWin = (os == &quot;win&quot;);
                        exports.isMac = (os == &quot;mac&quot;);
                        exports.isLinux = (os == &quot;linux&quot;);
                        exports.isIE = 
                            (navigator.appName == &quot;Microsoft Internet Explorer&quot; || navigator.appName.indexOf(&quot;MSAppHost&quot;) &gt;= 0)
                            ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1])
                            : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1]); // for ie
                            
                        exports.isOldIE = exports.isIE &amp;&amp; exports.isIE &lt; 9;
                        exports.isGecko = exports.isMozilla = (window.Controllers || window.controllers) &amp;&amp; window.navigator.product === &quot;Gecko&quot;;
                        exports.isOldGecko = exports.isGecko &amp;&amp; parseInt((ua.match(/rv\:(\d+)/)||[])[1], 10) &lt; 4;
                        exports.isOpera = window.opera &amp;&amp; Object.prototype.toString.call(window.opera) == &quot;[object Opera]&quot;;
                        exports.isWebKit = parseFloat(ua.split(&quot;WebKit/&quot;)[1]) || undefined;
                        
                        exports.isChrome = parseFloat(ua.split(&quot; Chrome/&quot;)[1]) || undefined;
                        
                        exports.isAIR = ua.indexOf(&quot;AdobeAIR&quot;) &gt;= 0;
                        
                        exports.isIPad = ua.indexOf(&quot;iPad&quot;) &gt;= 0;
                        
                        exports.isTouchPad = ua.indexOf(&quot;TouchPad&quot;) &gt;= 0;
                        
                        exports.isChromeOS = ua.indexOf(&quot; CrOS &quot;) &gt;= 0;
                        
                        });
                        
                        define(&quot;ace/lib/event&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/keys&quot;,&quot;ace/lib/useragent&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var keys = require(&quot;./keys&quot;);
                        var useragent = require(&quot;./useragent&quot;);
                        
                        exports.addListener = function(elem, type, callback) {
                            if (elem.addEventListener) {
                                return elem.addEventListener(type, callback, false);
                            }
                            if (elem.attachEvent) {
                                var wrapper = function() {
                                    callback.call(elem, window.event);
                                };
                                callback._wrapper = wrapper;
                                elem.attachEvent(&quot;on&quot; + type, wrapper);
                            }
                        };
                        
                        exports.removeListener = function(elem, type, callback) {
                            if (elem.removeEventListener) {
                                return elem.removeEventListener(type, callback, false);
                            }
                            if (elem.detachEvent) {
                                elem.detachEvent(&quot;on&quot; + type, callback._wrapper || callback);
                            }
                        };
                        exports.stopEvent = function(e) {
                            exports.stopPropagation(e);
                            exports.preventDefault(e);
                            return false;
                        };
                        
                        exports.stopPropagation = function(e) {
                            if (e.stopPropagation)
                                e.stopPropagation();
                            else
                                e.cancelBubble = true;
                        };
                        
                        exports.preventDefault = function(e) {
                            if (e.preventDefault)
                                e.preventDefault();
                            else
                                e.returnValue = false;
                        };
                        exports.getButton = function(e) {
                            if (e.type == &quot;dblclick&quot;)
                                return 0;
                            if (e.type == &quot;contextmenu&quot; || (useragent.isMac &amp;&amp; (e.ctrlKey &amp;&amp; !e.altKey &amp;&amp; !e.shiftKey)))
                                return 2;
                            if (e.preventDefault) {
                                return e.button;
                            }
                            else {
                                return {1:0, 2:2, 4:1}[e.button];
                            }
                        };
                        
                        exports.capture = function(el, eventHandler, releaseCaptureHandler) {
                            function onMouseUp(e) {
                                eventHandler &amp;&amp; eventHandler(e);
                                releaseCaptureHandler &amp;&amp; releaseCaptureHandler(e);
                        
                                exports.removeListener(document, &quot;mousemove&quot;, eventHandler, true);
                                exports.removeListener(document, &quot;mouseup&quot;, onMouseUp, true);
                                exports.removeListener(document, &quot;dragstart&quot;, onMouseUp, true);
                            }
                        
                            exports.addListener(document, &quot;mousemove&quot;, eventHandler, true);
                            exports.addListener(document, &quot;mouseup&quot;, onMouseUp, true);
                            exports.addListener(document, &quot;dragstart&quot;, onMouseUp, true);
                            
                            return onMouseUp;
                        };
                        
                        exports.addMouseWheelListener = function(el, callback) {
                            if (&quot;onmousewheel&quot; in el) {
                                exports.addListener(el, &quot;mousewheel&quot;, function(e) {
                                    var factor = 8;
                                    if (e.wheelDeltaX !== undefined) {
                                        e.wheelX = -e.wheelDeltaX / factor;
                                        e.wheelY = -e.wheelDeltaY / factor;
                                    } else {
                                        e.wheelX = 0;
                                        e.wheelY = -e.wheelDelta / factor;
                                    }
                                    callback(e);
                                });
                            } else if (&quot;onwheel&quot; in el) {
                                exports.addListener(el, &quot;wheel&quot;,  function(e) {
                                    var factor = 0.35;
                                    switch (e.deltaMode) {
                                        case e.DOM_DELTA_PIXEL:
                                            e.wheelX = e.deltaX * factor || 0;
                                            e.wheelY = e.deltaY * factor || 0;
                                            break;
                                        case e.DOM_DELTA_LINE:
                                        case e.DOM_DELTA_PAGE:
                                            e.wheelX = (e.deltaX || 0) * 5;
                                            e.wheelY = (e.deltaY || 0) * 5;
                                            break;
                                    }
                                    
                                    callback(e);
                                });
                            } else {
                                exports.addListener(el, &quot;DOMMouseScroll&quot;, function(e) {
                                    if (e.axis &amp;&amp; e.axis == e.HORIZONTAL_AXIS) {
                                        e.wheelX = (e.detail || 0) * 5;
                                        e.wheelY = 0;
                                    } else {
                                        e.wheelX = 0;
                                        e.wheelY = (e.detail || 0) * 5;
                                    }
                                    callback(e);
                                });
                            }
                        };
                        
                        exports.addMultiMouseDownListener = function(el, timeouts, eventHandler, callbackName) {
                            var clicks = 0;
                            var startX, startY, timer; 
                            var eventNames = {
                                2: &quot;dblclick&quot;,
                                3: &quot;tripleclick&quot;,
                                4: &quot;quadclick&quot;
                            };
                        
                            exports.addListener(el, &quot;mousedown&quot;, function(e) {
                                if (exports.getButton(e) !== 0) {
                                    clicks = 0;
                                } else if (e.detail &gt; 1) {
                                    clicks++;
                                    if (clicks &gt; 4)
                                        clicks = 1;
                                } else {
                                    clicks = 1;
                                }
                                if (useragent.isIE) {
                                    var isNewClick = Math.abs(e.clientX - startX) &gt; 5 || Math.abs(e.clientY - startY) &gt; 5;
                                    if (!timer || isNewClick)
                                        clicks = 1;
                                    if (timer)
                                        clearTimeout(timer);
                                    timer = setTimeout(function() {timer = null}, timeouts[clicks - 1] || 600);
                        
                                    if (clicks == 1) {
                                        startX = e.clientX;
                                        startY = e.clientY;
                                    }
                                }
                                
                                e._clicks = clicks;
                        
                                eventHandler[callbackName](&quot;mousedown&quot;, e);
                        
                                if (clicks &gt; 4)
                                    clicks = 0;
                                else if (clicks &gt; 1)
                                    return eventHandler[callbackName](eventNames[clicks], e);
                            });
                        
                            if (useragent.isOldIE) {
                                exports.addListener(el, &quot;dblclick&quot;, function(e) {
                                    clicks = 2;
                                    if (timer)
                                        clearTimeout(timer);
                                    timer = setTimeout(function() {timer = null}, timeouts[clicks - 1] || 600);
                                    eventHandler[callbackName](&quot;mousedown&quot;, e);
                                    eventHandler[callbackName](eventNames[clicks], e);
                                });
                            }
                        };
                        
                        var getModifierHash = useragent.isMac &amp;&amp; useragent.isOpera &amp;&amp; !(&quot;KeyboardEvent&quot; in window)
                            ? function(e) {
                                return 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);
                            }
                            : function(e) {
                                return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
                            };
                        
                        exports.getModifierString = function(e) {
                            return keys.KEY_MODS[getModifierHash(e)];
                        };
                        
                        function normalizeCommandKeys(callback, e, keyCode) {
                            var hashId = getModifierHash(e);
                        
                            if (!useragent.isMac &amp;&amp; pressedKeys) {
                                if (pressedKeys[91] || pressedKeys[92])
                                    hashId |= 8;
                                if (pressedKeys.altGr) {
                                    if ((3 &amp; hashId) != 3)
                                        pressedKeys.altGr = 0;
                                    else
                                        return;
                                }
                                if (keyCode === 18 || keyCode === 17) {
                                    var location = &quot;location&quot; in e ? e.location : e.keyLocation;
                                    if (keyCode === 17 &amp;&amp; location === 1) {
                                        if (pressedKeys[keyCode] == 1)
                                            ts = e.timeStamp;
                                    } else if (keyCode === 18 &amp;&amp; hashId === 3 &amp;&amp; location === 2) {
                                        var dt = e.timeStamp - ts;
                                        if (dt &lt; 50)
                                            pressedKeys.altGr = true;
                                    }
                                }
                            }
                            
                            if (keyCode in keys.MODIFIER_KEYS) {
                                keyCode = -1;
                            }
                        
                            if (hashId &amp; 8 &amp;&amp; (keyCode === 91 || keyCode === 93)) {
                                keyCode = -1;
                            }
                            
                            if (!hashId &amp;&amp; keyCode === 13) {
                                var location = &quot;location&quot; in e ? e.location : e.keyLocation;
                                if (location === 3) {
                                    callback(e, hashId, -keyCode);
                                    if (e.defaultPrevented)
                                        return;
                                }
                            }
                            
                            if (useragent.isChromeOS &amp;&amp; hashId &amp; 8) {
                                callback(e, hashId, keyCode);
                                if (e.defaultPrevented)
                                    return;
                                else
                                    hashId &amp;= ~8;
                            }
                            if (!hashId &amp;&amp; !(keyCode in keys.FUNCTION_KEYS) &amp;&amp; !(keyCode in keys.PRINTABLE_KEYS)) {
                                return false;
                            }
                            
                            return callback(e, hashId, keyCode);
                        }
                        
                        var pressedKeys = null;
                        var ts = 0;
                        exports.addCommandKeyListener = function(el, callback) {
                            var addListener = exports.addListener;
                            if (useragent.isOldGecko || (useragent.isOpera &amp;&amp; !(&quot;KeyboardEvent&quot; in window))) {
                                var lastKeyDownKeyCode = null;
                                addListener(el, &quot;keydown&quot;, function(e) {
                                    lastKeyDownKeyCode = e.keyCode;
                                });
                                addListener(el, &quot;keypress&quot;, function(e) {
                                    return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
                                });
                            } else {
                                var lastDefaultPrevented = null;
                        
                                addListener(el, &quot;keydown&quot;, function(e) {
                                    pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
                                    var result = normalizeCommandKeys(callback, e, e.keyCode);
                                    lastDefaultPrevented = e.defaultPrevented;
                                    return result;
                                });
                        
                                addListener(el, &quot;keypress&quot;, function(e) {
                                    if (lastDefaultPrevented &amp;&amp; (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
                                        exports.stopEvent(e);
                                        lastDefaultPrevented = null;
                                    }
                                });
                        
                                addListener(el, &quot;keyup&quot;, function(e) {
                                    pressedKeys[e.keyCode] = null;
                                });
                        
                                if (!pressedKeys) {
                                    pressedKeys = Object.create(null);
                                    addListener(window, &quot;focus&quot;, function(e) {
                                        pressedKeys = Object.create(null);
                                    });
                                }
                            }
                        };
                        
                        if (window.postMessage &amp;&amp; !useragent.isOldIE) {
                            var postMessageId = 1;
                            exports.nextTick = function(callback, win) {
                                win = win || window;
                                var messageName = &quot;zero-timeout-message-&quot; + postMessageId;
                                exports.addListener(win, &quot;message&quot;, function listener(e) {
                                    if (e.data == messageName) {
                                        exports.stopPropagation(e);
                                        exports.removeListener(win, &quot;message&quot;, listener);
                                        callback();
                                    }
                                });
                                win.postMessage(messageName, &quot;*&quot;);
                            };
                        }
                        
                        
                        exports.nextFrame = window.requestAnimationFrame ||
                            window.mozRequestAnimationFrame ||
                            window.webkitRequestAnimationFrame ||
                            window.msRequestAnimationFrame ||
                            window.oRequestAnimationFrame;
                        
                        if (exports.nextFrame)
                            exports.nextFrame = exports.nextFrame.bind(window);
                        else
                            exports.nextFrame = function(callback) {
                                setTimeout(callback, 17);
                            };
                        });
                        
                        define(&quot;ace/lib/lang&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        exports.last = function(a) {
                            return a[a.length - 1];
                        };
                        
                        exports.stringReverse = function(string) {
                            return string.split(&quot;&quot;).reverse().join(&quot;&quot;);
                        };
                        
                        exports.stringRepeat = function (string, count) {
                            var result = &#x27;&#x27;;
                            while (count &gt; 0) {
                                if (count &amp; 1)
                                    result += string;
                        
                                if (count &gt;&gt;= 1)
                                    string += string;
                            }
                            return result;
                        };
                        
                        var trimBeginRegexp = /^\s\s*/;
                        var trimEndRegexp = /\s\s*$/;
                        
                        exports.stringTrimLeft = function (string) {
                            return string.replace(trimBeginRegexp, &#x27;&#x27;);
                        };
                        
                        exports.stringTrimRight = function (string) {
                            return string.replace(trimEndRegexp, &#x27;&#x27;);
                        };
                        
                        exports.copyObject = function(obj) {
                            var copy = {};
                            for (var key in obj) {
                                copy[key] = obj[key];
                            }
                            return copy;
                        };
                        
                        exports.copyArray = function(array){
                            var copy = [];
                            for (var i=0, l=array.length; i&lt;l; i++) {
                                if (array[i] &amp;&amp; typeof array[i] == &quot;object&quot;)
                                    copy[i] = this.copyObject( array[i] );
                                else 
                                    copy[i] = array[i];
                            }
                            return copy;
                        };
                        
                        exports.deepCopy = function deepCopy(obj) {
                            if (typeof obj !== &quot;object&quot; || !obj)
                                return obj;
                            var copy;
                            if (Array.isArray(obj)) {
                                copy = [];
                                for (var key = 0; key &lt; obj.length; key++) {
                                    copy[key] = deepCopy(obj[key]);
                                }
                                return copy;
                            }
                            var cons = obj.constructor;
                            if (cons === RegExp)
                                return obj;
                            
                            copy = cons();
                            for (var key in obj) {
                                copy[key] = deepCopy(obj[key]);
                            }
                            return copy;
                        };
                        
                        exports.arrayToMap = function(arr) {
                            var map = {};
                            for (var i=0; i&lt;arr.length; i++) {
                                map[arr[i]] = 1;
                            }
                            return map;
                        
                        };
                        
                        exports.createMap = function(props) {
                            var map = Object.create(null);
                            for (var i in props) {
                                map[i] = props[i];
                            }
                            return map;
                        };
                        exports.arrayRemove = function(array, value) {
                          for (var i = 0; i &lt;= array.length; i++) {
                            if (value === array[i]) {
                              array.splice(i, 1);
                            }
                          }
                        };
                        
                        exports.escapeRegExp = function(str) {
                            return str.replace(/([.*+?^${}()|[\]\/\\])/g, &#x27;\\$1&#x27;);
                        };
                        
                        exports.escapeHTML = function(str) {
                            return str.replace(/&amp;/g, &quot;&amp;#38;&quot;).replace(/&quot;/g, &quot;&amp;#34;&quot;).replace(/&#x27;/g, &quot;&amp;#39;&quot;).replace(/&lt;/g, &quot;&amp;#60;&quot;);
                        };
                        
                        exports.getMatchOffsets = function(string, regExp) {
                            var matches = [];
                        
                            string.replace(regExp, function(str) {
                                matches.push({
                                    offset: arguments[arguments.length-2],
                                    length: str.length
                                });
                            });
                        
                            return matches;
                        };
                        exports.deferredCall = function(fcn) {
                            var timer = null;
                            var callback = function() {
                                timer = null;
                                fcn();
                            };
                        
                            var deferred = function(timeout) {
                                deferred.cancel();
                                timer = setTimeout(callback, timeout || 0);
                                return deferred;
                            };
                        
                            deferred.schedule = deferred;
                        
                            deferred.call = function() {
                                this.cancel();
                                fcn();
                                return deferred;
                            };
                        
                            deferred.cancel = function() {
                                clearTimeout(timer);
                                timer = null;
                                return deferred;
                            };
                            
                            deferred.isPending = function() {
                                return timer;
                            };
                        
                            return deferred;
                        };
                        
                        
                        exports.delayedCall = function(fcn, defaultTimeout) {
                            var timer = null;
                            var callback = function() {
                                timer = null;
                                fcn();
                            };
                        
                            var _self = function(timeout) {
                                if (timer == null)
                                    timer = setTimeout(callback, timeout || defaultTimeout);
                            };
                        
                            _self.delay = function(timeout) {
                                timer &amp;&amp; clearTimeout(timer);
                                timer = setTimeout(callback, timeout || defaultTimeout);
                            };
                            _self.schedule = _self;
                        
                            _self.call = function() {
                                this.cancel();
                                fcn();
                            };
                        
                            _self.cancel = function() {
                                timer &amp;&amp; clearTimeout(timer);
                                timer = null;
                            };
                        
                            _self.isPending = function() {
                                return timer;
                            };
                        
                            return _self;
                        };
                        });
                        
                        define(&quot;ace/keyboard/textinput&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/event&quot;,&quot;ace/lib/useragent&quot;,&quot;ace/lib/dom&quot;,&quot;ace/lib/lang&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var event = require(&quot;../lib/event&quot;);
                        var useragent = require(&quot;../lib/useragent&quot;);
                        var dom = require(&quot;../lib/dom&quot;);
                        var lang = require(&quot;../lib/lang&quot;);
                        var BROKEN_SETDATA = useragent.isChrome &lt; 18;
                        var USE_IE_MIME_TYPE =  useragent.isIE;
                        
                        var TextInput = function(parentNode, host) {
                            var text = dom.createElement(&quot;textarea&quot;);
                            text.className = &quot;ace_text-input&quot;;
                        
                            if (useragent.isTouchPad)
                                text.setAttribute(&quot;x-palm-disable-auto-cap&quot;, true);
                        
                            text.setAttribute(&quot;wrap&quot;, &quot;off&quot;);
                            text.setAttribute(&quot;autocorrect&quot;, &quot;off&quot;);
                            text.setAttribute(&quot;autocapitalize&quot;, &quot;off&quot;);
                            text.setAttribute(&quot;spellcheck&quot;, false);
                        
                            text.style.opacity = &quot;0&quot;;
                            if (useragent.isOldIE) text.style.top = &quot;-1000px&quot;;
                            parentNode.insertBefore(text, parentNode.firstChild);
                        
                            var PLACEHOLDER = &quot;\x01\x01&quot;;
                        
                            var copied = false;
                            var pasted = false;
                            var inComposition = false;
                            var tempStyle = &#x27;&#x27;;
                            var isSelectionEmpty = true;
                            try { var isFocused = document.activeElement === text; } catch(e) {}
                            
                            event.addListener(text, &quot;blur&quot;, function(e) {
                                host.onBlur(e);
                                isFocused = false;
                            });
                            event.addListener(text, &quot;focus&quot;, function(e) {
                                isFocused = true;
                                host.onFocus(e);
                                resetSelection();
                            });
                            this.focus = function() {
                                if (tempStyle) return text.focus();
                                text.style.position = &quot;fixed&quot;;
                                text.style.top = &quot;-1000px&quot;;
                                text.focus();
                                setTimeout(function() {
                                    text.style.position = &quot;&quot;;
                                }, 0);
                            };
                            this.blur = function() { text.blur(); };
                            this.isFocused = function() {
                                return isFocused;
                            };
                            var syncSelection = lang.delayedCall(function() {
                                isFocused &amp;&amp; resetSelection(isSelectionEmpty);
                            });
                            var syncValue = lang.delayedCall(function() {
                                 if (!inComposition) {
                                    text.value = PLACEHOLDER;
                                    isFocused &amp;&amp; resetSelection();
                                 }
                            });
                        
                            function resetSelection(isEmpty) {
                                if (inComposition)
                                    return;
                                inComposition = true;
                                
                                if (inputHandler) {
                                    selectionStart = 0;
                                    selectionEnd = isEmpty ? 0 : text.value.length - 1;
                                } else {
                                    var selectionStart = isEmpty ? 2 : 1;
                                    var selectionEnd = 2;
                                }
                                try {
                                    text.setSelectionRange(selectionStart, selectionEnd);
                                } catch(e){}
                                
                                inComposition = false;
                            }
                        
                            function resetValue() {
                                if (inComposition)
                                    return;
                                text.value = PLACEHOLDER;
                                if (useragent.isWebKit)
                                    syncValue.schedule();
                            }
                        
                            useragent.isWebKit || host.addEventListener(&#x27;changeSelection&#x27;, function() {
                                if (host.selection.isEmpty() != isSelectionEmpty) {
                                    isSelectionEmpty = !isSelectionEmpty;
                                    syncSelection.schedule();
                                }
                            });
                        
                            resetValue();
                            if (isFocused)
                                host.onFocus();
                        
                        
                            var isAllSelected = function(text) {
                                return text.selectionStart === 0 &amp;&amp; text.selectionEnd === text.value.length;
                            };
                            if (!text.setSelectionRange &amp;&amp; text.createTextRange) {
                                text.setSelectionRange = function(selectionStart, selectionEnd) {
                                    var range = this.createTextRange();
                                    range.collapse(true);
                                    range.moveStart(&#x27;character&#x27;, selectionStart);
                                    range.moveEnd(&#x27;character&#x27;, selectionEnd);
                                    range.select();
                                };
                                isAllSelected = function(text) {
                                    try {
                                        var range = text.ownerDocument.selection.createRange();
                                    }catch(e) {}
                                    if (!range || range.parentElement() != text) return false;
                                        return range.text == text.value;
                                }
                            }
                            if (useragent.isOldIE) {
                                var inPropertyChange = false;
                                var onPropertyChange = function(e){
                                    if (inPropertyChange)
                                        return;
                                    var data = text.value;
                                    if (inComposition || !data || data == PLACEHOLDER)
                                        return;
                                    if (e &amp;&amp; data == PLACEHOLDER[0])
                                        return syncProperty.schedule();
                        
                                    sendText(data);
                                    inPropertyChange = true;
                                    resetValue();
                                    inPropertyChange = false;
                                };
                                var syncProperty = lang.delayedCall(onPropertyChange);
                                event.addListener(text, &quot;propertychange&quot;, onPropertyChange);
                        
                                var keytable = { 13:1, 27:1 };
                                event.addListener(text, &quot;keyup&quot;, function (e) {
                                    if (inComposition &amp;&amp; (!text.value || keytable[e.keyCode]))
                                        setTimeout(onCompositionEnd, 0);
                                    if ((text.value.charCodeAt(0)||0) &lt; 129) {
                                        return syncProperty.call();
                                    }
                                    inComposition ? onCompositionUpdate() : onCompositionStart();
                                });
                                event.addListener(text, &quot;keydown&quot;, function (e) {
                                    syncProperty.schedule(50);
                                });
                            }
                        
                            var onSelect = function(e) {
                                if (copied) {
                                    copied = false;
                                } else if (isAllSelected(text)) {
                                    host.selectAll();
                                    resetSelection();
                                } else if (inputHandler) {
                                    resetSelection(host.selection.isEmpty());
                                }
                            };
                        
                            var inputHandler = null;
                            this.setInputHandler = function(cb) {inputHandler = cb};
                            this.getInputHandler = function() {return inputHandler};
                            var afterContextMenu = false;
                            
                            var sendText = function(data) {
                                if (inputHandler) {
                                    data = inputHandler(data);
                                    inputHandler = null;
                                }
                                if (pasted) {
                                    resetSelection();
                                    if (data)
                                        host.onPaste(data);
                                    pasted = false;
                                } else if (data == PLACEHOLDER.charAt(0)) {
                                    if (afterContextMenu)
                                        host.execCommand(&quot;del&quot;, {source: &quot;ace&quot;});
                                    else // some versions of android do not fire keydown when pressing backspace
                                        host.execCommand(&quot;backspace&quot;, {source: &quot;ace&quot;});
                                } else {
                                    if (data.substring(0, 2) == PLACEHOLDER)
                                        data = data.substr(2);
                                    else if (data.charAt(0) == PLACEHOLDER.charAt(0))
                                        data = data.substr(1);
                                    else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
                                        data = data.slice(0, -1);
                                    if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
                                        data = data.slice(0, -1);
                                    
                                    if (data)
                                        host.onTextInput(data);
                                }
                                if (afterContextMenu)
                                    afterContextMenu = false;
                            };
                            var onInput = function(e) {
                                if (inComposition)
                                    return;
                                var data = text.value;
                                sendText(data);
                                resetValue();
                            };
                            
                            var handleClipboardData = function(e, data) {
                                var clipboardData = e.clipboardData || window.clipboardData;
                                if (!clipboardData || BROKEN_SETDATA)
                                    return;
                                var mime = USE_IE_MIME_TYPE ? &quot;Text&quot; : &quot;text/plain&quot;;
                                if (data) {
                                    return clipboardData.setData(mime, data) !== false;
                                } else {
                                    return clipboardData.getData(mime);
                                }
                            };
                        
                            var doCopy = function(e, isCut) {
                                var data = host.getCopyText();
                                if (!data)
                                    return event.preventDefault(e);
                        
                                if (handleClipboardData(e, data)) {
                                    isCut ? host.onCut() : host.onCopy();
                                    event.preventDefault(e);
                                } else {
                                    copied = true;
                                    text.value = data;
                                    text.select();
                                    setTimeout(function(){
                                        copied = false;
                                        resetValue();
                                        resetSelection();
                                        isCut ? host.onCut() : host.onCopy();
                                    });
                                }
                            };
                            
                            var onCut = function(e) {
                                doCopy(e, true);
                            };
                            
                            var onCopy = function(e) {
                                doCopy(e, false);
                            };
                            
                            var onPaste = function(e) {
                                var data = handleClipboardData(e);
                                if (typeof data == &quot;string&quot;) {
                                    if (data)
                                        host.onPaste(data);
                                    if (useragent.isIE)
                                        setTimeout(resetSelection);
                                    event.preventDefault(e);
                                }
                                else {
                                    text.value = &quot;&quot;;
                                    pasted = true;
                                }
                            };
                        
                            event.addCommandKeyListener(text, host.onCommandKey.bind(host));
                        
                            event.addListener(text, &quot;select&quot;, onSelect);
                        
                            event.addListener(text, &quot;input&quot;, onInput);
                        
                            event.addListener(text, &quot;cut&quot;, onCut);
                            event.addListener(text, &quot;copy&quot;, onCopy);
                            event.addListener(text, &quot;paste&quot;, onPaste);
                            if (!(&#x27;oncut&#x27; in text) || !(&#x27;oncopy&#x27; in text) || !(&#x27;onpaste&#x27; in text)){
                                event.addListener(parentNode, &quot;keydown&quot;, function(e) {
                                    if ((useragent.isMac &amp;&amp; !e.metaKey) || !e.ctrlKey)
                                        return;
                        
                                    switch (e.keyCode) {
                                        case 67:
                                            onCopy(e);
                                            break;
                                        case 86:
                                            onPaste(e);
                                            break;
                                        case 88:
                                            onCut(e);
                                            break;
                                    }
                                });
                            }
                            var onCompositionStart = function(e) {
                                if (inComposition || !host.onCompositionStart || host.$readOnly) 
                                    return;
                                inComposition = {};
                                host.onCompositionStart();
                                setTimeout(onCompositionUpdate, 0);
                                host.on(&quot;mousedown&quot;, onCompositionEnd);
                                if (!host.selection.isEmpty()) {
                                    host.insert(&quot;&quot;);
                                    host.session.markUndoGroup();
                                    host.selection.clearSelection();
                                }
                                host.session.markUndoGroup();
                            };
                        
                            var onCompositionUpdate = function() {
                                if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
                                    return;
                                var val = text.value.replace(/\x01/g, &quot;&quot;);
                                if (inComposition.lastValue === val) return;
                                
                                host.onCompositionUpdate(val);
                                if (inComposition.lastValue)
                                    host.undo();
                                inComposition.lastValue = val;
                                if (inComposition.lastValue) {
                                    var r = host.selection.getRange();
                                    host.insert(inComposition.lastValue);
                                    host.session.markUndoGroup();
                                    inComposition.range = host.selection.getRange();
                                    host.selection.setRange(r);
                                    host.selection.clearSelection();
                                }
                            };
                        
                            var onCompositionEnd = function(e) {
                                if (!host.onCompositionEnd || host.$readOnly) return;
                                var c = inComposition;
                                inComposition = false;
                                var timer = setTimeout(function() {
                                    timer = null;
                                    var str = text.value.replace(/\x01/g, &quot;&quot;);
                                    if (inComposition)
                                        return;
                                    else if (str == c.lastValue)
                                        resetValue();
                                    else if (!c.lastValue &amp;&amp; str) {
                                        resetValue();
                                        sendText(str);
                                    }
                                });
                                inputHandler = function compositionInputHandler(str) {
                                    if (timer)
                                        clearTimeout(timer);
                                    str = str.replace(/\x01/g, &quot;&quot;);
                                    if (str == c.lastValue)
                                        return &quot;&quot;;
                                    if (c.lastValue &amp;&amp; timer)
                                        host.undo();
                                    return str;
                                };
                                host.onCompositionEnd();
                                host.removeListener(&quot;mousedown&quot;, onCompositionEnd);
                                if (e.type == &quot;compositionend&quot; &amp;&amp; c.range) {
                                    host.selection.setRange(c.range);
                                }
                            };
                            
                            
                        
                            var syncComposition = lang.delayedCall(onCompositionUpdate, 50);
                        
                            event.addListener(text, &quot;compositionstart&quot;, onCompositionStart);
                            if (useragent.isGecko) {
                                event.addListener(text, &quot;text&quot;, function(){syncComposition.schedule()});
                            } else {
                                event.addListener(text, &quot;keyup&quot;, function(){syncComposition.schedule()});
                                event.addListener(text, &quot;keydown&quot;, function(){syncComposition.schedule()});
                            }
                            event.addListener(text, &quot;compositionend&quot;, onCompositionEnd);
                        
                            this.getElement = function() {
                                return text;
                            };
                        
                            this.setReadOnly = function(readOnly) {
                               text.readOnly = readOnly;
                            };
                        
                            this.onContextMenu = function(e) {
                                afterContextMenu = true;
                                resetSelection(host.selection.isEmpty());
                                host._emit(&quot;nativecontextmenu&quot;, {target: host, domEvent: e});
                                this.moveToMouse(e, true);
                            };
                            
                            this.moveToMouse = function(e, bringToFront) {
                                if (!bringToFront &amp;&amp; useragent.isOldIE)
                                    return;
                                if (!tempStyle)
                                    tempStyle = text.style.cssText;
                                text.style.cssText = (bringToFront ? &quot;z-index:100000;&quot; : &quot;&quot;)
                                    + &quot;height:&quot; + text.style.height + &quot;;&quot;
                                    + (useragent.isIE ? &quot;opacity:0.1;&quot; : &quot;&quot;);
                        
                                var rect = host.container.getBoundingClientRect();
                                var style = dom.computedStyle(host.container);
                                var top = rect.top + (parseInt(style.borderTopWidth) || 0);
                                var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
                                var maxTop = rect.bottom - top - text.clientHeight -2;
                                var move = function(e) {
                                    text.style.left = e.clientX - left - 2 + &quot;px&quot;;
                                    text.style.top = Math.min(e.clientY - top - 2, maxTop) + &quot;px&quot;;
                                }; 
                                move(e);
                        
                                if (e.type != &quot;mousedown&quot;)
                                    return;
                        
                                if (host.renderer.$keepTextAreaAtCursor)
                                    host.renderer.$keepTextAreaAtCursor = null;
                                if (useragent.isWin &amp;&amp; !useragent.isOldIE)
                                    event.capture(host.container, move, onContextMenuClose);
                            };
                        
                            this.onContextMenuClose = onContextMenuClose;
                            var closeTimeout;
                            function onContextMenuClose() {
                                clearTimeout(closeTimeout)
                                closeTimeout = setTimeout(function () {
                                    if (tempStyle) {
                                        text.style.cssText = tempStyle;
                                        tempStyle = &#x27;&#x27;;
                                    }
                                    if (host.renderer.$keepTextAreaAtCursor == null) {
                                        host.renderer.$keepTextAreaAtCursor = true;
                                        host.renderer.$moveTextAreaToCursor();
                                    }
                                }, useragent.isOldIE ? 200 : 0);
                            }
                        
                            var onContextMenu = function(e) {
                                host.textInput.onContextMenu(e);
                                onContextMenuClose();
                            };
                            event.addListener(host.renderer.scroller, &quot;contextmenu&quot;, onContextMenu);
                            event.addListener(text, &quot;contextmenu&quot;, onContextMenu);
                        };
                        
                        exports.TextInput = TextInput;
                        });
                        
                        define(&quot;ace/mouse/default_handlers&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/dom&quot;,&quot;ace/lib/event&quot;,&quot;ace/lib/useragent&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var dom = require(&quot;../lib/dom&quot;);
                        var event = require(&quot;../lib/event&quot;);
                        var useragent = require(&quot;../lib/useragent&quot;);
                        
                        var DRAG_OFFSET = 0; // pixels
                        
                        function DefaultHandlers(mouseHandler) {
                            mouseHandler.$clickSelection = null;
                        
                            var editor = mouseHandler.editor;
                            editor.setDefaultHandler(&quot;mousedown&quot;, this.onMouseDown.bind(mouseHandler));
                            editor.setDefaultHandler(&quot;dblclick&quot;, this.onDoubleClick.bind(mouseHandler));
                            editor.setDefaultHandler(&quot;tripleclick&quot;, this.onTripleClick.bind(mouseHandler));
                            editor.setDefaultHandler(&quot;quadclick&quot;, this.onQuadClick.bind(mouseHandler));
                            editor.setDefaultHandler(&quot;mousewheel&quot;, this.onMouseWheel.bind(mouseHandler));
                        
                            var exports = [&quot;select&quot;, &quot;startSelect&quot;, &quot;selectEnd&quot;, &quot;selectAllEnd&quot;, &quot;selectByWordsEnd&quot;,
                                &quot;selectByLinesEnd&quot;, &quot;dragWait&quot;, &quot;dragWaitEnd&quot;, &quot;focusWait&quot;];
                        
                            exports.forEach(function(x) {
                                mouseHandler[x] = this[x];
                            }, this);
                        
                            mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, &quot;getLineRange&quot;);
                            mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, &quot;getWordRange&quot;);
                        }
                        
                        (function() {
                        
                            this.onMouseDown = function(ev) {
                                var inSelection = ev.inSelection();
                                var pos = ev.getDocumentPosition();
                                this.mousedownEvent = ev;
                                var editor = this.editor;
                        
                                var button = ev.getButton();
                                if (button !== 0) {
                                    var selectionRange = editor.getSelectionRange();
                                    var selectionEmpty = selectionRange.isEmpty();
                                    editor.$blockScrolling++;
                                    if (selectionEmpty)
                                        editor.selection.moveToPosition(pos);
                                    editor.$blockScrolling--;
                                    editor.textInput.onContextMenu(ev.domEvent);
                                    return; // stopping event here breaks contextmenu on ff mac
                                }
                        
                                this.mousedownEvent.time = Date.now();
                                if (inSelection &amp;&amp; !editor.isFocused()) {
                                    editor.focus();
                                    if (this.$focusTimout &amp;&amp; !this.$clickSelection &amp;&amp; !editor.inMultiSelectMode) {
                                        this.setState(&quot;focusWait&quot;);
                                        this.captureMouse(ev);
                                        return;
                                    }
                                }
                        
                                this.captureMouse(ev);
                                this.startSelect(pos, ev.domEvent._clicks &gt; 1);
                                return ev.preventDefault();
                            };
                        
                            this.startSelect = function(pos, waitForClickSelection) {
                                pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
                                var editor = this.editor;
                                editor.$blockScrolling++;
                                if (this.mousedownEvent.getShiftKey())
                                    editor.selection.selectToPosition(pos);
                                else if (!waitForClickSelection)
                                    editor.selection.moveToPosition(pos);
                                if (!waitForClickSelection)
                                    this.select();
                                if (editor.renderer.scroller.setCapture) {
                                    editor.renderer.scroller.setCapture();
                                }
                                editor.setStyle(&quot;ace_selecting&quot;);
                                this.setState(&quot;select&quot;);
                                editor.$blockScrolling--;
                            };
                        
                            this.select = function() {
                                var anchor, editor = this.editor;
                                var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
                                editor.$blockScrolling++;
                                if (this.$clickSelection) {
                                    var cmp = this.$clickSelection.comparePoint(cursor);
                        
                                    if (cmp == -1) {
                                        anchor = this.$clickSelection.end;
                                    } else if (cmp == 1) {
                                        anchor = this.$clickSelection.start;
                                    } else {
                                        var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                                        cursor = orientedRange.cursor;
                                        anchor = orientedRange.anchor;
                                    }
                                    editor.selection.setSelectionAnchor(anchor.row, anchor.column);
                                }
                                editor.selection.selectToPosition(cursor);
                                editor.$blockScrolling--;
                                editor.renderer.scrollCursorIntoView();
                            };
                        
                            this.extendSelectionBy = function(unitName) {
                                var anchor, editor = this.editor;
                                var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
                                var range = editor.selection[unitName](cursor.row, cursor.column);
                                editor.$blockScrolling++;
                                if (this.$clickSelection) {
                                    var cmpStart = this.$clickSelection.comparePoint(range.start);
                                    var cmpEnd = this.$clickSelection.comparePoint(range.end);
                        
                                    if (cmpStart == -1 &amp;&amp; cmpEnd &lt;= 0) {
                                        anchor = this.$clickSelection.end;
                                        if (range.end.row != cursor.row || range.end.column != cursor.column)
                                            cursor = range.start;
                                    } else if (cmpEnd == 1 &amp;&amp; cmpStart &gt;= 0) {
                                        anchor = this.$clickSelection.start;
                                        if (range.start.row != cursor.row || range.start.column != cursor.column)
                                            cursor = range.end;
                                    } else if (cmpStart == -1 &amp;&amp; cmpEnd == 1) {
                                        cursor = range.end;
                                        anchor = range.start;
                                    } else {
                                        var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                                        cursor = orientedRange.cursor;
                                        anchor = orientedRange.anchor;
                                    }
                                    editor.selection.setSelectionAnchor(anchor.row, anchor.column);
                                }
                                editor.selection.selectToPosition(cursor);
                                editor.$blockScrolling--;
                                editor.renderer.scrollCursorIntoView();
                            };
                        
                            this.selectEnd =
                            this.selectAllEnd =
                            this.selectByWordsEnd =
                            this.selectByLinesEnd = function() {
                                this.$clickSelection = null;
                                this.editor.unsetStyle(&quot;ace_selecting&quot;);
                                if (this.editor.renderer.scroller.releaseCapture) {
                                    this.editor.renderer.scroller.releaseCapture();
                                }
                            };
                        
                            this.focusWait = function() {
                                var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
                                var time = Date.now();
                        
                                if (distance &gt; DRAG_OFFSET || time - this.mousedownEvent.time &gt; this.$focusTimout)
                                    this.startSelect(this.mousedownEvent.getDocumentPosition());
                            };
                        
                            this.onDoubleClick = function(ev) {
                                var pos = ev.getDocumentPosition();
                                var editor = this.editor;
                                var session = editor.session;
                        
                                var range = session.getBracketRange(pos);
                                if (range) {
                                    if (range.isEmpty()) {
                                        range.start.column--;
                                        range.end.column++;
                                    }
                                    this.setState(&quot;select&quot;);
                                } else {
                                    range = editor.selection.getWordRange(pos.row, pos.column);
                                    this.setState(&quot;selectByWords&quot;);
                                }
                                this.$clickSelection = range;
                                this.select();
                            };
                        
                            this.onTripleClick = function(ev) {
                                var pos = ev.getDocumentPosition();
                                var editor = this.editor;
                        
                                this.setState(&quot;selectByLines&quot;);
                                var range = editor.getSelectionRange();
                                if (range.isMultiLine() &amp;&amp; range.contains(pos.row, pos.column)) {
                                    this.$clickSelection = editor.selection.getLineRange(range.start.row);
                                    this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
                                } else {
                                    this.$clickSelection = editor.selection.getLineRange(pos.row);
                                }
                                this.select();
                            };
                        
                            this.onQuadClick = function(ev) {
                                var editor = this.editor;
                        
                                editor.selectAll();
                                this.$clickSelection = editor.getSelectionRange();
                                this.setState(&quot;selectAll&quot;);
                            };
                        
                            this.onMouseWheel = function(ev) {
                                if (ev.getAccelKey())
                                    return;
                                if (ev.getShiftKey() &amp;&amp; ev.wheelY &amp;&amp; !ev.wheelX) {
                                    ev.wheelX = ev.wheelY;
                                    ev.wheelY = 0;
                                }
                        
                                var t = ev.domEvent.timeStamp;
                                var dt = t - (this.$lastScrollTime||0);
                                
                                var editor = this.editor;
                                var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                                if (isScrolable || dt &lt; 200) {
                                    this.$lastScrollTime = t;
                                    editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                                    return ev.stop();
                                }
                            };
                        
                        }).call(DefaultHandlers.prototype);
                        
                        exports.DefaultHandlers = DefaultHandlers;
                        
                        function calcDistance(ax, ay, bx, by) {
                            return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
                        }
                        
                        function calcRangeOrientation(range, cursor) {
                            if (range.start.row == range.end.row)
                                var cmp = 2 * cursor.column - range.start.column - range.end.column;
                            else if (range.start.row == range.end.row - 1 &amp;&amp; !range.start.column &amp;&amp; !range.end.column)
                                var cmp = cursor.column - 4;
                            else
                                var cmp = 2 * cursor.row - range.start.row - range.end.row;
                        
                            if (cmp &lt; 0)
                                return {cursor: range.start, anchor: range.end};
                            else
                                return {cursor: range.end, anchor: range.start};
                        }
                        
                        });
                        
                        define(&quot;ace/tooltip&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/dom&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var oop = require(&quot;./lib/oop&quot;);
                        var dom = require(&quot;./lib/dom&quot;);
                        function Tooltip (parentNode) {
                            this.isOpen = false;
                            this.$element = null;
                            this.$parentNode = parentNode;
                        }
                        
                        (function() {
                            this.$init = function() {
                                this.$element = dom.createElement(&quot;div&quot;);
                                this.$element.className = &quot;ace_tooltip&quot;;
                                this.$element.style.display = &quot;none&quot;;
                                this.$parentNode.appendChild(this.$element);
                                return this.$element;
                            };
                            this.getElement = function() {
                                return this.$element || this.$init();
                            };
                            this.setText = function(text) {
                                dom.setInnerText(this.getElement(), text);
                            };
                            this.setHtml = function(html) {
                                this.getElement().innerHTML = html;
                            };
                            this.setPosition = function(x, y) {
                                this.getElement().style.left = x + &quot;px&quot;;
                                this.getElement().style.top = y + &quot;px&quot;;
                            };
                            this.setClassName = function(className) {
                                dom.addCssClass(this.getElement(), className);
                            };
                            this.show = function(text, x, y) {
                                if (text != null)
                                    this.setText(text);
                                if (x != null &amp;&amp; y != null)
                                    this.setPosition(x, y);
                                if (!this.isOpen) {
                                    this.getElement().style.display = &quot;block&quot;;
                                    this.isOpen = true;
                                }
                            };
                        
                            this.hide = function() {
                                if (this.isOpen) {
                                    this.getElement().style.display = &quot;none&quot;;
                                    this.isOpen = false;
                                }
                            };
                            this.getHeight = function() {
                                return this.getElement().offsetHeight;
                            };
                            this.getWidth = function() {
                                return this.getElement().offsetWidth;
                            };
                        
                        }).call(Tooltip.prototype);
                        
                        exports.Tooltip = Tooltip;
                        });
                        
                        define(&quot;ace/mouse/default_gutter_handler&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/dom&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/event&quot;,&quot;ace/tooltip&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        var dom = require(&quot;../lib/dom&quot;);
                        var oop = require(&quot;../lib/oop&quot;);
                        var event = require(&quot;../lib/event&quot;);
                        var Tooltip = require(&quot;../tooltip&quot;).Tooltip;
                        
                        function GutterHandler(mouseHandler) {
                            var editor = mouseHandler.editor;
                            var gutter = editor.renderer.$gutterLayer;
                            var tooltip = new GutterTooltip(editor.container);
                        
                            mouseHandler.editor.setDefaultHandler(&quot;guttermousedown&quot;, function(e) {
                                if (!editor.isFocused() || e.getButton() != 0)
                                    return;
                                var gutterRegion = gutter.getRegion(e);
                        
                                if (gutterRegion == &quot;foldWidgets&quot;)
                                    return;
                        
                                var row = e.getDocumentPosition().row;
                                var selection = editor.session.selection;
                        
                                if (e.getShiftKey())
                                    selection.selectTo(row, 0);
                                else {
                                    if (e.domEvent.detail == 2) {
                                        editor.selectAll();
                                        return e.preventDefault();
                                    }
                                    mouseHandler.$clickSelection = editor.selection.getLineRange(row);
                                }
                                mouseHandler.setState(&quot;selectByLines&quot;);
                                mouseHandler.captureMouse(e);
                                return e.preventDefault();
                            });
                        
                        
                            var tooltipTimeout, mouseEvent, tooltipAnnotation;
                        
                            function showTooltip() {
                                var row = mouseEvent.getDocumentPosition().row;
                                var annotation = gutter.$annotations[row];
                                if (!annotation)
                                    return hideTooltip();
                        
                                var maxRow = editor.session.getLength();
                                if (row == maxRow) {
                                    var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
                                    var pos = mouseEvent.$pos;
                                    if (screenRow &gt; editor.session.documentToScreenRow(pos.row, pos.column))
                                        return hideTooltip();
                                }
                        
                                if (tooltipAnnotation == annotation)
                                    return;
                                tooltipAnnotation = annotation.text.join(&quot;&lt;br/&gt;&quot;);
                        
                                tooltip.setHtml(tooltipAnnotation);
                                tooltip.show();
                                editor.on(&quot;mousewheel&quot;, hideTooltip);
                        
                                if (mouseHandler.$tooltipFollowsMouse) {
                                    moveTooltip(mouseEvent);
                                } else {
                                    var gutterElement = gutter.$cells[editor.session.documentToScreenRow(row, 0)].element;
                                    var rect = gutterElement.getBoundingClientRect();
                                    var style = tooltip.getElement().style;
                                    style.left = rect.right + &quot;px&quot;;
                                    style.top = rect.bottom + &quot;px&quot;;
                                }
                            }
                        
                            function hideTooltip() {
                                if (tooltipTimeout)
                                    tooltipTimeout = clearTimeout(tooltipTimeout);
                                if (tooltipAnnotation) {
                                    tooltip.hide();
                                    tooltipAnnotation = null;
                                    editor.removeEventListener(&quot;mousewheel&quot;, hideTooltip);
                                }
                            }
                        
                            function moveTooltip(e) {
                                tooltip.setPosition(e.x, e.y);
                            }
                        
                            mouseHandler.editor.setDefaultHandler(&quot;guttermousemove&quot;, function(e) {
                                var target = e.domEvent.target || e.domEvent.srcElement;
                                if (dom.hasCssClass(target, &quot;ace_fold-widget&quot;))
                                    return hideTooltip();
                        
                                if (tooltipAnnotation &amp;&amp; mouseHandler.$tooltipFollowsMouse)
                                    moveTooltip(e);
                        
                                mouseEvent = e;
                                if (tooltipTimeout)
                                    return;
                                tooltipTimeout = setTimeout(function() {
                                    tooltipTimeout = null;
                                    if (mouseEvent &amp;&amp; !mouseHandler.isMousePressed)
                                        showTooltip();
                                    else
                                        hideTooltip();
                                }, 50);
                            });
                        
                            event.addListener(editor.renderer.$gutter, &quot;mouseout&quot;, function(e) {
                                mouseEvent = null;
                                if (!tooltipAnnotation || tooltipTimeout)
                                    return;
                        
                                tooltipTimeout = setTimeout(function() {
                                    tooltipTimeout = null;
                                    hideTooltip();
                                }, 50);
                            });
                            
                            editor.on(&quot;changeSession&quot;, hideTooltip);
                        }
                        
                        function GutterTooltip(parentNode) {
                            Tooltip.call(this, parentNode);
                        }
                        
                        oop.inherits(GutterTooltip, Tooltip);
                        
                        (function(){
                            this.setPosition = function(x, y) {
                                var windowWidth = window.innerWidth || document.documentElement.clientWidth;
                                var windowHeight = window.innerHeight || document.documentElement.clientHeight;
                                var width = this.getWidth();
                                var height = this.getHeight();
                                x += 15;
                                y += 15;
                                if (x + width &gt; windowWidth) {
                                    x -= (x + width) - windowWidth;
                                }
                                if (y + height &gt; windowHeight) {
                                    y -= 20 + height;
                                }
                                Tooltip.prototype.setPosition.call(this, x, y);
                            };
                        
                        }).call(GutterTooltip.prototype);
                        
                        
                        
                        exports.GutterHandler = GutterHandler;
                        
                        });
                        
                        define(&quot;ace/mouse/mouse_event&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/event&quot;,&quot;ace/lib/useragent&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var event = require(&quot;../lib/event&quot;);
                        var useragent = require(&quot;../lib/useragent&quot;);
                        var MouseEvent = exports.MouseEvent = function(domEvent, editor) {
                            this.domEvent = domEvent;
                            this.editor = editor;
                            
                            this.x = this.clientX = domEvent.clientX;
                            this.y = this.clientY = domEvent.clientY;
                        
                            this.$pos = null;
                            this.$inSelection = null;
                            
                            this.propagationStopped = false;
                            this.defaultPrevented = false;
                        };
                        
                        (function() {  
                            
                            this.stopPropagation = function() {
                                event.stopPropagation(this.domEvent);
                                this.propagationStopped = true;
                            };
                            
                            this.preventDefault = function() {
                                event.preventDefault(this.domEvent);
                                this.defaultPrevented = true;
                            };
                            
                            this.stop = function() {
                                this.stopPropagation();
                                this.preventDefault();
                            };
                            this.getDocumentPosition = function() {
                                if (this.$pos)
                                    return this.$pos;
                                
                                this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
                                return this.$pos;
                            };
                            this.inSelection = function() {
                                if (this.$inSelection !== null)
                                    return this.$inSelection;
                                    
                                var editor = this.editor;
                                
                        
                                var selectionRange = editor.getSelectionRange();
                                if (selectionRange.isEmpty())
                                    this.$inSelection = false;
                                else {
                                    var pos = this.getDocumentPosition();
                                    this.$inSelection = selectionRange.contains(pos.row, pos.column);
                                }
                        
                                return this.$inSelection;
                            };
                            this.getButton = function() {
                                return event.getButton(this.domEvent);
                            };
                            this.getShiftKey = function() {
                                return this.domEvent.shiftKey;
                            };
                            
                            this.getAccelKey = useragent.isMac
                                ? function() { return this.domEvent.metaKey; }
                                : function() { return this.domEvent.ctrlKey; };
                            
                        }).call(MouseEvent.prototype);
                        
                        });
                        
                        define(&quot;ace/mouse/dragdrop_handler&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/dom&quot;,&quot;ace/lib/event&quot;,&quot;ace/lib/useragent&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var dom = require(&quot;../lib/dom&quot;);
                        var event = require(&quot;../lib/event&quot;);
                        var useragent = require(&quot;../lib/useragent&quot;);
                        
                        var AUTOSCROLL_DELAY = 200;
                        var SCROLL_CURSOR_DELAY = 200;
                        var SCROLL_CURSOR_HYSTERESIS = 5;
                        
                        function DragdropHandler(mouseHandler) {
                        
                            var editor = mouseHandler.editor;
                        
                            var blankImage = dom.createElement(&quot;img&quot;);
                            blankImage.src = &quot;data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==&quot;;
                            if (useragent.isOpera)
                                blankImage.style.cssText = &quot;width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;&quot;;
                        
                            var exports = [&quot;dragWait&quot;, &quot;dragWaitEnd&quot;, &quot;startDrag&quot;, &quot;dragReadyEnd&quot;, &quot;onMouseDrag&quot;];
                        
                             exports.forEach(function(x) {
                                 mouseHandler[x] = this[x];
                            }, this);
                            editor.addEventListener(&quot;mousedown&quot;, this.onMouseDown.bind(mouseHandler));
                        
                        
                            var mouseTarget = editor.container;
                            var dragSelectionMarker, x, y;
                            var timerId, range;
                            var dragCursor, counter = 0;
                            var dragOperation;
                            var isInternal;
                            var autoScrollStartTime;
                            var cursorMovedTime;
                            var cursorPointOnCaretMoved;
                        
                            this.onDragStart = function(e) {
                                if (this.cancelDrag || !mouseTarget.draggable) {
                                    var self = this;
                                    setTimeout(function(){
                                        self.startSelect();
                                        self.captureMouse(e);
                                    }, 0);
                                    return e.preventDefault();
                                }
                                range = editor.getSelectionRange();
                        
                                var dataTransfer = e.dataTransfer;
                                dataTransfer.effectAllowed = editor.getReadOnly() ? &quot;copy&quot; : &quot;copyMove&quot;;
                                if (useragent.isOpera) {
                                    editor.container.appendChild(blankImage);
                                    blankImage.scrollTop = 0;
                                }
                                dataTransfer.setDragImage &amp;&amp; dataTransfer.setDragImage(blankImage, 0, 0);
                                if (useragent.isOpera) {
                                    editor.container.removeChild(blankImage);
                                }
                                dataTransfer.clearData();
                                dataTransfer.setData(&quot;Text&quot;, editor.session.getTextRange());
                        
                                isInternal = true;
                                this.setState(&quot;drag&quot;);
                            };
                        
                            this.onDragEnd = function(e) {
                                mouseTarget.draggable = false;
                                isInternal = false;
                                this.setState(null);
                                if (!editor.getReadOnly()) {
                                    var dropEffect = e.dataTransfer.dropEffect;
                                    if (!dragOperation &amp;&amp; dropEffect == &quot;move&quot;)
                                        editor.session.remove(editor.getSelectionRange());
                                    editor.renderer.$cursorLayer.setBlinking(true);
                                }
                                this.editor.unsetStyle(&quot;ace_dragging&quot;);
                                this.editor.renderer.setCursorStyle(&quot;&quot;);
                            };
                        
                            this.onDragEnter = function(e) {
                                if (editor.getReadOnly() || !canAccept(e.dataTransfer))
                                    return;
                                x = e.clientX;
                                y = e.clientY;
                                if (!dragSelectionMarker)
                                    addDragMarker();
                                counter++;
                                e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
                                return event.preventDefault(e);
                            };
                        
                            this.onDragOver = function(e) {
                                if (editor.getReadOnly() || !canAccept(e.dataTransfer))
                                    return;
                                x = e.clientX;
                                y = e.clientY;
                                if (!dragSelectionMarker) {
                                    addDragMarker();
                                    counter++;
                                }
                                if (onMouseMoveTimer !== null)
                                    onMouseMoveTimer = null;
                        
                                e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
                                return event.preventDefault(e);
                            };
                        
                            this.onDragLeave = function(e) {
                                counter--;
                                if (counter &lt;= 0 &amp;&amp; dragSelectionMarker) {
                                    clearDragMarker();
                                    dragOperation = null;
                                    return event.preventDefault(e);
                                }
                            };
                        
                            this.onDrop = function(e) {
                                if (!dragCursor)
                                    return;
                                var dataTransfer = e.dataTransfer;
                                if (isInternal) {
                                    switch (dragOperation) {
                                        case &quot;move&quot;:
                                            if (range.contains(dragCursor.row, dragCursor.column)) {
                                                range = {
                                                    start: dragCursor,
                                                    end: dragCursor
                                                };
                                            } else {
                                                range = editor.moveText(range, dragCursor);
                                            }
                                            break;
                                        case &quot;copy&quot;:
                                            range = editor.moveText(range, dragCursor, true);
                                            break;
                                    }
                                } else {
                                    var dropData = dataTransfer.getData(&#x27;Text&#x27;);
                                    range = {
                                        start: dragCursor,
                                        end: editor.session.insert(dragCursor, dropData)
                                    };
                                    editor.focus();
                                    dragOperation = null;
                                }
                                clearDragMarker();
                                return event.preventDefault(e);
                            };
                        
                            event.addListener(mouseTarget, &quot;dragstart&quot;, this.onDragStart.bind(mouseHandler));
                            event.addListener(mouseTarget, &quot;dragend&quot;, this.onDragEnd.bind(mouseHandler));
                            event.addListener(mouseTarget, &quot;dragenter&quot;, this.onDragEnter.bind(mouseHandler));
                            event.addListener(mouseTarget, &quot;dragover&quot;, this.onDragOver.bind(mouseHandler));
                            event.addListener(mouseTarget, &quot;dragleave&quot;, this.onDragLeave.bind(mouseHandler));
                            event.addListener(mouseTarget, &quot;drop&quot;, this.onDrop.bind(mouseHandler));
                        
                            function scrollCursorIntoView(cursor, prevCursor) {
                                var now = Date.now();
                                var vMovement = !prevCursor || cursor.row != prevCursor.row;
                                var hMovement = !prevCursor || cursor.column != prevCursor.column;
                                if (!cursorMovedTime || vMovement || hMovement) {
                                    editor.$blockScrolling += 1;
                                    editor.moveCursorToPosition(cursor);
                                    editor.$blockScrolling -= 1;
                                    cursorMovedTime = now;
                                    cursorPointOnCaretMoved = {x: x, y: y};
                                } else {
                                    var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
                                    if (distance &gt; SCROLL_CURSOR_HYSTERESIS) {
                                        cursorMovedTime = null;
                                    } else if (now - cursorMovedTime &gt;= SCROLL_CURSOR_DELAY) {
                                        editor.renderer.scrollCursorIntoView();
                                        cursorMovedTime = null;
                                    }
                                }
                            }
                        
                            function autoScroll(cursor, prevCursor) {
                                var now = Date.now();
                                var lineHeight = editor.renderer.layerConfig.lineHeight;
                                var characterWidth = editor.renderer.layerConfig.characterWidth;
                                var editorRect = editor.renderer.scroller.getBoundingClientRect();
                                var offsets = {
                                   x: {
                                       left: x - editorRect.left,
                                       right: editorRect.right - x
                                   },
                                   y: {
                                       top: y - editorRect.top,
                                       bottom: editorRect.bottom - y
                                   }
                                };
                                var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
                                var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
                                var scrollCursor = {row: cursor.row, column: cursor.column};
                                if (nearestXOffset / characterWidth &lt;= 2) {
                                    scrollCursor.column += (offsets.x.left &lt; offsets.x.right ? -3 : +2);
                                }
                                if (nearestYOffset / lineHeight &lt;= 1) {
                                    scrollCursor.row += (offsets.y.top &lt; offsets.y.bottom ? -1 : +1);
                                }
                                var vScroll = cursor.row != scrollCursor.row;
                                var hScroll = cursor.column != scrollCursor.column;
                                var vMovement = !prevCursor || cursor.row != prevCursor.row;
                                if (vScroll || (hScroll &amp;&amp; !vMovement)) {
                                    if (!autoScrollStartTime)
                                        autoScrollStartTime = now;
                                    else if (now - autoScrollStartTime &gt;= AUTOSCROLL_DELAY)
                                        editor.renderer.scrollCursorIntoView(scrollCursor);
                                } else {
                                    autoScrollStartTime = null;
                                }
                            }
                        
                            function onDragInterval() {
                                var prevCursor = dragCursor;
                                dragCursor = editor.renderer.screenToTextCoordinates(x, y);
                                scrollCursorIntoView(dragCursor, prevCursor);
                                autoScroll(dragCursor, prevCursor);
                            }
                        
                            function addDragMarker() {
                                range = editor.selection.toOrientedRange();
                                dragSelectionMarker = editor.session.addMarker(range, &quot;ace_selection&quot;, editor.getSelectionStyle());
                                editor.clearSelection();
                                if (editor.isFocused())
                                    editor.renderer.$cursorLayer.setBlinking(false);
                                clearInterval(timerId);
                                onDragInterval();
                                timerId = setInterval(onDragInterval, 20);
                                counter = 0;
                                event.addListener(document, &quot;mousemove&quot;, onMouseMove);
                            }
                        
                            function clearDragMarker() {
                                clearInterval(timerId);
                                editor.session.removeMarker(dragSelectionMarker);
                                dragSelectionMarker = null;
                                editor.$blockScrolling += 1;
                                editor.selection.fromOrientedRange(range);
                                editor.$blockScrolling -= 1;
                                if (editor.isFocused() &amp;&amp; !isInternal)
                                    editor.renderer.$cursorLayer.setBlinking(!editor.getReadOnly());
                                range = null;
                                dragCursor = null;
                                counter = 0;
                                autoScrollStartTime = null;
                                cursorMovedTime = null;
                                event.removeListener(document, &quot;mousemove&quot;, onMouseMove);
                            }
                            var onMouseMoveTimer = null;
                            function onMouseMove() {
                                if (onMouseMoveTimer == null) {
                                    onMouseMoveTimer = setTimeout(function() {
                                        if (onMouseMoveTimer != null &amp;&amp; dragSelectionMarker)
                                            clearDragMarker();
                                    }, 20);
                                }
                            }
                        
                            function canAccept(dataTransfer) {
                                var types = dataTransfer.types;
                                return !types || Array.prototype.some.call(types, function(type) {
                                    return type == &#x27;text/plain&#x27; || type == &#x27;Text&#x27;;
                                });
                            }
                        
                            function getDropEffect(e) {
                                var copyAllowed = [&#x27;copy&#x27;, &#x27;copymove&#x27;, &#x27;all&#x27;, &#x27;uninitialized&#x27;];
                                var moveAllowed = [&#x27;move&#x27;, &#x27;copymove&#x27;, &#x27;linkmove&#x27;, &#x27;all&#x27;, &#x27;uninitialized&#x27;];
                        
                                var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
                                var effectAllowed = &quot;uninitialized&quot;;
                                try {
                                    effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
                                } catch (e) {}
                                var dropEffect = &quot;none&quot;;
                        
                                if (copyModifierState &amp;&amp; copyAllowed.indexOf(effectAllowed) &gt;= 0)
                                    dropEffect = &quot;copy&quot;;
                                else if (moveAllowed.indexOf(effectAllowed) &gt;= 0)
                                    dropEffect = &quot;move&quot;;
                                else if (copyAllowed.indexOf(effectAllowed) &gt;= 0)
                                    dropEffect = &quot;copy&quot;;
                        
                                return dropEffect;
                            }
                        }
                        
                        (function() {
                        
                            this.dragWait = function() {
                                var interval = Date.now() - this.mousedownEvent.time;
                                if (interval &gt; this.editor.getDragDelay())
                                    this.startDrag();
                            };
                        
                            this.dragWaitEnd = function() {
                                var target = this.editor.container;
                                target.draggable = false;
                                this.startSelect(this.mousedownEvent.getDocumentPosition());
                                this.selectEnd();
                            };
                        
                            this.dragReadyEnd = function(e) {
                                this.editor.renderer.$cursorLayer.setBlinking(!this.editor.getReadOnly());
                                this.editor.unsetStyle(&quot;ace_dragging&quot;);
                                this.editor.renderer.setCursorStyle(&quot;&quot;);
                                this.dragWaitEnd();
                            };
                        
                            this.startDrag = function(){
                                this.cancelDrag = false;
                                var editor = this.editor;
                                var target = editor.container;
                                target.draggable = true;
                                editor.renderer.$cursorLayer.setBlinking(false);
                                editor.setStyle(&quot;ace_dragging&quot;);
                                var cursorStyle = useragent.isWin ? &quot;default&quot; : &quot;move&quot;;
                                editor.renderer.setCursorStyle(cursorStyle);
                                this.setState(&quot;dragReady&quot;);
                            };
                        
                            this.onMouseDrag = function(e) {
                                var target = this.editor.container;
                                if (useragent.isIE &amp;&amp; this.state == &quot;dragReady&quot;) {
                                    var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
                                    if (distance &gt; 3)
                                        target.dragDrop();
                                }
                                if (this.state === &quot;dragWait&quot;) {
                                    var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
                                    if (distance &gt; 0) {
                                        target.draggable = false;
                                        this.startSelect(this.mousedownEvent.getDocumentPosition());
                                    }
                                }
                            };
                        
                            this.onMouseDown = function(e) {
                                if (!this.$dragEnabled)
                                    return;
                                this.mousedownEvent = e;
                                var editor = this.editor;
                        
                                var inSelection = e.inSelection();
                                var button = e.getButton();
                                var clickCount = e.domEvent.detail || 1;
                                if (clickCount === 1 &amp;&amp; button === 0 &amp;&amp; inSelection) {
                                    if (e.editor.inMultiSelectMode &amp;&amp; (e.getAccelKey() || e.getShiftKey()))
                                        return;
                                    this.mousedownEvent.time = Date.now();
                                    var eventTarget = e.domEvent.target || e.domEvent.srcElement;
                                    if (&quot;unselectable&quot; in eventTarget)
                                        eventTarget.unselectable = &quot;on&quot;;
                                    if (editor.getDragDelay()) {
                                        if (useragent.isWebKit) {
                                            this.cancelDrag = true;
                                            var mouseTarget = editor.container;
                                            mouseTarget.draggable = true;
                                        }
                                        this.setState(&quot;dragWait&quot;);
                                    } else {
                                        this.startDrag();
                                    }
                                    this.captureMouse(e, this.onMouseDrag.bind(this));
                                    e.defaultPrevented = true;
                                }
                            };
                        
                        }).call(DragdropHandler.prototype);
                        
                        
                        function calcDistance(ax, ay, bx, by) {
                            return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
                        }
                        
                        exports.DragdropHandler = DragdropHandler;
                        
                        });
                        
                        define(&quot;ace/lib/net&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/dom&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        var dom = require(&quot;./dom&quot;);
                        
                        exports.get = function (url, callback) {
                            var xhr = new XMLHttpRequest();
                            xhr.open(&#x27;GET&#x27;, url, true);
                            xhr.onreadystatechange = function () {
                                if (xhr.readyState === 4) {
                                    callback(xhr.responseText);
                                }
                            };
                            xhr.send(null);
                        };
                        
                        exports.loadScript = function(path, callback) {
                            var head = dom.getDocumentHead();
                            var s = document.createElement(&#x27;script&#x27;);
                        
                            s.src = path;
                            head.appendChild(s);
                        
                            s.onload = s.onreadystatechange = function(_, isAbort) {
                                if (isAbort || !s.readyState || s.readyState == &quot;loaded&quot; || s.readyState == &quot;complete&quot;) {
                                    s = s.onload = s.onreadystatechange = null;
                                    if (!isAbort)
                                        callback();
                                }
                            };
                        };
                        exports.qualifyURL = function(url) {
                            var a = document.createElement(&#x27;a&#x27;);
                            a.href = url;
                            return a.href;
                        }
                        
                        });
                        
                        define(&quot;ace/lib/event_emitter&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var EventEmitter = {};
                        var stopPropagation = function() { this.propagationStopped = true; };
                        var preventDefault = function() { this.defaultPrevented = true; };
                        
                        EventEmitter._emit =
                        EventEmitter._dispatchEvent = function(eventName, e) {
                            this._eventRegistry || (this._eventRegistry = {});
                            this._defaultHandlers || (this._defaultHandlers = {});
                        
                            var listeners = this._eventRegistry[eventName] || [];
                            var defaultHandler = this._defaultHandlers[eventName];
                            if (!listeners.length &amp;&amp; !defaultHandler)
                                return;
                        
                            if (typeof e != &quot;object&quot; || !e)
                                e = {};
                        
                            if (!e.type)
                                e.type = eventName;
                            if (!e.stopPropagation)
                                e.stopPropagation = stopPropagation;
                            if (!e.preventDefault)
                                e.preventDefault = preventDefault;
                        
                            listeners = listeners.slice();
                            for (var i=0; i&lt;listeners.length; i++) {
                                listeners[i](e, this);
                                if (e.propagationStopped)
                                    break;
                            }
                            
                            if (defaultHandler &amp;&amp; !e.defaultPrevented)
                                return defaultHandler(e, this);
                        };
                        
                        
                        EventEmitter._signal = function(eventName, e) {
                            var listeners = (this._eventRegistry || {})[eventName];
                            if (!listeners)
                                return;
                            listeners = listeners.slice();
                            for (var i=0; i&lt;listeners.length; i++)
                                listeners[i](e, this);
                        };
                        
                        EventEmitter.once = function(eventName, callback) {
                            var _self = this;
                            callback &amp;&amp; this.addEventListener(eventName, function newCallback() {
                                _self.removeEventListener(eventName, newCallback);
                                callback.apply(null, arguments);
                            });
                        };
                        
                        
                        EventEmitter.setDefaultHandler = function(eventName, callback) {
                            var handlers = this._defaultHandlers
                            if (!handlers)
                                handlers = this._defaultHandlers = {_disabled_: {}};
                            
                            if (handlers[eventName]) {
                                var old = handlers[eventName];
                                var disabled = handlers._disabled_[eventName];
                                if (!disabled)
                                    handlers._disabled_[eventName] = disabled = [];
                                disabled.push(old);
                                var i = disabled.indexOf(callback);
                                if (i != -1) 
                                    disabled.splice(i, 1);
                            }
                            handlers[eventName] = callback;
                        };
                        EventEmitter.removeDefaultHandler = function(eventName, callback) {
                            var handlers = this._defaultHandlers
                            if (!handlers)
                                return;
                            var disabled = handlers._disabled_[eventName];
                            
                            if (handlers[eventName] == callback) {
                                var old = handlers[eventName];
                                if (disabled)
                                    this.setDefaultHandler(eventName, disabled.pop());
                            } else if (disabled) {
                                var i = disabled.indexOf(callback);
                                if (i != -1)
                                    disabled.splice(i, 1);
                            }
                        };
                        
                        EventEmitter.on =
                        EventEmitter.addEventListener = function(eventName, callback, capturing) {
                            this._eventRegistry = this._eventRegistry || {};
                        
                            var listeners = this._eventRegistry[eventName];
                            if (!listeners)
                                listeners = this._eventRegistry[eventName] = [];
                        
                            if (listeners.indexOf(callback) == -1)
                                listeners[capturing ? &quot;unshift&quot; : &quot;push&quot;](callback);
                            return callback;
                        };
                        
                        EventEmitter.off =
                        EventEmitter.removeListener =
                        EventEmitter.removeEventListener = function(eventName, callback) {
                            this._eventRegistry = this._eventRegistry || {};
                        
                            var listeners = this._eventRegistry[eventName];
                            if (!listeners)
                                return;
                        
                            var index = listeners.indexOf(callback);
                            if (index !== -1)
                                listeners.splice(index, 1);
                        };
                        
                        EventEmitter.removeAllListeners = function(eventName) {
                            if (this._eventRegistry) this._eventRegistry[eventName] = [];
                        };
                        
                        exports.EventEmitter = EventEmitter;
                        
                        });
                        
                        define(&quot;ace/lib/app_config&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/event_emitter&quot;], function(require, exports, module) {
                        &quot;no use strict&quot;;
                        
                        var oop = require(&quot;./oop&quot;);
                        var EventEmitter = require(&quot;./event_emitter&quot;).EventEmitter;
                        
                        var optionsProvider = {
                            setOptions: function(optList) {
                                Object.keys(optList).forEach(function(key) {
                                    this.setOption(key, optList[key]);
                                }, this);
                            },
                            getOptions: function(optionNames) {
                                var result = {};
                                if (!optionNames) {
                                    optionNames = Object.keys(this.$options);
                                } else if (!Array.isArray(optionNames)) {
                                    result = optionNames;
                                    optionNames = Object.keys(result);
                                }
                                optionNames.forEach(function(key) {
                                    result[key] = this.getOption(key);
                                }, this);
                                return result;
                            },
                            setOption: function(name, value) {
                                if (this[&quot;$&quot; + name] === value)
                                    return;
                                var opt = this.$options[name];
                                if (!opt) {
                                    return warn(&#x27;misspelled option &quot;&#x27; + name + &#x27;&quot;&#x27;);
                                }
                                if (opt.forwardTo)
                                    return this[opt.forwardTo] &amp;&amp; this[opt.forwardTo].setOption(name, value);
                        
                                if (!opt.handlesSet)
                                    this[&quot;$&quot; + name] = value;
                                if (opt &amp;&amp; opt.set)
                                    opt.set.call(this, value);
                            },
                            getOption: function(name) {
                                var opt = this.$options[name];
                                if (!opt) {
                                    return warn(&#x27;misspelled option &quot;&#x27; + name + &#x27;&quot;&#x27;);
                                }
                                if (opt.forwardTo)
                                    return this[opt.forwardTo] &amp;&amp; this[opt.forwardTo].getOption(name);
                                return opt &amp;&amp; opt.get ? opt.get.call(this) : this[&quot;$&quot; + name];
                            }
                        };
                        
                        function warn(message) {
                            if (typeof console != &quot;undefined&quot; &amp;&amp; console.warn)
                                console.warn.apply(console, arguments);
                        }
                        
                        function reportError(msg, data) {
                            var e = new Error(msg);
                            e.data = data;
                            if (typeof console == &quot;object&quot; &amp;&amp; console.error)
                                console.error(e);
                            setTimeout(function() { throw e; });
                        }
                        
                        var AppConfig = function() {
                            this.$defaultOptions = {};
                        };
                        
                        (function() {
                            oop.implement(this, EventEmitter);
                            this.defineOptions = function(obj, path, options) {
                                if (!obj.$options)
                                    this.$defaultOptions[path] = obj.$options = {};
                        
                                Object.keys(options).forEach(function(key) {
                                    var opt = options[key];
                                    if (typeof opt == &quot;string&quot;)
                                        opt = {forwardTo: opt};
                        
                                    opt.name || (opt.name = key);
                                    obj.$options[opt.name] = opt;
                                    if (&quot;initialValue&quot; in opt)
                                        obj[&quot;$&quot; + opt.name] = opt.initialValue;
                                });
                                oop.implement(obj, optionsProvider);
                        
                                return this;
                            };
                        
                            this.resetOptions = function(obj) {
                                Object.keys(obj.$options).forEach(function(key) {
                                    var opt = obj.$options[key];
                                    if (&quot;value&quot; in opt)
                                        obj.setOption(key, opt.value);
                                });
                            };
                        
                            this.setDefaultValue = function(path, name, value) {
                                var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
                                if (opts[name]) {
                                    if (opts.forwardTo)
                                        this.setDefaultValue(opts.forwardTo, name, value);
                                    else
                                        opts[name].value = value;
                                }
                            };
                        
                            this.setDefaultValues = function(path, optionHash) {
                                Object.keys(optionHash).forEach(function(key) {
                                    this.setDefaultValue(path, key, optionHash[key]);
                                }, this);
                            };
                            
                            this.warn = warn;
                            this.reportError = reportError;
                            
                        }).call(AppConfig.prototype);
                        
                        exports.AppConfig = AppConfig;
                        
                        });
                        
                        define(&quot;ace/config&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/lang&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/net&quot;,&quot;ace/lib/app_config&quot;], function(require, exports, module) {
                        &quot;no use strict&quot;;
                        
                        var lang = require(&quot;./lib/lang&quot;);
                        var oop = require(&quot;./lib/oop&quot;);
                        var net = require(&quot;./lib/net&quot;);
                        var AppConfig = require(&quot;./lib/app_config&quot;).AppConfig;
                        
                        module.exports = exports = new AppConfig();
                        
                        var global = (function() {
                            return this;
                        })();
                        
                        var options = {
                            packaged: false,
                            workerPath: null,
                            modePath: null,
                            themePath: null,
                            basePath: &quot;&quot;,
                            suffix: &quot;.js&quot;,
                            $moduleUrls: {}
                        };
                        
                        exports.get = function(key) {
                            if (!options.hasOwnProperty(key))
                                throw new Error(&quot;Unknown config key: &quot; + key);
                        
                            return options[key];
                        };
                        
                        exports.set = function(key, value) {
                            if (!options.hasOwnProperty(key))
                                throw new Error(&quot;Unknown config key: &quot; + key);
                        
                            options[key] = value;
                        };
                        
                        exports.all = function() {
                            return lang.copyObject(options);
                        };
                        exports.moduleUrl = function(name, component) {
                            if (options.$moduleUrls[name])
                                return options.$moduleUrls[name];
                        
                            var parts = name.split(&quot;/&quot;);
                            component = component || parts[parts.length - 2] || &quot;&quot;;
                            var sep = component == &quot;snippets&quot; ? &quot;/&quot; : &quot;-&quot;;
                            var base = parts[parts.length - 1];
                            if (component == &quot;worker&quot; &amp;&amp; sep == &quot;-&quot;) {
                                var re = new RegExp(&quot;^&quot; + component + &quot;[\\-_]|[\\-_]&quot; + component + &quot;$&quot;, &quot;g&quot;);
                                base = base.replace(re, &quot;&quot;);
                            }
                        
                            if ((!base || base == component) &amp;&amp; parts.length &gt; 1)
                                base = parts[parts.length - 2];
                            var path = options[component + &quot;Path&quot;];
                            if (path == null) {
                                path = options.basePath;
                            } else if (sep == &quot;/&quot;) {
                                component = sep = &quot;&quot;;
                            }
                            if (path &amp;&amp; path.slice(-1) != &quot;/&quot;)
                                path += &quot;/&quot;;
                            return path + component + sep + base + this.get(&quot;suffix&quot;);
                        };
                        
                        exports.setModuleUrl = function(name, subst) {
                            return options.$moduleUrls[name] = subst;
                        };
                        
                        exports.$loading = {};
                        exports.loadModule = function(moduleName, onLoad) {
                            var module, moduleType;
                            if (Array.isArray(moduleName)) {
                                moduleType = moduleName[0];
                                moduleName = moduleName[1];
                            }
                        
                            try {
                                module = require(moduleName);
                            } catch (e) {}
                            if (module &amp;&amp; !exports.$loading[moduleName])
                                return onLoad &amp;&amp; onLoad(module);
                        
                            if (!exports.$loading[moduleName])
                                exports.$loading[moduleName] = [];
                        
                            exports.$loading[moduleName].push(onLoad);
                        
                            if (exports.$loading[moduleName].length &gt; 1)
                                return;
                        
                            var afterLoad = function() {
                                require([moduleName], function(module) {
                                    exports._emit(&quot;load.module&quot;, {name: moduleName, module: module});
                                    var listeners = exports.$loading[moduleName];
                                    exports.$loading[moduleName] = null;
                                    listeners.forEach(function(onLoad) {
                                        onLoad &amp;&amp; onLoad(module);
                                    });
                                });
                            };
                        
                            if (!exports.get(&quot;packaged&quot;))
                                return afterLoad();
                            net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
                        };
                        init(true);function init(packaged) {
                        
                            options.packaged = packaged || require.packaged || module.packaged || (global.define &amp;&amp; define.packaged);
                        
                            if (!global.document)
                                return &quot;&quot;;
                        
                            var scriptOptions = {};
                            var scriptUrl = &quot;&quot;;
                            var currentScript = (document.currentScript || document._currentScript ); // native or polyfill
                            var currentDocument = currentScript &amp;&amp; currentScript.ownerDocument || document;
                            
                            var scripts = currentDocument.getElementsByTagName(&quot;script&quot;);
                            for (var i=0; i&lt;scripts.length; i++) {
                                var script = scripts[i];
                        
                                var src = script.src || script.getAttribute(&quot;src&quot;);
                                if (!src)
                                    continue;
                        
                                var attributes = script.attributes;
                                for (var j=0, l=attributes.length; j &lt; l; j++) {
                                    var attr = attributes[j];
                                    if (attr.name.indexOf(&quot;data-ace-&quot;) === 0) {
                                        scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, &quot;&quot;))] = attr.value;
                                    }
                                }
                        
                                var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
                                if (m)
                                    scriptUrl = m[1];
                            }
                        
                            if (scriptUrl) {
                                scriptOptions.base = scriptOptions.base || scriptUrl;
                                scriptOptions.packaged = true;
                            }
                        
                            scriptOptions.basePath = scriptOptions.base;
                            scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
                            scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
                            scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
                            delete scriptOptions.base;
                        
                            for (var key in scriptOptions)
                                if (typeof scriptOptions[key] !== &quot;undefined&quot;)
                                    exports.set(key, scriptOptions[key]);
                        };
                        
                        exports.init = init;
                        
                        function deHyphenate(str) {
                            return str.replace(/-(.)/g, function(m, m1) { return m1.toUpperCase(); });
                        }
                        
                        });
                        
                        define(&quot;ace/mouse/mouse_handler&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/event&quot;,&quot;ace/lib/useragent&quot;,&quot;ace/mouse/default_handlers&quot;,&quot;ace/mouse/default_gutter_handler&quot;,&quot;ace/mouse/mouse_event&quot;,&quot;ace/mouse/dragdrop_handler&quot;,&quot;ace/config&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var event = require(&quot;../lib/event&quot;);
                        var useragent = require(&quot;../lib/useragent&quot;);
                        var DefaultHandlers = require(&quot;./default_handlers&quot;).DefaultHandlers;
                        var DefaultGutterHandler = require(&quot;./default_gutter_handler&quot;).GutterHandler;
                        var MouseEvent = require(&quot;./mouse_event&quot;).MouseEvent;
                        var DragdropHandler = require(&quot;./dragdrop_handler&quot;).DragdropHandler;
                        var config = require(&quot;../config&quot;);
                        
                        var MouseHandler = function(editor) {
                            var _self = this;
                            this.editor = editor;
                        
                            new DefaultHandlers(this);
                            new DefaultGutterHandler(this);
                            new DragdropHandler(this);
                        
                            var focusEditor = function(e) {
                                if (!document.hasFocus || !document.hasFocus())
                                    window.focus();
                                editor.focus();
                            };
                        
                            var mouseTarget = editor.renderer.getMouseEventTarget();
                            event.addListener(mouseTarget, &quot;click&quot;, this.onMouseEvent.bind(this, &quot;click&quot;));
                            event.addListener(mouseTarget, &quot;mousemove&quot;, this.onMouseMove.bind(this, &quot;mousemove&quot;));
                            event.addMultiMouseDownListener(mouseTarget, [400, 300, 250], this, &quot;onMouseEvent&quot;);
                            if (editor.renderer.scrollBarV) {
                                event.addMultiMouseDownListener(editor.renderer.scrollBarV.inner, [400, 300, 250], this, &quot;onMouseEvent&quot;);
                                event.addMultiMouseDownListener(editor.renderer.scrollBarH.inner, [400, 300, 250], this, &quot;onMouseEvent&quot;);
                                if (useragent.isIE) {
                                    event.addListener(editor.renderer.scrollBarV.element, &quot;mousedown&quot;, focusEditor);
                                    event.addListener(editor.renderer.scrollBarH.element, &quot;mousedown&quot;, focusEditor);
                                }
                            }
                            event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, &quot;mousewheel&quot;));
                        
                            var gutterEl = editor.renderer.$gutter;
                            event.addListener(gutterEl, &quot;mousedown&quot;, this.onMouseEvent.bind(this, &quot;guttermousedown&quot;));
                            event.addListener(gutterEl, &quot;click&quot;, this.onMouseEvent.bind(this, &quot;gutterclick&quot;));
                            event.addListener(gutterEl, &quot;dblclick&quot;, this.onMouseEvent.bind(this, &quot;gutterdblclick&quot;));
                            event.addListener(gutterEl, &quot;mousemove&quot;, this.onMouseEvent.bind(this, &quot;guttermousemove&quot;));
                        
                            event.addListener(mouseTarget, &quot;mousedown&quot;, focusEditor);
                        
                            event.addListener(gutterEl, &quot;mousedown&quot;, function(e) {
                                editor.focus();
                                return event.preventDefault(e);
                            });
                        
                            editor.on(&quot;mousemove&quot;, function(e){
                                if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
                                    return;
                        
                                var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
                                var range = editor.session.selection.getRange();
                                var renderer = editor.renderer;
                        
                                if (!range.isEmpty() &amp;&amp; range.insideStart(character.row, character.column)) {
                                    renderer.setCursorStyle(&quot;default&quot;);
                                } else {
                                    renderer.setCursorStyle(&quot;&quot;);
                                }
                            });
                        };
                        
                        (function() {
                            this.onMouseEvent = function(name, e) {
                                this.editor._emit(name, new MouseEvent(e, this.editor));
                            };
                        
                            this.onMouseMove = function(name, e) {
                                var listeners = this.editor._eventRegistry &amp;&amp; this.editor._eventRegistry.mousemove;
                                if (!listeners || !listeners.length)
                                    return;
                        
                                this.editor._emit(name, new MouseEvent(e, this.editor));
                            };
                        
                            this.onMouseWheel = function(name, e) {
                                var mouseEvent = new MouseEvent(e, this.editor);
                                mouseEvent.speed = this.$scrollSpeed * 2;
                                mouseEvent.wheelX = e.wheelX;
                                mouseEvent.wheelY = e.wheelY;
                        
                                this.editor._emit(name, mouseEvent);
                            };
                        
                            this.setState = function(state) {
                                this.state = state;
                            };
                        
                            this.captureMouse = function(ev, mouseMoveHandler) {
                                this.x = ev.x;
                                this.y = ev.y;
                        
                                this.isMousePressed = true;
                                var renderer = this.editor.renderer;
                                if (renderer.$keepTextAreaAtCursor)
                                    renderer.$keepTextAreaAtCursor = null;
                        
                                var self = this;
                                var onMouseMove = function(e) {
                                    if (!e) return;
                                    if (useragent.isWebKit &amp;&amp; !e.which &amp;&amp; self.releaseMouse)
                                        return self.releaseMouse();
                        
                                    self.x = e.clientX;
                                    self.y = e.clientY;
                                    mouseMoveHandler &amp;&amp; mouseMoveHandler(e);
                                    self.mouseEvent = new MouseEvent(e, self.editor);
                                    self.$mouseMoved = true;
                                };
                        
                                var onCaptureEnd = function(e) {
                                    clearInterval(timerId);
                                    onCaptureInterval();
                                    self[self.state + &quot;End&quot;] &amp;&amp; self[self.state + &quot;End&quot;](e);
                                    self.state = &quot;&quot;;
                                    if (renderer.$keepTextAreaAtCursor == null) {
                                        renderer.$keepTextAreaAtCursor = true;
                                        renderer.$moveTextAreaToCursor();
                                    }
                                    self.isMousePressed = false;
                                    self.$onCaptureMouseMove = self.releaseMouse = null;
                                    e &amp;&amp; self.onMouseEvent(&quot;mouseup&quot;, e);
                                };
                        
                                var onCaptureInterval = function() {
                                    self[self.state] &amp;&amp; self[self.state]();
                                    self.$mouseMoved = false;
                                };
                        
                                if (useragent.isOldIE &amp;&amp; ev.domEvent.type == &quot;dblclick&quot;) {
                                    return setTimeout(function() {onCaptureEnd(ev);});
                                }
                        
                                self.$onCaptureMouseMove = onMouseMove;
                                self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
                                var timerId = setInterval(onCaptureInterval, 20);
                            };
                            this.releaseMouse = null;
                            this.cancelContextMenu = function() {
                                var stop = function(e) {
                                    if (e &amp;&amp; e.domEvent &amp;&amp; e.domEvent.type != &quot;contextmenu&quot;)
                                        return;
                                    this.editor.off(&quot;nativecontextmenu&quot;, stop);
                                    if (e &amp;&amp; e.domEvent)
                                        event.stopEvent(e.domEvent);
                                }.bind(this);
                                setTimeout(stop, 10);
                                this.editor.on(&quot;nativecontextmenu&quot;, stop);
                            };
                        }).call(MouseHandler.prototype);
                        
                        config.defineOptions(MouseHandler.prototype, &quot;mouseHandler&quot;, {
                            scrollSpeed: {initialValue: 2},
                            dragDelay: {initialValue: (useragent.isMac ? 150 : 0)},
                            dragEnabled: {initialValue: true},
                            focusTimout: {initialValue: 0},
                            tooltipFollowsMouse: {initialValue: true}
                        });
                        
                        
                        exports.MouseHandler = MouseHandler;
                        });
                        
                        define(&quot;ace/mouse/fold_handler&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        function FoldHandler(editor) {
                        
                            editor.on(&quot;click&quot;, function(e) {
                                var position = e.getDocumentPosition();
                                var session = editor.session;
                                var fold = session.getFoldAt(position.row, position.column, 1);
                                if (fold) {
                                    if (e.getAccelKey())
                                        session.removeFold(fold);
                                    else
                                        session.expandFold(fold);
                        
                                    e.stop();
                                }
                            });
                        
                            editor.on(&quot;gutterclick&quot;, function(e) {
                                var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
                        
                                if (gutterRegion == &quot;foldWidgets&quot;) {
                                    var row = e.getDocumentPosition().row;
                                    var session = editor.session;
                                    if (session.foldWidgets &amp;&amp; session.foldWidgets[row])
                                        editor.session.onFoldWidgetClick(row, e);
                                    if (!editor.isFocused())
                                        editor.focus();
                                    e.stop();
                                }
                            });
                        
                            editor.on(&quot;gutterdblclick&quot;, function(e) {
                                var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
                        
                                if (gutterRegion == &quot;foldWidgets&quot;) {
                                    var row = e.getDocumentPosition().row;
                                    var session = editor.session;
                                    var data = session.getParentFoldRangeData(row, true);
                                    var range = data.range || data.firstRange;
                        
                                    if (range) {
                                        row = range.start.row;
                                        var fold = session.getFoldAt(row, session.getLine(row).length, 1);
                        
                                        if (fold) {
                                            session.removeFold(fold);
                                        } else {
                                            session.addFold(&quot;...&quot;, range);
                                            editor.renderer.scrollCursorIntoView({row: range.start.row, column: 0});
                                        }
                                    }
                                    e.stop();
                                }
                            });
                        }
                        
                        exports.FoldHandler = FoldHandler;
                        
                        });
                        
                        define(&quot;ace/keyboard/keybinding&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/keys&quot;,&quot;ace/lib/event&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var keyUtil  = require(&quot;../lib/keys&quot;);
                        var event = require(&quot;../lib/event&quot;);
                        
                        var KeyBinding = function(editor) {
                            this.$editor = editor;
                            this.$data = {editor: editor};
                            this.$handlers = [];
                            this.setDefaultHandler(editor.commands);
                        };
                        
                        (function() {
                            this.setDefaultHandler = function(kb) {
                                this.removeKeyboardHandler(this.$defaultHandler);
                                this.$defaultHandler = kb;
                                this.addKeyboardHandler(kb, 0);
                            };
                        
                            this.setKeyboardHandler = function(kb) {
                                var h = this.$handlers;
                                if (h[h.length - 1] == kb)
                                    return;
                        
                                while (h[h.length - 1] &amp;&amp; h[h.length - 1] != this.$defaultHandler)
                                    this.removeKeyboardHandler(h[h.length - 1]);
                        
                                this.addKeyboardHandler(kb, 1);
                            };
                        
                            this.addKeyboardHandler = function(kb, pos) {
                                if (!kb)
                                    return;
                                if (typeof kb == &quot;function&quot; &amp;&amp; !kb.handleKeyboard)
                                    kb.handleKeyboard = kb;
                                var i = this.$handlers.indexOf(kb);
                                if (i != -1)
                                    this.$handlers.splice(i, 1);
                        
                                if (pos == undefined)
                                    this.$handlers.push(kb);
                                else
                                    this.$handlers.splice(pos, 0, kb);
                        
                                if (i == -1 &amp;&amp; kb.attach)
                                    kb.attach(this.$editor);
                            };
                        
                            this.removeKeyboardHandler = function(kb) {
                                var i = this.$handlers.indexOf(kb);
                                if (i == -1)
                                    return false;
                                this.$handlers.splice(i, 1);
                                kb.detach &amp;&amp; kb.detach(this.$editor);
                                return true;
                            };
                        
                            this.getKeyboardHandler = function() {
                                return this.$handlers[this.$handlers.length - 1];
                            };
                            
                            this.getStatusText = function() {
                                var data = this.$data;
                                var editor = data.editor;
                                return this.$handlers.map(function(h) {
                                    return h.getStatusText &amp;&amp; h.getStatusText(editor, data) || &quot;&quot;;
                                }).filter(Boolean).join(&quot; &quot;);
                            };
                        
                            this.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {
                                var toExecute;
                                var success = false;
                                var commands = this.$editor.commands;
                        
                                for (var i = this.$handlers.length; i--;) {
                                    toExecute = this.$handlers[i].handleKeyboard(
                                        this.$data, hashId, keyString, keyCode, e
                                    );
                                    if (!toExecute || !toExecute.command)
                                        continue;
                                    if (toExecute.command == &quot;null&quot;) {
                                        success = true;
                                    } else {
                                        success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);                
                                    }
                                    if (success &amp;&amp; e &amp;&amp; hashId != -1 &amp;&amp; 
                                        toExecute.passEvent != true &amp;&amp; toExecute.command.passEvent != true
                                    ) {
                                        event.stopEvent(e);
                                    }
                                    if (success)
                                        break;
                                }
                                return success;
                            };
                        
                            this.onCommandKey = function(e, hashId, keyCode) {
                                var keyString = keyUtil.keyCodeToString(keyCode);
                                this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
                            };
                        
                            this.onTextInput = function(text) {
                                var success = this.$callKeyboardHandlers(-1, text);
                                if (!success)
                                    this.$editor.commands.exec(&quot;insertstring&quot;, this.$editor, text);
                            };
                        
                        }).call(KeyBinding.prototype);
                        
                        exports.KeyBinding = KeyBinding;
                        });
                        
                        define(&quot;ace/range&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        var comparePoints = function(p1, p2) {
                            return p1.row - p2.row || p1.column - p2.column;
                        };
                        var Range = function(startRow, startColumn, endRow, endColumn) {
                            this.start = {
                                row: startRow,
                                column: startColumn
                            };
                        
                            this.end = {
                                row: endRow,
                                column: endColumn
                            };
                        };
                        
                        (function() {
                            this.isEqual = function(range) {
                                return this.start.row === range.start.row &amp;&amp;
                                    this.end.row === range.end.row &amp;&amp;
                                    this.start.column === range.start.column &amp;&amp;
                                    this.end.column === range.end.column;
                            };
                            this.toString = function() {
                                return (&quot;Range: [&quot; + this.start.row + &quot;/&quot; + this.start.column +
                                    &quot;] -&gt; [&quot; + this.end.row + &quot;/&quot; + this.end.column + &quot;]&quot;);
                            };
                        
                            this.contains = function(row, column) {
                                return this.compare(row, column) == 0;
                            };
                            this.compareRange = function(range) {
                                var cmp,
                                    end = range.end,
                                    start = range.start;
                        
                                cmp = this.compare(end.row, end.column);
                                if (cmp == 1) {
                                    cmp = this.compare(start.row, start.column);
                                    if (cmp == 1) {
                                        return 2;
                                    } else if (cmp == 0) {
                                        return 1;
                                    } else {
                                        return 0;
                                    }
                                } else if (cmp == -1) {
                                    return -2;
                                } else {
                                    cmp = this.compare(start.row, start.column);
                                    if (cmp == -1) {
                                        return -1;
                                    } else if (cmp == 1) {
                                        return 42;
                                    } else {
                                        return 0;
                                    }
                                }
                            };
                            this.comparePoint = function(p) {
                                return this.compare(p.row, p.column);
                            };
                            this.containsRange = function(range) {
                                return this.comparePoint(range.start) == 0 &amp;&amp; this.comparePoint(range.end) == 0;
                            };
                            this.intersects = function(range) {
                                var cmp = this.compareRange(range);
                                return (cmp == -1 || cmp == 0 || cmp == 1);
                            };
                            this.isEnd = function(row, column) {
                                return this.end.row == row &amp;&amp; this.end.column == column;
                            };
                            this.isStart = function(row, column) {
                                return this.start.row == row &amp;&amp; this.start.column == column;
                            };
                            this.setStart = function(row, column) {
                                if (typeof row == &quot;object&quot;) {
                                    this.start.column = row.column;
                                    this.start.row = row.row;
                                } else {
                                    this.start.row = row;
                                    this.start.column = column;
                                }
                            };
                            this.setEnd = function(row, column) {
                                if (typeof row == &quot;object&quot;) {
                                    this.end.column = row.column;
                                    this.end.row = row.row;
                                } else {
                                    this.end.row = row;
                                    this.end.column = column;
                                }
                            };
                            this.inside = function(row, column) {
                                if (this.compare(row, column) == 0) {
                                    if (this.isEnd(row, column) || this.isStart(row, column)) {
                                        return false;
                                    } else {
                                        return true;
                                    }
                                }
                                return false;
                            };
                            this.insideStart = function(row, column) {
                                if (this.compare(row, column) == 0) {
                                    if (this.isEnd(row, column)) {
                                        return false;
                                    } else {
                                        return true;
                                    }
                                }
                                return false;
                            };
                            this.insideEnd = function(row, column) {
                                if (this.compare(row, column) == 0) {
                                    if (this.isStart(row, column)) {
                                        return false;
                                    } else {
                                        return true;
                                    }
                                }
                                return false;
                            };
                            this.compare = function(row, column) {
                                if (!this.isMultiLine()) {
                                    if (row === this.start.row) {
                                        return column &lt; this.start.column ? -1 : (column &gt; this.end.column ? 1 : 0);
                                    };
                                }
                        
                                if (row &lt; this.start.row)
                                    return -1;
                        
                                if (row &gt; this.end.row)
                                    return 1;
                        
                                if (this.start.row === row)
                                    return column &gt;= this.start.column ? 0 : -1;
                        
                                if (this.end.row === row)
                                    return column &lt;= this.end.column ? 0 : 1;
                        
                                return 0;
                            };
                            this.compareStart = function(row, column) {
                                if (this.start.row == row &amp;&amp; this.start.column == column) {
                                    return -1;
                                } else {
                                    return this.compare(row, column);
                                }
                            };
                            this.compareEnd = function(row, column) {
                                if (this.end.row == row &amp;&amp; this.end.column == column) {
                                    return 1;
                                } else {
                                    return this.compare(row, column);
                                }
                            };
                            this.compareInside = function(row, column) {
                                if (this.end.row == row &amp;&amp; this.end.column == column) {
                                    return 1;
                                } else if (this.start.row == row &amp;&amp; this.start.column == column) {
                                    return -1;
                                } else {
                                    return this.compare(row, column);
                                }
                            };
                            this.clipRows = function(firstRow, lastRow) {
                                if (this.end.row &gt; lastRow)
                                    var end = {row: lastRow + 1, column: 0};
                                else if (this.end.row &lt; firstRow)
                                    var end = {row: firstRow, column: 0};
                        
                                if (this.start.row &gt; lastRow)
                                    var start = {row: lastRow + 1, column: 0};
                                else if (this.start.row &lt; firstRow)
                                    var start = {row: firstRow, column: 0};
                        
                                return Range.fromPoints(start || this.start, end || this.end);
                            };
                            this.extend = function(row, column) {
                                var cmp = this.compare(row, column);
                        
                                if (cmp == 0)
                                    return this;
                                else if (cmp == -1)
                                    var start = {row: row, column: column};
                                else
                                    var end = {row: row, column: column};
                        
                                return Range.fromPoints(start || this.start, end || this.end);
                            };
                        
                            this.isEmpty = function() {
                                return (this.start.row === this.end.row &amp;&amp; this.start.column === this.end.column);
                            };
                            this.isMultiLine = function() {
                                return (this.start.row !== this.end.row);
                            };
                            this.clone = function() {
                                return Range.fromPoints(this.start, this.end);
                            };
                            this.collapseRows = function() {
                                if (this.end.column == 0)
                                    return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0)
                                else
                                    return new Range(this.start.row, 0, this.end.row, 0)
                            };
                            this.toScreenRange = function(session) {
                                var screenPosStart = session.documentToScreenPosition(this.start);
                                var screenPosEnd = session.documentToScreenPosition(this.end);
                        
                                return new Range(
                                    screenPosStart.row, screenPosStart.column,
                                    screenPosEnd.row, screenPosEnd.column
                                );
                            };
                            this.moveBy = function(row, column) {
                                this.start.row += row;
                                this.start.column += column;
                                this.end.row += row;
                                this.end.column += column;
                            };
                        
                        }).call(Range.prototype);
                        Range.fromPoints = function(start, end) {
                            return new Range(start.row, start.column, end.row, end.column);
                        };
                        Range.comparePoints = comparePoints;
                        
                        Range.comparePoints = function(p1, p2) {
                            return p1.row - p2.row || p1.column - p2.column;
                        };
                        
                        
                        exports.Range = Range;
                        });
                        
                        define(&quot;ace/selection&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/lang&quot;,&quot;ace/lib/event_emitter&quot;,&quot;ace/range&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var oop = require(&quot;./lib/oop&quot;);
                        var lang = require(&quot;./lib/lang&quot;);
                        var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
                        var Range = require(&quot;./range&quot;).Range;
                        var Selection = function(session) {
                            this.session = session;
                            this.doc = session.getDocument();
                        
                            this.clearSelection();
                            this.lead = this.selectionLead = this.doc.createAnchor(0, 0);
                            this.anchor = this.selectionAnchor = this.doc.createAnchor(0, 0);
                        
                            var self = this;
                            this.lead.on(&quot;change&quot;, function(e) {
                                self._emit(&quot;changeCursor&quot;);
                                if (!self.$isEmpty)
                                    self._emit(&quot;changeSelection&quot;);
                                if (!self.$keepDesiredColumnOnChange &amp;&amp; e.old.column != e.value.column)
                                    self.$desiredColumn = null;
                            });
                        
                            this.selectionAnchor.on(&quot;change&quot;, function() {
                                if (!self.$isEmpty)
                                    self._emit(&quot;changeSelection&quot;);
                            });
                        };
                        
                        (function() {
                        
                            oop.implement(this, EventEmitter);
                            this.isEmpty = function() {
                                return (this.$isEmpty || (
                                    this.anchor.row == this.lead.row &amp;&amp;
                                    this.anchor.column == this.lead.column
                                ));
                            };
                            this.isMultiLine = function() {
                                if (this.isEmpty()) {
                                    return false;
                                }
                        
                                return this.getRange().isMultiLine();
                            };
                            this.getCursor = function() {
                                return this.lead.getPosition();
                            };
                            this.setSelectionAnchor = function(row, column) {
                                this.anchor.setPosition(row, column);
                        
                                if (this.$isEmpty) {
                                    this.$isEmpty = false;
                                    this._emit(&quot;changeSelection&quot;);
                                }
                            };
                            this.getSelectionAnchor = function() {
                                if (this.$isEmpty)
                                    return this.getSelectionLead();
                                else
                                    return this.anchor.getPosition();
                            };
                            this.getSelectionLead = function() {
                                return this.lead.getPosition();
                            };
                            this.shiftSelection = function(columns) {
                                if (this.$isEmpty) {
                                    this.moveCursorTo(this.lead.row, this.lead.column + columns);
                                    return;
                                }
                        
                                var anchor = this.getSelectionAnchor();
                                var lead = this.getSelectionLead();
                        
                                var isBackwards = this.isBackwards();
                        
                                if (!isBackwards || anchor.column !== 0)
                                    this.setSelectionAnchor(anchor.row, anchor.column + columns);
                        
                                if (isBackwards || lead.column !== 0) {
                                    this.$moveSelection(function() {
                                        this.moveCursorTo(lead.row, lead.column + columns);
                                    });
                                }
                            };
                            this.isBackwards = function() {
                                var anchor = this.anchor;
                                var lead = this.lead;
                                return (anchor.row &gt; lead.row || (anchor.row == lead.row &amp;&amp; anchor.column &gt; lead.column));
                            };
                            this.getRange = function() {
                                var anchor = this.anchor;
                                var lead = this.lead;
                        
                                if (this.isEmpty())
                                    return Range.fromPoints(lead, lead);
                        
                                if (this.isBackwards()) {
                                    return Range.fromPoints(lead, anchor);
                                }
                                else {
                                    return Range.fromPoints(anchor, lead);
                                }
                            };
                            this.clearSelection = function() {
                                if (!this.$isEmpty) {
                                    this.$isEmpty = true;
                                    this._emit(&quot;changeSelection&quot;);
                                }
                            };
                            this.selectAll = function() {
                                var lastRow = this.doc.getLength() - 1;
                                this.setSelectionAnchor(0, 0);
                                this.moveCursorTo(lastRow, this.doc.getLine(lastRow).length);
                            };
                            this.setRange =
                            this.setSelectionRange = function(range, reverse) {
                                if (reverse) {
                                    this.setSelectionAnchor(range.end.row, range.end.column);
                                    this.selectTo(range.start.row, range.start.column);
                                } else {
                                    this.setSelectionAnchor(range.start.row, range.start.column);
                                    this.selectTo(range.end.row, range.end.column);
                                }
                                if (this.getRange().isEmpty())
                                    this.$isEmpty = true;
                                this.$desiredColumn = null;
                            };
                        
                            this.$moveSelection = function(mover) {
                                var lead = this.lead;
                                if (this.$isEmpty)
                                    this.setSelectionAnchor(lead.row, lead.column);
                        
                                mover.call(this);
                            };
                            this.selectTo = function(row, column) {
                                this.$moveSelection(function() {
                                    this.moveCursorTo(row, column);
                                });
                            };
                            this.selectToPosition = function(pos) {
                                this.$moveSelection(function() {
                                    this.moveCursorToPosition(pos);
                                });
                            };
                            this.moveTo = function(row, column) {
                                this.clearSelection();
                                this.moveCursorTo(row, column);
                            };
                            this.moveToPosition = function(pos) {
                                this.clearSelection();
                                this.moveCursorToPosition(pos);
                            };
                            this.selectUp = function() {
                                this.$moveSelection(this.moveCursorUp);
                            };
                            this.selectDown = function() {
                                this.$moveSelection(this.moveCursorDown);
                            };
                            this.selectRight = function() {
                                this.$moveSelection(this.moveCursorRight);
                            };
                            this.selectLeft = function() {
                                this.$moveSelection(this.moveCursorLeft);
                            };
                            this.selectLineStart = function() {
                                this.$moveSelection(this.moveCursorLineStart);
                            };
                            this.selectLineEnd = function() {
                                this.$moveSelection(this.moveCursorLineEnd);
                            };
                            this.selectFileEnd = function() {
                                this.$moveSelection(this.moveCursorFileEnd);
                            };
                            this.selectFileStart = function() {
                                this.$moveSelection(this.moveCursorFileStart);
                            };
                            this.selectWordRight = function() {
                                this.$moveSelection(this.moveCursorWordRight);
                            };
                            this.selectWordLeft = function() {
                                this.$moveSelection(this.moveCursorWordLeft);
                            };
                            this.getWordRange = function(row, column) {
                                if (typeof column == &quot;undefined&quot;) {
                                    var cursor = row || this.lead;
                                    row = cursor.row;
                                    column = cursor.column;
                                }
                                return this.session.getWordRange(row, column);
                            };
                            this.selectWord = function() {
                                this.setSelectionRange(this.getWordRange());
                            };
                            this.selectAWord = function() {
                                var cursor = this.getCursor();
                                var range = this.session.getAWordRange(cursor.row, cursor.column);
                                this.setSelectionRange(range);
                            };
                        
                            this.getLineRange = function(row, excludeLastChar) {
                                var rowStart = typeof row == &quot;number&quot; ? row : this.lead.row;
                                var rowEnd;
                        
                                var foldLine = this.session.getFoldLine(rowStart);
                                if (foldLine) {
                                    rowStart = foldLine.start.row;
                                    rowEnd = foldLine.end.row;
                                } else {
                                    rowEnd = rowStart;
                                }
                                if (excludeLastChar === true)
                                    return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
                                else
                                    return new Range(rowStart, 0, rowEnd + 1, 0);
                            };
                            this.selectLine = function() {
                                this.setSelectionRange(this.getLineRange());
                            };
                            this.moveCursorUp = function() {
                                this.moveCursorBy(-1, 0);
                            };
                            this.moveCursorDown = function() {
                                this.moveCursorBy(1, 0);
                            };
                            this.moveCursorLeft = function() {
                                var cursor = this.lead.getPosition(),
                                    fold;
                        
                                if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
                                    this.moveCursorTo(fold.start.row, fold.start.column);
                                } else if (cursor.column === 0) {
                                    if (cursor.row &gt; 0) {
                                        this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
                                    }
                                }
                                else {
                                    var tabSize = this.session.getTabSize();
                                    if (this.session.isTabStop(cursor) &amp;&amp; this.doc.getLine(cursor.row).slice(cursor.column-tabSize, cursor.column).split(&quot; &quot;).length-1 == tabSize)
                                        this.moveCursorBy(0, -tabSize);
                                    else
                                        this.moveCursorBy(0, -1);
                                }
                            };
                            this.moveCursorRight = function() {
                                var cursor = this.lead.getPosition(),
                                    fold;
                                if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
                                    this.moveCursorTo(fold.end.row, fold.end.column);
                                }
                                else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
                                    if (this.lead.row &lt; this.doc.getLength() - 1) {
                                        this.moveCursorTo(this.lead.row + 1, 0);
                                    }
                                }
                                else {
                                    var tabSize = this.session.getTabSize();
                                    var cursor = this.lead;
                                    if (this.session.isTabStop(cursor) &amp;&amp; this.doc.getLine(cursor.row).slice(cursor.column, cursor.column+tabSize).split(&quot; &quot;).length-1 == tabSize)
                                        this.moveCursorBy(0, tabSize);
                                    else
                                        this.moveCursorBy(0, 1);
                                }
                            };
                            this.moveCursorLineStart = function() {
                                var row = this.lead.row;
                                var column = this.lead.column;
                                var screenRow = this.session.documentToScreenRow(row, column);
                                var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
                                var beforeCursor = this.session.getDisplayLine(
                                    row, null, firstColumnPosition.row,
                                    firstColumnPosition.column
                                );
                        
                                var leadingSpace = beforeCursor.match(/^\s*/);
                                if (leadingSpace[0].length != column &amp;&amp; !this.session.$useEmacsStyleLineStart)
                                    firstColumnPosition.column += leadingSpace[0].length;
                                this.moveCursorToPosition(firstColumnPosition);
                            };
                            this.moveCursorLineEnd = function() {
                                var lead = this.lead;
                                var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
                                if (this.lead.column == lineEnd.column) {
                                    var line = this.session.getLine(lineEnd.row);
                                    if (lineEnd.column == line.length) {
                                        var textEnd = line.search(/\s+$/);
                                        if (textEnd &gt; 0)
                                            lineEnd.column = textEnd;
                                    }
                                }
                        
                                this.moveCursorTo(lineEnd.row, lineEnd.column);
                            };
                            this.moveCursorFileEnd = function() {
                                var row = this.doc.getLength() - 1;
                                var column = this.doc.getLine(row).length;
                                this.moveCursorTo(row, column);
                            };
                            this.moveCursorFileStart = function() {
                                this.moveCursorTo(0, 0);
                            };
                            this.moveCursorLongWordRight = function() {
                                var row = this.lead.row;
                                var column = this.lead.column;
                                var line = this.doc.getLine(row);
                                var rightOfCursor = line.substring(column);
                        
                                var match;
                                this.session.nonTokenRe.lastIndex = 0;
                                this.session.tokenRe.lastIndex = 0;
                                var fold = this.session.getFoldAt(row, column, 1);
                                if (fold) {
                                    this.moveCursorTo(fold.end.row, fold.end.column);
                                    return;
                                }
                                if (match = this.session.nonTokenRe.exec(rightOfCursor)) {
                                    column += this.session.nonTokenRe.lastIndex;
                                    this.session.nonTokenRe.lastIndex = 0;
                                    rightOfCursor = line.substring(column);
                                }
                                if (column &gt;= line.length) {
                                    this.moveCursorTo(row, line.length);
                                    this.moveCursorRight();
                                    if (row &lt; this.doc.getLength() - 1)
                                        this.moveCursorWordRight();
                                    return;
                                }
                                if (match = this.session.tokenRe.exec(rightOfCursor)) {
                                    column += this.session.tokenRe.lastIndex;
                                    this.session.tokenRe.lastIndex = 0;
                                }
                        
                                this.moveCursorTo(row, column);
                            };
                            this.moveCursorLongWordLeft = function() {
                                var row = this.lead.row;
                                var column = this.lead.column;
                                var fold;
                                if (fold = this.session.getFoldAt(row, column, -1)) {
                                    this.moveCursorTo(fold.start.row, fold.start.column);
                                    return;
                                }
                        
                                var str = this.session.getFoldStringAt(row, column, -1);
                                if (str == null) {
                                    str = this.doc.getLine(row).substring(0, column);
                                }
                        
                                var leftOfCursor = lang.stringReverse(str);
                                var match;
                                this.session.nonTokenRe.lastIndex = 0;
                                this.session.tokenRe.lastIndex = 0;
                                if (match = this.session.nonTokenRe.exec(leftOfCursor)) {
                                    column -= this.session.nonTokenRe.lastIndex;
                                    leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
                                    this.session.nonTokenRe.lastIndex = 0;
                                }
                                if (column &lt;= 0) {
                                    this.moveCursorTo(row, 0);
                                    this.moveCursorLeft();
                                    if (row &gt; 0)
                                        this.moveCursorWordLeft();
                                    return;
                                }
                                if (match = this.session.tokenRe.exec(leftOfCursor)) {
                                    column -= this.session.tokenRe.lastIndex;
                                    this.session.tokenRe.lastIndex = 0;
                                }
                        
                                this.moveCursorTo(row, column);
                            };
                        
                            this.$shortWordEndIndex = function(rightOfCursor) {
                                var match, index = 0, ch;
                                var whitespaceRe = /\s/;
                                var tokenRe = this.session.tokenRe;
                        
                                tokenRe.lastIndex = 0;
                                if (match = this.session.tokenRe.exec(rightOfCursor)) {
                                    index = this.session.tokenRe.lastIndex;
                                } else {
                                    while ((ch = rightOfCursor[index]) &amp;&amp; whitespaceRe.test(ch))
                                        index ++;
                        
                                    if (index &lt; 1) {
                                        tokenRe.lastIndex = 0;
                                         while ((ch = rightOfCursor[index]) &amp;&amp; !tokenRe.test(ch)) {
                                            tokenRe.lastIndex = 0;
                                            index ++;
                                            if (whitespaceRe.test(ch)) {
                                                if (index &gt; 2) {
                                                    index--;
                                                    break;
                                                } else {
                                                    while ((ch = rightOfCursor[index]) &amp;&amp; whitespaceRe.test(ch))
                                                        index ++;
                                                    if (index &gt; 2)
                                                        break;
                                                }
                                            }
                                        }
                                    }
                                }
                                tokenRe.lastIndex = 0;
                        
                                return index;
                            };
                        
                            this.moveCursorShortWordRight = function() {
                                var row = this.lead.row;
                                var column = this.lead.column;
                                var line = this.doc.getLine(row);
                                var rightOfCursor = line.substring(column);
                        
                                var fold = this.session.getFoldAt(row, column, 1);
                                if (fold)
                                    return this.moveCursorTo(fold.end.row, fold.end.column);
                        
                                if (column == line.length) {
                                    var l = this.doc.getLength();
                                    do {
                                        row++;
                                        rightOfCursor = this.doc.getLine(row);
                                    } while (row &lt; l &amp;&amp; /^\s*$/.test(rightOfCursor));
                        
                                    if (!/^\s+/.test(rightOfCursor))
                                        rightOfCursor = &quot;&quot;;
                                    column = 0;
                                }
                        
                                var index = this.$shortWordEndIndex(rightOfCursor);
                        
                                this.moveCursorTo(row, column + index);
                            };
                        
                            this.moveCursorShortWordLeft = function() {
                                var row = this.lead.row;
                                var column = this.lead.column;
                        
                                var fold;
                                if (fold = this.session.getFoldAt(row, column, -1))
                                    return this.moveCursorTo(fold.start.row, fold.start.column);
                        
                                var line = this.session.getLine(row).substring(0, column);
                                if (column === 0) {
                                    do {
                                        row--;
                                        line = this.doc.getLine(row);
                                    } while (row &gt; 0 &amp;&amp; /^\s*$/.test(line));
                        
                                    column = line.length;
                                    if (!/\s+$/.test(line))
                                        line = &quot;&quot;;
                                }
                        
                                var leftOfCursor = lang.stringReverse(line);
                                var index = this.$shortWordEndIndex(leftOfCursor);
                        
                                return this.moveCursorTo(row, column - index);
                            };
                        
                            this.moveCursorWordRight = function() {
                                if (this.session.$selectLongWords)
                                    this.moveCursorLongWordRight();
                                else
                                    this.moveCursorShortWordRight();
                            };
                        
                            this.moveCursorWordLeft = function() {
                                if (this.session.$selectLongWords)
                                    this.moveCursorLongWordLeft();
                                else
                                    this.moveCursorShortWordLeft();
                            };
                            this.moveCursorBy = function(rows, chars) {
                                var screenPos = this.session.documentToScreenPosition(
                                    this.lead.row,
                                    this.lead.column
                                );
                        
                                if (chars === 0) {
                                    if (this.$desiredColumn)
                                        screenPos.column = this.$desiredColumn;
                                    else
                                        this.$desiredColumn = screenPos.column;
                                }
                        
                                var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column);
                                
                                if (rows !== 0 &amp;&amp; chars === 0 &amp;&amp; docPos.row === this.lead.row &amp;&amp; docPos.column === this.lead.column) {
                                    if (this.session.lineWidgets &amp;&amp; this.session.lineWidgets[docPos.row])
                                        docPos.row++;
                                }
                                this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
                            };
                            this.moveCursorToPosition = function(position) {
                                this.moveCursorTo(position.row, position.column);
                            };
                            this.moveCursorTo = function(row, column, keepDesiredColumn) {
                                var fold = this.session.getFoldAt(row, column, 1);
                                if (fold) {
                                    row = fold.start.row;
                                    column = fold.start.column;
                                }
                        
                                this.$keepDesiredColumnOnChange = true;
                                this.lead.setPosition(row, column);
                                this.$keepDesiredColumnOnChange = false;
                        
                                if (!keepDesiredColumn)
                                    this.$desiredColumn = null;
                            };
                            this.moveCursorToScreen = function(row, column, keepDesiredColumn) {
                                var pos = this.session.screenToDocumentPosition(row, column);
                                this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
                            };
                            this.detach = function() {
                                this.lead.detach();
                                this.anchor.detach();
                                this.session = this.doc = null;
                            };
                        
                            this.fromOrientedRange = function(range) {
                                this.setSelectionRange(range, range.cursor == range.start);
                                this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
                            };
                        
                            this.toOrientedRange = function(range) {
                                var r = this.getRange();
                                if (range) {
                                    range.start.column = r.start.column;
                                    range.start.row = r.start.row;
                                    range.end.column = r.end.column;
                                    range.end.row = r.end.row;
                                } else {
                                    range = r;
                                }
                        
                                range.cursor = this.isBackwards() ? range.start : range.end;
                                range.desiredColumn = this.$desiredColumn;
                                return range;
                            };
                            this.getRangeOfMovements = function(func) {
                                var start = this.getCursor();
                                try {
                                    func.call(null, this);
                                    var end = this.getCursor();
                                    return Range.fromPoints(start,end);
                                } catch(e) {
                                    return Range.fromPoints(start,start);
                                } finally {
                                    this.moveCursorToPosition(start);
                                }
                            };
                        
                            this.toJSON = function() {
                                if (this.rangeCount) {
                                    var data = this.ranges.map(function(r) {
                                        var r1 = r.clone();
                                        r1.isBackwards = r.cursor == r.start;
                                        return r1;
                                    });
                                } else {
                                    var data = this.getRange();
                                    data.isBackwards = this.isBackwards();
                                }
                                return data;
                            };
                        
                            this.fromJSON = function(data) {
                                if (data.start == undefined) {
                                    if (this.rangeList) {
                                        this.toSingleRange(data[0]);
                                        for (var i = data.length; i--; ) {
                                            var r = Range.fromPoints(data[i].start, data[i].end);
                                            if (data[i].isBackwards)
                                                r.cursor = r.start;
                                            this.addRange(r, true);
                                        }
                                        return;
                                    } else
                                        data = data[0];
                                }
                                if (this.rangeList)
                                    this.toSingleRange(data);
                                this.setSelectionRange(data, data.isBackwards);
                            };
                        
                            this.isEqual = function(data) {
                                if ((data.length || this.rangeCount) &amp;&amp; data.length != this.rangeCount)
                                    return false;
                                if (!data.length || !this.ranges)
                                    return this.getRange().isEqual(data);
                        
                                for (var i = this.ranges.length; i--; ) {
                                    if (!this.ranges[i].isEqual(data[i]))
                                        return false;
                                }
                                return true;
                            };
                        
                        }).call(Selection.prototype);
                        
                        exports.Selection = Selection;
                        });
                        
                        define(&quot;ace/tokenizer&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/config&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var config = require(&quot;./config&quot;);
                        var MAX_TOKEN_COUNT = 2000;
                        var Tokenizer = function(rules) {
                            this.states = rules;
                        
                            this.regExps = {};
                            this.matchMappings = {};
                            for (var key in this.states) {
                                var state = this.states[key];
                                var ruleRegExps = [];
                                var matchTotal = 0;
                                var mapping = this.matchMappings[key] = {defaultToken: &quot;text&quot;};
                                var flag = &quot;g&quot;;
                        
                                var splitterRurles = [];
                                for (var i = 0; i &lt; state.length; i++) {
                                    var rule = state[i];
                                    if (rule.defaultToken)
                                        mapping.defaultToken = rule.defaultToken;
                                    if (rule.caseInsensitive)
                                        flag = &quot;gi&quot;;
                                    if (rule.regex == null)
                                        continue;
                        
                                    if (rule.regex instanceof RegExp)
                                        rule.regex = rule.regex.toString().slice(1, -1);
                                    var adjustedregex = rule.regex;
                                    var matchcount = new RegExp(&quot;(?:(&quot; + adjustedregex + &quot;)|(.))&quot;).exec(&quot;a&quot;).length - 2;
                                    if (Array.isArray(rule.token)) {
                                        if (rule.token.length == 1 || matchcount == 1) {
                                            rule.token = rule.token[0];
                                        } else if (matchcount - 1 != rule.token.length) {
                                            this.reportError(&quot;number of classes and regexp groups doesn&#x27;t match&quot;, { 
                                                rule: rule,
                                                groupCount: matchcount - 1
                                            });
                                            rule.token = rule.token[0];
                                        } else {
                                            rule.tokenArray = rule.token;
                                            rule.token = null;
                                            rule.onMatch = this.$arrayTokens;
                                        }
                                    } else if (typeof rule.token == &quot;function&quot; &amp;&amp; !rule.onMatch) {
                                        if (matchcount &gt; 1)
                                            rule.onMatch = this.$applyToken;
                                        else
                                            rule.onMatch = rule.token;
                                    }
                        
                                    if (matchcount &gt; 1) {
                                        if (/\\\d/.test(rule.regex)) {
                                            adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
                                                return &quot;\\&quot; + (parseInt(digit, 10) + matchTotal + 1);
                                            });
                                        } else {
                                            matchcount = 1;
                                            adjustedregex = this.removeCapturingGroups(rule.regex);
                                        }
                                        if (!rule.splitRegex &amp;&amp; typeof rule.token != &quot;string&quot;)
                                            splitterRurles.push(rule); // flag will be known only at the very end
                                    }
                        
                                    mapping[matchTotal] = i;
                                    matchTotal += matchcount;
                        
                                    ruleRegExps.push(adjustedregex);
                                    if (!rule.onMatch)
                                        rule.onMatch = null;
                                }
                                
                                if (!ruleRegExps.length) {
                                    mapping[0] = 0;
                                    ruleRegExps.push(&quot;$&quot;);
                                }
                                
                                splitterRurles.forEach(function(rule) {
                                    rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
                                }, this);
                        
                                this.regExps[key] = new RegExp(&quot;(&quot; + ruleRegExps.join(&quot;)|(&quot;) + &quot;)|($)&quot;, flag);
                            }
                        };
                        
                        (function() {
                            this.$setMaxTokenCount = function(m) {
                                MAX_TOKEN_COUNT = m | 0;
                            };
                            
                            this.$applyToken = function(str) {
                                var values = this.splitRegex.exec(str).slice(1);
                                var types = this.token.apply(this, values);
                                if (typeof types === &quot;string&quot;)
                                    return [{type: types, value: str}];
                        
                                var tokens = [];
                                for (var i = 0, l = types.length; i &lt; l; i++) {
                                    if (values[i])
                                        tokens[tokens.length] = {
                                            type: types[i],
                                            value: values[i]
                                        };
                                }
                                return tokens;
                            },
                        
                            this.$arrayTokens = function(str) {
                                if (!str)
                                    return [];
                                var values = this.splitRegex.exec(str);
                                if (!values)
                                    return &quot;text&quot;;
                                var tokens = [];
                                var types = this.tokenArray;
                                for (var i = 0, l = types.length; i &lt; l; i++) {
                                    if (values[i + 1])
                                        tokens[tokens.length] = {
                                            type: types[i],
                                            value: values[i + 1]
                                        };
                                }
                                return tokens;
                            };
                        
                            this.removeCapturingGroups = function(src) {
                                var r = src.replace(
                                    /\[(?:\\.|[^\]])*?\]|\\.|\(\?[:=!]|(\()/g,
                                    function(x, y) {return y ? &quot;(?:&quot; : x;}
                                );
                                return r;
                            };
                        
                            this.createSplitterRegexp = function(src, flag) {
                                if (src.indexOf(&quot;(?=&quot;) != -1) {
                                    var stack = 0;
                                    var inChClass = false;
                                    var lastCapture = {};
                                    src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(
                                        m, esc, parenOpen, parenClose, square, index
                                    ) {
                                        if (inChClass) {
                                            inChClass = square != &quot;]&quot;;
                                        } else if (square) {
                                            inChClass = true;
                                        } else if (parenClose) {
                                            if (stack == lastCapture.stack) {
                                                lastCapture.end = index+1;
                                                lastCapture.stack = -1;
                                            }
                                            stack--;
                                        } else if (parenOpen) {
                                            stack++;
                                            if (parenOpen.length != 1) {
                                                lastCapture.stack = stack
                                                lastCapture.start = index;
                                            }
                                        }
                                        return m;
                                    });
                        
                                    if (lastCapture.end != null &amp;&amp; /^\)*$/.test(src.substr(lastCapture.end)))
                                        src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
                                }
                                return new RegExp(src, (flag||&quot;&quot;).replace(&quot;g&quot;, &quot;&quot;));
                            };
                            this.getLineTokens = function(line, startState) {
                                if (startState &amp;&amp; typeof startState != &quot;string&quot;) {
                                    var stack = startState.slice(0);
                                    startState = stack[0];
                                    if (startState === &quot;#tmp&quot;) {
                                        stack.shift()
                                        startState = stack.shift()
                                    }
                                } else
                                    var stack = [];
                        
                                var currentState = startState || &quot;start&quot;;
                                var state = this.states[currentState];
                                if (!state) {
                                    currentState = &quot;start&quot;;
                                    state = this.states[currentState];
                                }
                                var mapping = this.matchMappings[currentState];
                                var re = this.regExps[currentState];
                                re.lastIndex = 0;
                        
                                var match, tokens = [];
                                var lastIndex = 0;
                                var matchAttempts = 0;
                        
                                var token = {type: null, value: &quot;&quot;};
                        
                                while (match = re.exec(line)) {
                                    var type = mapping.defaultToken;
                                    var rule = null;
                                    var value = match[0];
                                    var index = re.lastIndex;
                        
                                    if (index - value.length &gt; lastIndex) {
                                        var skipped = line.substring(lastIndex, index - value.length);
                                        if (token.type == type) {
                                            token.value += skipped;
                                        } else {
                                            if (token.type)
                                                tokens.push(token);
                                            token = {type: type, value: skipped};
                                        }
                                    }
                        
                                    for (var i = 0; i &lt; match.length-2; i++) {
                                        if (match[i + 1] === undefined)
                                            continue;
                        
                                        rule = state[mapping[i]];
                        
                                        if (rule.onMatch)
                                            type = rule.onMatch(value, currentState, stack);
                                        else
                                            type = rule.token;
                        
                                        if (rule.next) {
                                            if (typeof rule.next == &quot;string&quot;) {
                                                currentState = rule.next;
                                            } else {
                                                currentState = rule.next(currentState, stack);
                                            }
                                            
                                            state = this.states[currentState];
                                            if (!state) {
                                                this.reportError(&quot;state doesn&#x27;t exist&quot;, currentState);
                                                currentState = &quot;start&quot;;
                                                state = this.states[currentState];
                                            }
                                            mapping = this.matchMappings[currentState];
                                            lastIndex = index;
                                            re = this.regExps[currentState];
                                            re.lastIndex = index;
                                        }
                                        break;
                                    }
                        
                                    if (value) {
                                        if (typeof type === &quot;string&quot;) {
                                            if ((!rule || rule.merge !== false) &amp;&amp; token.type === type) {
                                                token.value += value;
                                            } else {
                                                if (token.type)
                                                    tokens.push(token);
                                                token = {type: type, value: value};
                                            }
                                        } else if (type) {
                                            if (token.type)
                                                tokens.push(token);
                                            token = {type: null, value: &quot;&quot;};
                                            for (var i = 0; i &lt; type.length; i++)
                                                tokens.push(type[i]);
                                        }
                                    }
                        
                                    if (lastIndex == line.length)
                                        break;
                        
                                    lastIndex = index;
                        
                                    if (matchAttempts++ &gt; MAX_TOKEN_COUNT) {
                                        if (matchAttempts &gt; 2 * line.length) {
                                            this.reportError(&quot;infinite loop with in ace tokenizer&quot;, {
                                                startState: startState,
                                                line: line
                                            });
                                        }
                                        while (lastIndex &lt; line.length) {
                                            if (token.type)
                                                tokens.push(token);
                                            token = {
                                                value: line.substring(lastIndex, lastIndex += 2000),
                                                type: &quot;overflow&quot;
                                            };
                                        }
                                        currentState = &quot;start&quot;;
                                        stack = [];
                                        break;
                                    }
                                }
                        
                                if (token.type)
                                    tokens.push(token);
                                
                                if (stack.length &gt; 1) {
                                    if (stack[0] !== currentState)
                                        stack.unshift(&quot;#tmp&quot;, currentState);
                                }
                                return {
                                    tokens : tokens,
                                    state : stack.length ? stack : currentState
                                };
                            };
                            
                            this.reportError = config.reportError;
                            
                        }).call(Tokenizer.prototype);
                        
                        exports.Tokenizer = Tokenizer;
                        });
                        
                        define(&quot;ace/mode/text_highlight_rules&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/lang&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var lang = require(&quot;../lib/lang&quot;);
                        
                        var TextHighlightRules = function() {
                        
                            this.$rules = {
                                &quot;start&quot; : [{
                                    token : &quot;empty_line&quot;,
                                    regex : &#x27;^$&#x27;
                                }, {
                                    defaultToken : &quot;text&quot;
                                }]
                            };
                        };
                        
                        (function() {
                        
                            this.addRules = function(rules, prefix) {
                                if (!prefix) {
                                    for (var key in rules)
                                        this.$rules[key] = rules[key];
                                    return;
                                }
                                for (var key in rules) {
                                    var state = rules[key];
                                    for (var i = 0; i &lt; state.length; i++) {
                                        var rule = state[i];
                                        if (rule.next || rule.onMatch) {
                                            if (typeof rule.next != &quot;string&quot;) {
                                                if (rule.nextState &amp;&amp; rule.nextState.indexOf(prefix) !== 0)
                                                    rule.nextState = prefix + rule.nextState;
                                            } else {
                                                if (rule.next.indexOf(prefix) !== 0)
                                                    rule.next = prefix + rule.next;
                                            }
                                        }
                                    }
                                    this.$rules[prefix + key] = state;
                                }
                            };
                        
                            this.getRules = function() {
                                return this.$rules;
                            };
                        
                            this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {
                                var embedRules = typeof HighlightRules == &quot;function&quot;
                                    ? new HighlightRules().getRules()
                                    : HighlightRules;
                                if (states) {
                                    for (var i = 0; i &lt; states.length; i++)
                                        states[i] = prefix + states[i];
                                } else {
                                    states = [];
                                    for (var key in embedRules)
                                        states.push(prefix + key);
                                }
                        
                                this.addRules(embedRules, prefix);
                        
                                if (escapeRules) {
                                    var addRules = Array.prototype[append ? &quot;push&quot; : &quot;unshift&quot;];
                                    for (var i = 0; i &lt; states.length; i++)
                                        addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
                                }
                        
                                if (!this.$embeds)
                                    this.$embeds = [];
                                this.$embeds.push(prefix);
                            };
                        
                            this.getEmbeds = function() {
                                return this.$embeds;
                            };
                        
                            var pushState = function(currentState, stack) {
                                if (currentState != &quot;start&quot; || stack.length)
                                    stack.unshift(this.nextState, currentState);
                                return this.nextState;
                            };
                            var popState = function(currentState, stack) {
                                stack.shift();
                                return stack.shift() || &quot;start&quot;;
                            };
                        
                            this.normalizeRules = function() {
                                var id = 0;
                                var rules = this.$rules;
                                function processState(key) {
                                    var state = rules[key];
                                    state.processed = true;
                                    for (var i = 0; i &lt; state.length; i++) {
                                        var rule = state[i];
                                        if (!rule.regex &amp;&amp; rule.start) {
                                            rule.regex = rule.start;
                                            if (!rule.next)
                                                rule.next = [];
                                            rule.next.push({
                                                defaultToken: rule.token
                                            }, {
                                                token: rule.token + &quot;.end&quot;,
                                                regex: rule.end || rule.start,
                                                next: &quot;pop&quot;
                                            });
                                            rule.token = rule.token + &quot;.start&quot;;
                                            rule.push = true;
                                        }
                                        var next = rule.next || rule.push;
                                        if (next &amp;&amp; Array.isArray(next)) {
                                            var stateName = rule.stateName;
                                            if (!stateName)  {
                                                stateName = rule.token;
                                                if (typeof stateName != &quot;string&quot;)
                                                    stateName = stateName[0] || &quot;&quot;;
                                                if (rules[stateName])
                                                    stateName += id++;
                                            }
                                            rules[stateName] = next;
                                            rule.next = stateName;
                                            processState(stateName);
                                        } else if (next == &quot;pop&quot;) {
                                            rule.next = popState;
                                        }
                        
                                        if (rule.push) {
                                            rule.nextState = rule.next || rule.push;
                                            rule.next = pushState;
                                            delete rule.push;
                                        }
                        
                                        if (rule.rules) {
                                            for (var r in rule.rules) {
                                                if (rules[r]) {
                                                    if (rules[r].push)
                                                        rules[r].push.apply(rules[r], rule.rules[r]);
                                                } else {
                                                    rules[r] = rule.rules[r];
                                                }
                                            }
                                        }
                                        if (rule.include || typeof rule == &quot;string&quot;) {
                                            var includeName = rule.include || rule;
                                            var toInsert = rules[includeName];
                                        } else if (Array.isArray(rule))
                                            toInsert = rule;
                        
                                        if (toInsert) {
                                            var args = [i, 1].concat(toInsert);
                                            if (rule.noEscape)
                                                args = args.filter(function(x) {return !x.next;});
                                            state.splice.apply(state, args);
                                            i--;
                                            toInsert = null;
                                        }
                                        
                                        if (rule.keywordMap) {
                                            rule.token = this.createKeywordMapper(
                                                rule.keywordMap, rule.defaultToken || &quot;text&quot;, rule.caseInsensitive
                                            );
                                            delete rule.defaultToken;
                                        }
                                    }
                                }
                                Object.keys(rules).forEach(processState, this);
                            };
                        
                            this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
                                var keywords = Object.create(null);
                                Object.keys(map).forEach(function(className) {
                                    var a = map[className];
                                    if (ignoreCase)
                                        a = a.toLowerCase();
                                    var list = a.split(splitChar || &quot;|&quot;);
                                    for (var i = list.length; i--; )
                                        keywords[list[i]] = className;
                                });
                                if (Object.getPrototypeOf(keywords)) {
                                    keywords.__proto__ = null;
                                }
                                this.$keywordList = Object.keys(keywords);
                                map = null;
                                return ignoreCase
                                    ? function(value) {return keywords[value.toLowerCase()] || defaultToken }
                                    : function(value) {return keywords[value] || defaultToken };
                            };
                        
                            this.getKeywords = function() {
                                return this.$keywords;
                            };
                        
                        }).call(TextHighlightRules.prototype);
                        
                        exports.TextHighlightRules = TextHighlightRules;
                        });
                        
                        define(&quot;ace/mode/behaviour&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var Behaviour = function() {
                           this.$behaviours = {};
                        };
                        
                        (function () {
                        
                            this.add = function (name, action, callback) {
                                switch (undefined) {
                                  case this.$behaviours:
                                      this.$behaviours = {};
                                  case this.$behaviours[name]:
                                      this.$behaviours[name] = {};
                                }
                                this.$behaviours[name][action] = callback;
                            }
                            
                            this.addBehaviours = function (behaviours) {
                                for (var key in behaviours) {
                                    for (var action in behaviours[key]) {
                                        this.add(key, action, behaviours[key][action]);
                                    }
                                }
                            }
                            
                            this.remove = function (name) {
                                if (this.$behaviours &amp;&amp; this.$behaviours[name]) {
                                    delete this.$behaviours[name];
                                }
                            }
                            
                            this.inherit = function (mode, filter) {
                                if (typeof mode === &quot;function&quot;) {
                                    var behaviours = new mode().getBehaviours(filter);
                                } else {
                                    var behaviours = mode.getBehaviours(filter);
                                }
                                this.addBehaviours(behaviours);
                            }
                            
                            this.getBehaviours = function (filter) {
                                if (!filter) {
                                    return this.$behaviours;
                                } else {
                                    var ret = {}
                                    for (var i = 0; i &lt; filter.length; i++) {
                                        if (this.$behaviours[filter[i]]) {
                                            ret[filter[i]] = this.$behaviours[filter[i]];
                                        }
                                    }
                                    return ret;
                                }
                            }
                        
                        }).call(Behaviour.prototype);
                        
                        exports.Behaviour = Behaviour;
                        });
                        
                        define(&quot;ace/unicode&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        exports.packages = {};
                        
                        addUnicodePackage({
                            L:  &quot;0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC&quot;,
                            Ll: &quot;0061-007A00AA00B500BA00DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F0521052305250561-05871D00-1D2B1D62-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7C2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2D00-2D25A641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CFB00-FB06FB13-FB17FF41-FF5A&quot;,
                            Lu: &quot;0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E0520052205240531-055610A0-10C51E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CEDA640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BFF21-FF3A&quot;,
                            Lt: &quot;01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC&quot;,
                            Lm: &quot;02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D611D781D9B-1DBF2071207F2090-20942C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A9CFAA70AADDFF70FF9EFF9F&quot;,
                            Lo: &quot;01BB01C0-01C3029405D0-05EA05F0-05F20621-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150904-0939093D09500958-096109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF12135-21382D30-2D652D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC&quot;,
                            M:  &quot;0300-036F0483-04890591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DE-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0903093C093E-094E0951-0955096209630981-098309BC09BE-09C409C709C809CB-09CD09D709E209E30A01-0A030A3C0A3E-0A420A470A480A4B-0A4D0A510A700A710A750A81-0A830ABC0ABE-0AC50AC7-0AC90ACB-0ACD0AE20AE30B01-0B030B3C0B3E-0B440B470B480B4B-0B4D0B560B570B620B630B820BBE-0BC20BC6-0BC80BCA-0BCD0BD70C01-0C030C3E-0C440C46-0C480C4A-0C4D0C550C560C620C630C820C830CBC0CBE-0CC40CC6-0CC80CCA-0CCD0CD50CD60CE20CE30D020D030D3E-0D440D46-0D480D4A-0D4D0D570D620D630D820D830DCA0DCF-0DD40DD60DD8-0DDF0DF20DF30E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F3E0F3F0F71-0F840F860F870F90-0F970F99-0FBC0FC6102B-103E1056-1059105E-10601062-10641067-106D1071-10741082-108D108F109A-109D135F1712-17141732-1734175217531772177317B6-17D317DD180B-180D18A91920-192B1930-193B19B0-19C019C819C91A17-1A1B1A55-1A5E1A60-1A7C1A7F1B00-1B041B34-1B441B6B-1B731B80-1B821BA1-1BAA1C24-1C371CD0-1CD21CD4-1CE81CED1CF21DC0-1DE61DFD-1DFF20D0-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66F-A672A67CA67DA6F0A6F1A802A806A80BA823-A827A880A881A8B4-A8C4A8E0-A8F1A926-A92DA947-A953A980-A983A9B3-A9C0AA29-AA36AA43AA4CAA4DAA7BAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE3-ABEAABECABEDFB1EFE00-FE0FFE20-FE26&quot;,
                            Mn: &quot;0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0902093C0941-0948094D0951-095509620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F90-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135F1712-17141732-1734175217531772177317B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1DC0-1DE61DFD-1DFF20D0-20DC20E120E5-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66FA67CA67DA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26&quot;,
                            Mc: &quot;0903093E-09400949-094C094E0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1C24-1C2B1C341C351CE11CF2A823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BABE3ABE4ABE6ABE7ABE9ABEAABEC&quot;,
                            Me: &quot;0488048906DE20DD-20E020E2-20E4A670-A672&quot;,
                            N:  &quot;0030-003900B200B300B900BC-00BE0660-066906F0-06F907C0-07C90966-096F09E6-09EF09F4-09F90A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BF20C66-0C6F0C78-0C7E0CE6-0CEF0D66-0D750E50-0E590ED0-0ED90F20-0F331040-10491090-10991369-137C16EE-16F017E0-17E917F0-17F91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C5920702074-20792080-20892150-21822185-21892460-249B24EA-24FF2776-27932CFD30073021-30293038-303A3192-31953220-32293251-325F3280-328932B1-32BFA620-A629A6E6-A6EFA830-A835A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19&quot;,
                            Nd: &quot;0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19&quot;,
                            Nl: &quot;16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF&quot;,
                            No: &quot;00B200B300B900BC-00BE09F4-09F90BF0-0BF20C78-0C7E0D70-0D750F2A-0F331369-137C17F0-17F920702074-20792080-20892150-215F21892460-249B24EA-24FF2776-27932CFD3192-31953220-32293251-325F3280-328932B1-32BFA830-A835&quot;,
                            P:  &quot;0021-00230025-002A002C-002F003A003B003F0040005B-005D005F007B007D00A100AB00B700BB00BF037E0387055A-055F0589058A05BE05C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F3A-0F3D0F850FD0-0FD4104A-104F10FB1361-13681400166D166E169B169C16EB-16ED1735173617D4-17D617D8-17DA1800-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD32010-20272030-20432045-20512053-205E207D207E208D208E2329232A2768-277527C527C627E6-27EF2983-299829D8-29DB29FC29FD2CF9-2CFC2CFE2CFF2E00-2E2E2E302E313001-30033008-30113014-301F3030303D30A030FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFD3EFD3FFE10-FE19FE30-FE52FE54-FE61FE63FE68FE6AFE6BFF01-FF03FF05-FF0AFF0C-FF0FFF1AFF1BFF1FFF20FF3B-FF3DFF3FFF5BFF5DFF5F-FF65&quot;,
                            Pd: &quot;002D058A05BE140018062010-20152E172E1A301C303030A0FE31FE32FE58FE63FF0D&quot;,
                            Ps: &quot;0028005B007B0F3A0F3C169B201A201E2045207D208D23292768276A276C276E27702772277427C527E627E827EA27EC27EE2983298529872989298B298D298F299129932995299729D829DA29FC2E222E242E262E283008300A300C300E3010301430163018301A301DFD3EFE17FE35FE37FE39FE3BFE3DFE3FFE41FE43FE47FE59FE5BFE5DFF08FF3BFF5BFF5FFF62&quot;,
                            Pe: &quot;0029005D007D0F3B0F3D169C2046207E208E232A2769276B276D276F27712773277527C627E727E927EB27ED27EF298429862988298A298C298E2990299229942996299829D929DB29FD2E232E252E272E293009300B300D300F3011301530173019301B301E301FFD3FFE18FE36FE38FE3AFE3CFE3EFE40FE42FE44FE48FE5AFE5CFE5EFF09FF3DFF5DFF60FF63&quot;,
                            Pi: &quot;00AB2018201B201C201F20392E022E042E092E0C2E1C2E20&quot;,
                            Pf: &quot;00BB2019201D203A2E032E052E0A2E0D2E1D2E21&quot;,
                            Pc: &quot;005F203F20402054FE33FE34FE4D-FE4FFF3F&quot;,
                            Po: &quot;0021-00230025-0027002A002C002E002F003A003B003F0040005C00A100B700BF037E0387055A-055F058905C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F850FD0-0FD4104A-104F10FB1361-1368166D166E16EB-16ED1735173617D4-17D617D8-17DA1800-18051807-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD3201620172020-20272030-2038203B-203E2041-20432047-205120532055-205E2CF9-2CFC2CFE2CFF2E002E012E06-2E082E0B2E0E-2E162E182E192E1B2E1E2E1F2E2A-2E2E2E302E313001-3003303D30FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFE10-FE16FE19FE30FE45FE46FE49-FE4CFE50-FE52FE54-FE57FE5F-FE61FE68FE6AFE6BFF01-FF03FF05-FF07FF0AFF0CFF0EFF0FFF1AFF1BFF1FFF20FF3CFF61FF64FF65&quot;,
                            S:  &quot;0024002B003C-003E005E0060007C007E00A2-00A900AC00AE-00B100B400B600B800D700F702C2-02C502D2-02DF02E5-02EB02ED02EF-02FF03750384038503F604820606-0608060B060E060F06E906FD06FE07F609F209F309FA09FB0AF10B700BF3-0BFA0C7F0CF10CF20D790E3F0F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-139917DB194019E0-19FF1B61-1B6A1B74-1B7C1FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE20442052207A-207C208A-208C20A0-20B8210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B2140-2144214A-214D214F2190-2328232B-23E82400-24262440-244A249C-24E92500-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE27C0-27C427C7-27CA27CC27D0-27E527F0-29822999-29D729DC-29FB29FE-2B4C2B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F309B309C319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A700-A716A720A721A789A78AA828-A82BA836-A839AA77-AA79FB29FDFCFDFDFE62FE64-FE66FE69FF04FF0BFF1C-FF1EFF3EFF40FF5CFF5EFFE0-FFE6FFE8-FFEEFFFCFFFD&quot;,
                            Sm: &quot;002B003C-003E007C007E00AC00B100D700F703F60606-060820442052207A-207C208A-208C2140-2144214B2190-2194219A219B21A021A321A621AE21CE21CF21D221D421F4-22FF2308-230B23202321237C239B-23B323DC-23E125B725C125F8-25FF266F27C0-27C427C7-27CA27CC27D0-27E527F0-27FF2900-29822999-29D729DC-29FB29FE-2AFF2B30-2B442B47-2B4CFB29FE62FE64-FE66FF0BFF1C-FF1EFF5CFF5EFFE2FFE9-FFEC&quot;,
                            Sc: &quot;002400A2-00A5060B09F209F309FB0AF10BF90E3F17DB20A0-20B8A838FDFCFE69FF04FFE0FFE1FFE5FFE6&quot;,
                            Sk: &quot;005E006000A800AF00B400B802C2-02C502D2-02DF02E5-02EB02ED02EF-02FF0375038403851FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE309B309CA700-A716A720A721A789A78AFF3EFF40FFE3&quot;,
                            So: &quot;00A600A700A900AE00B000B60482060E060F06E906FD06FE07F609FA0B700BF3-0BF80BFA0C7F0CF10CF20D790F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-1399194019E0-19FF1B61-1B6A1B74-1B7C210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B214A214C214D214F2195-2199219C-219F21A121A221A421A521A7-21AD21AF-21CD21D021D121D321D5-21F32300-2307230C-231F2322-2328232B-237B237D-239A23B4-23DB23E2-23E82400-24262440-244A249C-24E92500-25B625B8-25C025C2-25F72600-266E2670-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE2800-28FF2B00-2B2F2B452B462B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A828-A82BA836A837A839AA77-AA79FDFDFFE4FFE8FFEDFFEEFFFCFFFD&quot;,
                            Z:  &quot;002000A01680180E2000-200A20282029202F205F3000&quot;,
                            Zs: &quot;002000A01680180E2000-200A202F205F3000&quot;,
                            Zl: &quot;2028&quot;,
                            Zp: &quot;2029&quot;,
                            C:  &quot;0000-001F007F-009F00AD03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-0605061C061D0620065F06DD070E070F074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17B417B517DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF200B-200F202A-202E2060-206F20722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-F8FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFD-FF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFFBFFFEFFFF&quot;,
                            Cc: &quot;0000-001F007F-009F&quot;,
                            Cf: &quot;00AD0600-060306DD070F17B417B5200B-200F202A-202E2060-2064206A-206FFEFFFFF9-FFFB&quot;,
                            Co: &quot;E000-F8FF&quot;,
                            Cs: &quot;D800-DFFF&quot;,
                            Cn: &quot;03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-05FF06040605061C061D0620065F070E074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF2065-206920722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-D7FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFDFEFEFF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFF8FFFEFFFF&quot;
                        });
                        
                        function addUnicodePackage (pack) {
                            var codePoint = /\w{4}/g;
                            for (var name in pack)
                                exports.packages[name] = pack[name].replace(codePoint, &quot;\\u$&amp;&quot;);
                        };
                        
                        });
                        
                        define(&quot;ace/token_iterator&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        var TokenIterator = function(session, initialRow, initialColumn) {
                            this.$session = session;
                            this.$row = initialRow;
                            this.$rowTokens = session.getTokens(initialRow);
                        
                            var token = session.getTokenAt(initialRow, initialColumn);
                            this.$tokenIndex = token ? token.index : -1;
                        };
                        
                        (function() { 
                            this.stepBackward = function() {
                                this.$tokenIndex -= 1;
                                
                                while (this.$tokenIndex &lt; 0) {
                                    this.$row -= 1;
                                    if (this.$row &lt; 0) {
                                        this.$row = 0;
                                        return null;
                                    }
                                        
                                    this.$rowTokens = this.$session.getTokens(this.$row);
                                    this.$tokenIndex = this.$rowTokens.length - 1;
                                }
                                    
                                return this.$rowTokens[this.$tokenIndex];
                            };   
                            this.stepForward = function() {
                                this.$tokenIndex += 1;
                                var rowCount;
                                while (this.$tokenIndex &gt;= this.$rowTokens.length) {
                                    this.$row += 1;
                                    if (!rowCount)
                                        rowCount = this.$session.getLength();
                                    if (this.$row &gt;= rowCount) {
                                        this.$row = rowCount - 1;
                                        return null;
                                    }
                        
                                    this.$rowTokens = this.$session.getTokens(this.$row);
                                    this.$tokenIndex = 0;
                                }
                                    
                                return this.$rowTokens[this.$tokenIndex];
                            };      
                            this.getCurrentToken = function () {
                                return this.$rowTokens[this.$tokenIndex];
                            };      
                            this.getCurrentTokenRow = function () {
                                return this.$row;
                            };     
                            this.getCurrentTokenColumn = function() {
                                var rowTokens = this.$rowTokens;
                                var tokenIndex = this.$tokenIndex;
                                var column = rowTokens[tokenIndex].start;
                                if (column !== undefined)
                                    return column;
                                    
                                column = 0;
                                while (tokenIndex &gt; 0) {
                                    tokenIndex -= 1;
                                    column += rowTokens[tokenIndex].value.length;
                                }
                                
                                return column;  
                            };
                                    
                        }).call(TokenIterator.prototype);
                        
                        exports.TokenIterator = TokenIterator;
                        });
                        
                        define(&quot;ace/mode/text&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/tokenizer&quot;,&quot;ace/mode/text_highlight_rules&quot;,&quot;ace/mode/behaviour&quot;,&quot;ace/unicode&quot;,&quot;ace/lib/lang&quot;,&quot;ace/token_iterator&quot;,&quot;ace/range&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var Tokenizer = require(&quot;../tokenizer&quot;).Tokenizer;
                        var TextHighlightRules = require(&quot;./text_highlight_rules&quot;).TextHighlightRules;
                        var Behaviour = require(&quot;./behaviour&quot;).Behaviour;
                        var unicode = require(&quot;../unicode&quot;);
                        var lang = require(&quot;../lib/lang&quot;);
                        var TokenIterator = require(&quot;../token_iterator&quot;).TokenIterator;
                        var Range = require(&quot;../range&quot;).Range;
                        
                        var Mode = function() {
                            this.HighlightRules = TextHighlightRules;
                            this.$behaviour = new Behaviour();
                        };
                        
                        (function() {
                        
                            this.tokenRe = new RegExp(&quot;^[&quot;
                                + unicode.packages.L
                                + unicode.packages.Mn + unicode.packages.Mc
                                + unicode.packages.Nd
                                + unicode.packages.Pc + &quot;\\$_]+&quot;, &quot;g&quot;
                            );
                        
                            this.nonTokenRe = new RegExp(&quot;^(?:[^&quot;
                                + unicode.packages.L
                                + unicode.packages.Mn + unicode.packages.Mc
                                + unicode.packages.Nd
                                + unicode.packages.Pc + &quot;\\$_]|\\s])+&quot;, &quot;g&quot;
                            );
                        
                            this.getTokenizer = function() {
                                if (!this.$tokenizer) {
                                    this.$highlightRules = this.$highlightRules || new this.HighlightRules();
                                    this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
                                }
                                return this.$tokenizer;
                            };
                        
                            this.lineCommentStart = &quot;&quot;;
                            this.blockComment = &quot;&quot;;
                        
                            this.toggleCommentLines = function(state, session, startRow, endRow) {
                                var doc = session.doc;
                        
                                var ignoreBlankLines = true;
                                var shouldRemove = true;
                                var minIndent = Infinity;
                                var tabSize = session.getTabSize();
                                var insertAtTabStop = false;
                        
                                if (!this.lineCommentStart) {
                                    if (!this.blockComment)
                                        return false;
                                    var lineCommentStart = this.blockComment.start;
                                    var lineCommentEnd = this.blockComment.end;
                                    var regexpStart = new RegExp(&quot;^(\\s*)(?:&quot; + lang.escapeRegExp(lineCommentStart) + &quot;)&quot;);
                                    var regexpEnd = new RegExp(&quot;(?:&quot; + lang.escapeRegExp(lineCommentEnd) + &quot;)\\s*$&quot;);
                        
                                    var comment = function(line, i) {
                                        if (testRemove(line, i))
                                            return;
                                        if (!ignoreBlankLines || /\S/.test(line)) {
                                            doc.insertInLine({row: i, column: line.length}, lineCommentEnd);
                                            doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
                                        }
                                    };
                        
                                    var uncomment = function(line, i) {
                                        var m;
                                        if (m = line.match(regexpEnd))
                                            doc.removeInLine(i, line.length - m[0].length, line.length);
                                        if (m = line.match(regexpStart))
                                            doc.removeInLine(i, m[1].length, m[0].length);
                                    };
                        
                                    var testRemove = function(line, row) {
                                        if (regexpStart.test(line))
                                            return true;
                                        var tokens = session.getTokens(row);
                                        for (var i = 0; i &lt; tokens.length; i++) {
                                            if (tokens[i].type === &#x27;comment&#x27;)
                                                return true;
                                        }
                                    };
                                } else {
                                    if (Array.isArray(this.lineCommentStart)) {
                                        var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join(&quot;|&quot;);
                                        var lineCommentStart = this.lineCommentStart[0];
                                    } else {
                                        var regexpStart = lang.escapeRegExp(this.lineCommentStart);
                                        var lineCommentStart = this.lineCommentStart;
                                    }
                                    regexpStart = new RegExp(&quot;^(\\s*)(?:&quot; + regexpStart + &quot;) ?&quot;);
                                    
                                    insertAtTabStop = session.getUseSoftTabs();
                        
                                    var uncomment = function(line, i) {
                                        var m = line.match(regexpStart);
                                        if (!m) return;
                                        var start = m[1].length, end = m[0].length;
                                        if (!shouldInsertSpace(line, start, end) &amp;&amp; m[0][end - 1] == &quot; &quot;)
                                            end--;
                                        doc.removeInLine(i, start, end);
                                    };
                                    var commentWithSpace = lineCommentStart + &quot; &quot;;
                                    var comment = function(line, i) {
                                        if (!ignoreBlankLines || /\S/.test(line)) {
                                            if (shouldInsertSpace(line, minIndent, minIndent))
                                                doc.insertInLine({row: i, column: minIndent}, commentWithSpace);
                                            else
                                                doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
                                        }
                                    };
                                    var testRemove = function(line, i) {
                                        return regexpStart.test(line);
                                    };
                                    
                                    var shouldInsertSpace = function(line, before, after) {
                                        var spaces = 0;
                                        while (before-- &amp;&amp; line.charAt(before) == &quot; &quot;)
                                            spaces++;
                                        if (spaces % tabSize != 0)
                                            return false;
                                        var spaces = 0;
                                        while (line.charAt(after++) == &quot; &quot;)
                                            spaces++;
                                        if (tabSize &gt; 2)
                                            return spaces % tabSize != tabSize - 1;
                                        else
                                            return spaces % tabSize == 0;
                                        return true;
                                    };
                                }
                        
                                function iter(fun) {
                                    for (var i = startRow; i &lt;= endRow; i++)
                                        fun(doc.getLine(i), i);
                                }
                        
                        
                                var minEmptyLength = Infinity;
                                iter(function(line, i) {
                                    var indent = line.search(/\S/);
                                    if (indent !== -1) {
                                        if (indent &lt; minIndent)
                                            minIndent = indent;
                                        if (shouldRemove &amp;&amp; !testRemove(line, i))
                                            shouldRemove = false;
                                    } else if (minEmptyLength &gt; line.length) {
                                        minEmptyLength = line.length;
                                    }
                                });
                        
                                if (minIndent == Infinity) {
                                    minIndent = minEmptyLength;
                                    ignoreBlankLines = false;
                                    shouldRemove = false;
                                }
                        
                                if (insertAtTabStop &amp;&amp; minIndent % tabSize != 0)
                                    minIndent = Math.floor(minIndent / tabSize) * tabSize;
                        
                                iter(shouldRemove ? uncomment : comment);
                            };
                        
                            this.toggleBlockComment = function(state, session, range, cursor) {
                                var comment = this.blockComment;
                                if (!comment)
                                    return;
                                if (!comment.start &amp;&amp; comment[0])
                                    comment = comment[0];
                        
                                var iterator = new TokenIterator(session, cursor.row, cursor.column);
                                var token = iterator.getCurrentToken();
                        
                                var sel = session.selection;
                                var initialRange = session.selection.toOrientedRange();
                                var startRow, colDiff;
                        
                                if (token &amp;&amp; /comment/.test(token.type)) {
                                    var startRange, endRange;
                                    while (token &amp;&amp; /comment/.test(token.type)) {
                                        var i = token.value.indexOf(comment.start);
                                        if (i != -1) {
                                            var row = iterator.getCurrentTokenRow();
                                            var column = iterator.getCurrentTokenColumn() + i;
                                            startRange = new Range(row, column, row, column + comment.start.length);
                                            break;
                                        }
                                        token = iterator.stepBackward();
                                    }
                        
                                    var iterator = new TokenIterator(session, cursor.row, cursor.column);
                                    var token = iterator.getCurrentToken();
                                    while (token &amp;&amp; /comment/.test(token.type)) {
                                        var i = token.value.indexOf(comment.end);
                                        if (i != -1) {
                                            var row = iterator.getCurrentTokenRow();
                                            var column = iterator.getCurrentTokenColumn() + i;
                                            endRange = new Range(row, column, row, column + comment.end.length);
                                            break;
                                        }
                                        token = iterator.stepForward();
                                    }
                                    if (endRange)
                                        session.remove(endRange);
                                    if (startRange) {
                                        session.remove(startRange);
                                        startRow = startRange.start.row;
                                        colDiff = -comment.start.length;
                                    }
                                } else {
                                    colDiff = comment.start.length;
                                    startRow = range.start.row;
                                    session.insert(range.end, comment.end);
                                    session.insert(range.start, comment.start);
                                }
                                if (initialRange.start.row == startRow)
                                    initialRange.start.column += colDiff;
                                if (initialRange.end.row == startRow)
                                    initialRange.end.column += colDiff;
                                session.selection.fromOrientedRange(initialRange);
                            };
                        
                            this.getNextLineIndent = function(state, line, tab) {
                                return this.$getIndent(line);
                            };
                        
                            this.checkOutdent = function(state, line, input) {
                                return false;
                            };
                        
                            this.autoOutdent = function(state, doc, row) {
                            };
                        
                            this.$getIndent = function(line) {
                                return line.match(/^\s*/)[0];
                            };
                        
                            this.createWorker = function(session) {
                                return null;
                            };
                        
                            this.createModeDelegates = function (mapping) {
                                this.$embeds = [];
                                this.$modes = {};
                                for (var i in mapping) {
                                    if (mapping[i]) {
                                        this.$embeds.push(i);
                                        this.$modes[i] = new mapping[i]();
                                    }
                                }
                        
                                var delegations = [&#x27;toggleBlockComment&#x27;, &#x27;toggleCommentLines&#x27;, &#x27;getNextLineIndent&#x27;, 
                                    &#x27;checkOutdent&#x27;, &#x27;autoOutdent&#x27;, &#x27;transformAction&#x27;, &#x27;getCompletions&#x27;];
                        
                                for (var i = 0; i &lt; delegations.length; i++) {
                                    (function(scope) {
                                      var functionName = delegations[i];
                                      var defaultHandler = scope[functionName];
                                      scope[delegations[i]] = function() {
                                          return this.$delegator(functionName, arguments, defaultHandler);
                                      };
                                    } (this));
                                }
                            };
                        
                            this.$delegator = function(method, args, defaultHandler) {
                                var state = args[0];
                                if (typeof state != &quot;string&quot;)
                                    state = state[0];
                                for (var i = 0; i &lt; this.$embeds.length; i++) {
                                    if (!this.$modes[this.$embeds[i]]) continue;
                        
                                    var split = state.split(this.$embeds[i]);
                                    if (!split[0] &amp;&amp; split[1]) {
                                        args[0] = split[1];
                                        var mode = this.$modes[this.$embeds[i]];
                                        return mode[method].apply(mode, args);
                                    }
                                }
                                var ret = defaultHandler.apply(this, args);
                                return defaultHandler ? ret : undefined;
                            };
                        
                            this.transformAction = function(state, action, editor, session, param) {
                                if (this.$behaviour) {
                                    var behaviours = this.$behaviour.getBehaviours();
                                    for (var key in behaviours) {
                                        if (behaviours[key][action]) {
                                            var ret = behaviours[key][action].apply(this, arguments);
                                            if (ret) {
                                                return ret;
                                            }
                                        }
                                    }
                                }
                            };
                            
                            this.getKeywords = function(append) {
                                if (!this.completionKeywords) {
                                    var rules = this.$tokenizer.rules;
                                    var completionKeywords = [];
                                    for (var rule in rules) {
                                        var ruleItr = rules[rule];
                                        for (var r = 0, l = ruleItr.length; r &lt; l; r++) {
                                            if (typeof ruleItr[r].token === &quot;string&quot;) {
                                                if (/keyword|support|storage/.test(ruleItr[r].token))
                                                    completionKeywords.push(ruleItr[r].regex);
                                            }
                                            else if (typeof ruleItr[r].token === &quot;object&quot;) {
                                                for (var a = 0, aLength = ruleItr[r].token.length; a &lt; aLength; a++) {    
                                                    if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                                                        var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                                                        completionKeywords.push(rule.substr(1, rule.length - 2));
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    this.completionKeywords = completionKeywords;
                                }
                                if (!append)
                                    return this.$keywordList;
                                return completionKeywords.concat(this.$keywordList || []);
                            };
                            
                            this.$createKeywordList = function() {
                                if (!this.$highlightRules)
                                    this.getTokenizer();
                                return this.$keywordList = this.$highlightRules.$keywordList || [];
                            };
                        
                            this.getCompletions = function(state, session, pos, prefix) {
                                var keywords = this.$keywordList || this.$createKeywordList();
                                return keywords.map(function(word) {
                                    return {
                                        name: word,
                                        value: word,
                                        score: 0,
                                        meta: &quot;keyword&quot;
                                    };
                                });
                            };
                        
                            this.$id = &quot;ace/mode/text&quot;;
                        }).call(Mode.prototype);
                        
                        exports.Mode = Mode;
                        });
                        
                        define(&quot;ace/anchor&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/event_emitter&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var oop = require(&quot;./lib/oop&quot;);
                        var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
                        
                        var Anchor = exports.Anchor = function(doc, row, column) {
                            this.$onChange = this.onChange.bind(this);
                            this.attach(doc);
                            
                            if (typeof column == &quot;undefined&quot;)
                                this.setPosition(row.row, row.column);
                            else
                                this.setPosition(row, column);
                        };
                        
                        (function() {
                        
                            oop.implement(this, EventEmitter);
                            this.getPosition = function() {
                                return this.$clipPositionToDocument(this.row, this.column);
                            };
                            this.getDocument = function() {
                                return this.document;
                            };
                            this.$insertRight = false;
                            this.onChange = function(e) {
                                var delta = e.data;
                                var range = delta.range;
                        
                                if (range.start.row == range.end.row &amp;&amp; range.start.row != this.row)
                                    return;
                        
                                if (range.start.row &gt; this.row)
                                    return;
                        
                                if (range.start.row == this.row &amp;&amp; range.start.column &gt; this.column)
                                    return;
                        
                                var row = this.row;
                                var column = this.column;
                                var start = range.start;
                                var end = range.end;
                        
                                if (delta.action === &quot;insertText&quot;) {
                                    if (start.row === row &amp;&amp; start.column &lt;= column) {
                                        if (start.column === column &amp;&amp; this.$insertRight) {
                                        } else if (start.row === end.row) {
                                            column += end.column - start.column;
                                        } else {
                                            column -= start.column;
                                            row += end.row - start.row;
                                        }
                                    } else if (start.row !== end.row &amp;&amp; start.row &lt; row) {
                                        row += end.row - start.row;
                                    }
                                } else if (delta.action === &quot;insertLines&quot;) {
                                    if (start.row === row &amp;&amp; column === 0 &amp;&amp; this.$insertRight) {
                                    }
                                    else if (start.row &lt;= row) {
                                        row += end.row - start.row;
                                    }
                                } else if (delta.action === &quot;removeText&quot;) {
                                    if (start.row === row &amp;&amp; start.column &lt; column) {
                                        if (end.column &gt;= column)
                                            column = start.column;
                                        else
                                            column = Math.max(0, column - (end.column - start.column));
                        
                                    } else if (start.row !== end.row &amp;&amp; start.row &lt; row) {
                                        if (end.row === row)
                                            column = Math.max(0, column - end.column) + start.column;
                                        row -= (end.row - start.row);
                                    } else if (end.row === row) {
                                        row -= end.row - start.row;
                                        column = Math.max(0, column - end.column) + start.column;
                                    }
                                } else if (delta.action == &quot;removeLines&quot;) {
                                    if (start.row &lt;= row) {
                                        if (end.row &lt;= row)
                                            row -= end.row - start.row;
                                        else {
                                            row = start.row;
                                            column = 0;
                                        }
                                    }
                                }
                        
                                this.setPosition(row, column, true);
                            };
                            this.setPosition = function(row, column, noClip) {
                                var pos;
                                if (noClip) {
                                    pos = {
                                        row: row,
                                        column: column
                                    };
                                } else {
                                    pos = this.$clipPositionToDocument(row, column);
                                }
                        
                                if (this.row == pos.row &amp;&amp; this.column == pos.column)
                                    return;
                        
                                var old = {
                                    row: this.row,
                                    column: this.column
                                };
                        
                                this.row = pos.row;
                                this.column = pos.column;
                                this._signal(&quot;change&quot;, {
                                    old: old,
                                    value: pos
                                });
                            };
                            this.detach = function() {
                                this.document.removeEventListener(&quot;change&quot;, this.$onChange);
                            };
                            this.attach = function(doc) {
                                this.document = doc || this.document;
                                this.document.on(&quot;change&quot;, this.$onChange);
                            };
                            this.$clipPositionToDocument = function(row, column) {
                                var pos = {};
                        
                                if (row &gt;= this.document.getLength()) {
                                    pos.row = Math.max(0, this.document.getLength() - 1);
                                    pos.column = this.document.getLine(pos.row).length;
                                }
                                else if (row &lt; 0) {
                                    pos.row = 0;
                                    pos.column = 0;
                                }
                                else {
                                    pos.row = row;
                                    pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
                                }
                        
                                if (column &lt; 0)
                                    pos.column = 0;
                        
                                return pos;
                            };
                        
                        }).call(Anchor.prototype);
                        
                        });
                        
                        define(&quot;ace/document&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/event_emitter&quot;,&quot;ace/range&quot;,&quot;ace/anchor&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var oop = require(&quot;./lib/oop&quot;);
                        var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
                        var Range = require(&quot;./range&quot;).Range;
                        var Anchor = require(&quot;./anchor&quot;).Anchor;
                        
                        var Document = function(text) {
                            this.$lines = [];
                            if (text.length === 0) {
                                this.$lines = [&quot;&quot;];
                            } else if (Array.isArray(text)) {
                                this._insertLines(0, text);
                            } else {
                                this.insert({row: 0, column:0}, text);
                            }
                        };
                        
                        (function() {
                        
                            oop.implement(this, EventEmitter);
                            this.setValue = function(text) {
                                var len = this.getLength();
                                this.remove(new Range(0, 0, len, this.getLine(len-1).length));
                                this.insert({row: 0, column:0}, text);
                            };
                            this.getValue = function() {
                                return this.getAllLines().join(this.getNewLineCharacter());
                            };
                            this.createAnchor = function(row, column) {
                                return new Anchor(this, row, column);
                            };
                            if (&quot;aaa&quot;.split(/a/).length === 0)
                                this.$split = function(text) {
                                    return text.replace(/\r\n|\r/g, &quot;\n&quot;).split(&quot;\n&quot;);
                                };
                            else
                                this.$split = function(text) {
                                    return text.split(/\r\n|\r|\n/);
                                };
                        
                        
                            this.$detectNewLine = function(text) {
                                var match = text.match(/^.*?(\r\n|\r|\n)/m);
                                this.$autoNewLine = match ? match[1] : &quot;\n&quot;;
                                this._signal(&quot;changeNewLineMode&quot;);
                            };
                            this.getNewLineCharacter = function() {
                                switch (this.$newLineMode) {
                                  case &quot;windows&quot;:
                                    return &quot;\r\n&quot;;
                                  case &quot;unix&quot;:
                                    return &quot;\n&quot;;
                                  default:
                                    return this.$autoNewLine || &quot;\n&quot;;
                                }
                            };
                        
                            this.$autoNewLine = &quot;&quot;;
                            this.$newLineMode = &quot;auto&quot;;
                            this.setNewLineMode = function(newLineMode) {
                                if (this.$newLineMode === newLineMode)
                                    return;
                        
                                this.$newLineMode = newLineMode;
                                this._signal(&quot;changeNewLineMode&quot;);
                            };
                            this.getNewLineMode = function() {
                                return this.$newLineMode;
                            };
                            this.isNewLine = function(text) {
                                return (text == &quot;\r\n&quot; || text == &quot;\r&quot; || text == &quot;\n&quot;);
                            };
                            this.getLine = function(row) {
                                return this.$lines[row] || &quot;&quot;;
                            };
                            this.getLines = function(firstRow, lastRow) {
                                return this.$lines.slice(firstRow, lastRow + 1);
                            };
                            this.getAllLines = function() {
                                return this.getLines(0, this.getLength());
                            };
                            this.getLength = function() {
                                return this.$lines.length;
                            };
                            this.getTextRange = function(range) {
                                if (range.start.row == range.end.row) {
                                    return this.getLine(range.start.row)
                                        .substring(range.start.column, range.end.column);
                                }
                                var lines = this.getLines(range.start.row, range.end.row);
                                lines[0] = (lines[0] || &quot;&quot;).substring(range.start.column);
                                var l = lines.length - 1;
                                if (range.end.row - range.start.row == l)
                                    lines[l] = lines[l].substring(0, range.end.column);
                                return lines.join(this.getNewLineCharacter());
                            };
                        
                            this.$clipPosition = function(position) {
                                var length = this.getLength();
                                if (position.row &gt;= length) {
                                    position.row = Math.max(0, length - 1);
                                    position.column = this.getLine(length-1).length;
                                } else if (position.row &lt; 0)
                                    position.row = 0;
                                return position;
                            };
                            this.insert = function(position, text) {
                                if (!text || text.length === 0)
                                    return position;
                        
                                position = this.$clipPosition(position);
                                if (this.getLength() &lt;= 1)
                                    this.$detectNewLine(text);
                        
                                var lines = this.$split(text);
                                var firstLine = lines.splice(0, 1)[0];
                                var lastLine = lines.length == 0 ? null : lines.splice(lines.length - 1, 1)[0];
                        
                                position = this.insertInLine(position, firstLine);
                                if (lastLine !== null) {
                                    position = this.insertNewLine(position); // terminate first line
                                    position = this._insertLines(position.row, lines);
                                    position = this.insertInLine(position, lastLine || &quot;&quot;);
                                }
                                return position;
                            };
                            this.insertLines = function(row, lines) {
                                if (row &gt;= this.getLength())
                                    return this.insert({row: row, column: 0}, &quot;\n&quot; + lines.join(&quot;\n&quot;));
                                return this._insertLines(Math.max(row, 0), lines);
                            };
                            this._insertLines = function(row, lines) {
                                if (lines.length == 0)
                                    return {row: row, column: 0};
                                while (lines.length &gt; 20000) {
                                    var end = this._insertLines(row, lines.slice(0, 20000));
                                    lines = lines.slice(20000);
                                    row = end.row;
                                }
                        
                                var args = [row, 0];
                                args.push.apply(args, lines);
                                this.$lines.splice.apply(this.$lines, args);
                        
                                var range = new Range(row, 0, row + lines.length, 0);
                                var delta = {
                                    action: &quot;insertLines&quot;,
                                    range: range,
                                    lines: lines
                                };
                                this._signal(&quot;change&quot;, { data: delta });
                                return range.end;
                            };
                            this.insertNewLine = function(position) {
                                position = this.$clipPosition(position);
                                var line = this.$lines[position.row] || &quot;&quot;;
                        
                                this.$lines[position.row] = line.substring(0, position.column);
                                this.$lines.splice(position.row + 1, 0, line.substring(position.column, line.length));
                        
                                var end = {
                                    row : position.row + 1,
                                    column : 0
                                };
                        
                                var delta = {
                                    action: &quot;insertText&quot;,
                                    range: Range.fromPoints(position, end),
                                    text: this.getNewLineCharacter()
                                };
                                this._signal(&quot;change&quot;, { data: delta });
                        
                                return end;
                            };
                            this.insertInLine = function(position, text) {
                                if (text.length == 0)
                                    return position;
                        
                                var line = this.$lines[position.row] || &quot;&quot;;
                        
                                this.$lines[position.row] = line.substring(0, position.column) + text
                                        + line.substring(position.column);
                        
                                var end = {
                                    row : position.row,
                                    column : position.column + text.length
                                };
                        
                                var delta = {
                                    action: &quot;insertText&quot;,
                                    range: Range.fromPoints(position, end),
                                    text: text
                                };
                                this._signal(&quot;change&quot;, { data: delta });
                        
                                return end;
                            };
                            this.remove = function(range) {
                                if (!(range instanceof Range))
                                    range = Range.fromPoints(range.start, range.end);
                                range.start = this.$clipPosition(range.start);
                                range.end = this.$clipPosition(range.end);
                        
                                if (range.isEmpty())
                                    return range.start;
                        
                                var firstRow = range.start.row;
                                var lastRow = range.end.row;
                        
                                if (range.isMultiLine()) {
                                    var firstFullRow = range.start.column == 0 ? firstRow : firstRow + 1;
                                    var lastFullRow = lastRow - 1;
                        
                                    if (range.end.column &gt; 0)
                                        this.removeInLine(lastRow, 0, range.end.column);
                        
                                    if (lastFullRow &gt;= firstFullRow)
                                        this._removeLines(firstFullRow, lastFullRow);
                        
                                    if (firstFullRow != firstRow) {
                                        this.removeInLine(firstRow, range.start.column, this.getLine(firstRow).length);
                                        this.removeNewLine(range.start.row);
                                    }
                                }
                                else {
                                    this.removeInLine(firstRow, range.start.column, range.end.column);
                                }
                                return range.start;
                            };
                            this.removeInLine = function(row, startColumn, endColumn) {
                                if (startColumn == endColumn)
                                    return;
                        
                                var range = new Range(row, startColumn, row, endColumn);
                                var line = this.getLine(row);
                                var removed = line.substring(startColumn, endColumn);
                                var newLine = line.substring(0, startColumn) + line.substring(endColumn, line.length);
                                this.$lines.splice(row, 1, newLine);
                        
                                var delta = {
                                    action: &quot;removeText&quot;,
                                    range: range,
                                    text: removed
                                };
                                this._signal(&quot;change&quot;, { data: delta });
                                return range.start;
                            };
                            this.removeLines = function(firstRow, lastRow) {
                                if (firstRow &lt; 0 || lastRow &gt;= this.getLength())
                                    return this.remove(new Range(firstRow, 0, lastRow + 1, 0));
                                return this._removeLines(firstRow, lastRow);
                            };
                        
                            this._removeLines = function(firstRow, lastRow) {
                                var range = new Range(firstRow, 0, lastRow + 1, 0);
                                var removed = this.$lines.splice(firstRow, lastRow - firstRow + 1);
                        
                                var delta = {
                                    action: &quot;removeLines&quot;,
                                    range: range,
                                    nl: this.getNewLineCharacter(),
                                    lines: removed
                                };
                                this._signal(&quot;change&quot;, { data: delta });
                                return removed;
                            };
                            this.removeNewLine = function(row) {
                                var firstLine = this.getLine(row);
                                var secondLine = this.getLine(row+1);
                        
                                var range = new Range(row, firstLine.length, row+1, 0);
                                var line = firstLine + secondLine;
                        
                                this.$lines.splice(row, 2, line);
                        
                                var delta = {
                                    action: &quot;removeText&quot;,
                                    range: range,
                                    text: this.getNewLineCharacter()
                                };
                                this._signal(&quot;change&quot;, { data: delta });
                            };
                            this.replace = function(range, text) {
                                if (!(range instanceof Range))
                                    range = Range.fromPoints(range.start, range.end);
                                if (text.length == 0 &amp;&amp; range.isEmpty())
                                    return range.start;
                                if (text == this.getTextRange(range))
                                    return range.end;
                        
                                this.remove(range);
                                if (text) {
                                    var end = this.insert(range.start, text);
                                }
                                else {
                                    end = range.start;
                                }
                        
                                return end;
                            };
                            this.applyDeltas = function(deltas) {
                                for (var i=0; i&lt;deltas.length; i++) {
                                    var delta = deltas[i];
                                    var range = Range.fromPoints(delta.range.start, delta.range.end);
                        
                                    if (delta.action == &quot;insertLines&quot;)
                                        this.insertLines(range.start.row, delta.lines);
                                    else if (delta.action == &quot;insertText&quot;)
                                        this.insert(range.start, delta.text);
                                    else if (delta.action == &quot;removeLines&quot;)
                                        this._removeLines(range.start.row, range.end.row - 1);
                                    else if (delta.action == &quot;removeText&quot;)
                                        this.remove(range);
                                }
                            };
                            this.revertDeltas = function(deltas) {
                                for (var i=deltas.length-1; i&gt;=0; i--) {
                                    var delta = deltas[i];
                        
                                    var range = Range.fromPoints(delta.range.start, delta.range.end);
                        
                                    if (delta.action == &quot;insertLines&quot;)
                                        this._removeLines(range.start.row, range.end.row - 1);
                                    else if (delta.action == &quot;insertText&quot;)
                                        this.remove(range);
                                    else if (delta.action == &quot;removeLines&quot;)
                                        this._insertLines(range.start.row, delta.lines);
                                    else if (delta.action == &quot;removeText&quot;)
                                        this.insert(range.start, delta.text);
                                }
                            };
                            this.indexToPosition = function(index, startRow) {
                                var lines = this.$lines || this.getAllLines();
                                var newlineLength = this.getNewLineCharacter().length;
                                for (var i = startRow || 0, l = lines.length; i &lt; l; i++) {
                                    index -= lines[i].length + newlineLength;
                                    if (index &lt; 0)
                                        return {row: i, column: index + lines[i].length + newlineLength};
                                }
                                return {row: l-1, column: lines[l-1].length};
                            };
                            this.positionToIndex = function(pos, startRow) {
                                var lines = this.$lines || this.getAllLines();
                                var newlineLength = this.getNewLineCharacter().length;
                                var index = 0;
                                var row = Math.min(pos.row, lines.length);
                                for (var i = startRow || 0; i &lt; row; ++i)
                                    index += lines[i].length + newlineLength;
                        
                                return index + pos.column;
                            };
                        
                        }).call(Document.prototype);
                        
                        exports.Document = Document;
                        });
                        
                        define(&quot;ace/background_tokenizer&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/event_emitter&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var oop = require(&quot;./lib/oop&quot;);
                        var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
                        
                        var BackgroundTokenizer = function(tokenizer, editor) {
                            this.running = false;
                            this.lines = [];
                            this.states = [];
                            this.currentLine = 0;
                            this.tokenizer = tokenizer;
                        
                            var self = this;
                        
                            this.$worker = function() {
                                if (!self.running) { return; }
                        
                                var workerStart = new Date();
                                var currentLine = self.currentLine;
                                var endLine = -1;
                                var doc = self.doc;
                        
                                while (self.lines[currentLine])
                                    currentLine++;
                        
                                var startLine = currentLine;
                        
                                var len = doc.getLength();
                                var processedLines = 0;
                                self.running = false;
                                while (currentLine &lt; len) {
                                    self.$tokenizeRow(currentLine);
                                    endLine = currentLine;
                                    do {
                                        currentLine++;
                                    } while (self.lines[currentLine]);
                                    processedLines ++;
                                    if ((processedLines % 5 === 0) &amp;&amp; (new Date() - workerStart) &gt; 20) {                
                                        self.running = setTimeout(self.$worker, 20);
                                        break;
                                    }
                                }
                                self.currentLine = currentLine;
                                
                                if (startLine &lt;= endLine)
                                    self.fireUpdateEvent(startLine, endLine);
                            };
                        };
                        
                        (function(){
                        
                            oop.implement(this, EventEmitter);
                            this.setTokenizer = function(tokenizer) {
                                this.tokenizer = tokenizer;
                                this.lines = [];
                                this.states = [];
                        
                                this.start(0);
                            };
                            this.setDocument = function(doc) {
                                this.doc = doc;
                                this.lines = [];
                                this.states = [];
                        
                                this.stop();
                            };
                            this.fireUpdateEvent = function(firstRow, lastRow) {
                                var data = {
                                    first: firstRow,
                                    last: lastRow
                                };
                                this._signal(&quot;update&quot;, {data: data});
                            };
                            this.start = function(startRow) {
                                this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
                                this.lines.splice(this.currentLine, this.lines.length);
                                this.states.splice(this.currentLine, this.states.length);
                        
                                this.stop();
                                this.running = setTimeout(this.$worker, 700);
                            };
                            
                            this.scheduleStart = function() {
                                if (!this.running)
                                    this.running = setTimeout(this.$worker, 700);
                            }
                        
                            this.$updateOnChange = function(delta) {
                                var range = delta.range;
                                var startRow = range.start.row;
                                var len = range.end.row - startRow;
                        
                                if (len === 0) {
                                    this.lines[startRow] = null;
                                } else if (delta.action == &quot;removeText&quot; || delta.action == &quot;removeLines&quot;) {
                                    this.lines.splice(startRow, len + 1, null);
                                    this.states.splice(startRow, len + 1, null);
                                } else {
                                    var args = Array(len + 1);
                                    args.unshift(startRow, 1);
                                    this.lines.splice.apply(this.lines, args);
                                    this.states.splice.apply(this.states, args);
                                }
                        
                                this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());
                        
                                this.stop();
                            };
                            this.stop = function() {
                                if (this.running)
                                    clearTimeout(this.running);
                                this.running = false;
                            };
                            this.getTokens = function(row) {
                                return this.lines[row] || this.$tokenizeRow(row);
                            };
                            this.getState = function(row) {
                                if (this.currentLine == row)
                                    this.$tokenizeRow(row);
                                return this.states[row] || &quot;start&quot;;
                            };
                        
                            this.$tokenizeRow = function(row) {
                                var line = this.doc.getLine(row);
                                var state = this.states[row - 1];
                        
                                var data = this.tokenizer.getLineTokens(line, state, row);
                        
                                if (this.states[row] + &quot;&quot; !== data.state + &quot;&quot;) {
                                    this.states[row] = data.state;
                                    this.lines[row + 1] = null;
                                    if (this.currentLine &gt; row + 1)
                                        this.currentLine = row + 1;
                                } else if (this.currentLine == row) {
                                    this.currentLine = row + 1;
                                }
                        
                                return this.lines[row] = data.tokens;
                            };
                        
                        }).call(BackgroundTokenizer.prototype);
                        
                        exports.BackgroundTokenizer = BackgroundTokenizer;
                        });
                        
                        define(&quot;ace/search_highlight&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/lang&quot;,&quot;ace/lib/oop&quot;,&quot;ace/range&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var lang = require(&quot;./lib/lang&quot;);
                        var oop = require(&quot;./lib/oop&quot;);
                        var Range = require(&quot;./range&quot;).Range;
                        
                        var SearchHighlight = function(regExp, clazz, type) {
                            this.setRegexp(regExp);
                            this.clazz = clazz;
                            this.type = type || &quot;text&quot;;
                        };
                        
                        (function() {
                            this.MAX_RANGES = 500;
                            
                            this.setRegexp = function(regExp) {
                                if (this.regExp+&quot;&quot; == regExp+&quot;&quot;)
                                    return;
                                this.regExp = regExp;
                                this.cache = [];
                            };
                        
                            this.update = function(html, markerLayer, session, config) {
                                if (!this.regExp)
                                    return;
                                var start = config.firstRow, end = config.lastRow;
                        
                                for (var i = start; i &lt;= end; i++) {
                                    var ranges = this.cache[i];
                                    if (ranges == null) {
                                        ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
                                        if (ranges.length &gt; this.MAX_RANGES)
                                            ranges = ranges.slice(0, this.MAX_RANGES);
                                        ranges = ranges.map(function(match) {
                                            return new Range(i, match.offset, i, match.offset + match.length);
                                        });
                                        this.cache[i] = ranges.length ? ranges : &quot;&quot;;
                                    }
                        
                                    for (var j = ranges.length; j --; ) {
                                        markerLayer.drawSingleLineMarker(
                                            html, ranges[j].toScreenRange(session), this.clazz, config);
                                    }
                                }
                            };
                        
                        }).call(SearchHighlight.prototype);
                        
                        exports.SearchHighlight = SearchHighlight;
                        });
                        
                        define(&quot;ace/edit_session/fold_line&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/range&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var Range = require(&quot;../range&quot;).Range;
                        function FoldLine(foldData, folds) {
                            this.foldData = foldData;
                            if (Array.isArray(folds)) {
                                this.folds = folds;
                            } else {
                                folds = this.folds = [ folds ];
                            }
                        
                            var last = folds[folds.length - 1];
                            this.range = new Range(folds[0].start.row, folds[0].start.column,
                                                   last.end.row, last.end.column);
                            this.start = this.range.start;
                            this.end   = this.range.end;
                        
                            this.folds.forEach(function(fold) {
                                fold.setFoldLine(this);
                            }, this);
                        }
                        
                        (function() {
                            this.shiftRow = function(shift) {
                                this.start.row += shift;
                                this.end.row += shift;
                                this.folds.forEach(function(fold) {
                                    fold.start.row += shift;
                                    fold.end.row += shift;
                                });
                            };
                        
                            this.addFold = function(fold) {
                                if (fold.sameRow) {
                                    if (fold.start.row &lt; this.startRow || fold.endRow &gt; this.endRow) {
                                        throw new Error(&quot;Can&#x27;t add a fold to this FoldLine as it has no connection&quot;);
                                    }
                                    this.folds.push(fold);
                                    this.folds.sort(function(a, b) {
                                        return -a.range.compareEnd(b.start.row, b.start.column);
                                    });
                                    if (this.range.compareEnd(fold.start.row, fold.start.column) &gt; 0) {
                                        this.end.row = fold.end.row;
                                        this.end.column =  fold.end.column;
                                    } else if (this.range.compareStart(fold.end.row, fold.end.column) &lt; 0) {
                                        this.start.row = fold.start.row;
                                        this.start.column = fold.start.column;
                                    }
                                } else if (fold.start.row == this.end.row) {
                                    this.folds.push(fold);
                                    this.end.row = fold.end.row;
                                    this.end.column = fold.end.column;
                                } else if (fold.end.row == this.start.row) {
                                    this.folds.unshift(fold);
                                    this.start.row = fold.start.row;
                                    this.start.column = fold.start.column;
                                } else {
                                    throw new Error(&quot;Trying to add fold to FoldRow that doesn&#x27;t have a matching row&quot;);
                                }
                                fold.foldLine = this;
                            };
                        
                            this.containsRow = function(row) {
                                return row &gt;= this.start.row &amp;&amp; row &lt;= this.end.row;
                            };
                        
                            this.walk = function(callback, endRow, endColumn) {
                                var lastEnd = 0,
                                    folds = this.folds,
                                    fold,
                                    cmp, stop, isNewRow = true;
                        
                                if (endRow == null) {
                                    endRow = this.end.row;
                                    endColumn = this.end.column;
                                }
                        
                                for (var i = 0; i &lt; folds.length; i++) {
                                    fold = folds[i];
                        
                                    cmp = fold.range.compareStart(endRow, endColumn);
                                    if (cmp == -1) {
                                        callback(null, endRow, endColumn, lastEnd, isNewRow);
                                        return;
                                    }
                        
                                    stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
                                    stop = !stop &amp;&amp; callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
                                    if (stop || cmp === 0) {
                                        return;
                                    }
                                    isNewRow = !fold.sameRow;
                                    lastEnd = fold.end.column;
                                }
                                callback(null, endRow, endColumn, lastEnd, isNewRow);
                            };
                        
                            this.getNextFoldTo = function(row, column) {
                                var fold, cmp;
                                for (var i = 0; i &lt; this.folds.length; i++) {
                                    fold = this.folds[i];
                                    cmp = fold.range.compareEnd(row, column);
                                    if (cmp == -1) {
                                        return {
                                            fold: fold,
                                            kind: &quot;after&quot;
                                        };
                                    } else if (cmp === 0) {
                                        return {
                                            fold: fold,
                                            kind: &quot;inside&quot;
                                        };
                                    }
                                }
                                return null;
                            };
                        
                            this.addRemoveChars = function(row, column, len) {
                                var ret = this.getNextFoldTo(row, column),
                                    fold, folds;
                                if (ret) {
                                    fold = ret.fold;
                                    if (ret.kind == &quot;inside&quot;
                                        &amp;&amp; fold.start.column != column
                                        &amp;&amp; fold.start.row != row)
                                    {
                                        window.console &amp;&amp; window.console.log(row, column, fold);
                                    } else if (fold.start.row == row) {
                                        folds = this.folds;
                                        var i = folds.indexOf(fold);
                                        if (i === 0) {
                                            this.start.column += len;
                                        }
                                        for (i; i &lt; folds.length; i++) {
                                            fold = folds[i];
                                            fold.start.column += len;
                                            if (!fold.sameRow) {
                                                return;
                                            }
                                            fold.end.column += len;
                                        }
                                        this.end.column += len;
                                    }
                                }
                            };
                        
                            this.split = function(row, column) {
                                var pos = this.getNextFoldTo(row, column);
                                
                                if (!pos || pos.kind == &quot;inside&quot;)
                                    return null;
                                    
                                var fold = pos.fold;
                                var folds = this.folds;
                                var foldData = this.foldData;
                                
                                var i = folds.indexOf(fold);
                                var foldBefore = folds[i - 1];
                                this.end.row = foldBefore.end.row;
                                this.end.column = foldBefore.end.column;
                                folds = folds.splice(i, folds.length - i);
                        
                                var newFoldLine = new FoldLine(foldData, folds);
                                foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
                                return newFoldLine;
                            };
                        
                            this.merge = function(foldLineNext) {
                                var folds = foldLineNext.folds;
                                for (var i = 0; i &lt; folds.length; i++) {
                                    this.addFold(folds[i]);
                                }
                                var foldData = this.foldData;
                                foldData.splice(foldData.indexOf(foldLineNext), 1);
                            };
                        
                            this.toString = function() {
                                var ret = [this.range.toString() + &quot;: [&quot; ];
                        
                                this.folds.forEach(function(fold) {
                                    ret.push(&quot;  &quot; + fold.toString());
                                });
                                ret.push(&quot;]&quot;);
                                return ret.join(&quot;\n&quot;);
                            };
                        
                            this.idxToPosition = function(idx) {
                                var lastFoldEndColumn = 0;
                        
                                for (var i = 0; i &lt; this.folds.length; i++) {
                                    var fold = this.folds[i];
                        
                                    idx -= fold.start.column - lastFoldEndColumn;
                                    if (idx &lt; 0) {
                                        return {
                                            row: fold.start.row,
                                            column: fold.start.column + idx
                                        };
                                    }
                        
                                    idx -= fold.placeholder.length;
                                    if (idx &lt; 0) {
                                        return fold.start;
                                    }
                        
                                    lastFoldEndColumn = fold.end.column;
                                }
                        
                                return {
                                    row: this.end.row,
                                    column: this.end.column + idx
                                };
                            };
                        }).call(FoldLine.prototype);
                        
                        exports.FoldLine = FoldLine;
                        });
                        
                        define(&quot;ace/range_list&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/range&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        var Range = require(&quot;./range&quot;).Range;
                        var comparePoints = Range.comparePoints;
                        
                        var RangeList = function() {
                            this.ranges = [];
                        };
                        
                        (function() {
                            this.comparePoints = comparePoints;
                        
                            this.pointIndex = function(pos, excludeEdges, startIndex) {
                                var list = this.ranges;
                        
                                for (var i = startIndex || 0; i &lt; list.length; i++) {
                                    var range = list[i];
                                    var cmpEnd = comparePoints(pos, range.end);
                                    if (cmpEnd &gt; 0)
                                        continue;
                                    var cmpStart = comparePoints(pos, range.start);
                                    if (cmpEnd === 0)
                                        return excludeEdges &amp;&amp; cmpStart !== 0 ? -i-2 : i;
                                    if (cmpStart &gt; 0 || (cmpStart === 0 &amp;&amp; !excludeEdges))
                                        return i;
                        
                                    return -i-1;
                                }
                                return -i - 1;
                            };
                        
                            this.add = function(range) {
                                var excludeEdges = !range.isEmpty();
                                var startIndex = this.pointIndex(range.start, excludeEdges);
                                if (startIndex &lt; 0)
                                    startIndex = -startIndex - 1;
                        
                                var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);
                        
                                if (endIndex &lt; 0)
                                    endIndex = -endIndex - 1;
                                else
                                    endIndex++;
                                return this.ranges.splice(startIndex, endIndex - startIndex, range);
                            };
                        
                            this.addList = function(list) {
                                var removed = [];
                                for (var i = list.length; i--; ) {
                                    removed.push.call(removed, this.add(list[i]));
                                }
                                return removed;
                            };
                        
                            this.substractPoint = function(pos) {
                                var i = this.pointIndex(pos);
                        
                                if (i &gt;= 0)
                                    return this.ranges.splice(i, 1);
                            };
                            this.merge = function() {
                                var removed = [];
                                var list = this.ranges;
                                
                                list = list.sort(function(a, b) {
                                    return comparePoints(a.start, b.start);
                                });
                                
                                var next = list[0], range;
                                for (var i = 1; i &lt; list.length; i++) {
                                    range = next;
                                    next = list[i];
                                    var cmp = comparePoints(range.end, next.start);
                                    if (cmp &lt; 0)
                                        continue;
                        
                                    if (cmp == 0 &amp;&amp; !range.isEmpty() &amp;&amp; !next.isEmpty())
                                        continue;
                        
                                    if (comparePoints(range.end, next.end) &lt; 0) {
                                        range.end.row = next.end.row;
                                        range.end.column = next.end.column;
                                    }
                        
                                    list.splice(i, 1);
                                    removed.push(next);
                                    next = range;
                                    i--;
                                }
                                
                                this.ranges = list;
                        
                                return removed;
                            };
                        
                            this.contains = function(row, column) {
                                return this.pointIndex({row: row, column: column}) &gt;= 0;
                            };
                        
                            this.containsPoint = function(pos) {
                                return this.pointIndex(pos) &gt;= 0;
                            };
                        
                            this.rangeAtPoint = function(pos) {
                                var i = this.pointIndex(pos);
                                if (i &gt;= 0)
                                    return this.ranges[i];
                            };
                        
                        
                            this.clipRows = function(startRow, endRow) {
                                var list = this.ranges;
                                if (list[0].start.row &gt; endRow || list[list.length - 1].start.row &lt; startRow)
                                    return [];
                        
                                var startIndex = this.pointIndex({row: startRow, column: 0});
                                if (startIndex &lt; 0)
                                    startIndex = -startIndex - 1;
                                var endIndex = this.pointIndex({row: endRow, column: 0}, startIndex);
                                if (endIndex &lt; 0)
                                    endIndex = -endIndex - 1;
                        
                                var clipped = [];
                                for (var i = startIndex; i &lt; endIndex; i++) {
                                    clipped.push(list[i]);
                                }
                                return clipped;
                            };
                        
                            this.removeAll = function() {
                                return this.ranges.splice(0, this.ranges.length);
                            };
                        
                            this.attach = function(session) {
                                if (this.session)
                                    this.detach();
                        
                                this.session = session;
                                this.onChange = this.$onChange.bind(this);
                        
                                this.session.on(&#x27;change&#x27;, this.onChange);
                            };
                        
                            this.detach = function() {
                                if (!this.session)
                                    return;
                                this.session.removeListener(&#x27;change&#x27;, this.onChange);
                                this.session = null;
                            };
                        
                            this.$onChange = function(e) {
                                var changeRange = e.data.range;
                                if (e.data.action[0] == &quot;i&quot;){
                                    var start = changeRange.start;
                                    var end = changeRange.end;
                                } else {
                                    var end = changeRange.start;
                                    var start = changeRange.end;
                                }
                                var startRow = start.row;
                                var endRow = end.row;
                                var lineDif = endRow - startRow;
                        
                                var colDiff = -start.column + end.column;
                                var ranges = this.ranges;
                        
                                for (var i = 0, n = ranges.length; i &lt; n; i++) {
                                    var r = ranges[i];
                                    if (r.end.row &lt; startRow)
                                        continue;
                                    if (r.start.row &gt; startRow)
                                        break;
                        
                                    if (r.start.row == startRow &amp;&amp; r.start.column &gt;= start.column ) {
                                        if (r.start.column == start.column &amp;&amp; this.$insertRight) {
                                        } else {
                                            r.start.column += colDiff;
                                            r.start.row += lineDif;
                                        }
                                    }
                                    if (r.end.row == startRow &amp;&amp; r.end.column &gt;= start.column) {
                                        if (r.end.column == start.column &amp;&amp; this.$insertRight) {
                                            continue;
                                        }
                                        if (r.end.column == start.column &amp;&amp; colDiff &gt; 0 &amp;&amp; i &lt; n - 1) {                
                                            if (r.end.column &gt; r.start.column &amp;&amp; r.end.column == ranges[i+1].start.column)
                                                r.end.column -= colDiff;
                                        }
                                        r.end.column += colDiff;
                                        r.end.row += lineDif;
                                    }
                                }
                        
                                if (lineDif != 0 &amp;&amp; i &lt; n) {
                                    for (; i &lt; n; i++) {
                                        var r = ranges[i];
                                        r.start.row += lineDif;
                                        r.end.row += lineDif;
                                    }
                                }
                            };
                        
                        }).call(RangeList.prototype);
                        
                        exports.RangeList = RangeList;
                        });
                        
                        define(&quot;ace/edit_session/fold&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/range&quot;,&quot;ace/range_list&quot;,&quot;ace/lib/oop&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var Range = require(&quot;../range&quot;).Range;
                        var RangeList = require(&quot;../range_list&quot;).RangeList;
                        var oop = require(&quot;../lib/oop&quot;)
                        var Fold = exports.Fold = function(range, placeholder) {
                            this.foldLine = null;
                            this.placeholder = placeholder;
                            this.range = range;
                            this.start = range.start;
                            this.end = range.end;
                        
                            this.sameRow = range.start.row == range.end.row;
                            this.subFolds = this.ranges = [];
                        };
                        
                        oop.inherits(Fold, RangeList);
                        
                        (function() {
                        
                            this.toString = function() {
                                return &#x27;&quot;&#x27; + this.placeholder + &#x27;&quot; &#x27; + this.range.toString();
                            };
                        
                            this.setFoldLine = function(foldLine) {
                                this.foldLine = foldLine;
                                this.subFolds.forEach(function(fold) {
                                    fold.setFoldLine(foldLine);
                                });
                            };
                        
                            this.clone = function() {
                                var range = this.range.clone();
                                var fold = new Fold(range, this.placeholder);
                                this.subFolds.forEach(function(subFold) {
                                    fold.subFolds.push(subFold.clone());
                                });
                                fold.collapseChildren = this.collapseChildren;
                                return fold;
                            };
                        
                            this.addSubFold = function(fold) {
                                if (this.range.isEqual(fold))
                                    return;
                        
                                if (!this.range.containsRange(fold))
                                    throw new Error(&quot;A fold can&#x27;t intersect already existing fold&quot; + fold.range + this.range);
                                consumeRange(fold, this.start);
                        
                                var row = fold.start.row, column = fold.start.column;
                                for (var i = 0, cmp = -1; i &lt; this.subFolds.length; i++) {
                                    cmp = this.subFolds[i].range.compare(row, column);
                                    if (cmp != 1)
                                        break;
                                }
                                var afterStart = this.subFolds[i];
                        
                                if (cmp == 0)
                                    return afterStart.addSubFold(fold);
                                var row = fold.range.end.row, column = fold.range.end.column;
                                for (var j = i, cmp = -1; j &lt; this.subFolds.length; j++) {
                                    cmp = this.subFolds[j].range.compare(row, column);
                                    if (cmp != 1)
                                        break;
                                }
                                var afterEnd = this.subFolds[j];
                        
                                if (cmp == 0)
                                    throw new Error(&quot;A fold can&#x27;t intersect already existing fold&quot; + fold.range + this.range);
                        
                                var consumedFolds = this.subFolds.splice(i, j - i, fold);
                                fold.setFoldLine(this.foldLine);
                        
                                return fold;
                            };
                            
                            this.restoreRange = function(range) {
                                return restoreRange(range, this.start);
                            };
                        
                        }).call(Fold.prototype);
                        
                        function consumePoint(point, anchor) {
                            point.row -= anchor.row;
                            if (point.row == 0)
                                point.column -= anchor.column;
                        }
                        function consumeRange(range, anchor) {
                            consumePoint(range.start, anchor);
                            consumePoint(range.end, anchor);
                        }
                        function restorePoint(point, anchor) {
                            if (point.row == 0)
                                point.column += anchor.column;
                            point.row += anchor.row;
                        }
                        function restoreRange(range, anchor) {
                            restorePoint(range.start, anchor);
                            restorePoint(range.end, anchor);
                        }
                        
                        });
                        
                        define(&quot;ace/edit_session/folding&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/range&quot;,&quot;ace/edit_session/fold_line&quot;,&quot;ace/edit_session/fold&quot;,&quot;ace/token_iterator&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var Range = require(&quot;../range&quot;).Range;
                        var FoldLine = require(&quot;./fold_line&quot;).FoldLine;
                        var Fold = require(&quot;./fold&quot;).Fold;
                        var TokenIterator = require(&quot;../token_iterator&quot;).TokenIterator;
                        
                        function Folding() {
                            this.getFoldAt = function(row, column, side) {
                                var foldLine = this.getFoldLine(row);
                                if (!foldLine)
                                    return null;
                        
                                var folds = foldLine.folds;
                                for (var i = 0; i &lt; folds.length; i++) {
                                    var fold = folds[i];
                                    if (fold.range.contains(row, column)) {
                                        if (side == 1 &amp;&amp; fold.range.isEnd(row, column)) {
                                            continue;
                                        } else if (side == -1 &amp;&amp; fold.range.isStart(row, column)) {
                                            continue;
                                        }
                                        return fold;
                                    }
                                }
                            };
                            this.getFoldsInRange = function(range) {
                                var start = range.start;
                                var end = range.end;
                                var foldLines = this.$foldData;
                                var foundFolds = [];
                        
                                start.column += 1;
                                end.column -= 1;
                        
                                for (var i = 0; i &lt; foldLines.length; i++) {
                                    var cmp = foldLines[i].range.compareRange(range);
                                    if (cmp == 2) {
                                        continue;
                                    }
                                    else if (cmp == -2) {
                                        break;
                                    }
                        
                                    var folds = foldLines[i].folds;
                                    for (var j = 0; j &lt; folds.length; j++) {
                                        var fold = folds[j];
                                        cmp = fold.range.compareRange(range);
                                        if (cmp == -2) {
                                            break;
                                        } else if (cmp == 2) {
                                            continue;
                                        } else
                                        if (cmp == 42) {
                                            break;
                                        }
                                        foundFolds.push(fold);
                                    }
                                }
                                start.column -= 1;
                                end.column += 1;
                        
                                return foundFolds;
                            };
                        
                            this.getFoldsInRangeList = function(ranges) {
                                if (Array.isArray(ranges)) {
                                    var folds = [];
                                    ranges.forEach(function(range) {
                                        folds = folds.concat(this.getFoldsInRange(range));
                                    }, this);
                                } else {
                                    var folds = this.getFoldsInRange(ranges);
                                }
                                return folds;
                            }
                            this.getAllFolds = function() {
                                var folds = [];
                                var foldLines = this.$foldData;
                                
                                for (var i = 0; i &lt; foldLines.length; i++)
                                    for (var j = 0; j &lt; foldLines[i].folds.length; j++)
                                        folds.push(foldLines[i].folds[j]);
                        
                                return folds;
                            };
                            this.getFoldStringAt = function(row, column, trim, foldLine) {
                                foldLine = foldLine || this.getFoldLine(row);
                                if (!foldLine)
                                    return null;
                        
                                var lastFold = {
                                    end: { column: 0 }
                                };
                                var str, fold;
                                for (var i = 0; i &lt; foldLine.folds.length; i++) {
                                    fold = foldLine.folds[i];
                                    var cmp = fold.range.compareEnd(row, column);
                                    if (cmp == -1) {
                                        str = this
                                            .getLine(fold.start.row)
                                            .substring(lastFold.end.column, fold.start.column);
                                        break;
                                    }
                                    else if (cmp === 0) {
                                        return null;
                                    }
                                    lastFold = fold;
                                }
                                if (!str)
                                    str = this.getLine(fold.start.row).substring(lastFold.end.column);
                        
                                if (trim == -1)
                                    return str.substring(0, column - lastFold.end.column);
                                else if (trim == 1)
                                    return str.substring(column - lastFold.end.column);
                                else
                                    return str;
                            };
                        
                            this.getFoldLine = function(docRow, startFoldLine) {
                                var foldData = this.$foldData;
                                var i = 0;
                                if (startFoldLine)
                                    i = foldData.indexOf(startFoldLine);
                                if (i == -1)
                                    i = 0;
                                for (i; i &lt; foldData.length; i++) {
                                    var foldLine = foldData[i];
                                    if (foldLine.start.row &lt;= docRow &amp;&amp; foldLine.end.row &gt;= docRow) {
                                        return foldLine;
                                    } else if (foldLine.end.row &gt; docRow) {
                                        return null;
                                    }
                                }
                                return null;
                            };
                            this.getNextFoldLine = function(docRow, startFoldLine) {
                                var foldData = this.$foldData;
                                var i = 0;
                                if (startFoldLine)
                                    i = foldData.indexOf(startFoldLine);
                                if (i == -1)
                                    i = 0;
                                for (i; i &lt; foldData.length; i++) {
                                    var foldLine = foldData[i];
                                    if (foldLine.end.row &gt;= docRow) {
                                        return foldLine;
                                    }
                                }
                                return null;
                            };
                        
                            this.getFoldedRowCount = function(first, last) {
                                var foldData = this.$foldData, rowCount = last-first+1;
                                for (var i = 0; i &lt; foldData.length; i++) {
                                    var foldLine = foldData[i],
                                        end = foldLine.end.row,
                                        start = foldLine.start.row;
                                    if (end &gt;= last) {
                                        if(start &lt; last) {
                                            if(start &gt;= first)
                                                rowCount -= last-start;
                                            else
                                                rowCount = 0;//in one fold
                                        }
                                        break;
                                    } else if(end &gt;= first){
                                        if (start &gt;= first) //fold inside range
                                            rowCount -=  end-start;
                                        else
                                            rowCount -=  end-first+1;
                                    }
                                }
                                return rowCount;
                            };
                        
                            this.$addFoldLine = function(foldLine) {
                                this.$foldData.push(foldLine);
                                this.$foldData.sort(function(a, b) {
                                    return a.start.row - b.start.row;
                                });
                                return foldLine;
                            };
                            this.addFold = function(placeholder, range) {
                                var foldData = this.$foldData;
                                var added = false;
                                var fold;
                                
                                if (placeholder instanceof Fold)
                                    fold = placeholder;
                                else {
                                    fold = new Fold(range, placeholder);
                                    fold.collapseChildren = range.collapseChildren;
                                }
                                this.$clipRangeToDocument(fold.range);
                        
                                var startRow = fold.start.row;
                                var startColumn = fold.start.column;
                                var endRow = fold.end.row;
                                var endColumn = fold.end.column;
                                if (!(startRow &lt; endRow || 
                                    startRow == endRow &amp;&amp; startColumn &lt;= endColumn - 2))
                                    throw new Error(&quot;The range has to be at least 2 characters width&quot;);
                        
                                var startFold = this.getFoldAt(startRow, startColumn, 1);
                                var endFold = this.getFoldAt(endRow, endColumn, -1);
                                if (startFold &amp;&amp; endFold == startFold)
                                    return startFold.addSubFold(fold);
                        
                                if (startFold &amp;&amp; !startFold.range.isStart(startRow, startColumn))
                                    this.removeFold(startFold);
                                
                                if (endFold &amp;&amp; !endFold.range.isEnd(endRow, endColumn))
                                    this.removeFold(endFold);
                                var folds = this.getFoldsInRange(fold.range);
                                if (folds.length &gt; 0) {
                                    this.removeFolds(folds);
                                    folds.forEach(function(subFold) {
                                        fold.addSubFold(subFold);
                                    });
                                }
                        
                                for (var i = 0; i &lt; foldData.length; i++) {
                                    var foldLine = foldData[i];
                                    if (endRow == foldLine.start.row) {
                                        foldLine.addFold(fold);
                                        added = true;
                                        break;
                                    } else if (startRow == foldLine.end.row) {
                                        foldLine.addFold(fold);
                                        added = true;
                                        if (!fold.sameRow) {
                                            var foldLineNext = foldData[i + 1];
                                            if (foldLineNext &amp;&amp; foldLineNext.start.row == endRow) {
                                                foldLine.merge(foldLineNext);
                                                break;
                                            }
                                        }
                                        break;
                                    } else if (endRow &lt;= foldLine.start.row) {
                                        break;
                                    }
                                }
                        
                                if (!added)
                                    foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));
                        
                                if (this.$useWrapMode)
                                    this.$updateWrapData(foldLine.start.row, foldLine.start.row);
                                else
                                    this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
                                this.$modified = true;
                                this._emit(&quot;changeFold&quot;, { data: fold, action: &quot;add&quot; });
                        
                                return fold;
                            };
                        
                            this.addFolds = function(folds) {
                                folds.forEach(function(fold) {
                                    this.addFold(fold);
                                }, this);
                            };
                        
                            this.removeFold = function(fold) {
                                var foldLine = fold.foldLine;
                                var startRow = foldLine.start.row;
                                var endRow = foldLine.end.row;
                        
                                var foldLines = this.$foldData;
                                var folds = foldLine.folds;
                                if (folds.length == 1) {
                                    foldLines.splice(foldLines.indexOf(foldLine), 1);
                                } else
                                if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
                                    folds.pop();
                                    foldLine.end.row = folds[folds.length - 1].end.row;
                                    foldLine.end.column = folds[folds.length - 1].end.column;
                                } else
                                if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
                                    folds.shift();
                                    foldLine.start.row = folds[0].start.row;
                                    foldLine.start.column = folds[0].start.column;
                                } else
                                if (fold.sameRow) {
                                    folds.splice(folds.indexOf(fold), 1);
                                } else
                                {
                                    var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
                                    folds = newFoldLine.folds;
                                    folds.shift();
                                    newFoldLine.start.row = folds[0].start.row;
                                    newFoldLine.start.column = folds[0].start.column;
                                }
                        
                                if (!this.$updating) {
                                    if (this.$useWrapMode)
                                        this.$updateWrapData(startRow, endRow);
                                    else
                                        this.$updateRowLengthCache(startRow, endRow);
                                }
                                this.$modified = true;
                                this._emit(&quot;changeFold&quot;, { data: fold, action: &quot;remove&quot; });
                            };
                        
                            this.removeFolds = function(folds) {
                                var cloneFolds = [];
                                for (var i = 0; i &lt; folds.length; i++) {
                                    cloneFolds.push(folds[i]);
                                }
                        
                                cloneFolds.forEach(function(fold) {
                                    this.removeFold(fold);
                                }, this);
                                this.$modified = true;
                            };
                        
                            this.expandFold = function(fold) {
                                this.removeFold(fold);
                                fold.subFolds.forEach(function(subFold) {
                                    fold.restoreRange(subFold);
                                    this.addFold(subFold);
                                }, this);
                                if (fold.collapseChildren &gt; 0) {
                                    this.foldAll(fold.start.row+1, fold.end.row, fold.collapseChildren-1);
                                }
                                fold.subFolds = [];
                            };
                        
                            this.expandFolds = function(folds) {
                                folds.forEach(function(fold) {
                                    this.expandFold(fold);
                                }, this);
                            };
                        
                            this.unfold = function(location, expandInner) {
                                var range, folds;
                                if (location == null) {
                                    range = new Range(0, 0, this.getLength(), 0);
                                    expandInner = true;
                                } else if (typeof location == &quot;number&quot;)
                                    range = new Range(location, 0, location, this.getLine(location).length);
                                else if (&quot;row&quot; in location)
                                    range = Range.fromPoints(location, location);
                                else
                                    range = location;
                                
                                folds = this.getFoldsInRangeList(range);
                                if (expandInner) {
                                    this.removeFolds(folds);
                                } else {
                                    var subFolds = folds;
                                    while (subFolds.length) {
                                        this.expandFolds(subFolds);
                                        subFolds = this.getFoldsInRangeList(range);
                                    }
                                }
                                if (folds.length)
                                    return folds;
                            };
                            this.isRowFolded = function(docRow, startFoldRow) {
                                return !!this.getFoldLine(docRow, startFoldRow);
                            };
                        
                            this.getRowFoldEnd = function(docRow, startFoldRow) {
                                var foldLine = this.getFoldLine(docRow, startFoldRow);
                                return foldLine ? foldLine.end.row : docRow;
                            };
                        
                            this.getRowFoldStart = function(docRow, startFoldRow) {
                                var foldLine = this.getFoldLine(docRow, startFoldRow);
                                return foldLine ? foldLine.start.row : docRow;
                            };
                        
                            this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
                                if (startRow == null)
                                    startRow = foldLine.start.row;
                                if (startColumn == null)
                                    startColumn = 0;
                                if (endRow == null)
                                    endRow = foldLine.end.row;
                                if (endColumn == null)
                                    endColumn = this.getLine(endRow).length;
                                var doc = this.doc;
                                var textLine = &quot;&quot;;
                        
                                foldLine.walk(function(placeholder, row, column, lastColumn) {
                                    if (row &lt; startRow)
                                        return;
                                    if (row == startRow) {
                                        if (column &lt; startColumn)
                                            return;
                                        lastColumn = Math.max(startColumn, lastColumn);
                                    }
                        
                                    if (placeholder != null) {
                                        textLine += placeholder;
                                    } else {
                                        textLine += doc.getLine(row).substring(lastColumn, column);
                                    }
                                }, endRow, endColumn);
                                return textLine;
                            };
                        
                            this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
                                var foldLine = this.getFoldLine(row);
                        
                                if (!foldLine) {
                                    var line;
                                    line = this.doc.getLine(row);
                                    return line.substring(startColumn || 0, endColumn || line.length);
                                } else {
                                    return this.getFoldDisplayLine(
                                        foldLine, row, endColumn, startRow, startColumn);
                                }
                            };
                        
                            this.$cloneFoldData = function() {
                                var fd = [];
                                fd = this.$foldData.map(function(foldLine) {
                                    var folds = foldLine.folds.map(function(fold) {
                                        return fold.clone();
                                    });
                                    return new FoldLine(fd, folds);
                                });
                        
                                return fd;
                            };
                        
                            this.toggleFold = function(tryToUnfold) {
                                var selection = this.selection;
                                var range = selection.getRange();
                                var fold;
                                var bracketPos;
                        
                                if (range.isEmpty()) {
                                    var cursor = range.start;
                                    fold = this.getFoldAt(cursor.row, cursor.column);
                        
                                    if (fold) {
                                        this.expandFold(fold);
                                        return;
                                    } else if (bracketPos = this.findMatchingBracket(cursor)) {
                                        if (range.comparePoint(bracketPos) == 1) {
                                            range.end = bracketPos;
                                        } else {
                                            range.start = bracketPos;
                                            range.start.column++;
                                            range.end.column--;
                                        }
                                    } else if (bracketPos = this.findMatchingBracket({row: cursor.row, column: cursor.column + 1})) {
                                        if (range.comparePoint(bracketPos) == 1)
                                            range.end = bracketPos;
                                        else
                                            range.start = bracketPos;
                        
                                        range.start.column++;
                                    } else {
                                        range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
                                    }
                                } else {
                                    var folds = this.getFoldsInRange(range);
                                    if (tryToUnfold &amp;&amp; folds.length) {
                                        this.expandFolds(folds);
                                        return;
                                    } else if (folds.length == 1 ) {
                                        fold = folds[0];
                                    }
                                }
                        
                                if (!fold)
                                    fold = this.getFoldAt(range.start.row, range.start.column);
                        
                                if (fold &amp;&amp; fold.range.toString() == range.toString()) {
                                    this.expandFold(fold);
                                    return;
                                }
                        
                                var placeholder = &quot;...&quot;;
                                if (!range.isMultiLine()) {
                                    placeholder = this.getTextRange(range);
                                    if(placeholder.length &lt; 4)
                                        return;
                                    placeholder = placeholder.trim().substring(0, 2) + &quot;..&quot;;
                                }
                        
                                this.addFold(placeholder, range);
                            };
                        
                            this.getCommentFoldRange = function(row, column, dir) {
                                var iterator = new TokenIterator(this, row, column);
                                var token = iterator.getCurrentToken();
                                if (token &amp;&amp; /^comment|string/.test(token.type)) {
                                    var range = new Range();
                                    var re = new RegExp(token.type.replace(/\..*/, &quot;\\.&quot;));
                                    if (dir != 1) {
                                        do {
                                            token = iterator.stepBackward();
                                        } while(token &amp;&amp; re.test(token.type));
                                        iterator.stepForward();
                                    }
                                    
                                    range.start.row = iterator.getCurrentTokenRow();
                                    range.start.column = iterator.getCurrentTokenColumn() + 2;
                        
                                    iterator = new TokenIterator(this, row, column);
                                    
                                    if (dir != -1) {
                                        do {
                                            token = iterator.stepForward();
                                        } while(token &amp;&amp; re.test(token.type));
                                        token = iterator.stepBackward();
                                    } else
                                        token = iterator.getCurrentToken();
                        
                                    range.end.row = iterator.getCurrentTokenRow();
                                    range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
                                    return range;
                                }
                            };
                        
                            this.foldAll = function(startRow, endRow, depth) {
                                if (depth == undefined)
                                    depth = 100000; // JSON.stringify doesn&#x27;t hanle Infinity
                                var foldWidgets = this.foldWidgets;
                                if (!foldWidgets)
                                    return; // mode doesn&#x27;t support folding
                                endRow = endRow || this.getLength();
                                startRow = startRow || 0;
                                for (var row = startRow; row &lt; endRow; row++) {
                                    if (foldWidgets[row] == null)
                                        foldWidgets[row] = this.getFoldWidget(row);
                                    if (foldWidgets[row] != &quot;start&quot;)
                                        continue;
                        
                                    var range = this.getFoldWidgetRange(row);
                                    if (range &amp;&amp; range.isMultiLine()
                                        &amp;&amp; range.end.row &lt;= endRow
                                        &amp;&amp; range.start.row &gt;= startRow
                                    ) {
                                        row = range.end.row;
                                        try {
                                            var fold = this.addFold(&quot;...&quot;, range);
                                            if (fold)
                                                fold.collapseChildren = depth;
                                        } catch(e) {}
                                    }
                                }
                            };
                            this.$foldStyles = {
                                &quot;manual&quot;: 1,
                                &quot;markbegin&quot;: 1,
                                &quot;markbeginend&quot;: 1
                            };
                            this.$foldStyle = &quot;markbegin&quot;;
                            this.setFoldStyle = function(style) {
                                if (!this.$foldStyles[style])
                                    throw new Error(&quot;invalid fold style: &quot; + style + &quot;[&quot; + Object.keys(this.$foldStyles).join(&quot;, &quot;) + &quot;]&quot;);
                                
                                if (this.$foldStyle == style)
                                    return;
                        
                                this.$foldStyle = style;
                                
                                if (style == &quot;manual&quot;)
                                    this.unfold();
                                var mode = this.$foldMode;
                                this.$setFolding(null);
                                this.$setFolding(mode);
                            };
                        
                            this.$setFolding = function(foldMode) {
                                if (this.$foldMode == foldMode)
                                    return;
                                    
                                this.$foldMode = foldMode;
                                
                                this.off(&#x27;change&#x27;, this.$updateFoldWidgets);
                                this.off(&#x27;tokenizerUpdate&#x27;, this.$tokenizerUpdateFoldWidgets);
                                this._emit(&quot;changeAnnotation&quot;);
                                
                                if (!foldMode || this.$foldStyle == &quot;manual&quot;) {
                                    this.foldWidgets = null;
                                    return;
                                }
                                
                                this.foldWidgets = [];
                                this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
                                this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
                                
                                this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
                                this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
                                this.on(&#x27;change&#x27;, this.$updateFoldWidgets);
                                this.on(&#x27;tokenizerUpdate&#x27;, this.$tokenizerUpdateFoldWidgets);
                            };
                        
                            this.getParentFoldRangeData = function (row, ignoreCurrent) {
                                var fw = this.foldWidgets;
                                if (!fw || (ignoreCurrent &amp;&amp; fw[row]))
                                    return {};
                        
                                var i = row - 1, firstRange;
                                while (i &gt;= 0) {
                                    var c = fw[i];
                                    if (c == null)
                                        c = fw[i] = this.getFoldWidget(i);
                        
                                    if (c == &quot;start&quot;) {
                                        var range = this.getFoldWidgetRange(i);
                                        if (!firstRange)
                                            firstRange = range;
                                        if (range &amp;&amp; range.end.row &gt;= row)
                                            break;
                                    }
                                    i--;
                                }
                        
                                return {
                                    range: i !== -1 &amp;&amp; range,
                                    firstRange: firstRange
                                };
                            }
                        
                            this.onFoldWidgetClick = function(row, e) {
                                e = e.domEvent;
                                var options = {
                                    children: e.shiftKey,
                                    all: e.ctrlKey || e.metaKey,
                                    siblings: e.altKey
                                };
                                
                                var range = this.$toggleFoldWidget(row, options);
                                if (!range) {
                                    var el = (e.target || e.srcElement)
                                    if (el &amp;&amp; /ace_fold-widget/.test(el.className))
                                        el.className += &quot; ace_invalid&quot;;
                                }
                            };
                            
                            this.$toggleFoldWidget = function(row, options) {
                                if (!this.getFoldWidget)
                                    return;
                                var type = this.getFoldWidget(row);
                                var line = this.getLine(row);
                        
                                var dir = type === &quot;end&quot; ? -1 : 1;
                                var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);
                        
                                if (fold) {
                                    if (options.children || options.all)
                                        this.removeFold(fold);
                                    else
                                        this.expandFold(fold);
                                    return;
                                }
                        
                                var range = this.getFoldWidgetRange(row, true);
                                if (range &amp;&amp; !range.isMultiLine()) {
                                    fold = this.getFoldAt(range.start.row, range.start.column, 1);
                                    if (fold &amp;&amp; range.isEqual(fold.range)) {
                                        this.removeFold(fold);
                                        return;
                                    }
                                }
                                
                                if (options.siblings) {
                                    var data = this.getParentFoldRangeData(row);
                                    if (data.range) {
                                        var startRow = data.range.start.row + 1;
                                        var endRow = data.range.end.row;
                                    }
                                    this.foldAll(startRow, endRow, options.all ? 10000 : 0);
                                } else if (options.children) {
                                    endRow = range ? range.end.row : this.getLength();
                                    this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
                                } else if (range) {
                                    if (options.all) 
                                        range.collapseChildren = 10000;
                                    this.addFold(&quot;...&quot;, range);
                                }
                                
                                return range;
                            };
                            
                            
                            
                            this.toggleFoldWidget = function(toggleParent) {
                                var row = this.selection.getCursor().row;
                                row = this.getRowFoldStart(row);
                                var range = this.$toggleFoldWidget(row, {});
                                
                                if (range)
                                    return;
                                var data = this.getParentFoldRangeData(row, true);
                                range = data.range || data.firstRange;
                                
                                if (range) {
                                    row = range.start.row;
                                    var fold = this.getFoldAt(row, this.getLine(row).length, 1);
                        
                                    if (fold) {
                                        this.removeFold(fold);
                                    } else {
                                        this.addFold(&quot;...&quot;, range);
                                    }
                                }
                            };
                        
                            this.updateFoldWidgets = function(e) {
                                var delta = e.data;
                                var range = delta.range;
                                var firstRow = range.start.row;
                                var len = range.end.row - firstRow;
                        
                                if (len === 0) {
                                    this.foldWidgets[firstRow] = null;
                                } else if (delta.action == &quot;removeText&quot; || delta.action == &quot;removeLines&quot;) {
                                    this.foldWidgets.splice(firstRow, len + 1, null);
                                } else {
                                    var args = Array(len + 1);
                                    args.unshift(firstRow, 1);
                                    this.foldWidgets.splice.apply(this.foldWidgets, args);
                                }
                            };
                            this.tokenizerUpdateFoldWidgets = function(e) {
                                var rows = e.data;
                                if (rows.first != rows.last) {
                                    if (this.foldWidgets.length &gt; rows.first)
                                        this.foldWidgets.splice(rows.first, this.foldWidgets.length);
                                }
                            }
                        }
                        
                        exports.Folding = Folding;
                        
                        });
                        
                        define(&quot;ace/edit_session/bracket_match&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/token_iterator&quot;,&quot;ace/range&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var TokenIterator = require(&quot;../token_iterator&quot;).TokenIterator;
                        var Range = require(&quot;../range&quot;).Range;
                        
                        
                        function BracketMatch() {
                        
                            this.findMatchingBracket = function(position, chr) {
                                if (position.column == 0) return null;
                        
                                var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column-1);
                                if (charBeforeCursor == &quot;&quot;) return null;
                        
                                var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
                                if (!match)
                                    return null;
                        
                                if (match[1])
                                    return this.$findClosingBracket(match[1], position);
                                else
                                    return this.$findOpeningBracket(match[2], position);
                            };
                            
                            this.getBracketRange = function(pos) {
                                var line = this.getLine(pos.row);
                                var before = true, range;
                        
                                var chr = line.charAt(pos.column-1);
                                var match = chr &amp;&amp; chr.match(/([\(\[\{])|([\)\]\}])/);
                                if (!match) {
                                    chr = line.charAt(pos.column);
                                    pos = {row: pos.row, column: pos.column + 1};
                                    match = chr &amp;&amp; chr.match(/([\(\[\{])|([\)\]\}])/);
                                    before = false;
                                }
                                if (!match)
                                    return null;
                        
                                if (match[1]) {
                                    var bracketPos = this.$findClosingBracket(match[1], pos);
                                    if (!bracketPos)
                                        return null;
                                    range = Range.fromPoints(pos, bracketPos);
                                    if (!before) {
                                        range.end.column++;
                                        range.start.column--;
                                    }
                                    range.cursor = range.end;
                                } else {
                                    var bracketPos = this.$findOpeningBracket(match[2], pos);
                                    if (!bracketPos)
                                        return null;
                                    range = Range.fromPoints(bracketPos, pos);
                                    if (!before) {
                                        range.start.column++;
                                        range.end.column--;
                                    }
                                    range.cursor = range.start;
                                }
                                
                                return range;
                            };
                        
                            this.$brackets = {
                                &quot;)&quot;: &quot;(&quot;,
                                &quot;(&quot;: &quot;)&quot;,
                                &quot;]&quot;: &quot;[&quot;,
                                &quot;[&quot;: &quot;]&quot;,
                                &quot;{&quot;: &quot;}&quot;,
                                &quot;}&quot;: &quot;{&quot;
                            };
                        
                            this.$findOpeningBracket = function(bracket, position, typeRe) {
                                var openBracket = this.$brackets[bracket];
                                var depth = 1;
                        
                                var iterator = new TokenIterator(this, position.row, position.column);
                                var token = iterator.getCurrentToken();
                                if (!token)
                                    token = iterator.stepForward();
                                if (!token)
                                    return;
                                
                                 if (!typeRe){
                                    typeRe = new RegExp(
                                        &quot;(\\.?&quot; +
                                        token.type.replace(&quot;.&quot;, &quot;\\.&quot;).replace(&quot;rparen&quot;, &quot;.paren&quot;)
                                            .replace(/\b(?:end)\b/, &quot;(?:start|begin|end)&quot;)
                                        + &quot;)+&quot;
                                    );
                                }
                                var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
                                var value = token.value;
                                
                                while (true) {
                                
                                    while (valueIndex &gt;= 0) {
                                        var chr = value.charAt(valueIndex);
                                        if (chr == openBracket) {
                                            depth -= 1;
                                            if (depth == 0) {
                                                return {row: iterator.getCurrentTokenRow(),
                                                    column: valueIndex + iterator.getCurrentTokenColumn()};
                                            }
                                        }
                                        else if (chr == bracket) {
                                            depth += 1;
                                        }
                                        valueIndex -= 1;
                                    }
                                    do {
                                        token = iterator.stepBackward();
                                    } while (token &amp;&amp; !typeRe.test(token.type));
                        
                                    if (token == null)
                                        break;
                                        
                                    value = token.value;
                                    valueIndex = value.length - 1;
                                }
                                
                                return null;
                            };
                        
                            this.$findClosingBracket = function(bracket, position, typeRe) {
                                var closingBracket = this.$brackets[bracket];
                                var depth = 1;
                        
                                var iterator = new TokenIterator(this, position.row, position.column);
                                var token = iterator.getCurrentToken();
                                if (!token)
                                    token = iterator.stepForward();
                                if (!token)
                                    return;
                        
                                if (!typeRe){
                                    typeRe = new RegExp(
                                        &quot;(\\.?&quot; +
                                        token.type.replace(&quot;.&quot;, &quot;\\.&quot;).replace(&quot;lparen&quot;, &quot;.paren&quot;)
                                            .replace(/\b(?:start|begin)\b/, &quot;(?:start|begin|end)&quot;)
                                        + &quot;)+&quot;
                                    );
                                }
                                var valueIndex = position.column - iterator.getCurrentTokenColumn();
                        
                                while (true) {
                        
                                    var value = token.value;
                                    var valueLength = value.length;
                                    while (valueIndex &lt; valueLength) {
                                        var chr = value.charAt(valueIndex);
                                        if (chr == closingBracket) {
                                            depth -= 1;
                                            if (depth == 0) {
                                                return {row: iterator.getCurrentTokenRow(),
                                                    column: valueIndex + iterator.getCurrentTokenColumn()};
                                            }
                                        }
                                        else if (chr == bracket) {
                                            depth += 1;
                                        }
                                        valueIndex += 1;
                                    }
                                    do {
                                        token = iterator.stepForward();
                                    } while (token &amp;&amp; !typeRe.test(token.type));
                        
                                    if (token == null)
                                        break;
                        
                                    valueIndex = 0;
                                }
                                
                                return null;
                            };
                        }
                        exports.BracketMatch = BracketMatch;
                        
                        });
                        
                        define(&quot;ace/edit_session&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/lang&quot;,&quot;ace/config&quot;,&quot;ace/lib/event_emitter&quot;,&quot;ace/selection&quot;,&quot;ace/mode/text&quot;,&quot;ace/range&quot;,&quot;ace/document&quot;,&quot;ace/background_tokenizer&quot;,&quot;ace/search_highlight&quot;,&quot;ace/edit_session/folding&quot;,&quot;ace/edit_session/bracket_match&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var oop = require(&quot;./lib/oop&quot;);
                        var lang = require(&quot;./lib/lang&quot;);
                        var config = require(&quot;./config&quot;);
                        var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
                        var Selection = require(&quot;./selection&quot;).Selection;
                        var TextMode = require(&quot;./mode/text&quot;).Mode;
                        var Range = require(&quot;./range&quot;).Range;
                        var Document = require(&quot;./document&quot;).Document;
                        var BackgroundTokenizer = require(&quot;./background_tokenizer&quot;).BackgroundTokenizer;
                        var SearchHighlight = require(&quot;./search_highlight&quot;).SearchHighlight;
                        
                        var EditSession = function(text, mode) {
                            this.$breakpoints = [];
                            this.$decorations = [];
                            this.$frontMarkers = {};
                            this.$backMarkers = {};
                            this.$markerId = 1;
                            this.$undoSelect = true;
                        
                            this.$foldData = [];
                            this.$foldData.toString = function() {
                                return this.join(&quot;\n&quot;);
                            }
                            this.on(&quot;changeFold&quot;, this.onChangeFold.bind(this));
                            this.$onChange = this.onChange.bind(this);
                        
                            if (typeof text != &quot;object&quot; || !text.getLine)
                                text = new Document(text);
                        
                            this.setDocument(text);
                            this.selection = new Selection(this);
                        
                            config.resetOptions(this);
                            this.setMode(mode);
                            config._signal(&quot;session&quot;, this);
                        };
                        
                        
                        (function() {
                        
                            oop.implement(this, EventEmitter);
                            this.setDocument = function(doc) {
                                if (this.doc)
                                    this.doc.removeListener(&quot;change&quot;, this.$onChange);
                        
                                this.doc = doc;
                                doc.on(&quot;change&quot;, this.$onChange);
                        
                                if (this.bgTokenizer)
                                    this.bgTokenizer.setDocument(this.getDocument());
                        
                                this.resetCaches();
                            };
                            this.getDocument = function() {
                                return this.doc;
                            };
                            this.$resetRowCache = function(docRow) {
                                if (!docRow) {
                                    this.$docRowCache = [];
                                    this.$screenRowCache = [];
                                    return;
                                }
                                var l = this.$docRowCache.length;
                                var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
                                if (l &gt; i) {
                                    this.$docRowCache.splice(i, l);
                                    this.$screenRowCache.splice(i, l);
                                }
                            };
                        
                            this.$getRowCacheIndex = function(cacheArray, val) {
                                var low = 0;
                                var hi = cacheArray.length - 1;
                        
                                while (low &lt;= hi) {
                                    var mid = (low + hi) &gt;&gt; 1;
                                    var c = cacheArray[mid];
                        
                                    if (val &gt; c)
                                        low = mid + 1;
                                    else if (val &lt; c)
                                        hi = mid - 1;
                                    else
                                        return mid;
                                }
                        
                                return low -1;
                            };
                        
                            this.resetCaches = function() {
                                this.$modified = true;
                                this.$wrapData = [];
                                this.$rowLengthCache = [];
                                this.$resetRowCache(0);
                                if (this.bgTokenizer)
                                    this.bgTokenizer.start(0);
                            };
                        
                            this.onChangeFold = function(e) {
                                var fold = e.data;
                                this.$resetRowCache(fold.start.row);
                            };
                        
                            this.onChange = function(e) {
                                var delta = e.data;
                                this.$modified = true;
                        
                                this.$resetRowCache(delta.range.start.row);
                        
                                var removedFolds = this.$updateInternalDataOnChange(e);
                                if (!this.$fromUndo &amp;&amp; this.$undoManager &amp;&amp; !delta.ignore) {
                                    this.$deltasDoc.push(delta);
                                    if (removedFolds &amp;&amp; removedFolds.length != 0) {
                                        this.$deltasFold.push({
                                            action: &quot;removeFolds&quot;,
                                            folds:  removedFolds
                                        });
                                    }
                        
                                    this.$informUndoManager.schedule();
                                }
                        
                                this.bgTokenizer &amp;&amp; this.bgTokenizer.$updateOnChange(delta);
                                this._signal(&quot;change&quot;, e);
                            };
                            this.setValue = function(text) {
                                this.doc.setValue(text);
                                this.selection.moveTo(0, 0);
                        
                                this.$resetRowCache(0);
                                this.$deltas = [];
                                this.$deltasDoc = [];
                                this.$deltasFold = [];
                                this.setUndoManager(this.$undoManager);
                                this.getUndoManager().reset();
                            };
                            this.getValue =
                            this.toString = function() {
                                return this.doc.getValue();
                            };
                            this.getSelection = function() {
                                return this.selection;
                            };
                            this.getState = function(row) {
                                return this.bgTokenizer.getState(row);
                            };
                            this.getTokens = function(row) {
                                return this.bgTokenizer.getTokens(row);
                            };
                            this.getTokenAt = function(row, column) {
                                var tokens = this.bgTokenizer.getTokens(row);
                                var token, c = 0;
                                if (column == null) {
                                    i = tokens.length - 1;
                                    c = this.getLine(row).length;
                                } else {
                                    for (var i = 0; i &lt; tokens.length; i++) {
                                        c += tokens[i].value.length;
                                        if (c &gt;= column)
                                            break;
                                    }
                                }
                                token = tokens[i];
                                if (!token)
                                    return null;
                                token.index = i;
                                token.start = c - token.value.length;
                                return token;
                            };
                            this.setUndoManager = function(undoManager) {
                                this.$undoManager = undoManager;
                                this.$deltas = [];
                                this.$deltasDoc = [];
                                this.$deltasFold = [];
                        
                                if (this.$informUndoManager)
                                    this.$informUndoManager.cancel();
                        
                                if (undoManager) {
                                    var self = this;
                        
                                    this.$syncInformUndoManager = function() {
                                        self.$informUndoManager.cancel();
                        
                                        if (self.$deltasFold.length) {
                                            self.$deltas.push({
                                                group: &quot;fold&quot;,
                                                deltas: self.$deltasFold
                                            });
                                            self.$deltasFold = [];
                                        }
                        
                                        if (self.$deltasDoc.length) {
                                            self.$deltas.push({
                                                group: &quot;doc&quot;,
                                                deltas: self.$deltasDoc
                                            });
                                            self.$deltasDoc = [];
                                        }
                        
                                        if (self.$deltas.length &gt; 0) {
                                            undoManager.execute({
                                                action: &quot;aceupdate&quot;,
                                                args: [self.$deltas, self],
                                                merge: self.mergeUndoDeltas
                                            });
                                        }
                                        self.mergeUndoDeltas = false;
                                        self.$deltas = [];
                                    };
                                    this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
                                }
                            };
                            this.markUndoGroup = function() {
                                if (this.$syncInformUndoManager)
                                    this.$syncInformUndoManager();
                            };
                            
                            this.$defaultUndoManager = {
                                undo: function() {},
                                redo: function() {},
                                reset: function() {}
                            };
                            this.getUndoManager = function() {
                                return this.$undoManager || this.$defaultUndoManager;
                            };
                            this.getTabString = function() {
                                if (this.getUseSoftTabs()) {
                                    return lang.stringRepeat(&quot; &quot;, this.getTabSize());
                                } else {
                                    return &quot;\t&quot;;
                                }
                            };
                            this.setUseSoftTabs = function(val) {
                                this.setOption(&quot;useSoftTabs&quot;, val);
                            };
                            this.getUseSoftTabs = function() {
                                return this.$useSoftTabs &amp;&amp; !this.$mode.$indentWithTabs;
                            };
                            this.setTabSize = function(tabSize) {
                                this.setOption(&quot;tabSize&quot;, tabSize);
                            };
                            this.getTabSize = function() {
                                return this.$tabSize;
                            };
                            this.isTabStop = function(position) {
                                return this.$useSoftTabs &amp;&amp; (position.column % this.$tabSize === 0);
                            };
                        
                            this.$overwrite = false;
                            this.setOverwrite = function(overwrite) {
                                this.setOption(&quot;overwrite&quot;, overwrite);
                            };
                            this.getOverwrite = function() {
                                return this.$overwrite;
                            };
                            this.toggleOverwrite = function() {
                                this.setOverwrite(!this.$overwrite);
                            };
                            this.addGutterDecoration = function(row, className) {
                                if (!this.$decorations[row])
                                    this.$decorations[row] = &quot;&quot;;
                                this.$decorations[row] += &quot; &quot; + className;
                                this._signal(&quot;changeBreakpoint&quot;, {});
                            };
                            this.removeGutterDecoration = function(row, className) {
                                this.$decorations[row] = (this.$decorations[row] || &quot;&quot;).replace(&quot; &quot; + className, &quot;&quot;);
                                this._signal(&quot;changeBreakpoint&quot;, {});
                            };
                            this.getBreakpoints = function() {
                                return this.$breakpoints;
                            };
                            this.setBreakpoints = function(rows) {
                                this.$breakpoints = [];
                                for (var i=0; i&lt;rows.length; i++) {
                                    this.$breakpoints[rows[i]] = &quot;ace_breakpoint&quot;;
                                }
                                this._signal(&quot;changeBreakpoint&quot;, {});
                            };
                            this.clearBreakpoints = function() {
                                this.$breakpoints = [];
                                this._signal(&quot;changeBreakpoint&quot;, {});
                            };
                            this.setBreakpoint = function(row, className) {
                                if (className === undefined)
                                    className = &quot;ace_breakpoint&quot;;
                                if (className)
                                    this.$breakpoints[row] = className;
                                else
                                    delete this.$breakpoints[row];
                                this._signal(&quot;changeBreakpoint&quot;, {});
                            };
                            this.clearBreakpoint = function(row) {
                                delete this.$breakpoints[row];
                                this._signal(&quot;changeBreakpoint&quot;, {});
                            };
                            this.addMarker = function(range, clazz, type, inFront) {
                                var id = this.$markerId++;
                        
                                var marker = {
                                    range : range,
                                    type : type || &quot;line&quot;,
                                    renderer: typeof type == &quot;function&quot; ? type : null,
                                    clazz : clazz,
                                    inFront: !!inFront,
                                    id: id
                                };
                        
                                if (inFront) {
                                    this.$frontMarkers[id] = marker;
                                    this._signal(&quot;changeFrontMarker&quot;);
                                } else {
                                    this.$backMarkers[id] = marker;
                                    this._signal(&quot;changeBackMarker&quot;);
                                }
                        
                                return id;
                            };
                            this.addDynamicMarker = function(marker, inFront) {
                                if (!marker.update)
                                    return;
                                var id = this.$markerId++;
                                marker.id = id;
                                marker.inFront = !!inFront;
                        
                                if (inFront) {
                                    this.$frontMarkers[id] = marker;
                                    this._signal(&quot;changeFrontMarker&quot;);
                                } else {
                                    this.$backMarkers[id] = marker;
                                    this._signal(&quot;changeBackMarker&quot;);
                                }
                        
                                return marker;
                            };
                            this.removeMarker = function(markerId) {
                                var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
                                if (!marker)
                                    return;
                        
                                var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
                                if (marker) {
                                    delete (markers[markerId]);
                                    this._signal(marker.inFront ? &quot;changeFrontMarker&quot; : &quot;changeBackMarker&quot;);
                                }
                            };
                            this.getMarkers = function(inFront) {
                                return inFront ? this.$frontMarkers : this.$backMarkers;
                            };
                        
                            this.highlight = function(re) {
                                if (!this.$searchHighlight) {
                                    var highlight = new SearchHighlight(null, &quot;ace_selected-word&quot;, &quot;text&quot;);
                                    this.$searchHighlight = this.addDynamicMarker(highlight);
                                }
                                this.$searchHighlight.setRegexp(re);
                            };
                            this.highlightLines = function(startRow, endRow, clazz, inFront) {
                                if (typeof endRow != &quot;number&quot;) {
                                    clazz = endRow;
                                    endRow = startRow;
                                }
                                if (!clazz)
                                    clazz = &quot;ace_step&quot;;
                        
                                var range = new Range(startRow, 0, endRow, Infinity);
                                range.id = this.addMarker(range, clazz, &quot;fullLine&quot;, inFront);
                                return range;
                            };
                            this.setAnnotations = function(annotations) {
                                this.$annotations = annotations;
                                this._signal(&quot;changeAnnotation&quot;, {});
                            };
                            this.getAnnotations = function() {
                                return this.$annotations || [];
                            };
                            this.clearAnnotations = function() {
                                this.setAnnotations([]);
                            };
                            this.$detectNewLine = function(text) {
                                var match = text.match(/^.*?(\r?\n)/m);
                                if (match) {
                                    this.$autoNewLine = match[1];
                                } else {
                                    this.$autoNewLine = &quot;\n&quot;;
                                }
                            };
                            this.getWordRange = function(row, column) {
                                var line = this.getLine(row);
                        
                                var inToken = false;
                                if (column &gt; 0)
                                    inToken = !!line.charAt(column - 1).match(this.tokenRe);
                        
                                if (!inToken)
                                    inToken = !!line.charAt(column).match(this.tokenRe);
                        
                                if (inToken)
                                    var re = this.tokenRe;
                                else if (/^\s+$/.test(line.slice(column-1, column+1)))
                                    var re = /\s/;
                                else
                                    var re = this.nonTokenRe;
                        
                                var start = column;
                                if (start &gt; 0) {
                                    do {
                                        start--;
                                    }
                                    while (start &gt;= 0 &amp;&amp; line.charAt(start).match(re));
                                    start++;
                                }
                        
                                var end = column;
                                while (end &lt; line.length &amp;&amp; line.charAt(end).match(re)) {
                                    end++;
                                }
                        
                                return new Range(row, start, row, end);
                            };
                            this.getAWordRange = function(row, column) {
                                var wordRange = this.getWordRange(row, column);
                                var line = this.getLine(wordRange.end.row);
                        
                                while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
                                    wordRange.end.column += 1;
                                }
                                return wordRange;
                            };
                            this.setNewLineMode = function(newLineMode) {
                                this.doc.setNewLineMode(newLineMode);
                            };
                            this.getNewLineMode = function() {
                                return this.doc.getNewLineMode();
                            };
                            this.setUseWorker = function(useWorker) { this.setOption(&quot;useWorker&quot;, useWorker); };
                            this.getUseWorker = function() { return this.$useWorker; };
                            this.onReloadTokenizer = function(e) {
                                var rows = e.data;
                                this.bgTokenizer.start(rows.first);
                                this._signal(&quot;tokenizerUpdate&quot;, e);
                            };
                        
                            this.$modes = {};
                            this.$mode = null;
                            this.$modeId = null;
                            this.setMode = function(mode, cb) {
                                if (mode &amp;&amp; typeof mode === &quot;object&quot;) {
                                    if (mode.getTokenizer)
                                        return this.$onChangeMode(mode);
                                    var options = mode;
                                    var path = options.path;
                                } else {
                                    path = mode || &quot;ace/mode/text&quot;;
                                }
                                if (!this.$modes[&quot;ace/mode/text&quot;])
                                    this.$modes[&quot;ace/mode/text&quot;] = new TextMode();
                        
                                if (this.$modes[path] &amp;&amp; !options) {
                                    this.$onChangeMode(this.$modes[path]);
                                    cb &amp;&amp; cb();
                                    return;
                                }
                                this.$modeId = path;
                                config.loadModule([&quot;mode&quot;, path], function(m) {
                                    if (this.$modeId !== path)
                                        return cb &amp;&amp; cb();
                                    if (this.$modes[path] &amp;&amp; !options) {
                                        this.$onChangeMode(this.$modes[path]);
                                    } else if (m &amp;&amp; m.Mode) {
                                        m = new m.Mode(options);
                                        if (!options) {
                                            this.$modes[path] = m;
                                            m.$id = path;
                                        }
                                        this.$onChangeMode(m);
                                    }
                                    cb &amp;&amp; cb();
                                }.bind(this));
                                if (!this.$mode)
                                    this.$onChangeMode(this.$modes[&quot;ace/mode/text&quot;], true);
                            };
                        
                            this.$onChangeMode = function(mode, $isPlaceholder) {
                                if (!$isPlaceholder)
                                    this.$modeId = mode.$id;
                                if (this.$mode === mode) 
                                    return;
                        
                                this.$mode = mode;
                        
                                this.$stopWorker();
                        
                                if (this.$useWorker)
                                    this.$startWorker();
                        
                                var tokenizer = mode.getTokenizer();
                        
                                if(tokenizer.addEventListener !== undefined) {
                                    var onReloadTokenizer = this.onReloadTokenizer.bind(this);
                                    tokenizer.addEventListener(&quot;update&quot;, onReloadTokenizer);
                                }
                        
                                if (!this.bgTokenizer) {
                                    this.bgTokenizer = new BackgroundTokenizer(tokenizer);
                                    var _self = this;
                                    this.bgTokenizer.addEventListener(&quot;update&quot;, function(e) {
                                        _self._signal(&quot;tokenizerUpdate&quot;, e);
                                    });
                                } else {
                                    this.bgTokenizer.setTokenizer(tokenizer);
                                }
                        
                                this.bgTokenizer.setDocument(this.getDocument());
                        
                                this.tokenRe = mode.tokenRe;
                                this.nonTokenRe = mode.nonTokenRe;
                        
                                
                                if (!$isPlaceholder) {
                                    if (mode.attachToSession)
                                        mode.attachToSession(this);
                                    this.$options.wrapMethod.set.call(this, this.$wrapMethod);
                                    this.$setFolding(mode.foldingRules);
                                    this.bgTokenizer.start(0);
                                    this._emit(&quot;changeMode&quot;);
                                }
                            };
                        
                            this.$stopWorker = function() {
                                if (this.$worker) {
                                    this.$worker.terminate();
                                    this.$worker = null;
                                }
                            };
                        
                            this.$startWorker = function() {
                                try {
                                    this.$worker = this.$mode.createWorker(this);
                                } catch (e) {
                                    config.warn(&quot;Could not load worker&quot;, e);
                                    this.$worker = null;
                                }
                            };
                            this.getMode = function() {
                                return this.$mode;
                            };
                        
                            this.$scrollTop = 0;
                            this.setScrollTop = function(scrollTop) {
                                if (this.$scrollTop === scrollTop || isNaN(scrollTop))
                                    return;
                        
                                this.$scrollTop = scrollTop;
                                this._signal(&quot;changeScrollTop&quot;, scrollTop);
                            };
                            this.getScrollTop = function() {
                                return this.$scrollTop;
                            };
                        
                            this.$scrollLeft = 0;
                            this.setScrollLeft = function(scrollLeft) {
                                if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
                                    return;
                        
                                this.$scrollLeft = scrollLeft;
                                this._signal(&quot;changeScrollLeft&quot;, scrollLeft);
                            };
                            this.getScrollLeft = function() {
                                return this.$scrollLeft;
                            };
                            this.getScreenWidth = function() {
                                this.$computeWidth();
                                if (this.lineWidgets) 
                                    return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
                                return this.screenWidth;
                            };
                            
                            this.getLineWidgetMaxWidth = function() {
                                if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;
                                var width = 0;
                                this.lineWidgets.forEach(function(w) {
                                    if (w &amp;&amp; w.screenWidth &gt; width)
                                        width = w.screenWidth;
                                });
                                return this.lineWidgetWidth = width;
                            };
                        
                            this.$computeWidth = function(force) {
                                if (this.$modified || force) {
                                    this.$modified = false;
                        
                                    if (this.$useWrapMode)
                                        return this.screenWidth = this.$wrapLimit;
                        
                                    var lines = this.doc.getAllLines();
                                    var cache = this.$rowLengthCache;
                                    var longestScreenLine = 0;
                                    var foldIndex = 0;
                                    var foldLine = this.$foldData[foldIndex];
                                    var foldStart = foldLine ? foldLine.start.row : Infinity;
                                    var len = lines.length;
                        
                                    for (var i = 0; i &lt; len; i++) {
                                        if (i &gt; foldStart) {
                                            i = foldLine.end.row + 1;
                                            if (i &gt;= len)
                                                break;
                                            foldLine = this.$foldData[foldIndex++];
                                            foldStart = foldLine ? foldLine.start.row : Infinity;
                                        }
                        
                                        if (cache[i] == null)
                                            cache[i] = this.$getStringScreenWidth(lines[i])[0];
                        
                                        if (cache[i] &gt; longestScreenLine)
                                            longestScreenLine = cache[i];
                                    }
                                    this.screenWidth = longestScreenLine;
                                }
                            };
                            this.getLine = function(row) {
                                return this.doc.getLine(row);
                            };
                            this.getLines = function(firstRow, lastRow) {
                                return this.doc.getLines(firstRow, lastRow);
                            };
                            this.getLength = function() {
                                return this.doc.getLength();
                            };
                            this.getTextRange = function(range) {
                                return this.doc.getTextRange(range || this.selection.getRange());
                            };
                            this.insert = function(position, text) {
                                return this.doc.insert(position, text);
                            };
                            this.remove = function(range) {
                                return this.doc.remove(range);
                            };
                            this.undoChanges = function(deltas, dontSelect) {
                                if (!deltas.length)
                                    return;
                        
                                this.$fromUndo = true;
                                var lastUndoRange = null;
                                for (var i = deltas.length - 1; i != -1; i--) {
                                    var delta = deltas[i];
                                    if (delta.group == &quot;doc&quot;) {
                                        this.doc.revertDeltas(delta.deltas);
                                        lastUndoRange =
                                            this.$getUndoSelection(delta.deltas, true, lastUndoRange);
                                    } else {
                                        delta.deltas.forEach(function(foldDelta) {
                                            this.addFolds(foldDelta.folds);
                                        }, this);
                                    }
                                }
                                this.$fromUndo = false;
                                lastUndoRange &amp;&amp;
                                    this.$undoSelect &amp;&amp;
                                    !dontSelect &amp;&amp;
                                    this.selection.setSelectionRange(lastUndoRange);
                                return lastUndoRange;
                            };
                            this.redoChanges = function(deltas, dontSelect) {
                                if (!deltas.length)
                                    return;
                        
                                this.$fromUndo = true;
                                var lastUndoRange = null;
                                for (var i = 0; i &lt; deltas.length; i++) {
                                    var delta = deltas[i];
                                    if (delta.group == &quot;doc&quot;) {
                                        this.doc.applyDeltas(delta.deltas);
                                        lastUndoRange =
                                            this.$getUndoSelection(delta.deltas, false, lastUndoRange);
                                    }
                                }
                                this.$fromUndo = false;
                                lastUndoRange &amp;&amp;
                                    this.$undoSelect &amp;&amp;
                                    !dontSelect &amp;&amp;
                                    this.selection.setSelectionRange(lastUndoRange);
                                return lastUndoRange;
                            };
                            this.setUndoSelect = function(enable) {
                                this.$undoSelect = enable;
                            };
                        
                            this.$getUndoSelection = function(deltas, isUndo, lastUndoRange) {
                                function isInsert(delta) {
                                    var insert =
                                        delta.action === &quot;insertText&quot; || delta.action === &quot;insertLines&quot;;
                                    return isUndo ? !insert : insert;
                                }
                        
                                var delta = deltas[0];
                                var range, point;
                                var lastDeltaIsInsert = false;
                                if (isInsert(delta)) {
                                    range = Range.fromPoints(delta.range.start, delta.range.end);
                                    lastDeltaIsInsert = true;
                                } else {
                                    range = Range.fromPoints(delta.range.start, delta.range.start);
                                    lastDeltaIsInsert = false;
                                }
                        
                                for (var i = 1; i &lt; deltas.length; i++) {
                                    delta = deltas[i];
                                    if (isInsert(delta)) {
                                        point = delta.range.start;
                                        if (range.compare(point.row, point.column) == -1) {
                                            range.setStart(delta.range.start);
                                        }
                                        point = delta.range.end;
                                        if (range.compare(point.row, point.column) == 1) {
                                            range.setEnd(delta.range.end);
                                        }
                                        lastDeltaIsInsert = true;
                                    } else {
                                        point = delta.range.start;
                                        if (range.compare(point.row, point.column) == -1) {
                                            range =
                                                Range.fromPoints(delta.range.start, delta.range.start);
                                        }
                                        lastDeltaIsInsert = false;
                                    }
                                }
                                if (lastUndoRange != null) {
                                    if (Range.comparePoints(lastUndoRange.start, range.start) === 0) {
                                        lastUndoRange.start.column += range.end.column - range.start.column;
                                        lastUndoRange.end.column += range.end.column - range.start.column;
                                    }
                        
                                    var cmp = lastUndoRange.compareRange(range);
                                    if (cmp == 1) {
                                        range.setStart(lastUndoRange.start);
                                    } else if (cmp == -1) {
                                        range.setEnd(lastUndoRange.end);
                                    }
                                }
                        
                                return range;
                            };
                            this.replace = function(range, text) {
                                return this.doc.replace(range, text);
                            };
                            this.moveText = function(fromRange, toPosition, copy) {
                                var text = this.getTextRange(fromRange);
                                var folds = this.getFoldsInRange(fromRange);
                        
                                var toRange = Range.fromPoints(toPosition, toPosition);
                                if (!copy) {
                                    this.remove(fromRange);
                                    var rowDiff = fromRange.start.row - fromRange.end.row;
                                    var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
                                    if (collDiff) {
                                        if (toRange.start.row == fromRange.end.row &amp;&amp; toRange.start.column &gt; fromRange.end.column)
                                            toRange.start.column += collDiff;
                                        if (toRange.end.row == fromRange.end.row &amp;&amp; toRange.end.column &gt; fromRange.end.column)
                                            toRange.end.column += collDiff;
                                    }
                                    if (rowDiff &amp;&amp; toRange.start.row &gt;= fromRange.end.row) {
                                        toRange.start.row += rowDiff;
                                        toRange.end.row += rowDiff;
                                    }
                                }
                        
                                toRange.end = this.insert(toRange.start, text);
                                if (folds.length) {
                                    var oldStart = fromRange.start;
                                    var newStart = toRange.start;
                                    var rowDiff = newStart.row - oldStart.row;
                                    var collDiff = newStart.column - oldStart.column;
                                    this.addFolds(folds.map(function(x) {
                                        x = x.clone();
                                        if (x.start.row == oldStart.row)
                                            x.start.column += collDiff;
                                        if (x.end.row == oldStart.row)
                                            x.end.column += collDiff;
                                        x.start.row += rowDiff;
                                        x.end.row += rowDiff;
                                        return x;
                                    }));
                                }
                        
                                return toRange;
                            };
                            this.indentRows = function(startRow, endRow, indentString) {
                                indentString = indentString.replace(/\t/g, this.getTabString());
                                for (var row=startRow; row&lt;=endRow; row++)
                                    this.insert({row: row, column:0}, indentString);
                            };
                            this.outdentRows = function (range) {
                                var rowRange = range.collapseRows();
                                var deleteRange = new Range(0, 0, 0, 0);
                                var size = this.getTabSize();
                        
                                for (var i = rowRange.start.row; i &lt;= rowRange.end.row; ++i) {
                                    var line = this.getLine(i);
                        
                                    deleteRange.start.row = i;
                                    deleteRange.end.row = i;
                                    for (var j = 0; j &lt; size; ++j)
                                        if (line.charAt(j) != &#x27; &#x27;)
                                            break;
                                    if (j &lt; size &amp;&amp; line.charAt(j) == &#x27;\t&#x27;) {
                                        deleteRange.start.column = j;
                                        deleteRange.end.column = j + 1;
                                    } else {
                                        deleteRange.start.column = 0;
                                        deleteRange.end.column = j;
                                    }
                                    this.remove(deleteRange);
                                }
                            };
                        
                            this.$moveLines = function(firstRow, lastRow, dir) {
                                firstRow = this.getRowFoldStart(firstRow);
                                lastRow = this.getRowFoldEnd(lastRow);
                                if (dir &lt; 0) {
                                    var row = this.getRowFoldStart(firstRow + dir);
                                    if (row &lt; 0) return 0;
                                    var diff = row-firstRow;
                                } else if (dir &gt; 0) {
                                    var row = this.getRowFoldEnd(lastRow + dir);
                                    if (row &gt; this.doc.getLength()-1) return 0;
                                    var diff = row-lastRow;
                                } else {
                                    firstRow = this.$clipRowToDocument(firstRow);
                                    lastRow = this.$clipRowToDocument(lastRow);
                                    var diff = lastRow - firstRow + 1;
                                }
                        
                                var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
                                var folds = this.getFoldsInRange(range).map(function(x){
                                    x = x.clone();
                                    x.start.row += diff;
                                    x.end.row += diff;
                                    return x;
                                });
                        
                                var lines = dir == 0
                                    ? this.doc.getLines(firstRow, lastRow)
                                    : this.doc.removeLines(firstRow, lastRow);
                                this.doc.insertLines(firstRow+diff, lines);
                                folds.length &amp;&amp; this.addFolds(folds);
                                return diff;
                            };
                            this.moveLinesUp = function(firstRow, lastRow) {
                                return this.$moveLines(firstRow, lastRow, -1);
                            };
                            this.moveLinesDown = function(firstRow, lastRow) {
                                return this.$moveLines(firstRow, lastRow, 1);
                            };
                            this.duplicateLines = function(firstRow, lastRow) {
                                return this.$moveLines(firstRow, lastRow, 0);
                            };
                        
                        
                            this.$clipRowToDocument = function(row) {
                                return Math.max(0, Math.min(row, this.doc.getLength()-1));
                            };
                        
                            this.$clipColumnToRow = function(row, column) {
                                if (column &lt; 0)
                                    return 0;
                                return Math.min(this.doc.getLine(row).length, column);
                            };
                        
                        
                            this.$clipPositionToDocument = function(row, column) {
                                column = Math.max(0, column);
                        
                                if (row &lt; 0) {
                                    row = 0;
                                    column = 0;
                                } else {
                                    var len = this.doc.getLength();
                                    if (row &gt;= len) {
                                        row = len - 1;
                                        column = this.doc.getLine(len-1).length;
                                    } else {
                                        column = Math.min(this.doc.getLine(row).length, column);
                                    }
                                }
                        
                                return {
                                    row: row,
                                    column: column
                                };
                            };
                        
                            this.$clipRangeToDocument = function(range) {
                                if (range.start.row &lt; 0) {
                                    range.start.row = 0;
                                    range.start.column = 0;
                                } else {
                                    range.start.column = this.$clipColumnToRow(
                                        range.start.row,
                                        range.start.column
                                    );
                                }
                        
                                var len = this.doc.getLength() - 1;
                                if (range.end.row &gt; len) {
                                    range.end.row = len;
                                    range.end.column = this.doc.getLine(len).length;
                                } else {
                                    range.end.column = this.$clipColumnToRow(
                                        range.end.row,
                                        range.end.column
                                    );
                                }
                                return range;
                            };
                            this.$wrapLimit = 80;
                            this.$useWrapMode = false;
                            this.$wrapLimitRange = {
                                min : null,
                                max : null
                            };
                            this.setUseWrapMode = function(useWrapMode) {
                                if (useWrapMode != this.$useWrapMode) {
                                    this.$useWrapMode = useWrapMode;
                                    this.$modified = true;
                                    this.$resetRowCache(0);
                                    if (useWrapMode) {
                                        var len = this.getLength();
                                        this.$wrapData = Array(len);
                                        this.$updateWrapData(0, len - 1);
                                    }
                        
                                    this._signal(&quot;changeWrapMode&quot;);
                                }
                            };
                            this.getUseWrapMode = function() {
                                return this.$useWrapMode;
                            };
                            this.setWrapLimitRange = function(min, max) {
                                if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
                                    this.$wrapLimitRange = { min: min, max: max };
                                    this.$modified = true;
                                    if (this.$useWrapMode)
                                        this._signal(&quot;changeWrapMode&quot;);
                                }
                            };
                            this.adjustWrapLimit = function(desiredLimit, $printMargin) {
                                var limits = this.$wrapLimitRange;
                                if (limits.max &lt; 0)
                                    limits = {min: $printMargin, max: $printMargin};
                                var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
                                if (wrapLimit != this.$wrapLimit &amp;&amp; wrapLimit &gt; 1) {
                                    this.$wrapLimit = wrapLimit;
                                    this.$modified = true;
                                    if (this.$useWrapMode) {
                                        this.$updateWrapData(0, this.getLength() - 1);
                                        this.$resetRowCache(0);
                                        this._signal(&quot;changeWrapLimit&quot;);
                                    }
                                    return true;
                                }
                                return false;
                            };
                        
                            this.$constrainWrapLimit = function(wrapLimit, min, max) {
                                if (min)
                                    wrapLimit = Math.max(min, wrapLimit);
                        
                                if (max)
                                    wrapLimit = Math.min(max, wrapLimit);
                        
                                return wrapLimit;
                            };
                            this.getWrapLimit = function() {
                                return this.$wrapLimit;
                            };
                            this.setWrapLimit = function (limit) {
                                this.setWrapLimitRange(limit, limit);
                            };
                            this.getWrapLimitRange = function() {
                                return {
                                    min : this.$wrapLimitRange.min,
                                    max : this.$wrapLimitRange.max
                                };
                            };
                        
                            this.$updateInternalDataOnChange = function(e) {
                                var useWrapMode = this.$useWrapMode;
                                var len;
                                var action = e.data.action;
                                var firstRow = e.data.range.start.row;
                                var lastRow = e.data.range.end.row;
                                var start = e.data.range.start;
                                var end = e.data.range.end;
                                var removedFolds = null;
                        
                                if (action.indexOf(&quot;Lines&quot;) != -1) {
                                    if (action == &quot;insertLines&quot;) {
                                        lastRow = firstRow + (e.data.lines.length);
                                    } else {
                                        lastRow = firstRow;
                                    }
                                    len = e.data.lines ? e.data.lines.length : lastRow - firstRow;
                                } else {
                                    len = lastRow - firstRow;
                                }
                        
                                this.$updating = true;
                                if (len != 0) {
                                    if (action.indexOf(&quot;remove&quot;) != -1) {
                                        this[useWrapMode ? &quot;$wrapData&quot; : &quot;$rowLengthCache&quot;].splice(firstRow, len);
                        
                                        var foldLines = this.$foldData;
                                        removedFolds = this.getFoldsInRange(e.data.range);
                                        this.removeFolds(removedFolds);
                        
                                        var foldLine = this.getFoldLine(end.row);
                                        var idx = 0;
                                        if (foldLine) {
                                            foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                                            foldLine.shiftRow(-len);
                        
                                            var foldLineBefore = this.getFoldLine(firstRow);
                                            if (foldLineBefore &amp;&amp; foldLineBefore !== foldLine) {
                                                foldLineBefore.merge(foldLine);
                                                foldLine = foldLineBefore;
                                            }
                                            idx = foldLines.indexOf(foldLine) + 1;
                                        }
                        
                                        for (idx; idx &lt; foldLines.length; idx++) {
                                            var foldLine = foldLines[idx];
                                            if (foldLine.start.row &gt;= end.row) {
                                                foldLine.shiftRow(-len);
                                            }
                                        }
                        
                                        lastRow = firstRow;
                                    } else {
                                        var args = Array(len);
                                        args.unshift(firstRow, 0);
                                        var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache
                                        arr.splice.apply(arr, args);
                                        var foldLines = this.$foldData;
                                        var foldLine = this.getFoldLine(firstRow);
                                        var idx = 0;
                                        if (foldLine) {
                                            var cmp = foldLine.range.compareInside(start.row, start.column);
                                            if (cmp == 0) {
                                                foldLine = foldLine.split(start.row, start.column);
                                                if (foldLine) {
                                                    foldLine.shiftRow(len);
                                                    foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                                                }
                                            } else
                                            if (cmp == -1) {
                                                foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                                                foldLine.shiftRow(len);
                                            }
                                            idx = foldLines.indexOf(foldLine) + 1;
                                        }
                        
                                        for (idx; idx &lt; foldLines.length; idx++) {
                                            var foldLine = foldLines[idx];
                                            if (foldLine.start.row &gt;= firstRow) {
                                                foldLine.shiftRow(len);
                                            }
                                        }
                                    }
                                } else {
                                    len = Math.abs(e.data.range.start.column - e.data.range.end.column);
                                    if (action.indexOf(&quot;remove&quot;) != -1) {
                                        removedFolds = this.getFoldsInRange(e.data.range);
                                        this.removeFolds(removedFolds);
                        
                                        len = -len;
                                    }
                                    var foldLine = this.getFoldLine(firstRow);
                                    if (foldLine) {
                                        foldLine.addRemoveChars(firstRow, start.column, len);
                                    }
                                }
                        
                                if (useWrapMode &amp;&amp; this.$wrapData.length != this.doc.getLength()) {
                                    console.error(&quot;doc.getLength() and $wrapData.length have to be the same!&quot;);
                                }
                                this.$updating = false;
                        
                                if (useWrapMode)
                                    this.$updateWrapData(firstRow, lastRow);
                                else
                                    this.$updateRowLengthCache(firstRow, lastRow);
                        
                                return removedFolds;
                            };
                        
                            this.$updateRowLengthCache = function(firstRow, lastRow, b) {
                                this.$rowLengthCache[firstRow] = null;
                                this.$rowLengthCache[lastRow] = null;
                            };
                        
                            this.$updateWrapData = function(firstRow, lastRow) {
                                var lines = this.doc.getAllLines();
                                var tabSize = this.getTabSize();
                                var wrapData = this.$wrapData;
                                var wrapLimit = this.$wrapLimit;
                                var tokens;
                                var foldLine;
                        
                                var row = firstRow;
                                lastRow = Math.min(lastRow, lines.length - 1);
                                while (row &lt;= lastRow) {
                                    foldLine = this.getFoldLine(row, foldLine);
                                    if (!foldLine) {
                                        tokens = this.$getDisplayTokens(lines[row]);
                                        wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                                        row ++;
                                    } else {
                                        tokens = [];
                                        foldLine.walk(function(placeholder, row, column, lastColumn) {
                                                var walkTokens;
                                                if (placeholder != null) {
                                                    walkTokens = this.$getDisplayTokens(
                                                                    placeholder, tokens.length);
                                                    walkTokens[0] = PLACEHOLDER_START;
                                                    for (var i = 1; i &lt; walkTokens.length; i++) {
                                                        walkTokens[i] = PLACEHOLDER_BODY;
                                                    }
                                                } else {
                                                    walkTokens = this.$getDisplayTokens(
                                                        lines[row].substring(lastColumn, column),
                                                        tokens.length);
                                                }
                                                tokens = tokens.concat(walkTokens);
                                            }.bind(this),
                                            foldLine.end.row,
                                            lines[foldLine.end.row].length + 1
                                        );
                        
                                        wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                                        row = foldLine.end.row + 1;
                                    }
                                }
                            };
                            var CHAR = 1,
                                CHAR_EXT = 2,
                                PLACEHOLDER_START = 3,
                                PLACEHOLDER_BODY =  4,
                                PUNCTUATION = 9,
                                SPACE = 10,
                                TAB = 11,
                                TAB_SPACE = 12;
                        
                        
                            this.$computeWrapSplits = function(tokens, wrapLimit, tabSize) {
                                if (tokens.length == 0) {
                                    return [];
                                }
                        
                                var splits = [];
                                var displayLength = tokens.length;
                                var lastSplit = 0, lastDocSplit = 0;
                        
                                var isCode = this.$wrapAsCode;
                        
                                var indentedSoftWrap = this.$indentedSoftWrap;
                                var maxIndent = wrapLimit &lt;= Math.max(2 * tabSize, 8)
                                    || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);
                        
                                function getWrapIndent() {
                                    var indentation = 0;
                                    if (maxIndent === 0)
                                        return indentation;
                                    if (indentedSoftWrap) {
                                        for (var i = 0; i &lt; tokens.length; i++) {
                                            var token = tokens[i];
                                            if (token == SPACE)
                                                indentation += 1;
                                            else if (token == TAB)
                                                indentation += tabSize;
                                            else if (token == TAB_SPACE)
                                                continue;
                                            else
                                                break;
                                        }
                                    }
                                    if (isCode &amp;&amp; indentedSoftWrap !== false)
                                        indentation += tabSize;
                                    return Math.min(indentation, maxIndent);
                                }
                                function addSplit(screenPos) {
                                    var displayed = tokens.slice(lastSplit, screenPos);
                                    var len = displayed.length;
                                    displayed.join(&quot;&quot;).
                                        replace(/12/g, function() {
                                            len -= 1;
                                        }).
                                        replace(/2/g, function() {
                                            len -= 1;
                                        });
                        
                                    if (!splits.length) {
                                        indent = getWrapIndent();
                                        splits.indent = indent;
                                    }
                                    lastDocSplit += len;
                                    splits.push(lastDocSplit);
                                    lastSplit = screenPos;
                                }
                                var indent = 0;
                                while (displayLength - lastSplit &gt; wrapLimit - indent) {
                                    var split = lastSplit + wrapLimit - indent;
                                    if (tokens[split - 1] &gt;= SPACE &amp;&amp; tokens[split] &gt;= SPACE) {
                                        addSplit(split);
                                        continue;
                                    }
                                    if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
                                        for (split; split != lastSplit - 1; split--) {
                                            if (tokens[split] == PLACEHOLDER_START) {
                                                break;
                                            }
                                        }
                                        if (split &gt; lastSplit) {
                                            addSplit(split);
                                            continue;
                                        }
                                        split = lastSplit + wrapLimit;
                                        for (split; split &lt; tokens.length; split++) {
                                            if (tokens[split] != PLACEHOLDER_BODY) {
                                                break;
                                            }
                                        }
                                        if (split == tokens.length) {
                                            break;  // Breaks the while-loop.
                                        }
                                        addSplit(split);
                                        continue;
                                    }
                                    var minSplit = Math.max(split - (wrapLimit -(wrapLimit&gt;&gt;2)), lastSplit - 1);
                                    while (split &gt; minSplit &amp;&amp; tokens[split] &lt; PLACEHOLDER_START) {
                                        split --;
                                    }
                                    if (isCode) {
                                        while (split &gt; minSplit &amp;&amp; tokens[split] &lt; PLACEHOLDER_START) {
                                            split --;
                                        }
                                        while (split &gt; minSplit &amp;&amp; tokens[split] == PUNCTUATION) {
                                            split --;
                                        }
                                    } else {
                                        while (split &gt; minSplit &amp;&amp; tokens[split] &lt; SPACE) {
                                            split --;
                                        }
                                    }
                                    if (split &gt; minSplit) {
                                        addSplit(++split);
                                        continue;
                                    }
                                    split = lastSplit + wrapLimit;
                                    if (tokens[split] == CHAR_EXT)
                                        split--;
                                    addSplit(split - indent);
                                }
                                return splits;
                            };
                            this.$getDisplayTokens = function(str, offset) {
                                var arr = [];
                                var tabSize;
                                offset = offset || 0;
                        
                                for (var i = 0; i &lt; str.length; i++) {
                                    var c = str.charCodeAt(i);
                                    if (c == 9) {
                                        tabSize = this.getScreenTabSize(arr.length + offset);
                                        arr.push(TAB);
                                        for (var n = 1; n &lt; tabSize; n++) {
                                            arr.push(TAB_SPACE);
                                        }
                                    }
                                    else if (c == 32) {
                                        arr.push(SPACE);
                                    } else if((c &gt; 39 &amp;&amp; c &lt; 48) || (c &gt; 57 &amp;&amp; c &lt; 64)) {
                                        arr.push(PUNCTUATION);
                                    }
                                    else if (c &gt;= 0x1100 &amp;&amp; isFullWidth(c)) {
                                        arr.push(CHAR, CHAR_EXT);
                                    } else {
                                        arr.push(CHAR);
                                    }
                                }
                                return arr;
                            };
                            this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
                                if (maxScreenColumn == 0)
                                    return [0, 0];
                                if (maxScreenColumn == null)
                                    maxScreenColumn = Infinity;
                                screenColumn = screenColumn || 0;
                        
                                var c, column;
                                for (column = 0; column &lt; str.length; column++) {
                                    c = str.charCodeAt(column);
                                    if (c == 9) {
                                        screenColumn += this.getScreenTabSize(screenColumn);
                                    }
                                    else if (c &gt;= 0x1100 &amp;&amp; isFullWidth(c)) {
                                        screenColumn += 2;
                                    } else {
                                        screenColumn += 1;
                                    }
                                    if (screenColumn &gt; maxScreenColumn) {
                                        break;
                                    }
                                }
                        
                                return [screenColumn, column];
                            };
                        
                            this.lineWidgets = null;
                            this.getRowLength = function(row) {
                                if (this.lineWidgets)
                                    var h = this.lineWidgets[row] &amp;&amp; this.lineWidgets[row].rowCount || 0;
                                else 
                                    h = 0
                                if (!this.$useWrapMode || !this.$wrapData[row]) {
                                    return 1 + h;
                                } else {
                                    return this.$wrapData[row].length + 1 + h;
                                }
                            };
                            this.getRowLineCount = function(row) {
                                if (!this.$useWrapMode || !this.$wrapData[row]) {
                                    return 1;
                                } else {
                                    return this.$wrapData[row].length + 1;
                                }
                            };
                        
                            this.getRowWrapIndent = function(screenRow) {
                                if (this.$useWrapMode) {
                                    var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
                                    var splits = this.$wrapData[pos.row];
                                    return splits.length &amp;&amp; splits[0] &lt; pos.column ? splits.indent : 0;
                                } else {
                                    return 0;
                                }
                            }
                            this.getScreenLastRowColumn = function(screenRow) {
                                var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
                                return this.documentToScreenColumn(pos.row, pos.column);
                            };
                            this.getDocumentLastRowColumn = function(docRow, docColumn) {
                                var screenRow = this.documentToScreenRow(docRow, docColumn);
                                return this.getScreenLastRowColumn(screenRow);
                            };
                            this.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
                                var screenRow = this.documentToScreenRow(docRow, docColumn);
                                return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
                            };
                            this.getRowSplitData = function(row) {
                                if (!this.$useWrapMode) {
                                    return undefined;
                                } else {
                                    return this.$wrapData[row];
                                }
                            };
                            this.getScreenTabSize = function(screenColumn) {
                                return this.$tabSize - screenColumn % this.$tabSize;
                            };
                        
                        
                            this.screenToDocumentRow = function(screenRow, screenColumn) {
                                return this.screenToDocumentPosition(screenRow, screenColumn).row;
                            };
                        
                        
                            this.screenToDocumentColumn = function(screenRow, screenColumn) {
                                return this.screenToDocumentPosition(screenRow, screenColumn).column;
                            };
                            this.screenToDocumentPosition = function(screenRow, screenColumn) {
                                if (screenRow &lt; 0)
                                    return {row: 0, column: 0};
                        
                                var line;
                                var docRow = 0;
                                var docColumn = 0;
                                var column;
                                var row = 0;
                                var rowLength = 0;
                        
                                var rowCache = this.$screenRowCache;
                                var i = this.$getRowCacheIndex(rowCache, screenRow);
                                var l = rowCache.length;
                                if (l &amp;&amp; i &gt;= 0) {
                                    var row = rowCache[i];
                                    var docRow = this.$docRowCache[i];
                                    var doCache = screenRow &gt; rowCache[l - 1];
                                } else {
                                    var doCache = !l;
                                }
                        
                                var maxRow = this.getLength() - 1;
                                var foldLine = this.getNextFoldLine(docRow);
                                var foldStart = foldLine ? foldLine.start.row : Infinity;
                        
                                while (row &lt;= screenRow) {
                                    rowLength = this.getRowLength(docRow);
                                    if (row + rowLength &gt; screenRow || docRow &gt;= maxRow) {
                                        break;
                                    } else {
                                        row += rowLength;
                                        docRow++;
                                        if (docRow &gt; foldStart) {
                                            docRow = foldLine.end.row+1;
                                            foldLine = this.getNextFoldLine(docRow, foldLine);
                                            foldStart = foldLine ? foldLine.start.row : Infinity;
                                        }
                                    }
                        
                                    if (doCache) {
                                        this.$docRowCache.push(docRow);
                                        this.$screenRowCache.push(row);
                                    }
                                }
                        
                                if (foldLine &amp;&amp; foldLine.start.row &lt;= docRow) {
                                    line = this.getFoldDisplayLine(foldLine);
                                    docRow = foldLine.start.row;
                                } else if (row + rowLength &lt;= screenRow || docRow &gt; maxRow) {
                                    return {
                                        row: maxRow,
                                        column: this.getLine(maxRow).length
                                    };
                                } else {
                                    line = this.getLine(docRow);
                                    foldLine = null;
                                }
                                var wrapIndent = 0;
                                if (this.$useWrapMode) {
                                    var splits = this.$wrapData[docRow];
                                    if (splits) {
                                        var splitIndex = Math.floor(screenRow - row);
                                        column = splits[splitIndex];
                                        if(splitIndex &gt; 0 &amp;&amp; splits.length) {
                                            wrapIndent = splits.indent;
                                            docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                                            line = line.substring(docColumn);
                                        }
                                    }
                                }
                        
                                docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
                                if (this.$useWrapMode &amp;&amp; docColumn &gt;= column)
                                    docColumn = column - 1;
                        
                                if (foldLine)
                                    return foldLine.idxToPosition(docColumn);
                        
                                return {row: docRow, column: docColumn};
                            };
                            this.documentToScreenPosition = function(docRow, docColumn) {
                                if (typeof docColumn === &quot;undefined&quot;)
                                    var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
                                else
                                    pos = this.$clipPositionToDocument(docRow, docColumn);
                        
                                docRow = pos.row;
                                docColumn = pos.column;
                        
                                var screenRow = 0;
                                var foldStartRow = null;
                                var fold = null;
                                fold = this.getFoldAt(docRow, docColumn, 1);
                                if (fold) {
                                    docRow = fold.start.row;
                                    docColumn = fold.start.column;
                                }
                        
                                var rowEnd, row = 0;
                        
                        
                                var rowCache = this.$docRowCache;
                                var i = this.$getRowCacheIndex(rowCache, docRow);
                                var l = rowCache.length;
                                if (l &amp;&amp; i &gt;= 0) {
                                    var row = rowCache[i];
                                    var screenRow = this.$screenRowCache[i];
                                    var doCache = docRow &gt; rowCache[l - 1];
                                } else {
                                    var doCache = !l;
                                }
                        
                                var foldLine = this.getNextFoldLine(row);
                                var foldStart = foldLine ?foldLine.start.row :Infinity;
                        
                                while (row &lt; docRow) {
                                    if (row &gt;= foldStart) {
                                        rowEnd = foldLine.end.row + 1;
                                        if (rowEnd &gt; docRow)
                                            break;
                                        foldLine = this.getNextFoldLine(rowEnd, foldLine);
                                        foldStart = foldLine ?foldLine.start.row :Infinity;
                                    }
                                    else {
                                        rowEnd = row + 1;
                                    }
                        
                                    screenRow += this.getRowLength(row);
                                    row = rowEnd;
                        
                                    if (doCache) {
                                        this.$docRowCache.push(row);
                                        this.$screenRowCache.push(screenRow);
                                    }
                                }
                                var textLine = &quot;&quot;;
                                if (foldLine &amp;&amp; row &gt;= foldStart) {
                                    textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
                                    foldStartRow = foldLine.start.row;
                                } else {
                                    textLine = this.getLine(docRow).substring(0, docColumn);
                                    foldStartRow = docRow;
                                }
                                var wrapIndent = 0;
                                if (this.$useWrapMode) {
                                    var wrapRow = this.$wrapData[foldStartRow];
                                    if (wrapRow) {
                                        var screenRowOffset = 0;
                                        while (textLine.length &gt;= wrapRow[screenRowOffset]) {
                                            screenRow ++;
                                            screenRowOffset++;
                                        }
                                        textLine = textLine.substring(
                                            wrapRow[screenRowOffset - 1] || 0, textLine.length
                                        );
                                        wrapIndent = screenRowOffset &gt; 0 ? wrapRow.indent : 0;
                                    }
                                }
                        
                                return {
                                    row: screenRow,
                                    column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
                                };
                            };
                            this.documentToScreenColumn = function(row, docColumn) {
                                return this.documentToScreenPosition(row, docColumn).column;
                            };
                            this.documentToScreenRow = function(docRow, docColumn) {
                                return this.documentToScreenPosition(docRow, docColumn).row;
                            };
                            this.getScreenLength = function() {
                                var screenRows = 0;
                                var fold = null;
                                if (!this.$useWrapMode) {
                                    screenRows = this.getLength();
                                    var foldData = this.$foldData;
                                    for (var i = 0; i &lt; foldData.length; i++) {
                                        fold = foldData[i];
                                        screenRows -= fold.end.row - fold.start.row;
                                    }
                                } else {
                                    var lastRow = this.$wrapData.length;
                                    var row = 0, i = 0;
                                    var fold = this.$foldData[i++];
                                    var foldStart = fold ? fold.start.row :Infinity;
                        
                                    while (row &lt; lastRow) {
                                        var splits = this.$wrapData[row];
                                        screenRows += splits ? splits.length + 1 : 1;
                                        row ++;
                                        if (row &gt; foldStart) {
                                            row = fold.end.row+1;
                                            fold = this.$foldData[i++];
                                            foldStart = fold ?fold.start.row :Infinity;
                                        }
                                    }
                                }
                                if (this.lineWidgets)
                                    screenRows += this.$getWidgetScreenLength();
                        
                                return screenRows;
                            };
                            this.$setFontMetrics = function(fm) {
                            };
                            
                            this.destroy = function() {
                                if (this.bgTokenizer) {
                                    this.bgTokenizer.setDocument(null);
                                    this.bgTokenizer = null;
                                }
                                this.$stopWorker();
                            };
                            function isFullWidth(c) {
                                if (c &lt; 0x1100)
                                    return false;
                                return c &gt;= 0x1100 &amp;&amp; c &lt;= 0x115F ||
                                       c &gt;= 0x11A3 &amp;&amp; c &lt;= 0x11A7 ||
                                       c &gt;= 0x11FA &amp;&amp; c &lt;= 0x11FF ||
                                       c &gt;= 0x2329 &amp;&amp; c &lt;= 0x232A ||
                                       c &gt;= 0x2E80 &amp;&amp; c &lt;= 0x2E99 ||
                                       c &gt;= 0x2E9B &amp;&amp; c &lt;= 0x2EF3 ||
                                       c &gt;= 0x2F00 &amp;&amp; c &lt;= 0x2FD5 ||
                                       c &gt;= 0x2FF0 &amp;&amp; c &lt;= 0x2FFB ||
                                       c &gt;= 0x3000 &amp;&amp; c &lt;= 0x303E ||
                                       c &gt;= 0x3041 &amp;&amp; c &lt;= 0x3096 ||
                                       c &gt;= 0x3099 &amp;&amp; c &lt;= 0x30FF ||
                                       c &gt;= 0x3105 &amp;&amp; c &lt;= 0x312D ||
                                       c &gt;= 0x3131 &amp;&amp; c &lt;= 0x318E ||
                                       c &gt;= 0x3190 &amp;&amp; c &lt;= 0x31BA ||
                                       c &gt;= 0x31C0 &amp;&amp; c &lt;= 0x31E3 ||
                                       c &gt;= 0x31F0 &amp;&amp; c &lt;= 0x321E ||
                                       c &gt;= 0x3220 &amp;&amp; c &lt;= 0x3247 ||
                                       c &gt;= 0x3250 &amp;&amp; c &lt;= 0x32FE ||
                                       c &gt;= 0x3300 &amp;&amp; c &lt;= 0x4DBF ||
                                       c &gt;= 0x4E00 &amp;&amp; c &lt;= 0xA48C ||
                                       c &gt;= 0xA490 &amp;&amp; c &lt;= 0xA4C6 ||
                                       c &gt;= 0xA960 &amp;&amp; c &lt;= 0xA97C ||
                                       c &gt;= 0xAC00 &amp;&amp; c &lt;= 0xD7A3 ||
                                       c &gt;= 0xD7B0 &amp;&amp; c &lt;= 0xD7C6 ||
                                       c &gt;= 0xD7CB &amp;&amp; c &lt;= 0xD7FB ||
                                       c &gt;= 0xF900 &amp;&amp; c &lt;= 0xFAFF ||
                                       c &gt;= 0xFE10 &amp;&amp; c &lt;= 0xFE19 ||
                                       c &gt;= 0xFE30 &amp;&amp; c &lt;= 0xFE52 ||
                                       c &gt;= 0xFE54 &amp;&amp; c &lt;= 0xFE66 ||
                                       c &gt;= 0xFE68 &amp;&amp; c &lt;= 0xFE6B ||
                                       c &gt;= 0xFF01 &amp;&amp; c &lt;= 0xFF60 ||
                                       c &gt;= 0xFFE0 &amp;&amp; c &lt;= 0xFFE6;
                            };
                        
                        }).call(EditSession.prototype);
                        
                        require(&quot;./edit_session/folding&quot;).Folding.call(EditSession.prototype);
                        require(&quot;./edit_session/bracket_match&quot;).BracketMatch.call(EditSession.prototype);
                        
                        
                        config.defineOptions(EditSession.prototype, &quot;session&quot;, {
                            wrap: {
                                set: function(value) {
                                    if (!value || value == &quot;off&quot;)
                                        value = false;
                                    else if (value == &quot;free&quot;)
                                        value = true;
                                    else if (value == &quot;printMargin&quot;)
                                        value = -1;
                                    else if (typeof value == &quot;string&quot;)
                                        value = parseInt(value, 10) || false;
                        
                                    if (this.$wrap == value)
                                        return;
                                    this.$wrap = value;
                                    if (!value) {
                                        this.setUseWrapMode(false);
                                    } else {
                                        var col = typeof value == &quot;number&quot; ? value : null;
                                        this.setWrapLimitRange(col, col);
                                        this.setUseWrapMode(true);
                                    }
                                },
                                get: function() {
                                    if (this.getUseWrapMode()) {
                                        if (this.$wrap == -1)
                                            return &quot;printMargin&quot;;
                                        if (!this.getWrapLimitRange().min)
                                            return &quot;free&quot;;
                                        return this.$wrap;
                                    }
                                    return &quot;off&quot;;
                                },
                                handlesSet: true
                            },    
                            wrapMethod: {
                                set: function(val) {
                                    val = val == &quot;auto&quot;
                                        ? this.$mode.type != &quot;text&quot;
                                        : val != &quot;text&quot;;
                                    if (val != this.$wrapAsCode) {
                                        this.$wrapAsCode = val;
                                        if (this.$useWrapMode) {
                                            this.$modified = true;
                                            this.$resetRowCache(0);
                                            this.$updateWrapData(0, this.getLength() - 1);
                                        }
                                    }
                                },
                                initialValue: &quot;auto&quot;
                            },
                            indentedSoftWrap: { initialValue: true },
                            firstLineNumber: {
                                set: function() {this._signal(&quot;changeBreakpoint&quot;);},
                                initialValue: 1
                            },
                            useWorker: {
                                set: function(useWorker) {
                                    this.$useWorker = useWorker;
                        
                                    this.$stopWorker();
                                    if (useWorker)
                                        this.$startWorker();
                                },
                                initialValue: true
                            },
                            useSoftTabs: {initialValue: true},
                            tabSize: {
                                set: function(tabSize) {
                                    if (isNaN(tabSize) || this.$tabSize === tabSize) return;
                        
                                    this.$modified = true;
                                    this.$rowLengthCache = [];
                                    this.$tabSize = tabSize;
                                    this._signal(&quot;changeTabSize&quot;);
                                },
                                initialValue: 4,
                                handlesSet: true
                            },
                            overwrite: {
                                set: function(val) {this._signal(&quot;changeOverwrite&quot;);},
                                initialValue: false
                            },
                            newLineMode: {
                                set: function(val) {this.doc.setNewLineMode(val)},
                                get: function() {return this.doc.getNewLineMode()},
                                handlesSet: true
                            },
                            mode: {
                                set: function(val) { this.setMode(val) },
                                get: function() { return this.$modeId }
                            }
                        });
                        
                        exports.EditSession = EditSession;
                        });
                        
                        define(&quot;ace/search&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/lang&quot;,&quot;ace/lib/oop&quot;,&quot;ace/range&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var lang = require(&quot;./lib/lang&quot;);
                        var oop = require(&quot;./lib/oop&quot;);
                        var Range = require(&quot;./range&quot;).Range;
                        
                        var Search = function() {
                            this.$options = {};
                        };
                        
                        (function() {
                            this.set = function(options) {
                                oop.mixin(this.$options, options);
                                return this;
                            };
                            this.getOptions = function() {
                                return lang.copyObject(this.$options);
                            };
                            this.setOptions = function(options) {
                                this.$options = options;
                            };
                            this.find = function(session) {
                                var options = this.$options;
                                var iterator = this.$matchIterator(session, options);
                                if (!iterator)
                                    return false;
                        
                                var firstRange = null;
                                iterator.forEach(function(range, row, offset) {
                                    if (!range.start) {
                                        var column = range.offset + (offset || 0);
                                        firstRange = new Range(row, column, row, column + range.length);
                                        if (!range.length &amp;&amp; options.start &amp;&amp; options.start.start
                                            &amp;&amp; options.skipCurrent != false &amp;&amp; firstRange.isEqual(options.start)
                                        ) {
                                            firstRange = null;
                                            return false;
                                        }
                                    } else
                                        firstRange = range;
                                    return true;
                                });
                        
                                return firstRange;
                            };
                            this.findAll = function(session) {
                                var options = this.$options;
                                if (!options.needle)
                                    return [];
                                this.$assembleRegExp(options);
                        
                                var range = options.range;
                                var lines = range
                                    ? session.getLines(range.start.row, range.end.row)
                                    : session.doc.getAllLines();
                        
                                var ranges = [];
                                var re = options.re;
                                if (options.$isMultiLine) {
                                    var len = re.length;
                                    var maxRow = lines.length - len;
                                    var prevRange;
                                    outer: for (var row = re.offset || 0; row &lt;= maxRow; row++) {
                                        for (var j = 0; j &lt; len; j++)
                                            if (lines[row + j].search(re[j]) == -1)
                                                continue outer;
                                        
                                        var startLine = lines[row];
                                        var line = lines[row + len - 1];
                                        var startIndex = startLine.length - startLine.match(re[0])[0].length;
                                        var endIndex = line.match(re[len - 1])[0].length;
                                        
                                        if (prevRange &amp;&amp; prevRange.end.row === row &amp;&amp;
                                            prevRange.end.column &gt; startIndex
                                        ) {
                                            continue;
                                        }
                                        ranges.push(prevRange = new Range(
                                            row, startIndex, row + len - 1, endIndex
                                        ));
                                        if (len &gt; 2)
                                            row = row + len - 2;
                                    }
                                } else {
                                    for (var i = 0; i &lt; lines.length; i++) {
                                        var matches = lang.getMatchOffsets(lines[i], re);
                                        for (var j = 0; j &lt; matches.length; j++) {
                                            var match = matches[j];
                                            ranges.push(new Range(i, match.offset, i, match.offset + match.length));
                                        }
                                    }
                                }
                        
                                if (range) {
                                    var startColumn = range.start.column;
                                    var endColumn = range.start.column;
                                    var i = 0, j = ranges.length - 1;
                                    while (i &lt; j &amp;&amp; ranges[i].start.column &lt; startColumn &amp;&amp; ranges[i].start.row == range.start.row)
                                        i++;
                        
                                    while (i &lt; j &amp;&amp; ranges[j].end.column &gt; endColumn &amp;&amp; ranges[j].end.row == range.end.row)
                                        j--;
                                    
                                    ranges = ranges.slice(i, j + 1);
                                    for (i = 0, j = ranges.length; i &lt; j; i++) {
                                        ranges[i].start.row += range.start.row;
                                        ranges[i].end.row += range.start.row;
                                    }
                                }
                        
                                return ranges;
                            };
                            this.replace = function(input, replacement) {
                                var options = this.$options;
                        
                                var re = this.$assembleRegExp(options);
                                if (options.$isMultiLine)
                                    return replacement;
                        
                                if (!re)
                                    return;
                        
                                var match = re.exec(input);
                                if (!match || match[0].length != input.length)
                                    return null;
                                
                                replacement = input.replace(re, replacement);
                                if (options.preserveCase) {
                                    replacement = replacement.split(&quot;&quot;);
                                    for (var i = Math.min(input.length, input.length); i--; ) {
                                        var ch = input[i];
                                        if (ch &amp;&amp; ch.toLowerCase() != ch)
                                            replacement[i] = replacement[i].toUpperCase();
                                        else
                                            replacement[i] = replacement[i].toLowerCase();
                                    }
                                    replacement = replacement.join(&quot;&quot;);
                                }
                                
                                return replacement;
                            };
                        
                            this.$matchIterator = function(session, options) {
                                var re = this.$assembleRegExp(options);
                                if (!re)
                                    return false;
                        
                                var callback;
                                if (options.$isMultiLine) {
                                    var len = re.length;
                                    var matchIterator = function(line, row, offset) {
                                        var startIndex = line.search(re[0]);
                                        if (startIndex == -1)
                                            return;
                                        for (var i = 1; i &lt; len; i++) {
                                            line = session.getLine(row + i);
                                            if (line.search(re[i]) == -1)
                                                return;
                                        }
                        
                                        var endIndex = line.match(re[len - 1])[0].length;
                        
                                        var range = new Range(row, startIndex, row + len - 1, endIndex);
                                        if (re.offset == 1) {
                                            range.start.row--;
                                            range.start.column = Number.MAX_VALUE;
                                        } else if (offset)
                                            range.start.column += offset;
                        
                                        if (callback(range))
                                            return true;
                                    };
                                } else if (options.backwards) {
                                    var matchIterator = function(line, row, startIndex) {
                                        var matches = lang.getMatchOffsets(line, re);
                                        for (var i = matches.length-1; i &gt;= 0; i--)
                                            if (callback(matches[i], row, startIndex))
                                                return true;
                                    };
                                } else {
                                    var matchIterator = function(line, row, startIndex) {
                                        var matches = lang.getMatchOffsets(line, re);
                                        for (var i = 0; i &lt; matches.length; i++)
                                            if (callback(matches[i], row, startIndex))
                                                return true;
                                    };
                                }
                                
                                var lineIterator = this.$lineIterator(session, options);
                        
                                return {
                                    forEach: function(_callback) {
                                        callback = _callback;
                                        lineIterator.forEach(matchIterator);
                                    }
                                };
                            };
                        
                            this.$assembleRegExp = function(options, $disableFakeMultiline) {
                                if (options.needle instanceof RegExp)
                                    return options.re = options.needle;
                        
                                var needle = options.needle;
                        
                                if (!options.needle)
                                    return options.re = false;
                        
                                if (!options.regExp)
                                    needle = lang.escapeRegExp(needle);
                        
                                if (options.wholeWord)
                                    needle = &quot;\\b&quot; + needle + &quot;\\b&quot;;
                        
                                var modifier = options.caseSensitive ? &quot;gm&quot; : &quot;gmi&quot;;
                        
                                options.$isMultiLine = !$disableFakeMultiline &amp;&amp; /[\n\r]/.test(needle);
                                if (options.$isMultiLine)
                                    return options.re = this.$assembleMultilineRegExp(needle, modifier);
                        
                                try {
                                    var re = new RegExp(needle, modifier);
                                } catch(e) {
                                    re = false;
                                }
                                return options.re = re;
                            };
                        
                            this.$assembleMultilineRegExp = function(needle, modifier) {
                                var parts = needle.replace(/\r\n|\r|\n/g, &quot;$\n^&quot;).split(&quot;\n&quot;);
                                var re = [];
                                for (var i = 0; i &lt; parts.length; i++) try {
                                    re.push(new RegExp(parts[i], modifier));
                                } catch(e) {
                                    return false;
                                }
                                if (parts[0] == &quot;&quot;) {
                                    re.shift();
                                    re.offset = 1;
                                } else {
                                    re.offset = 0;
                                }
                                return re;
                            };
                        
                            this.$lineIterator = function(session, options) {
                                var backwards = options.backwards == true;
                                var skipCurrent = options.skipCurrent != false;
                        
                                var range = options.range;
                                var start = options.start;
                                if (!start)
                                    start = range ? range[backwards ? &quot;end&quot; : &quot;start&quot;] : session.selection.getRange();
                                 
                                if (start.start)
                                    start = start[skipCurrent != backwards ? &quot;end&quot; : &quot;start&quot;];
                        
                                var firstRow = range ? range.start.row : 0;
                                var lastRow = range ? range.end.row : session.getLength() - 1;
                        
                                var forEach = backwards ? function(callback) {
                                        var row = start.row;
                        
                                        var line = session.getLine(row).substring(0, start.column);
                                        if (callback(line, row))
                                            return;
                        
                                        for (row--; row &gt;= firstRow; row--)
                                            if (callback(session.getLine(row), row))
                                                return;
                        
                                        if (options.wrap == false)
                                            return;
                        
                                        for (row = lastRow, firstRow = start.row; row &gt;= firstRow; row--)
                                            if (callback(session.getLine(row), row))
                                                return;
                                    } : function(callback) {
                                        var row = start.row;
                        
                                        var line = session.getLine(row).substr(start.column);
                                        if (callback(line, row, start.column))
                                            return;
                        
                                        for (row = row+1; row &lt;= lastRow; row++)
                                            if (callback(session.getLine(row), row))
                                                return;
                        
                                        if (options.wrap == false)
                                            return;
                        
                                        for (row = firstRow, lastRow = start.row; row &lt;= lastRow; row++)
                                            if (callback(session.getLine(row), row))
                                                return;
                                    };
                                
                                return {forEach: forEach};
                            };
                        
                        }).call(Search.prototype);
                        
                        exports.Search = Search;
                        });
                        
                        define(&quot;ace/keyboard/hash_handler&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/keys&quot;,&quot;ace/lib/useragent&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var keyUtil = require(&quot;../lib/keys&quot;);
                        var useragent = require(&quot;../lib/useragent&quot;);
                        var KEY_MODS = keyUtil.KEY_MODS;
                        
                        function HashHandler(config, platform) {
                            this.platform = platform || (useragent.isMac ? &quot;mac&quot; : &quot;win&quot;);
                            this.commands = {};
                            this.commandKeyBinding = {};
                            this.addCommands(config);
                            this.$singleCommand = true;
                        }
                        
                        function MultiHashHandler(config, platform) {
                            HashHandler.call(this, config, platform);
                            this.$singleCommand = false;
                        }
                        
                        MultiHashHandler.prototype = HashHandler.prototype;
                        
                        (function() {
                            
                        
                            this.addCommand = function(command) {
                                if (this.commands[command.name])
                                    this.removeCommand(command);
                        
                                this.commands[command.name] = command;
                        
                                if (command.bindKey)
                                    this._buildKeyHash(command);
                            };
                        
                            this.removeCommand = function(command, keepCommand) {
                                var name = command &amp;&amp; (typeof command === &#x27;string&#x27; ? command : command.name);
                                command = this.commands[name];
                                if (!keepCommand)
                                    delete this.commands[name];
                                var ckb = this.commandKeyBinding;
                                for (var keyId in ckb) {
                                    var cmdGroup = ckb[keyId];
                                    if (cmdGroup == command) {
                                        delete ckb[keyId];
                                    } else if (Array.isArray(cmdGroup)) {
                                        var i = cmdGroup.indexOf(command);
                                        if (i != -1) {
                                            cmdGroup.splice(i, 1);
                                            if (cmdGroup.length == 1)
                                                ckb[keyId] = cmdGroup[0];
                                        }
                                    }
                                }
                            };
                        
                            this.bindKey = function(key, command, position) {
                                if (typeof key == &quot;object&quot;) {
                                    if (position == undefined)
                                        position = key.position;
                                    key = key[this.platform];
                                }
                                if (!key)
                                    return;
                                if (typeof command == &quot;function&quot;)
                                    return this.addCommand({exec: command, bindKey: key, name: command.name || key});
                                
                                key.split(&quot;|&quot;).forEach(function(keyPart) {
                                    var chain = &quot;&quot;;
                                    if (keyPart.indexOf(&quot; &quot;) != -1) {
                                        var parts = keyPart.split(/\s+/);
                                        keyPart = parts.pop();
                                        parts.forEach(function(keyPart) {
                                            var binding = this.parseKeys(keyPart);
                                            var id = KEY_MODS[binding.hashId] + binding.key;
                                            chain += (chain ? &quot; &quot; : &quot;&quot;) + id;
                                            this._addCommandToBinding(chain, &quot;chainKeys&quot;);
                                        }, this);
                                        chain += &quot; &quot;;
                                    }
                                    var binding = this.parseKeys(keyPart);
                                    var id = KEY_MODS[binding.hashId] + binding.key;
                                    this._addCommandToBinding(chain + id, command, position);
                                }, this);
                            };
                            
                            function getPosition(command) {
                                return typeof command == &quot;object&quot; &amp;&amp; command.bindKey
                                    &amp;&amp; command.bindKey.position || 0;
                            }
                            this._addCommandToBinding = function(keyId, command, position) {
                                var ckb = this.commandKeyBinding, i;
                                if (!command) {
                                    delete ckb[keyId];
                                } else if (!ckb[keyId] || this.$singleCommand) {
                                    ckb[keyId] = command;
                                } else {
                                    if (!Array.isArray(ckb[keyId])) {
                                        ckb[keyId] = [ckb[keyId]];
                                    } else if ((i = ckb[keyId].indexOf(command)) != -1) {
                                        ckb[keyId].splice(i, 1);
                                    }
                        
                                    if (typeof position != &quot;number&quot;) {
                                        if (position || command.isDefault)
                                            position = -100;
                                        else
                                           position = getPosition(command);
                                    }
                                    var commands = ckb[keyId];
                                    for (i = 0; i &lt; commands.length; i++) {
                                        var other = commands[i];
                                        var otherPos = getPosition(other);
                                        if (otherPos &gt; position)
                                            break;
                                    }
                                    commands.splice(i, 0, command);
                                }
                            };
                        
                            this.addCommands = function(commands) {
                                commands &amp;&amp; Object.keys(commands).forEach(function(name) {
                                    var command = commands[name];
                                    if (!command)
                                        return;
                                    
                                    if (typeof command === &quot;string&quot;)
                                        return this.bindKey(command, name);
                        
                                    if (typeof command === &quot;function&quot;)
                                        command = { exec: command };
                        
                                    if (typeof command !== &quot;object&quot;)
                                        return;
                        
                                    if (!command.name)
                                        command.name = name;
                        
                                    this.addCommand(command);
                                }, this);
                            };
                        
                            this.removeCommands = function(commands) {
                                Object.keys(commands).forEach(function(name) {
                                    this.removeCommand(commands[name]);
                                }, this);
                            };
                        
                            this.bindKeys = function(keyList) {
                                Object.keys(keyList).forEach(function(key) {
                                    this.bindKey(key, keyList[key]);
                                }, this);
                            };
                        
                            this._buildKeyHash = function(command) {
                                this.bindKey(command.bindKey, command);
                            };
                            this.parseKeys = function(keys) {
                                var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x){return x});
                                var key = parts.pop();
                        
                                var keyCode = keyUtil[key];
                                if (keyUtil.FUNCTION_KEYS[keyCode])
                                    key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
                                else if (!parts.length)
                                    return {key: key, hashId: -1};
                                else if (parts.length == 1 &amp;&amp; parts[0] == &quot;shift&quot;)
                                    return {key: key.toUpperCase(), hashId: -1};
                        
                                var hashId = 0;
                                for (var i = parts.length; i--;) {
                                    var modifier = keyUtil.KEY_MODS[parts[i]];
                                    if (modifier == null) {
                                        if (typeof console != &quot;undefined&quot;)
                                            console.error(&quot;invalid modifier &quot; + parts[i] + &quot; in &quot; + keys);
                                        return false;
                                    }
                                    hashId |= modifier;
                                }
                                return {key: key, hashId: hashId};
                            };
                        
                            this.findKeyCommand = function findKeyCommand(hashId, keyString) {
                                var key = KEY_MODS[hashId] + keyString;
                                return this.commandKeyBinding[key];
                            };
                        
                            this.handleKeyboard = function(data, hashId, keyString, keyCode) {
                                var key = KEY_MODS[hashId] + keyString;
                                var command = this.commandKeyBinding[key];
                                if (data.$keyChain) {
                                    data.$keyChain += &quot; &quot; + key;
                                    command = this.commandKeyBinding[data.$keyChain] || command;
                                }
                                
                                if (command) {
                                    if (command == &quot;chainKeys&quot; || command[command.length - 1] == &quot;chainKeys&quot;) {
                                        data.$keyChain = data.$keyChain || key;
                                        return {command: &quot;null&quot;};
                                    }
                                }
                                
                                if (data.$keyChain) {
                                    if ((!hashId || hashId == 4) &amp;&amp; keyString.length == 1)
                                        data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input
                                    else if (hashId == -1 || keyCode &gt; 0)
                                        data.$keyChain = &quot;&quot;; // reset keyChain
                                }
                                return {command: command};
                            };
                            
                            this.getStatusText = function(editor, data) {
                                return data.$keyChain || &quot;&quot;;
                            };
                        
                        }).call(HashHandler.prototype);
                        
                        exports.HashHandler = HashHandler;
                        exports.MultiHashHandler = MultiHashHandler;
                        });
                        
                        define(&quot;ace/commands/command_manager&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/keyboard/hash_handler&quot;,&quot;ace/lib/event_emitter&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var oop = require(&quot;../lib/oop&quot;);
                        var MultiHashHandler = require(&quot;../keyboard/hash_handler&quot;).MultiHashHandler;
                        var EventEmitter = require(&quot;../lib/event_emitter&quot;).EventEmitter;
                        
                        var CommandManager = function(platform, commands) {
                            MultiHashHandler.call(this, commands, platform);
                            this.byName = this.commands;
                            this.setDefaultHandler(&quot;exec&quot;, function(e) {
                                return e.command.exec(e.editor, e.args || {});
                            });
                        };
                        
                        oop.inherits(CommandManager, MultiHashHandler);
                        
                        (function() {
                        
                            oop.implement(this, EventEmitter);
                        
                            this.exec = function(command, editor, args) {
                                if (Array.isArray(command)) {
                                    for (var i = command.length; i--; ) {
                                        if (this.exec(command[i], editor, args)) return true;
                                    }
                                    return false;
                                }
                                
                                if (typeof command === &quot;string&quot;)
                                    command = this.commands[command];
                        
                                if (!command)
                                    return false;
                        
                                if (editor &amp;&amp; editor.$readOnly &amp;&amp; !command.readOnly)
                                    return false;
                        
                                var e = {editor: editor, command: command, args: args};
                                e.returnValue = this._emit(&quot;exec&quot;, e);
                                this._signal(&quot;afterExec&quot;, e);
                        
                                return e.returnValue === false ? false : true;
                            };
                        
                            this.toggleRecording = function(editor) {
                                if (this.$inReplay)
                                    return;
                        
                                editor &amp;&amp; editor._emit(&quot;changeStatus&quot;);
                                if (this.recording) {
                                    this.macro.pop();
                                    this.removeEventListener(&quot;exec&quot;, this.$addCommandToMacro);
                        
                                    if (!this.macro.length)
                                        this.macro = this.oldMacro;
                        
                                    return this.recording = false;
                                }
                                if (!this.$addCommandToMacro) {
                                    this.$addCommandToMacro = function(e) {
                                        this.macro.push([e.command, e.args]);
                                    }.bind(this);
                                }
                        
                                this.oldMacro = this.macro;
                                this.macro = [];
                                this.on(&quot;exec&quot;, this.$addCommandToMacro);
                                return this.recording = true;
                            };
                        
                            this.replay = function(editor) {
                                if (this.$inReplay || !this.macro)
                                    return;
                        
                                if (this.recording)
                                    return this.toggleRecording(editor);
                        
                                try {
                                    this.$inReplay = true;
                                    this.macro.forEach(function(x) {
                                        if (typeof x == &quot;string&quot;)
                                            this.exec(x, editor);
                                        else
                                            this.exec(x[0], editor, x[1]);
                                    }, this);
                                } finally {
                                    this.$inReplay = false;
                                }
                            };
                        
                            this.trimMacro = function(m) {
                                return m.map(function(x){
                                    if (typeof x[0] != &quot;string&quot;)
                                        x[0] = x[0].name;
                                    if (!x[1])
                                        x = x[0];
                                    return x;
                                });
                            };
                        
                        }).call(CommandManager.prototype);
                        
                        exports.CommandManager = CommandManager;
                        
                        });
                        
                        define(&quot;ace/commands/default_commands&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/lang&quot;,&quot;ace/config&quot;,&quot;ace/range&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var lang = require(&quot;../lib/lang&quot;);
                        var config = require(&quot;../config&quot;);
                        var Range = require(&quot;../range&quot;).Range;
                        
                        function bindKey(win, mac) {
                            return {win: win, mac: mac};
                        }
                        exports.commands = [{
                            name: &quot;showSettingsMenu&quot;,
                            bindKey: bindKey(&quot;Ctrl-,&quot;, &quot;Command-,&quot;),
                            exec: function(editor) {
                                config.loadModule(&quot;ace/ext/settings_menu&quot;, function(module) {
                                    module.init(editor);
                                    editor.showSettingsMenu();
                                });
                            },
                            readOnly: true
                        }, {
                            name: &quot;goToNextError&quot;,
                            bindKey: bindKey(&quot;Alt-E&quot;, &quot;Ctrl-E&quot;),
                            exec: function(editor) {
                                config.loadModule(&quot;ace/ext/error_marker&quot;, function(module) {
                                    module.showErrorMarker(editor, 1);
                                });
                            },
                            scrollIntoView: &quot;animate&quot;,
                            readOnly: true
                        }, {
                            name: &quot;goToPreviousError&quot;,
                            bindKey: bindKey(&quot;Alt-Shift-E&quot;, &quot;Ctrl-Shift-E&quot;),
                            exec: function(editor) {
                                config.loadModule(&quot;ace/ext/error_marker&quot;, function(module) {
                                    module.showErrorMarker(editor, -1);
                                });
                            },
                            scrollIntoView: &quot;animate&quot;,
                            readOnly: true
                        }, {
                            name: &quot;selectall&quot;,
                            bindKey: bindKey(&quot;Ctrl-A&quot;, &quot;Command-A&quot;),
                            exec: function(editor) { editor.selectAll(); },
                            readOnly: true
                        }, {
                            name: &quot;centerselection&quot;,
                            bindKey: bindKey(null, &quot;Ctrl-L&quot;),
                            exec: function(editor) { editor.centerSelection(); },
                            readOnly: true
                        }, {
                            name: &quot;gotoline&quot;,
                            bindKey: bindKey(&quot;Ctrl-L&quot;, &quot;Command-L&quot;),
                            exec: function(editor) {
                                var line = parseInt(prompt(&quot;Enter line number:&quot;), 10);
                                if (!isNaN(line)) {
                                    editor.gotoLine(line);
                                }
                            },
                            readOnly: true
                        }, {
                            name: &quot;fold&quot;,
                            bindKey: bindKey(&quot;Alt-L|Ctrl-F1&quot;, &quot;Command-Alt-L|Command-F1&quot;),
                            exec: function(editor) { editor.session.toggleFold(false); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;center&quot;,
                            readOnly: true
                        }, {
                            name: &quot;unfold&quot;,
                            bindKey: bindKey(&quot;Alt-Shift-L|Ctrl-Shift-F1&quot;, &quot;Command-Alt-Shift-L|Command-Shift-F1&quot;),
                            exec: function(editor) { editor.session.toggleFold(true); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;center&quot;,
                            readOnly: true
                        }, {
                            name: &quot;toggleFoldWidget&quot;,
                            bindKey: bindKey(&quot;F2&quot;, &quot;F2&quot;),
                            exec: function(editor) { editor.session.toggleFoldWidget(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;center&quot;,
                            readOnly: true
                        }, {
                            name: &quot;toggleParentFoldWidget&quot;,
                            bindKey: bindKey(&quot;Alt-F2&quot;, &quot;Alt-F2&quot;),
                            exec: function(editor) { editor.session.toggleFoldWidget(true); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;center&quot;,
                            readOnly: true
                        }, {
                            name: &quot;foldall&quot;,
                            bindKey: bindKey(null, &quot;Ctrl-Command-Option-0&quot;),
                            exec: function(editor) { editor.session.foldAll(); },
                            scrollIntoView: &quot;center&quot;,
                            readOnly: true
                        }, {
                            name: &quot;foldOther&quot;,
                            bindKey: bindKey(&quot;Alt-0&quot;, &quot;Command-Option-0&quot;),
                            exec: function(editor) { 
                                editor.session.foldAll();
                                editor.session.unfold(editor.selection.getAllRanges());
                            },
                            scrollIntoView: &quot;center&quot;,
                            readOnly: true
                        }, {
                            name: &quot;unfoldall&quot;,
                            bindKey: bindKey(&quot;Alt-Shift-0&quot;, &quot;Command-Option-Shift-0&quot;),
                            exec: function(editor) { editor.session.unfold(); },
                            scrollIntoView: &quot;center&quot;,
                            readOnly: true
                        }, {
                            name: &quot;findnext&quot;,
                            bindKey: bindKey(&quot;Ctrl-K&quot;, &quot;Command-G&quot;),
                            exec: function(editor) { editor.findNext(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;center&quot;,
                            readOnly: true
                        }, {
                            name: &quot;findprevious&quot;,
                            bindKey: bindKey(&quot;Ctrl-Shift-K&quot;, &quot;Command-Shift-G&quot;),
                            exec: function(editor) { editor.findPrevious(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;center&quot;,
                            readOnly: true
                        }, {
                            name: &quot;selectOrFindNext&quot;,
                            bindKey: bindKey(&quot;Alt-K&quot;, &quot;Ctrl-G&quot;),
                            exec: function(editor) {
                                if (editor.selection.isEmpty())
                                    editor.selection.selectWord();
                                else
                                    editor.findNext(); 
                            },
                            readOnly: true
                        }, {
                            name: &quot;selectOrFindPrevious&quot;,
                            bindKey: bindKey(&quot;Alt-Shift-K&quot;, &quot;Ctrl-Shift-G&quot;),
                            exec: function(editor) { 
                                if (editor.selection.isEmpty())
                                    editor.selection.selectWord();
                                else
                                    editor.findPrevious();
                            },
                            readOnly: true
                        }, {
                            name: &quot;find&quot;,
                            bindKey: bindKey(&quot;Ctrl-F&quot;, &quot;Command-F&quot;),
                            exec: function(editor) {
                                config.loadModule(&quot;ace/ext/searchbox&quot;, function(e) {e.Search(editor)});
                            },
                            readOnly: true
                        }, {
                            name: &quot;overwrite&quot;,
                            bindKey: &quot;Insert&quot;,
                            exec: function(editor) { editor.toggleOverwrite(); },
                            readOnly: true
                        }, {
                            name: &quot;selecttostart&quot;,
                            bindKey: bindKey(&quot;Ctrl-Shift-Home&quot;, &quot;Command-Shift-Up&quot;),
                            exec: function(editor) { editor.getSelection().selectFileStart(); },
                            multiSelectAction: &quot;forEach&quot;,
                            readOnly: true,
                            scrollIntoView: &quot;animate&quot;,
                            aceCommandGroup: &quot;fileJump&quot;
                        }, {
                            name: &quot;gotostart&quot;,
                            bindKey: bindKey(&quot;Ctrl-Home&quot;, &quot;Command-Home|Command-Up&quot;),
                            exec: function(editor) { editor.navigateFileStart(); },
                            multiSelectAction: &quot;forEach&quot;,
                            readOnly: true,
                            scrollIntoView: &quot;animate&quot;,
                            aceCommandGroup: &quot;fileJump&quot;
                        }, {
                            name: &quot;selectup&quot;,
                            bindKey: bindKey(&quot;Shift-Up&quot;, &quot;Shift-Up&quot;),
                            exec: function(editor) { editor.getSelection().selectUp(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;,
                            readOnly: true
                        }, {
                            name: &quot;golineup&quot;,
                            bindKey: bindKey(&quot;Up&quot;, &quot;Up|Ctrl-P&quot;),
                            exec: function(editor, args) { editor.navigateUp(args.times); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;,
                            readOnly: true
                        }, {
                            name: &quot;selecttoend&quot;,
                            bindKey: bindKey(&quot;Ctrl-Shift-End&quot;, &quot;Command-Shift-Down&quot;),
                            exec: function(editor) { editor.getSelection().selectFileEnd(); },
                            multiSelectAction: &quot;forEach&quot;,
                            readOnly: true,
                            scrollIntoView: &quot;animate&quot;,
                            aceCommandGroup: &quot;fileJump&quot;
                        }, {
                            name: &quot;gotoend&quot;,
                            bindKey: bindKey(&quot;Ctrl-End&quot;, &quot;Command-End|Command-Down&quot;),
                            exec: function(editor) { editor.navigateFileEnd(); },
                            multiSelectAction: &quot;forEach&quot;,
                            readOnly: true,
                            scrollIntoView: &quot;animate&quot;,
                            aceCommandGroup: &quot;fileJump&quot;
                        }, {
                            name: &quot;selectdown&quot;,
                            bindKey: bindKey(&quot;Shift-Down&quot;, &quot;Shift-Down&quot;),
                            exec: function(editor) { editor.getSelection().selectDown(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;,
                            readOnly: true
                        }, {
                            name: &quot;golinedown&quot;,
                            bindKey: bindKey(&quot;Down&quot;, &quot;Down|Ctrl-N&quot;),
                            exec: function(editor, args) { editor.navigateDown(args.times); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;,
                            readOnly: true
                        }, {
                            name: &quot;selectwordleft&quot;,
                            bindKey: bindKey(&quot;Ctrl-Shift-Left&quot;, &quot;Option-Shift-Left&quot;),
                            exec: function(editor) { editor.getSelection().selectWordLeft(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;,
                            readOnly: true
                        }, {
                            name: &quot;gotowordleft&quot;,
                            bindKey: bindKey(&quot;Ctrl-Left&quot;, &quot;Option-Left&quot;),
                            exec: function(editor) { editor.navigateWordLeft(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;,
                            readOnly: true
                        }, {
                            name: &quot;selecttolinestart&quot;,
                            bindKey: bindKey(&quot;Alt-Shift-Left&quot;, &quot;Command-Shift-Left&quot;),
                            exec: function(editor) { editor.getSelection().selectLineStart(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;,
                            readOnly: true
                        }, {
                            name: &quot;gotolinestart&quot;,
                            bindKey: bindKey(&quot;Alt-Left|Home&quot;, &quot;Command-Left|Home|Ctrl-A&quot;),
                            exec: function(editor) { editor.navigateLineStart(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;,
                            readOnly: true
                        }, {
                            name: &quot;selectleft&quot;,
                            bindKey: bindKey(&quot;Shift-Left&quot;, &quot;Shift-Left&quot;),
                            exec: function(editor) { editor.getSelection().selectLeft(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;,
                            readOnly: true
                        }, {
                            name: &quot;gotoleft&quot;,
                            bindKey: bindKey(&quot;Left&quot;, &quot;Left|Ctrl-B&quot;),
                            exec: function(editor, args) { editor.navigateLeft(args.times); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;,
                            readOnly: true
                        }, {
                            name: &quot;selectwordright&quot;,
                            bindKey: bindKey(&quot;Ctrl-Shift-Right&quot;, &quot;Option-Shift-Right&quot;),
                            exec: function(editor) { editor.getSelection().selectWordRight(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;,
                            readOnly: true
                        }, {
                            name: &quot;gotowordright&quot;,
                            bindKey: bindKey(&quot;Ctrl-Right&quot;, &quot;Option-Right&quot;),
                            exec: function(editor) { editor.navigateWordRight(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;,
                            readOnly: true
                        }, {
                            name: &quot;selecttolineend&quot;,
                            bindKey: bindKey(&quot;Alt-Shift-Right&quot;, &quot;Command-Shift-Right&quot;),
                            exec: function(editor) { editor.getSelection().selectLineEnd(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;,
                            readOnly: true
                        }, {
                            name: &quot;gotolineend&quot;,
                            bindKey: bindKey(&quot;Alt-Right|End&quot;, &quot;Command-Right|End|Ctrl-E&quot;),
                            exec: function(editor) { editor.navigateLineEnd(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;,
                            readOnly: true
                        }, {
                            name: &quot;selectright&quot;,
                            bindKey: bindKey(&quot;Shift-Right&quot;, &quot;Shift-Right&quot;),
                            exec: function(editor) { editor.getSelection().selectRight(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;,
                            readOnly: true
                        }, {
                            name: &quot;gotoright&quot;,
                            bindKey: bindKey(&quot;Right&quot;, &quot;Right|Ctrl-F&quot;),
                            exec: function(editor, args) { editor.navigateRight(args.times); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;,
                            readOnly: true
                        }, {
                            name: &quot;selectpagedown&quot;,
                            bindKey: &quot;Shift-PageDown&quot;,
                            exec: function(editor) { editor.selectPageDown(); },
                            readOnly: true
                        }, {
                            name: &quot;pagedown&quot;,
                            bindKey: bindKey(null, &quot;Option-PageDown&quot;),
                            exec: function(editor) { editor.scrollPageDown(); },
                            readOnly: true
                        }, {
                            name: &quot;gotopagedown&quot;,
                            bindKey: bindKey(&quot;PageDown&quot;, &quot;PageDown|Ctrl-V&quot;),
                            exec: function(editor) { editor.gotoPageDown(); },
                            readOnly: true
                        }, {
                            name: &quot;selectpageup&quot;,
                            bindKey: &quot;Shift-PageUp&quot;,
                            exec: function(editor) { editor.selectPageUp(); },
                            readOnly: true
                        }, {
                            name: &quot;pageup&quot;,
                            bindKey: bindKey(null, &quot;Option-PageUp&quot;),
                            exec: function(editor) { editor.scrollPageUp(); },
                            readOnly: true
                        }, {
                            name: &quot;gotopageup&quot;,
                            bindKey: &quot;PageUp&quot;,
                            exec: function(editor) { editor.gotoPageUp(); },
                            readOnly: true
                        }, {
                            name: &quot;scrollup&quot;,
                            bindKey: bindKey(&quot;Ctrl-Up&quot;, null),
                            exec: function(e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },
                            readOnly: true
                        }, {
                            name: &quot;scrolldown&quot;,
                            bindKey: bindKey(&quot;Ctrl-Down&quot;, null),
                            exec: function(e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },
                            readOnly: true
                        }, {
                            name: &quot;selectlinestart&quot;,
                            bindKey: &quot;Shift-Home&quot;,
                            exec: function(editor) { editor.getSelection().selectLineStart(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;,
                            readOnly: true
                        }, {
                            name: &quot;selectlineend&quot;,
                            bindKey: &quot;Shift-End&quot;,
                            exec: function(editor) { editor.getSelection().selectLineEnd(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;,
                            readOnly: true
                        }, {
                            name: &quot;togglerecording&quot;,
                            bindKey: bindKey(&quot;Ctrl-Alt-E&quot;, &quot;Command-Option-E&quot;),
                            exec: function(editor) { editor.commands.toggleRecording(editor); },
                            readOnly: true
                        }, {
                            name: &quot;replaymacro&quot;,
                            bindKey: bindKey(&quot;Ctrl-Shift-E&quot;, &quot;Command-Shift-E&quot;),
                            exec: function(editor) { editor.commands.replay(editor); },
                            readOnly: true
                        }, {
                            name: &quot;jumptomatching&quot;,
                            bindKey: bindKey(&quot;Ctrl-P&quot;, &quot;Ctrl-P&quot;),
                            exec: function(editor) { editor.jumpToMatching(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;animate&quot;,
                            readOnly: true
                        }, {
                            name: &quot;selecttomatching&quot;,
                            bindKey: bindKey(&quot;Ctrl-Shift-P&quot;, &quot;Ctrl-Shift-P&quot;),
                            exec: function(editor) { editor.jumpToMatching(true); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;animate&quot;,
                            readOnly: true
                        }, {
                            name: &quot;expandToMatching&quot;,
                            bindKey: bindKey(&quot;Ctrl-Shift-M&quot;, &quot;Ctrl-Shift-M&quot;),
                            exec: function(editor) { editor.jumpToMatching(true, true); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;animate&quot;,
                            readOnly: true
                        }, {
                            name: &quot;passKeysToBrowser&quot;,
                            bindKey: bindKey(null, null),
                            exec: function() {},
                            passEvent: true,
                            readOnly: true
                        },
                        {
                            name: &quot;cut&quot;,
                            exec: function(editor) {
                                var range = editor.getSelectionRange();
                                editor._emit(&quot;cut&quot;, range);
                        
                                if (!editor.selection.isEmpty()) {
                                    editor.session.remove(range);
                                    editor.clearSelection();
                                }
                            },
                            scrollIntoView: &quot;cursor&quot;,
                            multiSelectAction: &quot;forEach&quot;
                        }, {
                            name: &quot;removeline&quot;,
                            bindKey: bindKey(&quot;Ctrl-D&quot;, &quot;Command-D&quot;),
                            exec: function(editor) { editor.removeLines(); },
                            scrollIntoView: &quot;cursor&quot;,
                            multiSelectAction: &quot;forEachLine&quot;
                        }, {
                            name: &quot;duplicateSelection&quot;,
                            bindKey: bindKey(&quot;Ctrl-Shift-D&quot;, &quot;Command-Shift-D&quot;),
                            exec: function(editor) { editor.duplicateSelection(); },
                            scrollIntoView: &quot;cursor&quot;,
                            multiSelectAction: &quot;forEach&quot;
                        }, {
                            name: &quot;sortlines&quot;,
                            bindKey: bindKey(&quot;Ctrl-Alt-S&quot;, &quot;Command-Alt-S&quot;),
                            exec: function(editor) { editor.sortLines(); },
                            scrollIntoView: &quot;selection&quot;,
                            multiSelectAction: &quot;forEachLine&quot;
                        }, {
                            name: &quot;togglecomment&quot;,
                            bindKey: bindKey(&quot;Ctrl-/&quot;, &quot;Command-/&quot;),
                            exec: function(editor) { editor.toggleCommentLines(); },
                            multiSelectAction: &quot;forEachLine&quot;,
                            scrollIntoView: &quot;selectionPart&quot;
                        }, {
                            name: &quot;toggleBlockComment&quot;,
                            bindKey: bindKey(&quot;Ctrl-Shift-/&quot;, &quot;Command-Shift-/&quot;),
                            exec: function(editor) { editor.toggleBlockComment(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;selectionPart&quot;
                        }, {
                            name: &quot;modifyNumberUp&quot;,
                            bindKey: bindKey(&quot;Ctrl-Shift-Up&quot;, &quot;Alt-Shift-Up&quot;),
                            exec: function(editor) { editor.modifyNumber(1); },
                            scrollIntoView: &quot;cursor&quot;,
                            multiSelectAction: &quot;forEach&quot;
                        }, {
                            name: &quot;modifyNumberDown&quot;,
                            bindKey: bindKey(&quot;Ctrl-Shift-Down&quot;, &quot;Alt-Shift-Down&quot;),
                            exec: function(editor) { editor.modifyNumber(-1); },
                            scrollIntoView: &quot;cursor&quot;,
                            multiSelectAction: &quot;forEach&quot;
                        }, {
                            name: &quot;replace&quot;,
                            bindKey: bindKey(&quot;Ctrl-H&quot;, &quot;Command-Option-F&quot;),
                            exec: function(editor) {
                                config.loadModule(&quot;ace/ext/searchbox&quot;, function(e) {e.Search(editor, true)});
                            }
                        }, {
                            name: &quot;undo&quot;,
                            bindKey: bindKey(&quot;Ctrl-Z&quot;, &quot;Command-Z&quot;),
                            exec: function(editor) { editor.undo(); }
                        }, {
                            name: &quot;redo&quot;,
                            bindKey: bindKey(&quot;Ctrl-Shift-Z|Ctrl-Y&quot;, &quot;Command-Shift-Z|Command-Y&quot;),
                            exec: function(editor) { editor.redo(); }
                        }, {
                            name: &quot;copylinesup&quot;,
                            bindKey: bindKey(&quot;Alt-Shift-Up&quot;, &quot;Command-Option-Up&quot;),
                            exec: function(editor) { editor.copyLinesUp(); },
                            scrollIntoView: &quot;cursor&quot;
                        }, {
                            name: &quot;movelinesup&quot;,
                            bindKey: bindKey(&quot;Alt-Up&quot;, &quot;Option-Up&quot;),
                            exec: function(editor) { editor.moveLinesUp(); },
                            scrollIntoView: &quot;cursor&quot;
                        }, {
                            name: &quot;copylinesdown&quot;,
                            bindKey: bindKey(&quot;Alt-Shift-Down&quot;, &quot;Command-Option-Down&quot;),
                            exec: function(editor) { editor.copyLinesDown(); },
                            scrollIntoView: &quot;cursor&quot;
                        }, {
                            name: &quot;movelinesdown&quot;,
                            bindKey: bindKey(&quot;Alt-Down&quot;, &quot;Option-Down&quot;),
                            exec: function(editor) { editor.moveLinesDown(); },
                            scrollIntoView: &quot;cursor&quot;
                        }, {
                            name: &quot;del&quot;,
                            bindKey: bindKey(&quot;Delete&quot;, &quot;Delete|Ctrl-D|Shift-Delete&quot;),
                            exec: function(editor) { editor.remove(&quot;right&quot;); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;
                        }, {
                            name: &quot;backspace&quot;,
                            bindKey: bindKey(
                                &quot;Shift-Backspace|Backspace&quot;,
                                &quot;Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H&quot;
                            ),
                            exec: function(editor) { editor.remove(&quot;left&quot;); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;
                        }, {
                            name: &quot;cut_or_delete&quot;,
                            bindKey: bindKey(&quot;Shift-Delete&quot;, null),
                            exec: function(editor) { 
                                if (editor.selection.isEmpty()) {
                                    editor.remove(&quot;left&quot;);
                                } else {
                                    return false;
                                }
                            },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;
                        }, {
                            name: &quot;removetolinestart&quot;,
                            bindKey: bindKey(&quot;Alt-Backspace&quot;, &quot;Command-Backspace&quot;),
                            exec: function(editor) { editor.removeToLineStart(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;
                        }, {
                            name: &quot;removetolineend&quot;,
                            bindKey: bindKey(&quot;Alt-Delete&quot;, &quot;Ctrl-K&quot;),
                            exec: function(editor) { editor.removeToLineEnd(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;
                        }, {
                            name: &quot;removewordleft&quot;,
                            bindKey: bindKey(&quot;Ctrl-Backspace&quot;, &quot;Alt-Backspace|Ctrl-Alt-Backspace&quot;),
                            exec: function(editor) { editor.removeWordLeft(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;
                        }, {
                            name: &quot;removewordright&quot;,
                            bindKey: bindKey(&quot;Ctrl-Delete&quot;, &quot;Alt-Delete&quot;),
                            exec: function(editor) { editor.removeWordRight(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;
                        }, {
                            name: &quot;outdent&quot;,
                            bindKey: bindKey(&quot;Shift-Tab&quot;, &quot;Shift-Tab&quot;),
                            exec: function(editor) { editor.blockOutdent(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;selectionPart&quot;
                        }, {
                            name: &quot;indent&quot;,
                            bindKey: bindKey(&quot;Tab&quot;, &quot;Tab&quot;),
                            exec: function(editor) { editor.indent(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;selectionPart&quot;
                        }, {
                            name: &quot;blockoutdent&quot;,
                            bindKey: bindKey(&quot;Ctrl-[&quot;, &quot;Ctrl-[&quot;),
                            exec: function(editor) { editor.blockOutdent(); },
                            multiSelectAction: &quot;forEachLine&quot;,
                            scrollIntoView: &quot;selectionPart&quot;
                        }, {
                            name: &quot;blockindent&quot;,
                            bindKey: bindKey(&quot;Ctrl-]&quot;, &quot;Ctrl-]&quot;),
                            exec: function(editor) { editor.blockIndent(); },
                            multiSelectAction: &quot;forEachLine&quot;,
                            scrollIntoView: &quot;selectionPart&quot;
                        }, {
                            name: &quot;insertstring&quot;,
                            exec: function(editor, str) { editor.insert(str); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;
                        }, {
                            name: &quot;inserttext&quot;,
                            exec: function(editor, args) {
                                editor.insert(lang.stringRepeat(args.text  || &quot;&quot;, args.times || 1));
                            },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;
                        }, {
                            name: &quot;splitline&quot;,
                            bindKey: bindKey(null, &quot;Ctrl-O&quot;),
                            exec: function(editor) { editor.splitLine(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;
                        }, {
                            name: &quot;transposeletters&quot;,
                            bindKey: bindKey(&quot;Ctrl-T&quot;, &quot;Ctrl-T&quot;),
                            exec: function(editor) { editor.transposeLetters(); },
                            multiSelectAction: function(editor) {editor.transposeSelections(1); },
                            scrollIntoView: &quot;cursor&quot;
                        }, {
                            name: &quot;touppercase&quot;,
                            bindKey: bindKey(&quot;Ctrl-U&quot;, &quot;Ctrl-U&quot;),
                            exec: function(editor) { editor.toUpperCase(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;
                        }, {
                            name: &quot;tolowercase&quot;,
                            bindKey: bindKey(&quot;Ctrl-Shift-U&quot;, &quot;Ctrl-Shift-U&quot;),
                            exec: function(editor) { editor.toLowerCase(); },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;
                        }, {
                            name: &quot;expandtoline&quot;,
                            bindKey: bindKey(&quot;Ctrl-Shift-L&quot;, &quot;Command-Shift-L&quot;),
                            exec: function(editor) {
                                var range = editor.selection.getRange();
                        
                                range.start.column = range.end.column = 0;
                                range.end.row++;
                                editor.selection.setRange(range, false);
                            },
                            multiSelectAction: &quot;forEach&quot;,
                            scrollIntoView: &quot;cursor&quot;,
                            readOnly: true
                        }, {
                            name: &quot;joinlines&quot;,
                            bindKey: bindKey(null, null),
                            exec: function(editor) {
                                var isBackwards = editor.selection.isBackwards();
                                var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
                                var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
                                var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
                                var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
                                var selectedCount = selectedText.replace(/\n\s*/, &quot; &quot;).length;
                                var insertLine = editor.session.doc.getLine(selectionStart.row);
                        
                                for (var i = selectionStart.row + 1; i &lt;= selectionEnd.row + 1; i++) {
                                    var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
                                    if (curLine.length !== 0) {
                                        curLine = &quot; &quot; + curLine;
                                    }
                                    insertLine += curLine;
                                }
                        
                                if (selectionEnd.row + 1 &lt; (editor.session.doc.getLength() - 1)) {
                                    insertLine += editor.session.doc.getNewLineCharacter();
                                }
                        
                                editor.clearSelection();
                                editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);
                        
                                if (selectedCount &gt; 0) {
                                    editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
                                    editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
                                } else {
                                    firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length &gt; firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;
                                    editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
                                }
                            },
                            multiSelectAction: &quot;forEach&quot;,
                            readOnly: true
                        }, {
                            name: &quot;invertSelection&quot;,
                            bindKey: bindKey(null, null),
                            exec: function(editor) {
                                var endRow = editor.session.doc.getLength() - 1;
                                var endCol = editor.session.doc.getLine(endRow).length;
                                var ranges = editor.selection.rangeList.ranges;
                                var newRanges = [];
                                if (ranges.length &lt; 1) {
                                    ranges = [editor.selection.getRange()];
                                }
                        
                                for (var i = 0; i &lt; ranges.length; i++) {
                                    if (i == (ranges.length - 1)) {
                                        if (!(ranges[i].end.row === endRow &amp;&amp; ranges[i].end.column === endCol)) {
                                            newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
                                        }
                                    }
                        
                                    if (i === 0) {
                                        if (!(ranges[i].start.row === 0 &amp;&amp; ranges[i].start.column === 0)) {
                                            newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
                                        }
                                    } else {
                                        newRanges.push(new Range(ranges[i-1].end.row, ranges[i-1].end.column, ranges[i].start.row, ranges[i].start.column));
                                    }
                                }
                        
                                editor.exitMultiSelectMode();
                                editor.clearSelection();
                        
                                for(var i = 0; i &lt; newRanges.length; i++) {
                                    editor.selection.addRange(newRanges[i], false);
                                }
                            },
                            readOnly: true,
                            scrollIntoView: &quot;none&quot;
                        }];
                        
                        });
                        
                        define(&quot;ace/editor&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/fixoldbrowsers&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/dom&quot;,&quot;ace/lib/lang&quot;,&quot;ace/lib/useragent&quot;,&quot;ace/keyboard/textinput&quot;,&quot;ace/mouse/mouse_handler&quot;,&quot;ace/mouse/fold_handler&quot;,&quot;ace/keyboard/keybinding&quot;,&quot;ace/edit_session&quot;,&quot;ace/search&quot;,&quot;ace/range&quot;,&quot;ace/lib/event_emitter&quot;,&quot;ace/commands/command_manager&quot;,&quot;ace/commands/default_commands&quot;,&quot;ace/config&quot;,&quot;ace/token_iterator&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        require(&quot;./lib/fixoldbrowsers&quot;);
                        
                        var oop = require(&quot;./lib/oop&quot;);
                        var dom = require(&quot;./lib/dom&quot;);
                        var lang = require(&quot;./lib/lang&quot;);
                        var useragent = require(&quot;./lib/useragent&quot;);
                        var TextInput = require(&quot;./keyboard/textinput&quot;).TextInput;
                        var MouseHandler = require(&quot;./mouse/mouse_handler&quot;).MouseHandler;
                        var FoldHandler = require(&quot;./mouse/fold_handler&quot;).FoldHandler;
                        var KeyBinding = require(&quot;./keyboard/keybinding&quot;).KeyBinding;
                        var EditSession = require(&quot;./edit_session&quot;).EditSession;
                        var Search = require(&quot;./search&quot;).Search;
                        var Range = require(&quot;./range&quot;).Range;
                        var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
                        var CommandManager = require(&quot;./commands/command_manager&quot;).CommandManager;
                        var defaultCommands = require(&quot;./commands/default_commands&quot;).commands;
                        var config = require(&quot;./config&quot;);
                        var TokenIterator = require(&quot;./token_iterator&quot;).TokenIterator;
                        var Editor = function(renderer, session) {
                            var container = renderer.getContainerElement();
                            this.container = container;
                            this.renderer = renderer;
                        
                            this.commands = new CommandManager(useragent.isMac ? &quot;mac&quot; : &quot;win&quot;, defaultCommands);
                            this.textInput  = new TextInput(renderer.getTextAreaContainer(), this);
                            this.renderer.textarea = this.textInput.getElement();
                            this.keyBinding = new KeyBinding(this);
                            this.$mouseHandler = new MouseHandler(this);
                            new FoldHandler(this);
                        
                            this.$blockScrolling = 0;
                            this.$search = new Search().set({
                                wrap: true
                            });
                        
                            this.$historyTracker = this.$historyTracker.bind(this);
                            this.commands.on(&quot;exec&quot;, this.$historyTracker);
                        
                            this.$initOperationListeners();
                            
                            this._$emitInputEvent = lang.delayedCall(function() {
                                this._signal(&quot;input&quot;, {});
                                if (this.session &amp;&amp; this.session.bgTokenizer)
                                    this.session.bgTokenizer.scheduleStart();
                            }.bind(this));
                            
                            this.on(&quot;change&quot;, function(_, _self) {
                                _self._$emitInputEvent.schedule(31);
                            });
                        
                            this.setSession(session || new EditSession(&quot;&quot;));
                            config.resetOptions(this);
                            config._signal(&quot;editor&quot;, this);
                        };
                        
                        (function(){
                        
                            oop.implement(this, EventEmitter);
                        
                            this.$initOperationListeners = function() {
                                function last(a) {return a[a.length - 1]}
                        
                                this.selections = [];
                                this.commands.on(&quot;exec&quot;, this.startOperation.bind(this), true);
                                this.commands.on(&quot;afterExec&quot;, this.endOperation.bind(this), true);
                        
                                this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this));
                        
                                this.on(&quot;change&quot;, function() {
                                    this.curOp || this.startOperation();
                                    this.curOp.docChanged = true;
                                }.bind(this), true);
                        
                                this.on(&quot;changeSelection&quot;, function() {
                                    this.curOp || this.startOperation();
                                    this.curOp.selectionChanged = true;
                                }.bind(this), true);
                            };
                        
                            this.curOp = null;
                            this.prevOp = {};
                            this.startOperation = function(commadEvent) {
                                if (this.curOp) {
                                    if (!commadEvent || this.curOp.command)
                                        return;
                                    this.prevOp = this.curOp;
                                }
                                if (!commadEvent) {
                                    this.previousCommand = null;
                                    commadEvent = {};
                                }
                        
                                this.$opResetTimer.schedule();
                                this.curOp = {
                                    command: commadEvent.command || {},
                                    args: commadEvent.args,
                                    scrollTop: this.renderer.scrollTop
                                };
                                if (this.curOp.command.name &amp;&amp; this.curOp.command.scrollIntoView !== undefined)
                                    this.$blockScrolling++;
                            };
                        
                            this.endOperation = function(e) {
                                if (this.curOp) {
                                    if (e &amp;&amp; e.returnValue === false)
                                        return this.curOp = null;
                                    this._signal(&quot;beforeEndOperation&quot;);
                                    var command = this.curOp.command;
                                    if (command.name &amp;&amp; this.$blockScrolling &gt; 0)
                                        this.$blockScrolling--;
                                    var scrollIntoView = command &amp;&amp; command.scrollIntoView;
                                    if (scrollIntoView) {
                                        switch (scrollIntoView) {
                                            case &quot;center-animate&quot;:
                                                scrollIntoView = &quot;animate&quot;;
                                            case &quot;center&quot;:
                                                this.renderer.scrollCursorIntoView(null, 0.5);
                                                break;
                                            case &quot;animate&quot;:
                                            case &quot;cursor&quot;:
                                                this.renderer.scrollCursorIntoView();
                                                break;
                                            case &quot;selectionPart&quot;:
                                                var range = this.selection.getRange();
                                                var config = this.renderer.layerConfig;
                                                if (range.start.row &gt;= config.lastRow || range.end.row &lt;= config.firstRow) {
                                                    this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                                                }
                                                break;
                                            default:
                                                break;
                                        }
                                        if (scrollIntoView == &quot;animate&quot;)
                                            this.renderer.animateScrolling(this.curOp.scrollTop);
                                    }
                                    
                                    this.prevOp = this.curOp;
                                    this.curOp = null;
                                }
                            };
                            this.$mergeableCommands = [&quot;backspace&quot;, &quot;del&quot;, &quot;insertstring&quot;];
                            this.$historyTracker = function(e) {
                                if (!this.$mergeUndoDeltas)
                                    return;
                        
                                var prev = this.prevOp;
                                var mergeableCommands = this.$mergeableCommands;
                                var shouldMerge = prev.command &amp;&amp; (e.command.name == prev.command.name);
                                if (e.command.name == &quot;insertstring&quot;) {
                                    var text = e.args;
                                    if (this.mergeNextCommand === undefined)
                                        this.mergeNextCommand = true;
                        
                                    shouldMerge = shouldMerge
                                        &amp;&amp; this.mergeNextCommand // previous command allows to coalesce with
                                        &amp;&amp; (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type
                        
                                    this.mergeNextCommand = true;
                                } else {
                                    shouldMerge = shouldMerge
                                        &amp;&amp; mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
                                }
                        
                                if (
                                    this.$mergeUndoDeltas != &quot;always&quot;
                                    &amp;&amp; Date.now() - this.sequenceStartTime &gt; 2000
                                ) {
                                    shouldMerge = false; // the sequence is too long
                                }
                        
                                if (shouldMerge)
                                    this.session.mergeUndoDeltas = true;
                                else if (mergeableCommands.indexOf(e.command.name) !== -1)
                                    this.sequenceStartTime = Date.now();
                            };
                            this.setKeyboardHandler = function(keyboardHandler, cb) {
                                if (keyboardHandler &amp;&amp; typeof keyboardHandler === &quot;string&quot;) {
                                    this.$keybindingId = keyboardHandler;
                                    var _self = this;
                                    config.loadModule([&quot;keybinding&quot;, keyboardHandler], function(module) {
                                        if (_self.$keybindingId == keyboardHandler)
                                            _self.keyBinding.setKeyboardHandler(module &amp;&amp; module.handler);
                                        cb &amp;&amp; cb();
                                    });
                                } else {
                                    this.$keybindingId = null;
                                    this.keyBinding.setKeyboardHandler(keyboardHandler);
                                    cb &amp;&amp; cb();
                                }
                            };
                            this.getKeyboardHandler = function() {
                                return this.keyBinding.getKeyboardHandler();
                            };
                            this.setSession = function(session) {
                                if (this.session == session)
                                    return;
                                if (this.curOp) this.endOperation();
                                this.curOp = {};
                        
                                var oldSession = this.session;
                                if (oldSession) {
                                    this.session.removeEventListener(&quot;change&quot;, this.$onDocumentChange);
                                    this.session.removeEventListener(&quot;changeMode&quot;, this.$onChangeMode);
                                    this.session.removeEventListener(&quot;tokenizerUpdate&quot;, this.$onTokenizerUpdate);
                                    this.session.removeEventListener(&quot;changeTabSize&quot;, this.$onChangeTabSize);
                                    this.session.removeEventListener(&quot;changeWrapLimit&quot;, this.$onChangeWrapLimit);
                                    this.session.removeEventListener(&quot;changeWrapMode&quot;, this.$onChangeWrapMode);
                                    this.session.removeEventListener(&quot;onChangeFold&quot;, this.$onChangeFold);
                                    this.session.removeEventListener(&quot;changeFrontMarker&quot;, this.$onChangeFrontMarker);
                                    this.session.removeEventListener(&quot;changeBackMarker&quot;, this.$onChangeBackMarker);
                                    this.session.removeEventListener(&quot;changeBreakpoint&quot;, this.$onChangeBreakpoint);
                                    this.session.removeEventListener(&quot;changeAnnotation&quot;, this.$onChangeAnnotation);
                                    this.session.removeEventListener(&quot;changeOverwrite&quot;, this.$onCursorChange);
                                    this.session.removeEventListener(&quot;changeScrollTop&quot;, this.$onScrollTopChange);
                                    this.session.removeEventListener(&quot;changeScrollLeft&quot;, this.$onScrollLeftChange);
                        
                                    var selection = this.session.getSelection();
                                    selection.removeEventListener(&quot;changeCursor&quot;, this.$onCursorChange);
                                    selection.removeEventListener(&quot;changeSelection&quot;, this.$onSelectionChange);
                                }
                        
                                this.session = session;
                                if (session) {
                                    this.$onDocumentChange = this.onDocumentChange.bind(this);
                                    session.addEventListener(&quot;change&quot;, this.$onDocumentChange);
                                    this.renderer.setSession(session);
                            
                                    this.$onChangeMode = this.onChangeMode.bind(this);
                                    session.addEventListener(&quot;changeMode&quot;, this.$onChangeMode);
                            
                                    this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
                                    session.addEventListener(&quot;tokenizerUpdate&quot;, this.$onTokenizerUpdate);
                            
                                    this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
                                    session.addEventListener(&quot;changeTabSize&quot;, this.$onChangeTabSize);
                            
                                    this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
                                    session.addEventListener(&quot;changeWrapLimit&quot;, this.$onChangeWrapLimit);
                            
                                    this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
                                    session.addEventListener(&quot;changeWrapMode&quot;, this.$onChangeWrapMode);
                            
                                    this.$onChangeFold = this.onChangeFold.bind(this);
                                    session.addEventListener(&quot;changeFold&quot;, this.$onChangeFold);
                            
                                    this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
                                    this.session.addEventListener(&quot;changeFrontMarker&quot;, this.$onChangeFrontMarker);
                            
                                    this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
                                    this.session.addEventListener(&quot;changeBackMarker&quot;, this.$onChangeBackMarker);
                            
                                    this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
                                    this.session.addEventListener(&quot;changeBreakpoint&quot;, this.$onChangeBreakpoint);
                            
                                    this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
                                    this.session.addEventListener(&quot;changeAnnotation&quot;, this.$onChangeAnnotation);
                            
                                    this.$onCursorChange = this.onCursorChange.bind(this);
                                    this.session.addEventListener(&quot;changeOverwrite&quot;, this.$onCursorChange);
                            
                                    this.$onScrollTopChange = this.onScrollTopChange.bind(this);
                                    this.session.addEventListener(&quot;changeScrollTop&quot;, this.$onScrollTopChange);
                            
                                    this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
                                    this.session.addEventListener(&quot;changeScrollLeft&quot;, this.$onScrollLeftChange);
                            
                                    this.selection = session.getSelection();
                                    this.selection.addEventListener(&quot;changeCursor&quot;, this.$onCursorChange);
                            
                                    this.$onSelectionChange = this.onSelectionChange.bind(this);
                                    this.selection.addEventListener(&quot;changeSelection&quot;, this.$onSelectionChange);
                            
                                    this.onChangeMode();
                            
                                    this.$blockScrolling += 1;
                                    this.onCursorChange();
                                    this.$blockScrolling -= 1;
                            
                                    this.onScrollTopChange();
                                    this.onScrollLeftChange();
                                    this.onSelectionChange();
                                    this.onChangeFrontMarker();
                                    this.onChangeBackMarker();
                                    this.onChangeBreakpoint();
                                    this.onChangeAnnotation();
                                    this.session.getUseWrapMode() &amp;&amp; this.renderer.adjustWrapLimit();
                                    this.renderer.updateFull();
                                } else {
                                    this.selection = null;
                                    this.renderer.setSession(session);
                                }
                        
                                this._signal(&quot;changeSession&quot;, {
                                    session: session,
                                    oldSession: oldSession
                                });
                                
                                this.curOp = null;
                                
                                oldSession &amp;&amp; oldSession._signal(&quot;changeEditor&quot;, {oldEditor: this});
                                session &amp;&amp; session._signal(&quot;changeEditor&quot;, {editor: this});
                            };
                            this.getSession = function() {
                                return this.session;
                            };
                            this.setValue = function(val, cursorPos) {
                                this.session.doc.setValue(val);
                        
                                if (!cursorPos)
                                    this.selectAll();
                                else if (cursorPos == 1)
                                    this.navigateFileEnd();
                                else if (cursorPos == -1)
                                    this.navigateFileStart();
                        
                                return val;
                            };
                            this.getValue = function() {
                                return this.session.getValue();
                            };
                            this.getSelection = function() {
                                return this.selection;
                            };
                            this.resize = function(force) {
                                this.renderer.onResize(force);
                            };
                            this.setTheme = function(theme, cb) {
                                this.renderer.setTheme(theme, cb);
                            };
                            this.getTheme = function() {
                                return this.renderer.getTheme();
                            };
                            this.setStyle = function(style) {
                                this.renderer.setStyle(style);
                            };
                            this.unsetStyle = function(style) {
                                this.renderer.unsetStyle(style);
                            };
                            this.getFontSize = function () {
                                return this.getOption(&quot;fontSize&quot;) ||
                                   dom.computedStyle(this.container, &quot;fontSize&quot;);
                            };
                            this.setFontSize = function(size) {
                                this.setOption(&quot;fontSize&quot;, size);
                            };
                        
                            this.$highlightBrackets = function() {
                                if (this.session.$bracketHighlight) {
                                    this.session.removeMarker(this.session.$bracketHighlight);
                                    this.session.$bracketHighlight = null;
                                }
                        
                                if (this.$highlightPending) {
                                    return;
                                }
                                var self = this;
                                this.$highlightPending = true;
                                setTimeout(function() {
                                    self.$highlightPending = false;
                                    var session = self.session;
                                    if (!session || !session.bgTokenizer) return;
                                    var pos = session.findMatchingBracket(self.getCursorPosition());
                                    if (pos) {
                                        var range = new Range(pos.row, pos.column, pos.row, pos.column + 1);
                                    } else if (session.$mode.getMatching) {
                                        var range = session.$mode.getMatching(self.session);
                                    }
                                    if (range)
                                        session.$bracketHighlight = session.addMarker(range, &quot;ace_bracket&quot;, &quot;text&quot;);
                                }, 50);
                            };
                            this.$highlightTags = function() {
                                if (this.$highlightTagPending)
                                    return;
                                var self = this;
                                this.$highlightTagPending = true;
                                setTimeout(function() {
                                    self.$highlightTagPending = false;
                                    
                                    var session = self.session;
                                    if (!session || !session.bgTokenizer) return;
                                    
                                    var pos = self.getCursorPosition();
                                    var iterator = new TokenIterator(self.session, pos.row, pos.column);
                                    var token = iterator.getCurrentToken();
                                    
                                    if (!token || !/\b(?:tag-open|tag-name)/.test(token.type)) {
                                        session.removeMarker(session.$tagHighlight);
                                        session.$tagHighlight = null;
                                        return;
                                    }
                                    
                                    if (token.type.indexOf(&quot;tag-open&quot;) != -1) {
                                        token = iterator.stepForward();
                                        if (!token)
                                            return;
                                    }
                                    
                                    var tag = token.value;
                                    var depth = 0;
                                    var prevToken = iterator.stepBackward();
                                    
                                    if (prevToken.value == &#x27;&lt;&#x27;){
                                        do {
                                            prevToken = token;
                                            token = iterator.stepForward();
                                            
                                            if (token &amp;&amp; token.value === tag &amp;&amp; token.type.indexOf(&#x27;tag-name&#x27;) !== -1) {
                                                if (prevToken.value === &#x27;&lt;&#x27;){
                                                    depth++;
                                                } else if (prevToken.value === &#x27;&lt;/&#x27;){
                                                    depth--;
                                                }
                                            }
                                            
                                        } while (token &amp;&amp; depth &gt;= 0);
                                    } else {
                                        do {
                                            token = prevToken;
                                            prevToken = iterator.stepBackward();
                                            
                                            if (token &amp;&amp; token.value === tag &amp;&amp; token.type.indexOf(&#x27;tag-name&#x27;) !== -1) {
                                                if (prevToken.value === &#x27;&lt;&#x27;) {
                                                    depth++;
                                                } else if (prevToken.value === &#x27;&lt;/&#x27;) {
                                                    depth--;
                                                }
                                            }
                                        } while (prevToken &amp;&amp; depth &lt;= 0);
                                        iterator.stepForward();
                                    }
                                    
                                    if (!token) {
                                        session.removeMarker(session.$tagHighlight);
                                        session.$tagHighlight = null;
                                        return;
                                    }
                                    
                                    var row = iterator.getCurrentTokenRow();
                                    var column = iterator.getCurrentTokenColumn();
                                    var range = new Range(row, column, row, column+token.value.length);
                                    if (session.$tagHighlight &amp;&amp; range.compareRange(session.$backMarkers[session.$tagHighlight].range)!==0) {
                                        session.removeMarker(session.$tagHighlight);
                                        session.$tagHighlight = null;
                                    }
                                    
                                    if (range &amp;&amp; !session.$tagHighlight)
                                        session.$tagHighlight = session.addMarker(range, &quot;ace_bracket&quot;, &quot;text&quot;);
                                }, 50);
                            };
                            this.focus = function() {
                                var _self = this;
                                setTimeout(function() {
                                    _self.textInput.focus();
                                });
                                this.textInput.focus();
                            };
                            this.isFocused = function() {
                                return this.textInput.isFocused();
                            };
                            this.blur = function() {
                                this.textInput.blur();
                            };
                            this.onFocus = function(e) {
                                if (this.$isFocused)
                                    return;
                                this.$isFocused = true;
                                this.renderer.showCursor();
                                this.renderer.visualizeFocus();
                                this._emit(&quot;focus&quot;, e);
                            };
                            this.onBlur = function(e) {
                                if (!this.$isFocused)
                                    return;
                                this.$isFocused = false;
                                this.renderer.hideCursor();
                                this.renderer.visualizeBlur();
                                this._emit(&quot;blur&quot;, e);
                            };
                        
                            this.$cursorChange = function() {
                                this.renderer.updateCursor();
                            };
                            this.onDocumentChange = function(e) {
                                var delta = e.data;
                                var range = delta.range;
                                var lastRow;
                        
                                if (range.start.row == range.end.row &amp;&amp; delta.action != &quot;insertLines&quot; &amp;&amp; delta.action != &quot;removeLines&quot;)
                                    lastRow = range.end.row;
                                else
                                    lastRow = Infinity;
                                this.renderer.updateLines(range.start.row, lastRow, this.session.$useWrapMode);
                        
                                this._signal(&quot;change&quot;, e);
                                this.$cursorChange();
                                this.$updateHighlightActiveLine();
                            };
                        
                            this.onTokenizerUpdate = function(e) {
                                var rows = e.data;
                                this.renderer.updateLines(rows.first, rows.last);
                            };
                        
                        
                            this.onScrollTopChange = function() {
                                this.renderer.scrollToY(this.session.getScrollTop());
                            };
                        
                            this.onScrollLeftChange = function() {
                                this.renderer.scrollToX(this.session.getScrollLeft());
                            };
                            this.onCursorChange = function() {
                                this.$cursorChange();
                        
                                if (!this.$blockScrolling) {
                                    config.warn(&quot;Automatically scrolling cursor into view after selection change&quot;,
                                        &quot;this will be disabled in the next version&quot;,
                                        &quot;set editor.$blockScrolling = Infinity to disable this message&quot;
                                    );
                                    this.renderer.scrollCursorIntoView();
                                }
                        
                                this.$highlightBrackets();
                                this.$highlightTags();
                                this.$updateHighlightActiveLine();
                                this._signal(&quot;changeSelection&quot;);
                            };
                        
                            this.$updateHighlightActiveLine = function() {
                                var session = this.getSession();
                        
                                var highlight;
                                if (this.$highlightActiveLine) {
                                    if ((this.$selectionStyle != &quot;line&quot; || !this.selection.isMultiLine()))
                                        highlight = this.getCursorPosition();
                                    if (this.renderer.$maxLines &amp;&amp; this.session.getLength() === 1 &amp;&amp; !(this.renderer.$minLines &gt; 1))
                                        highlight = false;
                                }
                        
                                if (session.$highlightLineMarker &amp;&amp; !highlight) {
                                    session.removeMarker(session.$highlightLineMarker.id);
                                    session.$highlightLineMarker = null;
                                } else if (!session.$highlightLineMarker &amp;&amp; highlight) {
                                    var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
                                    range.id = session.addMarker(range, &quot;ace_active-line&quot;, &quot;screenLine&quot;);
                                    session.$highlightLineMarker = range;
                                } else if (highlight) {
                                    session.$highlightLineMarker.start.row = highlight.row;
                                    session.$highlightLineMarker.end.row = highlight.row;
                                    session.$highlightLineMarker.start.column = highlight.column;
                                    session._signal(&quot;changeBackMarker&quot;);
                                }
                            };
                        
                            this.onSelectionChange = function(e) {
                                var session = this.session;
                        
                                if (session.$selectionMarker) {
                                    session.removeMarker(session.$selectionMarker);
                                }
                                session.$selectionMarker = null;
                        
                                if (!this.selection.isEmpty()) {
                                    var range = this.selection.getRange();
                                    var style = this.getSelectionStyle();
                                    session.$selectionMarker = session.addMarker(range, &quot;ace_selection&quot;, style);
                                } else {
                                    this.$updateHighlightActiveLine();
                                }
                        
                                var re = this.$highlightSelectedWord &amp;&amp; this.$getSelectionHighLightRegexp();
                                this.session.highlight(re);
                        
                                this._signal(&quot;changeSelection&quot;);
                            };
                        
                            this.$getSelectionHighLightRegexp = function() {
                                var session = this.session;
                        
                                var selection = this.getSelectionRange();
                                if (selection.isEmpty() || selection.isMultiLine())
                                    return;
                        
                                var startOuter = selection.start.column - 1;
                                var endOuter = selection.end.column + 1;
                                var line = session.getLine(selection.start.row);
                                var lineCols = line.length;
                                var needle = line.substring(Math.max(startOuter, 0),
                                                            Math.min(endOuter, lineCols));
                                if ((startOuter &gt;= 0 &amp;&amp; /^[\w\d]/.test(needle)) ||
                                    (endOuter &lt;= lineCols &amp;&amp; /[\w\d]$/.test(needle)))
                                    return;
                        
                                needle = line.substring(selection.start.column, selection.end.column);
                                if (!/^[\w\d]+$/.test(needle))
                                    return;
                        
                                var re = this.$search.$assembleRegExp({
                                    wholeWord: true,
                                    caseSensitive: true,
                                    needle: needle
                                });
                        
                                return re;
                            };
                        
                        
                            this.onChangeFrontMarker = function() {
                                this.renderer.updateFrontMarkers();
                            };
                        
                            this.onChangeBackMarker = function() {
                                this.renderer.updateBackMarkers();
                            };
                        
                        
                            this.onChangeBreakpoint = function() {
                                this.renderer.updateBreakpoints();
                            };
                        
                            this.onChangeAnnotation = function() {
                                this.renderer.setAnnotations(this.session.getAnnotations());
                            };
                        
                        
                            this.onChangeMode = function(e) {
                                this.renderer.updateText();
                                this._emit(&quot;changeMode&quot;, e);
                            };
                        
                        
                            this.onChangeWrapLimit = function() {
                                this.renderer.updateFull();
                            };
                        
                            this.onChangeWrapMode = function() {
                                this.renderer.onResize(true);
                            };
                        
                        
                            this.onChangeFold = function() {
                                this.$updateHighlightActiveLine();
                                this.renderer.updateFull();
                            };
                            this.getSelectedText = function() {
                                return this.session.getTextRange(this.getSelectionRange());
                            };
                            this.getCopyText = function() {
                                var text = this.getSelectedText();
                                this._signal(&quot;copy&quot;, text);
                                return text;
                            };
                            this.onCopy = function() {
                                this.commands.exec(&quot;copy&quot;, this);
                            };
                            this.onCut = function() {
                                this.commands.exec(&quot;cut&quot;, this);
                            };
                            this.onPaste = function(text) {
                                if (this.$readOnly)
                                    return;
                        
                                var e = {text: text};
                                this._signal(&quot;paste&quot;, e);
                                text = e.text;
                                if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
                                    this.insert(text);
                                } else {
                                    var lines = text.split(/\r\n|\r|\n/);
                                    var ranges = this.selection.rangeList.ranges;
                            
                                    if (lines.length &gt; ranges.length || lines.length &lt; 2 || !lines[1])
                                        return this.commands.exec(&quot;insertstring&quot;, this, text);
                            
                                    for (var i = ranges.length; i--;) {
                                        var range = ranges[i];
                                        if (!range.isEmpty())
                                            this.session.remove(range);
                            
                                        this.session.insert(range.start, lines[i]);
                                    }
                                }
                                this.renderer.scrollCursorIntoView();
                            };
                        
                            this.execCommand = function(command, args) {
                                return this.commands.exec(command, this, args);
                            };
                            this.insert = function(text, pasted) {
                                var session = this.session;
                                var mode = session.getMode();
                                var cursor = this.getCursorPosition();
                        
                                if (this.getBehavioursEnabled() &amp;&amp; !pasted) {
                                    var transform = mode.transformAction(session.getState(cursor.row), &#x27;insertion&#x27;, this, session, text);
                                    if (transform) {
                                        if (text !== transform.text) {
                                            this.session.mergeUndoDeltas = false;
                                            this.$mergeNextCommand = false;
                                        }
                                        text = transform.text;
                        
                                    }
                                }
                                
                                if (text == &quot;\t&quot;)
                                    text = this.session.getTabString();
                                if (!this.selection.isEmpty()) {
                                    var range = this.getSelectionRange();
                                    cursor = this.session.remove(range);
                                    this.clearSelection();
                                }
                                else if (this.session.getOverwrite()) {
                                    var range = new Range.fromPoints(cursor, cursor);
                                    range.end.column += text.length;
                                    this.session.remove(range);
                                }
                        
                                if (text == &quot;\n&quot; || text == &quot;\r\n&quot;) {
                                    var line = session.getLine(cursor.row);
                                    if (cursor.column &gt; line.search(/\S|$/)) {
                                        var d = line.substr(cursor.column).search(/\S|$/);
                                        session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
                                    }
                                }
                                this.clearSelection();
                        
                                var start = cursor.column;
                                var lineState = session.getState(cursor.row);
                                var line = session.getLine(cursor.row);
                                var shouldOutdent = mode.checkOutdent(lineState, line, text);
                                var end = session.insert(cursor, text);
                        
                                if (transform &amp;&amp; transform.selection) {
                                    if (transform.selection.length == 2) { // Transform relative to the current column
                                        this.selection.setSelectionRange(
                                            new Range(cursor.row, start + transform.selection[0],
                                                      cursor.row, start + transform.selection[1]));
                                    } else { // Transform relative to the current row.
                                        this.selection.setSelectionRange(
                                            new Range(cursor.row + transform.selection[0],
                                                      transform.selection[1],
                                                      cursor.row + transform.selection[2],
                                                      transform.selection[3]));
                                    }
                                }
                        
                                if (session.getDocument().isNewLine(text)) {
                                    var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());
                        
                                    session.insert({row: cursor.row+1, column: 0}, lineIndent);
                                }
                                if (shouldOutdent)
                                    mode.autoOutdent(lineState, session, cursor.row);
                            };
                        
                            this.onTextInput = function(text) {
                                this.keyBinding.onTextInput(text);
                            };
                        
                            this.onCommandKey = function(e, hashId, keyCode) {
                                this.keyBinding.onCommandKey(e, hashId, keyCode);
                            };
                            this.setOverwrite = function(overwrite) {
                                this.session.setOverwrite(overwrite);
                            };
                            this.getOverwrite = function() {
                                return this.session.getOverwrite();
                            };
                            this.toggleOverwrite = function() {
                                this.session.toggleOverwrite();
                            };
                            this.setScrollSpeed = function(speed) {
                                this.setOption(&quot;scrollSpeed&quot;, speed);
                            };
                            this.getScrollSpeed = function() {
                                return this.getOption(&quot;scrollSpeed&quot;);
                            };
                            this.setDragDelay = function(dragDelay) {
                                this.setOption(&quot;dragDelay&quot;, dragDelay);
                            };
                            this.getDragDelay = function() {
                                return this.getOption(&quot;dragDelay&quot;);
                            };
                            this.setSelectionStyle = function(val) {
                                this.setOption(&quot;selectionStyle&quot;, val);
                            };
                            this.getSelectionStyle = function() {
                                return this.getOption(&quot;selectionStyle&quot;);
                            };
                            this.setHighlightActiveLine = function(shouldHighlight) {
                                this.setOption(&quot;highlightActiveLine&quot;, shouldHighlight);
                            };
                            this.getHighlightActiveLine = function() {
                                return this.getOption(&quot;highlightActiveLine&quot;);
                            };
                            this.setHighlightGutterLine = function(shouldHighlight) {
                                this.setOption(&quot;highlightGutterLine&quot;, shouldHighlight);
                            };
                        
                            this.getHighlightGutterLine = function() {
                                return this.getOption(&quot;highlightGutterLine&quot;);
                            };
                            this.setHighlightSelectedWord = function(shouldHighlight) {
                                this.setOption(&quot;highlightSelectedWord&quot;, shouldHighlight);
                            };
                            this.getHighlightSelectedWord = function() {
                                return this.$highlightSelectedWord;
                            };
                        
                            this.setAnimatedScroll = function(shouldAnimate){
                                this.renderer.setAnimatedScroll(shouldAnimate);
                            };
                        
                            this.getAnimatedScroll = function(){
                                return this.renderer.getAnimatedScroll();
                            };
                            this.setShowInvisibles = function(showInvisibles) {
                                this.renderer.setShowInvisibles(showInvisibles);
                            };
                            this.getShowInvisibles = function() {
                                return this.renderer.getShowInvisibles();
                            };
                        
                            this.setDisplayIndentGuides = function(display) {
                                this.renderer.setDisplayIndentGuides(display);
                            };
                        
                            this.getDisplayIndentGuides = function() {
                                return this.renderer.getDisplayIndentGuides();
                            };
                            this.setShowPrintMargin = function(showPrintMargin) {
                                this.renderer.setShowPrintMargin(showPrintMargin);
                            };
                            this.getShowPrintMargin = function() {
                                return this.renderer.getShowPrintMargin();
                            };
                            this.setPrintMarginColumn = function(showPrintMargin) {
                                this.renderer.setPrintMarginColumn(showPrintMargin);
                            };
                            this.getPrintMarginColumn = function() {
                                return this.renderer.getPrintMarginColumn();
                            };
                            this.setReadOnly = function(readOnly) {
                                this.setOption(&quot;readOnly&quot;, readOnly);
                            };
                            this.getReadOnly = function() {
                                return this.getOption(&quot;readOnly&quot;);
                            };
                            this.setBehavioursEnabled = function (enabled) {
                                this.setOption(&quot;behavioursEnabled&quot;, enabled);
                            };
                            this.getBehavioursEnabled = function () {
                                return this.getOption(&quot;behavioursEnabled&quot;);
                            };
                            this.setWrapBehavioursEnabled = function (enabled) {
                                this.setOption(&quot;wrapBehavioursEnabled&quot;, enabled);
                            };
                            this.getWrapBehavioursEnabled = function () {
                                return this.getOption(&quot;wrapBehavioursEnabled&quot;);
                            };
                            this.setShowFoldWidgets = function(show) {
                                this.setOption(&quot;showFoldWidgets&quot;, show);
                        
                            };
                            this.getShowFoldWidgets = function() {
                                return this.getOption(&quot;showFoldWidgets&quot;);
                            };
                        
                            this.setFadeFoldWidgets = function(fade) {
                                this.setOption(&quot;fadeFoldWidgets&quot;, fade);
                            };
                        
                            this.getFadeFoldWidgets = function() {
                                return this.getOption(&quot;fadeFoldWidgets&quot;);
                            };
                            this.remove = function(dir) {
                                if (this.selection.isEmpty()){
                                    if (dir == &quot;left&quot;)
                                        this.selection.selectLeft();
                                    else
                                        this.selection.selectRight();
                                }
                        
                                var range = this.getSelectionRange();
                                if (this.getBehavioursEnabled()) {
                                    var session = this.session;
                                    var state = session.getState(range.start.row);
                                    var new_range = session.getMode().transformAction(state, &#x27;deletion&#x27;, this, session, range);
                        
                                    if (range.end.column === 0) {
                                        var text = session.getTextRange(range);
                                        if (text[text.length - 1] == &quot;\n&quot;) {
                                            var line = session.getLine(range.end.row);
                                            if (/^\s+$/.test(line)) {
                                                range.end.column = line.length;
                                            }
                                        }
                                    }
                                    if (new_range)
                                        range = new_range;
                                }
                        
                                this.session.remove(range);
                                this.clearSelection();
                            };
                            this.removeWordRight = function() {
                                if (this.selection.isEmpty())
                                    this.selection.selectWordRight();
                        
                                this.session.remove(this.getSelectionRange());
                                this.clearSelection();
                            };
                            this.removeWordLeft = function() {
                                if (this.selection.isEmpty())
                                    this.selection.selectWordLeft();
                        
                                this.session.remove(this.getSelectionRange());
                                this.clearSelection();
                            };
                            this.removeToLineStart = function() {
                                if (this.selection.isEmpty())
                                    this.selection.selectLineStart();
                        
                                this.session.remove(this.getSelectionRange());
                                this.clearSelection();
                            };
                            this.removeToLineEnd = function() {
                                if (this.selection.isEmpty())
                                    this.selection.selectLineEnd();
                        
                                var range = this.getSelectionRange();
                                if (range.start.column == range.end.column &amp;&amp; range.start.row == range.end.row) {
                                    range.end.column = 0;
                                    range.end.row++;
                                }
                        
                                this.session.remove(range);
                                this.clearSelection();
                            };
                            this.splitLine = function() {
                                if (!this.selection.isEmpty()) {
                                    this.session.remove(this.getSelectionRange());
                                    this.clearSelection();
                                }
                        
                                var cursor = this.getCursorPosition();
                                this.insert(&quot;\n&quot;);
                                this.moveCursorToPosition(cursor);
                            };
                            this.transposeLetters = function() {
                                if (!this.selection.isEmpty()) {
                                    return;
                                }
                        
                                var cursor = this.getCursorPosition();
                                var column = cursor.column;
                                if (column === 0)
                                    return;
                        
                                var line = this.session.getLine(cursor.row);
                                var swap, range;
                                if (column &lt; line.length) {
                                    swap = line.charAt(column) + line.charAt(column-1);
                                    range = new Range(cursor.row, column-1, cursor.row, column+1);
                                }
                                else {
                                    swap = line.charAt(column-1) + line.charAt(column-2);
                                    range = new Range(cursor.row, column-2, cursor.row, column);
                                }
                                this.session.replace(range, swap);
                            };
                            this.toLowerCase = function() {
                                var originalRange = this.getSelectionRange();
                                if (this.selection.isEmpty()) {
                                    this.selection.selectWord();
                                }
                        
                                var range = this.getSelectionRange();
                                var text = this.session.getTextRange(range);
                                this.session.replace(range, text.toLowerCase());
                                this.selection.setSelectionRange(originalRange);
                            };
                            this.toUpperCase = function() {
                                var originalRange = this.getSelectionRange();
                                if (this.selection.isEmpty()) {
                                    this.selection.selectWord();
                                }
                        
                                var range = this.getSelectionRange();
                                var text = this.session.getTextRange(range);
                                this.session.replace(range, text.toUpperCase());
                                this.selection.setSelectionRange(originalRange);
                            };
                            this.indent = function() {
                                var session = this.session;
                                var range = this.getSelectionRange();
                        
                                if (range.start.row &lt; range.end.row) {
                                    var rows = this.$getSelectedRows();
                                    session.indentRows(rows.first, rows.last, &quot;\t&quot;);
                                    return;
                                } else if (range.start.column &lt; range.end.column) {
                                    var text = session.getTextRange(range);
                                    if (!/^\s+$/.test(text)) {
                                        var rows = this.$getSelectedRows();
                                        session.indentRows(rows.first, rows.last, &quot;\t&quot;);
                                        return;
                                    }
                                }
                                
                                var line = session.getLine(range.start.row);
                                var position = range.start;
                                var size = session.getTabSize();
                                var column = session.documentToScreenColumn(position.row, position.column);
                        
                                if (this.session.getUseSoftTabs()) {
                                    var count = (size - column % size);
                                    var indentString = lang.stringRepeat(&quot; &quot;, count);
                                } else {
                                    var count = column % size;
                                    while (line[range.start.column] == &quot; &quot; &amp;&amp; count) {
                                        range.start.column--;
                                        count--;
                                    }
                                    this.selection.setSelectionRange(range);
                                    indentString = &quot;\t&quot;;
                                }
                                return this.insert(indentString);
                            };
                            this.blockIndent = function() {
                                var rows = this.$getSelectedRows();
                                this.session.indentRows(rows.first, rows.last, &quot;\t&quot;);
                            };
                            this.blockOutdent = function() {
                                var selection = this.session.getSelection();
                                this.session.outdentRows(selection.getRange());
                            };
                            this.sortLines = function() {
                                var rows = this.$getSelectedRows();
                                var session = this.session;
                        
                                var lines = [];
                                for (i = rows.first; i &lt;= rows.last; i++)
                                    lines.push(session.getLine(i));
                        
                                lines.sort(function(a, b) {
                                    if (a.toLowerCase() &lt; b.toLowerCase()) return -1;
                                    if (a.toLowerCase() &gt; b.toLowerCase()) return 1;
                                    return 0;
                                });
                        
                                var deleteRange = new Range(0, 0, 0, 0);
                                for (var i = rows.first; i &lt;= rows.last; i++) {
                                    var line = session.getLine(i);
                                    deleteRange.start.row = i;
                                    deleteRange.end.row = i;
                                    deleteRange.end.column = line.length;
                                    session.replace(deleteRange, lines[i-rows.first]);
                                }
                            };
                            this.toggleCommentLines = function() {
                                var state = this.session.getState(this.getCursorPosition().row);
                                var rows = this.$getSelectedRows();
                                this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
                            };
                        
                            this.toggleBlockComment = function() {
                                var cursor = this.getCursorPosition();
                                var state = this.session.getState(cursor.row);
                                var range = this.getSelectionRange();
                                this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
                            };
                            this.getNumberAt = function(row, column) {
                                var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
                                _numberRx.lastIndex = 0;
                        
                                var s = this.session.getLine(row);
                                while (_numberRx.lastIndex &lt; column) {
                                    var m = _numberRx.exec(s);
                                    if(m.index &lt;= column &amp;&amp; m.index+m[0].length &gt;= column){
                                        var number = {
                                            value: m[0],
                                            start: m.index,
                                            end: m.index+m[0].length
                                        };
                                        return number;
                                    }
                                }
                                return null;
                            };
                            this.modifyNumber = function(amount) {
                                var row = this.selection.getCursor().row;
                                var column = this.selection.getCursor().column;
                                var charRange = new Range(row, column-1, row, column);
                        
                                var c = this.session.getTextRange(charRange);
                                if (!isNaN(parseFloat(c)) &amp;&amp; isFinite(c)) {
                                    var nr = this.getNumberAt(row, column);
                                    if (nr) {
                                        var fp = nr.value.indexOf(&quot;.&quot;) &gt;= 0 ? nr.start + nr.value.indexOf(&quot;.&quot;) + 1 : nr.end;
                                        var decimals = nr.start + nr.value.length - fp;
                        
                                        var t = parseFloat(nr.value);
                                        t *= Math.pow(10, decimals);
                        
                        
                                        if(fp !== nr.end &amp;&amp; column &lt; fp){
                                            amount *= Math.pow(10, nr.end - column - 1);
                                        } else {
                                            amount *= Math.pow(10, nr.end - column);
                                        }
                        
                                        t += amount;
                                        t /= Math.pow(10, decimals);
                                        var nnr = t.toFixed(decimals);
                                        var replaceRange = new Range(row, nr.start, row, nr.end);
                                        this.session.replace(replaceRange, nnr);
                                        this.moveCursorTo(row, Math.max(nr.start +1, column + nnr.length - nr.value.length));
                        
                                    }
                                }
                            };
                            this.removeLines = function() {
                                var rows = this.$getSelectedRows();
                                var range;
                                if (rows.first === 0 || rows.last+1 &lt; this.session.getLength())
                                    range = new Range(rows.first, 0, rows.last+1, 0);
                                else
                                    range = new Range(
                                        rows.first-1, this.session.getLine(rows.first-1).length,
                                        rows.last, this.session.getLine(rows.last).length
                                    );
                                this.session.remove(range);
                                this.clearSelection();
                            };
                        
                            this.duplicateSelection = function() {
                                var sel = this.selection;
                                var doc = this.session;
                                var range = sel.getRange();
                                var reverse = sel.isBackwards();
                                if (range.isEmpty()) {
                                    var row = range.start.row;
                                    doc.duplicateLines(row, row);
                                } else {
                                    var point = reverse ? range.start : range.end;
                                    var endPoint = doc.insert(point, doc.getTextRange(range), false);
                                    range.start = point;
                                    range.end = endPoint;
                        
                                    sel.setSelectionRange(range, reverse);
                                }
                            };
                            this.moveLinesDown = function() {
                                this.$moveLines(1, false);
                            };
                            this.moveLinesUp = function() {
                                this.$moveLines(-1, false);
                            };
                            this.moveText = function(range, toPosition, copy) {
                                return this.session.moveText(range, toPosition, copy);
                            };
                            this.copyLinesUp = function() {
                                this.$moveLines(-1, true);
                            };
                            this.copyLinesDown = function() {
                                this.$moveLines(1, true);
                            };
                            this.$moveLines = function(dir, copy) {
                                var rows, moved;
                                var selection = this.selection;
                                if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
                                    var range = selection.toOrientedRange();
                                    rows = this.$getSelectedRows(range);
                                    moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
                                    if (copy &amp;&amp; dir == -1) moved = 0;
                                    range.moveBy(moved, 0);
                                    selection.fromOrientedRange(range);
                                } else {
                                    var ranges = selection.rangeList.ranges;
                                    selection.rangeList.detach(this.session);
                                    this.inVirtualSelectionMode = true;
                                    
                                    var diff = 0;
                                    var totalDiff = 0;
                                    var l = ranges.length;
                                    for (var i = 0; i &lt; l; i++) {
                                        var rangeIndex = i;
                                        ranges[i].moveBy(diff, 0);
                                        rows = this.$getSelectedRows(ranges[i]);
                                        var first = rows.first;
                                        var last = rows.last;
                                        while (++i &lt; l) {
                                            if (totalDiff) ranges[i].moveBy(totalDiff, 0);
                                            var subRows = this.$getSelectedRows(ranges[i]);
                                            if (copy &amp;&amp; subRows.first != last)
                                                break;
                                            else if (!copy &amp;&amp; subRows.first &gt; last + 1)
                                                break;
                                            last = subRows.last;
                                        }
                                        i--;
                                        diff = this.session.$moveLines(first, last, copy ? 0 : dir);
                                        if (copy &amp;&amp; dir == -1) rangeIndex = i + 1;
                                        while (rangeIndex &lt;= i) {
                                            ranges[rangeIndex].moveBy(diff, 0);
                                            rangeIndex++;
                                        }
                                        if (!copy) diff = 0;
                                        totalDiff += diff;
                                    }
                                    
                                    selection.fromOrientedRange(selection.ranges[0]);
                                    selection.rangeList.attach(this.session);
                                    this.inVirtualSelectionMode = false;
                                }
                            };
                            this.$getSelectedRows = function(range) {
                                range = (range || this.getSelectionRange()).collapseRows();
                        
                                return {
                                    first: this.session.getRowFoldStart(range.start.row),
                                    last: this.session.getRowFoldEnd(range.end.row)
                                };
                            };
                        
                            this.onCompositionStart = function(text) {
                                this.renderer.showComposition(this.getCursorPosition());
                            };
                        
                            this.onCompositionUpdate = function(text) {
                                this.renderer.setCompositionText(text);
                            };
                        
                            this.onCompositionEnd = function() {
                                this.renderer.hideComposition();
                            };
                            this.getFirstVisibleRow = function() {
                                return this.renderer.getFirstVisibleRow();
                            };
                            this.getLastVisibleRow = function() {
                                return this.renderer.getLastVisibleRow();
                            };
                            this.isRowVisible = function(row) {
                                return (row &gt;= this.getFirstVisibleRow() &amp;&amp; row &lt;= this.getLastVisibleRow());
                            };
                            this.isRowFullyVisible = function(row) {
                                return (row &gt;= this.renderer.getFirstFullyVisibleRow() &amp;&amp; row &lt;= this.renderer.getLastFullyVisibleRow());
                            };
                            this.$getVisibleRowCount = function() {
                                return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
                            };
                        
                            this.$moveByPage = function(dir, select) {
                                var renderer = this.renderer;
                                var config = this.renderer.layerConfig;
                                var rows = dir * Math.floor(config.height / config.lineHeight);
                        
                                this.$blockScrolling++;
                                if (select === true) {
                                    this.selection.$moveSelection(function(){
                                        this.moveCursorBy(rows, 0);
                                    });
                                } else if (select === false) {
                                    this.selection.moveCursorBy(rows, 0);
                                    this.selection.clearSelection();
                                }
                                this.$blockScrolling--;
                        
                                var scrollTop = renderer.scrollTop;
                        
                                renderer.scrollBy(0, rows * config.lineHeight);
                                if (select != null)
                                    renderer.scrollCursorIntoView(null, 0.5);
                        
                                renderer.animateScrolling(scrollTop);
                            };
                            this.selectPageDown = function() {
                                this.$moveByPage(1, true);
                            };
                            this.selectPageUp = function() {
                                this.$moveByPage(-1, true);
                            };
                            this.gotoPageDown = function() {
                               this.$moveByPage(1, false);
                            };
                            this.gotoPageUp = function() {
                                this.$moveByPage(-1, false);
                            };
                            this.scrollPageDown = function() {
                                this.$moveByPage(1);
                            };
                            this.scrollPageUp = function() {
                                this.$moveByPage(-1);
                            };
                            this.scrollToRow = function(row) {
                                this.renderer.scrollToRow(row);
                            };
                            this.scrollToLine = function(line, center, animate, callback) {
                                this.renderer.scrollToLine(line, center, animate, callback);
                            };
                            this.centerSelection = function() {
                                var range = this.getSelectionRange();
                                var pos = {
                                    row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
                                    column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
                                };
                                this.renderer.alignCursor(pos, 0.5);
                            };
                            this.getCursorPosition = function() {
                                return this.selection.getCursor();
                            };
                            this.getCursorPositionScreen = function() {
                                return this.session.documentToScreenPosition(this.getCursorPosition());
                            };
                            this.getSelectionRange = function() {
                                return this.selection.getRange();
                            };
                            this.selectAll = function() {
                                this.$blockScrolling += 1;
                                this.selection.selectAll();
                                this.$blockScrolling -= 1;
                            };
                            this.clearSelection = function() {
                                this.selection.clearSelection();
                            };
                            this.moveCursorTo = function(row, column) {
                                this.selection.moveCursorTo(row, column);
                            };
                            this.moveCursorToPosition = function(pos) {
                                this.selection.moveCursorToPosition(pos);
                            };
                            this.jumpToMatching = function(select, expand) {
                                var cursor = this.getCursorPosition();
                                var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
                                var prevToken = iterator.getCurrentToken();
                                var token = prevToken || iterator.stepForward();
                        
                                if (!token) return;
                                var matchType;
                                var found = false;
                                var depth = {};
                                var i = cursor.column - token.start;
                                var bracketType;
                                var brackets = {
                                    &quot;)&quot;: &quot;(&quot;,
                                    &quot;(&quot;: &quot;(&quot;,
                                    &quot;]&quot;: &quot;[&quot;,
                                    &quot;[&quot;: &quot;[&quot;,
                                    &quot;{&quot;: &quot;{&quot;,
                                    &quot;}&quot;: &quot;{&quot;
                                };
                                
                                do {
                                    if (token.value.match(/[{}()\[\]]/g)) {
                                        for (; i &lt; token.value.length &amp;&amp; !found; i++) {
                                            if (!brackets[token.value[i]]) {
                                                continue;
                                            }
                        
                                            bracketType = brackets[token.value[i]] + &#x27;.&#x27; + token.type.replace(&quot;rparen&quot;, &quot;lparen&quot;);
                        
                                            if (isNaN(depth[bracketType])) {
                                                depth[bracketType] = 0;
                                            }
                        
                                            switch (token.value[i]) {
                                                case &#x27;(&#x27;:
                                                case &#x27;[&#x27;:
                                                case &#x27;{&#x27;:
                                                    depth[bracketType]++;
                                                    break;
                                                case &#x27;)&#x27;:
                                                case &#x27;]&#x27;:
                                                case &#x27;}&#x27;:
                                                    depth[bracketType]--;
                        
                                                    if (depth[bracketType] === -1) {
                                                        matchType = &#x27;bracket&#x27;;
                                                        found = true;
                                                    }
                                                break;
                                            }
                                        }
                                    }
                                    else if (token &amp;&amp; token.type.indexOf(&#x27;tag-name&#x27;) !== -1) {
                                        if (isNaN(depth[token.value])) {
                                            depth[token.value] = 0;
                                        }
                                        
                                        if (prevToken.value === &#x27;&lt;&#x27;) {
                                            depth[token.value]++;
                                        }
                                        else if (prevToken.value === &#x27;&lt;/&#x27;) {
                                            depth[token.value]--;
                                        }
                                        
                                        if (depth[token.value] === -1) {
                                            matchType = &#x27;tag&#x27;;
                                            found = true;
                                        }
                                    }
                        
                                    if (!found) {
                                        prevToken = token;
                                        token = iterator.stepForward();
                                        i = 0;
                                    }
                                } while (token &amp;&amp; !found);
                                if (!matchType)
                                    return;
                        
                                var range, pos;
                                if (matchType === &#x27;bracket&#x27;) {
                                    range = this.session.getBracketRange(cursor);
                                    if (!range) {
                                        range = new Range(
                                            iterator.getCurrentTokenRow(),
                                            iterator.getCurrentTokenColumn() + i - 1,
                                            iterator.getCurrentTokenRow(),
                                            iterator.getCurrentTokenColumn() + i - 1
                                        );
                                        pos = range.start;
                                        if (expand || pos.row === cursor.row &amp;&amp; Math.abs(pos.column - cursor.column) &lt; 2)
                                            range = this.session.getBracketRange(pos);
                                    }
                                }
                                else if (matchType === &#x27;tag&#x27;) {
                                    if (token &amp;&amp; token.type.indexOf(&#x27;tag-name&#x27;) !== -1) 
                                        var tag = token.value;
                                    else
                                        return;
                        
                                    range = new Range(
                                        iterator.getCurrentTokenRow(),
                                        iterator.getCurrentTokenColumn() - 2,
                                        iterator.getCurrentTokenRow(),
                                        iterator.getCurrentTokenColumn() - 2
                                    );
                                    if (range.compare(cursor.row, cursor.column) === 0) {
                                        found = false;
                                        do {
                                            token = prevToken;
                                            prevToken = iterator.stepBackward();
                                            
                                            if (prevToken) {
                                                if (prevToken.type.indexOf(&#x27;tag-close&#x27;) !== -1) {
                                                    range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                                                }
                        
                                                if (token.value === tag &amp;&amp; token.type.indexOf(&#x27;tag-name&#x27;) !== -1) {
                                                    if (prevToken.value === &#x27;&lt;&#x27;) {
                                                        depth[tag]++;
                                                    }
                                                    else if (prevToken.value === &#x27;&lt;/&#x27;) {
                                                        depth[tag]--;
                                                    }
                                                    
                                                    if (depth[tag] === 0)
                                                        found = true;
                                                }
                                            }
                                        } while (prevToken &amp;&amp; !found);
                                    }
                                    if (token &amp;&amp; token.type.indexOf(&#x27;tag-name&#x27;)) {
                                        pos = range.start;
                                        if (pos.row == cursor.row &amp;&amp; Math.abs(pos.column - cursor.column) &lt; 2)
                                            pos = range.end;
                                    }
                                }
                        
                                pos = range &amp;&amp; range.cursor || pos;
                                if (pos) {
                                    if (select) {
                                        if (range &amp;&amp; expand) {
                                            this.selection.setRange(range);
                                        } else if (range &amp;&amp; range.isEqual(this.getSelectionRange())) {
                                            this.clearSelection();
                                        } else {
                                            this.selection.selectTo(pos.row, pos.column);
                                        }
                                    } else {
                                        this.selection.moveTo(pos.row, pos.column);
                                    }
                                }
                            };
                            this.gotoLine = function(lineNumber, column, animate) {
                                this.selection.clearSelection();
                                this.session.unfold({row: lineNumber - 1, column: column || 0});
                        
                                this.$blockScrolling += 1;
                                this.exitMultiSelectMode &amp;&amp; this.exitMultiSelectMode();
                                this.moveCursorTo(lineNumber - 1, column || 0);
                                this.$blockScrolling -= 1;
                        
                                if (!this.isRowFullyVisible(lineNumber - 1))
                                    this.scrollToLine(lineNumber - 1, true, animate);
                            };
                            this.navigateTo = function(row, column) {
                                this.selection.moveTo(row, column);
                            };
                            this.navigateUp = function(times) {
                                if (this.selection.isMultiLine() &amp;&amp; !this.selection.isBackwards()) {
                                    var selectionStart = this.selection.anchor.getPosition();
                                    return this.moveCursorToPosition(selectionStart);
                                }
                                this.selection.clearSelection();
                                this.selection.moveCursorBy(-times || -1, 0);
                            };
                            this.navigateDown = function(times) {
                                if (this.selection.isMultiLine() &amp;&amp; this.selection.isBackwards()) {
                                    var selectionEnd = this.selection.anchor.getPosition();
                                    return this.moveCursorToPosition(selectionEnd);
                                }
                                this.selection.clearSelection();
                                this.selection.moveCursorBy(times || 1, 0);
                            };
                            this.navigateLeft = function(times) {
                                if (!this.selection.isEmpty()) {
                                    var selectionStart = this.getSelectionRange().start;
                                    this.moveCursorToPosition(selectionStart);
                                }
                                else {
                                    times = times || 1;
                                    while (times--) {
                                        this.selection.moveCursorLeft();
                                    }
                                }
                                this.clearSelection();
                            };
                            this.navigateRight = function(times) {
                                if (!this.selection.isEmpty()) {
                                    var selectionEnd = this.getSelectionRange().end;
                                    this.moveCursorToPosition(selectionEnd);
                                }
                                else {
                                    times = times || 1;
                                    while (times--) {
                                        this.selection.moveCursorRight();
                                    }
                                }
                                this.clearSelection();
                            };
                            this.navigateLineStart = function() {
                                this.selection.moveCursorLineStart();
                                this.clearSelection();
                            };
                            this.navigateLineEnd = function() {
                                this.selection.moveCursorLineEnd();
                                this.clearSelection();
                            };
                            this.navigateFileEnd = function() {
                                this.selection.moveCursorFileEnd();
                                this.clearSelection();
                            };
                            this.navigateFileStart = function() {
                                this.selection.moveCursorFileStart();
                                this.clearSelection();
                            };
                            this.navigateWordRight = function() {
                                this.selection.moveCursorWordRight();
                                this.clearSelection();
                            };
                            this.navigateWordLeft = function() {
                                this.selection.moveCursorWordLeft();
                                this.clearSelection();
                            };
                            this.replace = function(replacement, options) {
                                if (options)
                                    this.$search.set(options);
                        
                                var range = this.$search.find(this.session);
                                var replaced = 0;
                                if (!range)
                                    return replaced;
                        
                                if (this.$tryReplace(range, replacement)) {
                                    replaced = 1;
                                }
                                if (range !== null) {
                                    this.selection.setSelectionRange(range);
                                    this.renderer.scrollSelectionIntoView(range.start, range.end);
                                }
                        
                                return replaced;
                            };
                            this.replaceAll = function(replacement, options) {
                                if (options) {
                                    this.$search.set(options);
                                }
                        
                                var ranges = this.$search.findAll(this.session);
                                var replaced = 0;
                                if (!ranges.length)
                                    return replaced;
                        
                                this.$blockScrolling += 1;
                        
                                var selection = this.getSelectionRange();
                                this.selection.moveTo(0, 0);
                        
                                for (var i = ranges.length - 1; i &gt;= 0; --i) {
                                    if(this.$tryReplace(ranges[i], replacement)) {
                                        replaced++;
                                    }
                                }
                        
                                this.selection.setSelectionRange(selection);
                                this.$blockScrolling -= 1;
                        
                                return replaced;
                            };
                        
                            this.$tryReplace = function(range, replacement) {
                                var input = this.session.getTextRange(range);
                                replacement = this.$search.replace(input, replacement);
                                if (replacement !== null) {
                                    range.end = this.session.replace(range, replacement);
                                    return range;
                                } else {
                                    return null;
                                }
                            };
                            this.getLastSearchOptions = function() {
                                return this.$search.getOptions();
                            };
                            this.find = function(needle, options, animate) {
                                if (!options)
                                    options = {};
                        
                                if (typeof needle == &quot;string&quot; || needle instanceof RegExp)
                                    options.needle = needle;
                                else if (typeof needle == &quot;object&quot;)
                                    oop.mixin(options, needle);
                        
                                var range = this.selection.getRange();
                                if (options.needle == null) {
                                    needle = this.session.getTextRange(range)
                                        || this.$search.$options.needle;
                                    if (!needle) {
                                        range = this.session.getWordRange(range.start.row, range.start.column);
                                        needle = this.session.getTextRange(range);
                                    }
                                    this.$search.set({needle: needle});
                                }
                        
                                this.$search.set(options);
                                if (!options.start)
                                    this.$search.set({start: range});
                        
                                var newRange = this.$search.find(this.session);
                                if (options.preventScroll)
                                    return newRange;
                                if (newRange) {
                                    this.revealRange(newRange, animate);
                                    return newRange;
                                }
                                if (options.backwards)
                                    range.start = range.end;
                                else
                                    range.end = range.start;
                                this.selection.setRange(range);
                            };
                            this.findNext = function(options, animate) {
                                this.find({skipCurrent: true, backwards: false}, options, animate);
                            };
                            this.findPrevious = function(options, animate) {
                                this.find(options, {skipCurrent: true, backwards: true}, animate);
                            };
                        
                            this.revealRange = function(range, animate) {
                                this.$blockScrolling += 1;
                                this.session.unfold(range);
                                this.selection.setSelectionRange(range);
                                this.$blockScrolling -= 1;
                        
                                var scrollTop = this.renderer.scrollTop;
                                this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
                                if (animate !== false)
                                    this.renderer.animateScrolling(scrollTop);
                            };
                            this.undo = function() {
                                this.$blockScrolling++;
                                this.session.getUndoManager().undo();
                                this.$blockScrolling--;
                                this.renderer.scrollCursorIntoView(null, 0.5);
                            };
                            this.redo = function() {
                                this.$blockScrolling++;
                                this.session.getUndoManager().redo();
                                this.$blockScrolling--;
                                this.renderer.scrollCursorIntoView(null, 0.5);
                            };
                            this.destroy = function() {
                                this.renderer.destroy();
                                this._signal(&quot;destroy&quot;, this);
                                if (this.session) {
                                    this.session.destroy();
                                }
                            };
                            this.setAutoScrollEditorIntoView = function(enable) {
                                if (!enable)
                                    return;
                                var rect;
                                var self = this;
                                var shouldScroll = false;
                                if (!this.$scrollAnchor)
                                    this.$scrollAnchor = document.createElement(&quot;div&quot;);
                                var scrollAnchor = this.$scrollAnchor;
                                scrollAnchor.style.cssText = &quot;position:absolute&quot;;
                                this.container.insertBefore(scrollAnchor, this.container.firstChild);
                                var onChangeSelection = this.on(&quot;changeSelection&quot;, function() {
                                    shouldScroll = true;
                                });
                                var onBeforeRender = this.renderer.on(&quot;beforeRender&quot;, function() {
                                    if (shouldScroll)
                                        rect = self.renderer.container.getBoundingClientRect();
                                });
                                var onAfterRender = this.renderer.on(&quot;afterRender&quot;, function() {
                                    if (shouldScroll &amp;&amp; rect &amp;&amp; (self.isFocused()
                                        || self.searchBox &amp;&amp; self.searchBox.isFocused())
                                    ) {
                                        var renderer = self.renderer;
                                        var pos = renderer.$cursorLayer.$pixelPos;
                                        var config = renderer.layerConfig;
                                        var top = pos.top - config.offset;
                                        if (pos.top &gt;= 0 &amp;&amp; top + rect.top &lt; 0) {
                                            shouldScroll = true;
                                        } else if (pos.top &lt; config.height &amp;&amp;
                                            pos.top + rect.top + config.lineHeight &gt; window.innerHeight) {
                                            shouldScroll = false;
                                        } else {
                                            shouldScroll = null;
                                        }
                                        if (shouldScroll != null) {
                                            scrollAnchor.style.top = top + &quot;px&quot;;
                                            scrollAnchor.style.left = pos.left + &quot;px&quot;;
                                            scrollAnchor.style.height = config.lineHeight + &quot;px&quot;;
                                            scrollAnchor.scrollIntoView(shouldScroll);
                                        }
                                        shouldScroll = rect = null;
                                    }
                                });
                                this.setAutoScrollEditorIntoView = function(enable) {
                                    if (enable)
                                        return;
                                    delete this.setAutoScrollEditorIntoView;
                                    this.removeEventListener(&quot;changeSelection&quot;, onChangeSelection);
                                    this.renderer.removeEventListener(&quot;afterRender&quot;, onAfterRender);
                                    this.renderer.removeEventListener(&quot;beforeRender&quot;, onBeforeRender);
                                };
                            };
                        
                        
                            this.$resetCursorStyle = function() {
                                var style = this.$cursorStyle || &quot;ace&quot;;
                                var cursorLayer = this.renderer.$cursorLayer;
                                if (!cursorLayer)
                                    return;
                                cursorLayer.setSmoothBlinking(/smooth/.test(style));
                                cursorLayer.isBlinking = !this.$readOnly &amp;&amp; style != &quot;wide&quot;;
                                dom.setCssClass(cursorLayer.element, &quot;ace_slim-cursors&quot;, /slim/.test(style));
                            };
                        
                        }).call(Editor.prototype);
                        
                        
                        
                        config.defineOptions(Editor.prototype, &quot;editor&quot;, {
                            selectionStyle: {
                                set: function(style) {
                                    this.onSelectionChange();
                                    this._signal(&quot;changeSelectionStyle&quot;, {data: style});
                                },
                                initialValue: &quot;line&quot;
                            },
                            highlightActiveLine: {
                                set: function() {this.$updateHighlightActiveLine();},
                                initialValue: true
                            },
                            highlightSelectedWord: {
                                set: function(shouldHighlight) {this.$onSelectionChange();},
                                initialValue: true
                            },
                            readOnly: {
                                set: function(readOnly) {
                                    this.$resetCursorStyle(); 
                                },
                                initialValue: false
                            },
                            cursorStyle: {
                                set: function(val) { this.$resetCursorStyle(); },
                                values: [&quot;ace&quot;, &quot;slim&quot;, &quot;smooth&quot;, &quot;wide&quot;],
                                initialValue: &quot;ace&quot;
                            },
                            mergeUndoDeltas: {
                                values: [false, true, &quot;always&quot;],
                                initialValue: true
                            },
                            behavioursEnabled: {initialValue: true},
                            wrapBehavioursEnabled: {initialValue: true},
                            autoScrollEditorIntoView: {
                                set: function(val) {this.setAutoScrollEditorIntoView(val)}
                            },
                        
                            hScrollBarAlwaysVisible: &quot;renderer&quot;,
                            vScrollBarAlwaysVisible: &quot;renderer&quot;,
                            highlightGutterLine: &quot;renderer&quot;,
                            animatedScroll: &quot;renderer&quot;,
                            showInvisibles: &quot;renderer&quot;,
                            showPrintMargin: &quot;renderer&quot;,
                            printMarginColumn: &quot;renderer&quot;,
                            printMargin: &quot;renderer&quot;,
                            fadeFoldWidgets: &quot;renderer&quot;,
                            showFoldWidgets: &quot;renderer&quot;,
                            showLineNumbers: &quot;renderer&quot;,
                            showGutter: &quot;renderer&quot;,
                            displayIndentGuides: &quot;renderer&quot;,
                            fontSize: &quot;renderer&quot;,
                            fontFamily: &quot;renderer&quot;,
                            maxLines: &quot;renderer&quot;,
                            minLines: &quot;renderer&quot;,
                            scrollPastEnd: &quot;renderer&quot;,
                            fixedWidthGutter: &quot;renderer&quot;,
                            theme: &quot;renderer&quot;,
                        
                            scrollSpeed: &quot;$mouseHandler&quot;,
                            dragDelay: &quot;$mouseHandler&quot;,
                            dragEnabled: &quot;$mouseHandler&quot;,
                            focusTimout: &quot;$mouseHandler&quot;,
                            tooltipFollowsMouse: &quot;$mouseHandler&quot;,
                        
                            firstLineNumber: &quot;session&quot;,
                            overwrite: &quot;session&quot;,
                            newLineMode: &quot;session&quot;,
                            useWorker: &quot;session&quot;,
                            useSoftTabs: &quot;session&quot;,
                            tabSize: &quot;session&quot;,
                            wrap: &quot;session&quot;,
                            indentedSoftWrap: &quot;session&quot;,
                            foldStyle: &quot;session&quot;,
                            mode: &quot;session&quot;
                        });
                        
                        exports.Editor = Editor;
                        });
                        
                        define(&quot;ace/undomanager&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        var UndoManager = function() {
                            this.reset();
                        };
                        
                        (function() {
                            this.execute = function(options) {
                                var deltas = options.args[0];
                                this.$doc  = options.args[1];
                                if (options.merge &amp;&amp; this.hasUndo()){
                                    this.dirtyCounter--;
                                    deltas = this.$undoStack.pop().concat(deltas);
                                }
                                this.$undoStack.push(deltas);
                                this.$redoStack = [];
                        
                                if (this.dirtyCounter &lt; 0) {
                                    this.dirtyCounter = NaN;
                                }
                                this.dirtyCounter++;
                            };
                            this.undo = function(dontSelect) {
                                var deltas = this.$undoStack.pop();
                                var undoSelectionRange = null;
                                if (deltas) {
                                    undoSelectionRange =
                                        this.$doc.undoChanges(deltas, dontSelect);
                                    this.$redoStack.push(deltas);
                                    this.dirtyCounter--;
                                }
                        
                                return undoSelectionRange;
                            };
                            this.redo = function(dontSelect) {
                                var deltas = this.$redoStack.pop();
                                var redoSelectionRange = null;
                                if (deltas) {
                                    redoSelectionRange =
                                        this.$doc.redoChanges(deltas, dontSelect);
                                    this.$undoStack.push(deltas);
                                    this.dirtyCounter++;
                                }
                        
                                return redoSelectionRange;
                            };
                            this.reset = function() {
                                this.$undoStack = [];
                                this.$redoStack = [];
                                this.dirtyCounter = 0;
                            };
                            this.hasUndo = function() {
                                return this.$undoStack.length &gt; 0;
                            };
                            this.hasRedo = function() {
                                return this.$redoStack.length &gt; 0;
                            };
                            this.markClean = function() {
                                this.dirtyCounter = 0;
                            };
                            this.isClean = function() {
                                return this.dirtyCounter === 0;
                            };
                        
                        }).call(UndoManager.prototype);
                        
                        exports.UndoManager = UndoManager;
                        });
                        
                        define(&quot;ace/layer/gutter&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/dom&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/lang&quot;,&quot;ace/lib/event_emitter&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var dom = require(&quot;../lib/dom&quot;);
                        var oop = require(&quot;../lib/oop&quot;);
                        var lang = require(&quot;../lib/lang&quot;);
                        var EventEmitter = require(&quot;../lib/event_emitter&quot;).EventEmitter;
                        
                        var Gutter = function(parentEl) {
                            this.element = dom.createElement(&quot;div&quot;);
                            this.element.className = &quot;ace_layer ace_gutter-layer&quot;;
                            parentEl.appendChild(this.element);
                            this.setShowFoldWidgets(this.$showFoldWidgets);
                            
                            this.gutterWidth = 0;
                        
                            this.$annotations = [];
                            this.$updateAnnotations = this.$updateAnnotations.bind(this);
                        
                            this.$cells = [];
                        };
                        
                        (function() {
                        
                            oop.implement(this, EventEmitter);
                        
                            this.setSession = function(session) {
                                if (this.session)
                                    this.session.removeEventListener(&quot;change&quot;, this.$updateAnnotations);
                                this.session = session;
                                if (session)
                                    session.on(&quot;change&quot;, this.$updateAnnotations);
                            };
                        
                            this.addGutterDecoration = function(row, className){
                                if (window.console)
                                    console.warn &amp;&amp; console.warn(&quot;deprecated use session.addGutterDecoration&quot;);
                                this.session.addGutterDecoration(row, className);
                            };
                        
                            this.removeGutterDecoration = function(row, className){
                                if (window.console)
                                    console.warn &amp;&amp; console.warn(&quot;deprecated use session.removeGutterDecoration&quot;);
                                this.session.removeGutterDecoration(row, className);
                            };
                        
                            this.setAnnotations = function(annotations) {
                                this.$annotations = [];
                                for (var i = 0; i &lt; annotations.length; i++) {
                                    var annotation = annotations[i];
                                    var row = annotation.row;
                                    var rowInfo = this.$annotations[row];
                                    if (!rowInfo)
                                        rowInfo = this.$annotations[row] = {text: []};
                                   
                                    var annoText = annotation.text;
                                    annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || &quot;&quot;;
                        
                                    if (rowInfo.text.indexOf(annoText) === -1)
                                        rowInfo.text.push(annoText);
                        
                                    var type = annotation.type;
                                    if (type == &quot;error&quot;)
                                        rowInfo.className = &quot; ace_error&quot;;
                                    else if (type == &quot;warning&quot; &amp;&amp; rowInfo.className != &quot; ace_error&quot;)
                                        rowInfo.className = &quot; ace_warning&quot;;
                                    else if (type == &quot;info&quot; &amp;&amp; (!rowInfo.className))
                                        rowInfo.className = &quot; ace_info&quot;;
                                }
                            };
                        
                            this.$updateAnnotations = function (e) {
                                if (!this.$annotations.length)
                                    return;
                                var delta = e.data;
                                var range = delta.range;
                                var firstRow = range.start.row;
                                var len = range.end.row - firstRow;
                                if (len === 0) {
                                } else if (delta.action == &quot;removeText&quot; || delta.action == &quot;removeLines&quot;) {
                                    this.$annotations.splice(firstRow, len + 1, null);
                                } else {
                                    var args = new Array(len + 1);
                                    args.unshift(firstRow, 1);
                                    this.$annotations.splice.apply(this.$annotations, args);
                                }
                            };
                        
                            this.update = function(config) {
                                var session = this.session;
                                var firstRow = config.firstRow;
                                var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar
                                    session.getLength() - 1);
                                var fold = session.getNextFoldLine(firstRow);
                                var foldStart = fold ? fold.start.row : Infinity;
                                var foldWidgets = this.$showFoldWidgets &amp;&amp; session.foldWidgets;
                                var breakpoints = session.$breakpoints;
                                var decorations = session.$decorations;
                                var firstLineNumber = session.$firstLineNumber;
                                var lastLineNumber = 0;
                                
                                var gutterRenderer = session.gutterRenderer || this.$renderer;
                        
                                var cell = null;
                                var index = -1;
                                var row = firstRow;
                                while (true) {
                                    if (row &gt; foldStart) {
                                        row = fold.end.row + 1;
                                        fold = session.getNextFoldLine(row, fold);
                                        foldStart = fold ? fold.start.row : Infinity;
                                    }
                                    if (row &gt; lastRow) {
                                        while (this.$cells.length &gt; index + 1) {
                                            cell = this.$cells.pop();
                                            this.element.removeChild(cell.element);
                                        }
                                        break;
                                    }
                        
                                    cell = this.$cells[++index];
                                    if (!cell) {
                                        cell = {element: null, textNode: null, foldWidget: null};
                                        cell.element = dom.createElement(&quot;div&quot;);
                                        cell.textNode = document.createTextNode(&#x27;&#x27;);
                                        cell.element.appendChild(cell.textNode);
                                        this.element.appendChild(cell.element);
                                        this.$cells[index] = cell;
                                    }
                        
                                    var className = &quot;ace_gutter-cell &quot;;
                                    if (breakpoints[row])
                                        className += breakpoints[row];
                                    if (decorations[row])
                                        className += decorations[row];
                                    if (this.$annotations[row])
                                        className += this.$annotations[row].className;
                                    if (cell.element.className != className)
                                        cell.element.className = className;
                        
                                    var height = session.getRowLength(row) * config.lineHeight + &quot;px&quot;;
                                    if (height != cell.element.style.height)
                                        cell.element.style.height = height;
                        
                                    if (foldWidgets) {
                                        var c = foldWidgets[row];
                                        if (c == null)
                                            c = foldWidgets[row] = session.getFoldWidget(row);
                                    }
                        
                                    if (c) {
                                        if (!cell.foldWidget) {
                                            cell.foldWidget = dom.createElement(&quot;span&quot;);
                                            cell.element.appendChild(cell.foldWidget);
                                        }
                                        var className = &quot;ace_fold-widget ace_&quot; + c;
                                        if (c == &quot;start&quot; &amp;&amp; row == foldStart &amp;&amp; row &lt; fold.end.row)
                                            className += &quot; ace_closed&quot;;
                                        else
                                            className += &quot; ace_open&quot;;
                                        if (cell.foldWidget.className != className)
                                            cell.foldWidget.className = className;
                        
                                        var height = config.lineHeight + &quot;px&quot;;
                                        if (cell.foldWidget.style.height != height)
                                            cell.foldWidget.style.height = height;
                                    } else {
                                        if (cell.foldWidget) {
                                            cell.element.removeChild(cell.foldWidget);
                                            cell.foldWidget = null;
                                        }
                                    }
                                    
                                    var text = lastLineNumber = gutterRenderer
                                        ? gutterRenderer.getText(session, row)
                                        : row + firstLineNumber;
                                    if (text != cell.textNode.data)
                                        cell.textNode.data = text;
                        
                                    row++;
                                }
                        
                                this.element.style.height = config.minHeight + &quot;px&quot;;
                        
                                if (this.$fixedWidth || session.$useWrapMode)
                                    lastLineNumber = session.getLength() + firstLineNumber;
                        
                                var gutterWidth = gutterRenderer 
                                    ? gutterRenderer.getWidth(session, lastLineNumber, config)
                                    : lastLineNumber.toString().length * config.characterWidth;
                                
                                var padding = this.$padding || this.$computePadding();
                                gutterWidth += padding.left + padding.right;
                                if (gutterWidth !== this.gutterWidth &amp;&amp; !isNaN(gutterWidth)) {
                                    this.gutterWidth = gutterWidth;
                                    this.element.style.width = Math.ceil(this.gutterWidth) + &quot;px&quot;;
                                    this._emit(&quot;changeGutterWidth&quot;, gutterWidth);
                                }
                            };
                        
                            this.$fixedWidth = false;
                            
                            this.$showLineNumbers = true;
                            this.$renderer = &quot;&quot;;
                            this.setShowLineNumbers = function(show) {
                                this.$renderer = !show &amp;&amp; {
                                    getWidth: function() {return &quot;&quot;},
                                    getText: function() {return &quot;&quot;}
                                };
                            };
                            
                            this.getShowLineNumbers = function() {
                                return this.$showLineNumbers;
                            };
                            
                            this.$showFoldWidgets = true;
                            this.setShowFoldWidgets = function(show) {
                                if (show)
                                    dom.addCssClass(this.element, &quot;ace_folding-enabled&quot;);
                                else
                                    dom.removeCssClass(this.element, &quot;ace_folding-enabled&quot;);
                        
                                this.$showFoldWidgets = show;
                                this.$padding = null;
                            };
                            
                            this.getShowFoldWidgets = function() {
                                return this.$showFoldWidgets;
                            };
                        
                            this.$computePadding = function() {
                                if (!this.element.firstChild)
                                    return {left: 0, right: 0};
                                var style = dom.computedStyle(this.element.firstChild);
                                this.$padding = {};
                                this.$padding.left = parseInt(style.paddingLeft) + 1 || 0;
                                this.$padding.right = parseInt(style.paddingRight) || 0;
                                return this.$padding;
                            };
                        
                            this.getRegion = function(point) {
                                var padding = this.$padding || this.$computePadding();
                                var rect = this.element.getBoundingClientRect();
                                if (point.x &lt; padding.left + rect.left)
                                    return &quot;markers&quot;;
                                if (this.$showFoldWidgets &amp;&amp; point.x &gt; rect.right - padding.right)
                                    return &quot;foldWidgets&quot;;
                            };
                        
                        }).call(Gutter.prototype);
                        
                        exports.Gutter = Gutter;
                        
                        });
                        
                        define(&quot;ace/layer/marker&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/range&quot;,&quot;ace/lib/dom&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var Range = require(&quot;../range&quot;).Range;
                        var dom = require(&quot;../lib/dom&quot;);
                        
                        var Marker = function(parentEl) {
                            this.element = dom.createElement(&quot;div&quot;);
                            this.element.className = &quot;ace_layer ace_marker-layer&quot;;
                            parentEl.appendChild(this.element);
                        };
                        
                        (function() {
                        
                            this.$padding = 0;
                        
                            this.setPadding = function(padding) {
                                this.$padding = padding;
                            };
                            this.setSession = function(session) {
                                this.session = session;
                            };
                            
                            this.setMarkers = function(markers) {
                                this.markers = markers;
                            };
                        
                            this.update = function(config) {
                                var config = config || this.config;
                                if (!config)
                                    return;
                        
                                this.config = config;
                        
                        
                                var html = [];
                                for (var key in this.markers) {
                                    var marker = this.markers[key];
                        
                                    if (!marker.range) {
                                        marker.update(html, this, this.session, config);
                                        continue;
                                    }
                        
                                    var range = marker.range.clipRows(config.firstRow, config.lastRow);
                                    if (range.isEmpty()) continue;
                        
                                    range = range.toScreenRange(this.session);
                                    if (marker.renderer) {
                                        var top = this.$getTop(range.start.row, config);
                                        var left = this.$padding + range.start.column * config.characterWidth;
                                        marker.renderer(html, range, left, top, config);
                                    } else if (marker.type == &quot;fullLine&quot;) {
                                        this.drawFullLineMarker(html, range, marker.clazz, config);
                                    } else if (marker.type == &quot;screenLine&quot;) {
                                        this.drawScreenLineMarker(html, range, marker.clazz, config);
                                    } else if (range.isMultiLine()) {
                                        if (marker.type == &quot;text&quot;)
                                            this.drawTextMarker(html, range, marker.clazz, config);
                                        else
                                            this.drawMultiLineMarker(html, range, marker.clazz, config);
                                    } else {
                                        this.drawSingleLineMarker(html, range, marker.clazz + &quot; ace_start&quot;, config);
                                    }
                                }
                                this.element.innerHTML = html.join(&quot;&quot;);
                            };
                        
                            this.$getTop = function(row, layerConfig) {
                                return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
                            };
                            this.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
                                var row = range.start.row;
                                var session = this.session;
                        
                                var lineRange = new Range(
                                    row, range.start.column,
                                    row, session.getScreenLastRowColumn(row)
                                );
                                this.drawSingleLineMarker(stringBuilder, lineRange, clazz + &quot; ace_start&quot;, layerConfig, 1, extraStyle);
                                row = range.end.row;
                                lineRange = new Range(row, session.getRowWrapIndent(row), row, range.end.column);
                                this.drawSingleLineMarker(stringBuilder, lineRange, clazz, layerConfig, 0, extraStyle);
                        
                                for (row = range.start.row + 1; row &lt; range.end.row; row++) {
                                    lineRange.start.row = row;
                                    lineRange.start.column = session.getRowWrapIndent(row);
                                    lineRange.end.row = row;
                                    lineRange.end.column = session.getScreenLastRowColumn(row);
                                    this.drawSingleLineMarker(stringBuilder, lineRange, clazz, layerConfig, 1, extraStyle);
                                }
                            };
                            this.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
                                var padding = this.$padding;
                                var height = config.lineHeight;
                                var top = this.$getTop(range.start.row, config);
                                var left = padding + range.start.column * config.characterWidth;
                                extraStyle = extraStyle || &quot;&quot;;
                        
                                stringBuilder.push(
                                    &quot;&lt;div class=&#x27;&quot;, clazz, &quot; ace_start&#x27; style=&#x27;&quot;,
                                    &quot;height:&quot;, height, &quot;px;&quot;,
                                    &quot;right:0;&quot;,
                                    &quot;top:&quot;, top, &quot;px;&quot;,
                                    &quot;left:&quot;, left, &quot;px;&quot;, extraStyle, &quot;&#x27;&gt;&lt;/div&gt;&quot;
                                );
                                top = this.$getTop(range.end.row, config);
                                var width = range.end.column * config.characterWidth;
                        
                                stringBuilder.push(
                                    &quot;&lt;div class=&#x27;&quot;, clazz, &quot;&#x27; style=&#x27;&quot;,
                                    &quot;height:&quot;, height, &quot;px;&quot;,
                                    &quot;width:&quot;, width, &quot;px;&quot;,
                                    &quot;top:&quot;, top, &quot;px;&quot;,
                                    &quot;left:&quot;, padding, &quot;px;&quot;, extraStyle, &quot;&#x27;&gt;&lt;/div&gt;&quot;
                                );
                                height = (range.end.row - range.start.row - 1) * config.lineHeight;
                                if (height &lt;= 0)
                                    return;
                                top = this.$getTop(range.start.row + 1, config);
                        
                                stringBuilder.push(
                                    &quot;&lt;div class=&#x27;&quot;, clazz, &quot;&#x27; style=&#x27;&quot;,
                                    &quot;height:&quot;, height, &quot;px;&quot;,
                                    &quot;right:0;&quot;,
                                    &quot;top:&quot;, top, &quot;px;&quot;,
                                    &quot;left:&quot;, padding, &quot;px;&quot;, extraStyle, &quot;&#x27;&gt;&lt;/div&gt;&quot;
                                );
                            };
                            this.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
                                var height = config.lineHeight;
                                var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;
                        
                                var top = this.$getTop(range.start.row, config);
                                var left = this.$padding + range.start.column * config.characterWidth;
                        
                                stringBuilder.push(
                                    &quot;&lt;div class=&#x27;&quot;, clazz, &quot;&#x27; style=&#x27;&quot;,
                                    &quot;height:&quot;, height, &quot;px;&quot;,
                                    &quot;width:&quot;, width, &quot;px;&quot;,
                                    &quot;top:&quot;, top, &quot;px;&quot;,
                                    &quot;left:&quot;, left, &quot;px;&quot;, extraStyle || &quot;&quot;, &quot;&#x27;&gt;&lt;/div&gt;&quot;
                                );
                            };
                        
                            this.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
                                var top = this.$getTop(range.start.row, config);
                                var height = config.lineHeight;
                                if (range.start.row != range.end.row)
                                    height += this.$getTop(range.end.row, config) - top;
                        
                                stringBuilder.push(
                                    &quot;&lt;div class=&#x27;&quot;, clazz, &quot;&#x27; style=&#x27;&quot;,
                                    &quot;height:&quot;, height, &quot;px;&quot;,
                                    &quot;top:&quot;, top, &quot;px;&quot;,
                                    &quot;left:0;right:0;&quot;, extraStyle || &quot;&quot;, &quot;&#x27;&gt;&lt;/div&gt;&quot;
                                );
                            };
                            
                            this.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
                                var top = this.$getTop(range.start.row, config);
                                var height = config.lineHeight;
                        
                                stringBuilder.push(
                                    &quot;&lt;div class=&#x27;&quot;, clazz, &quot;&#x27; style=&#x27;&quot;,
                                    &quot;height:&quot;, height, &quot;px;&quot;,
                                    &quot;top:&quot;, top, &quot;px;&quot;,
                                    &quot;left:0;right:0;&quot;, extraStyle || &quot;&quot;, &quot;&#x27;&gt;&lt;/div&gt;&quot;
                                );
                            };
                        
                        }).call(Marker.prototype);
                        
                        exports.Marker = Marker;
                        
                        });
                        
                        define(&quot;ace/layer/text&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/dom&quot;,&quot;ace/lib/lang&quot;,&quot;ace/lib/useragent&quot;,&quot;ace/lib/event_emitter&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var oop = require(&quot;../lib/oop&quot;);
                        var dom = require(&quot;../lib/dom&quot;);
                        var lang = require(&quot;../lib/lang&quot;);
                        var useragent = require(&quot;../lib/useragent&quot;);
                        var EventEmitter = require(&quot;../lib/event_emitter&quot;).EventEmitter;
                        
                        var Text = function(parentEl) {
                            this.element = dom.createElement(&quot;div&quot;);
                            this.element.className = &quot;ace_layer ace_text-layer&quot;;
                            parentEl.appendChild(this.element);
                            this.$updateEolChar = this.$updateEolChar.bind(this);
                        };
                        
                        (function() {
                        
                            oop.implement(this, EventEmitter);
                        
                            this.EOF_CHAR = &quot;\xB6&quot;;
                            this.EOL_CHAR_LF = &quot;\xAC&quot;;
                            this.EOL_CHAR_CRLF = &quot;\xa4&quot;;
                            this.EOL_CHAR = this.EOL_CHAR_LF;
                            this.TAB_CHAR = &quot;\u2192&quot;; //&quot;\u21E5&quot;;
                            this.SPACE_CHAR = &quot;\xB7&quot;;
                            this.$padding = 0;
                        
                            this.$updateEolChar = function() {
                                var EOL_CHAR = this.session.doc.getNewLineCharacter() == &quot;\n&quot;
                                   ? this.EOL_CHAR_LF
                                   : this.EOL_CHAR_CRLF;
                                if (this.EOL_CHAR != EOL_CHAR) {
                                    this.EOL_CHAR = EOL_CHAR;
                                    return true;
                                }
                            }
                        
                            this.setPadding = function(padding) {
                                this.$padding = padding;
                                this.element.style.padding = &quot;0 &quot; + padding + &quot;px&quot;;
                            };
                        
                            this.getLineHeight = function() {
                                return this.$fontMetrics.$characterSize.height || 0;
                            };
                        
                            this.getCharacterWidth = function() {
                                return this.$fontMetrics.$characterSize.width || 0;
                            };
                            
                            this.$setFontMetrics = function(measure) {
                                this.$fontMetrics = measure;
                                this.$fontMetrics.on(&quot;changeCharacterSize&quot;, function(e) {
                                    this._signal(&quot;changeCharacterSize&quot;, e);
                                }.bind(this));
                                this.$pollSizeChanges();
                            }
                        
                            this.checkForSizeChanges = function() {
                                this.$fontMetrics.checkForSizeChanges();
                            };
                            this.$pollSizeChanges = function() {
                                return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
                            };
                            this.setSession = function(session) {
                                this.session = session;
                                if (session)
                                    this.$computeTabString();
                            };
                        
                            this.showInvisibles = false;
                            this.setShowInvisibles = function(showInvisibles) {
                                if (this.showInvisibles == showInvisibles)
                                    return false;
                        
                                this.showInvisibles = showInvisibles;
                                this.$computeTabString();
                                return true;
                            };
                        
                            this.displayIndentGuides = true;
                            this.setDisplayIndentGuides = function(display) {
                                if (this.displayIndentGuides == display)
                                    return false;
                        
                                this.displayIndentGuides = display;
                                this.$computeTabString();
                                return true;
                            };
                        
                            this.$tabStrings = [];
                            this.onChangeTabSize =
                            this.$computeTabString = function() {
                                var tabSize = this.session.getTabSize();
                                this.tabSize = tabSize;
                                var tabStr = this.$tabStrings = [0];
                                for (var i = 1; i &lt; tabSize + 1; i++) {
                                    if (this.showInvisibles) {
                                        tabStr.push(&quot;&lt;span class=&#x27;ace_invisible ace_invisible_tab&#x27;&gt;&quot;
                                            + this.TAB_CHAR
                                            + lang.stringRepeat(&quot; &quot;, i - 1)
                                            + &quot;&lt;/span&gt;&quot;);
                                    } else {
                                        tabStr.push(lang.stringRepeat(&quot; &quot;, i));
                                    }
                                }
                                if (this.displayIndentGuides) {
                                    this.$indentGuideRe =  /\s\S| \t|\t |\s$/;
                                    var className = &quot;ace_indent-guide&quot;;
                                    var spaceClass = &quot;&quot;;
                                    var tabClass = &quot;&quot;;
                                    if (this.showInvisibles) {
                                        className += &quot; ace_invisible&quot;;
                                        spaceClass = &quot; ace_invisible_space&quot;;
                                        tabClass = &quot; ace_invisible_tab&quot;;
                                        var spaceContent = lang.stringRepeat(this.SPACE_CHAR, this.tabSize);
                                        var tabContent = this.TAB_CHAR + lang.stringRepeat(&quot; &quot;, this.tabSize - 1);
                                    } else{
                                        var spaceContent = lang.stringRepeat(&quot; &quot;, this.tabSize);
                                        var tabContent = spaceContent;
                                    }
                        
                                    this.$tabStrings[&quot; &quot;] = &quot;&lt;span class=&#x27;&quot; + className + spaceClass + &quot;&#x27;&gt;&quot; + spaceContent + &quot;&lt;/span&gt;&quot;;
                                    this.$tabStrings[&quot;\t&quot;] = &quot;&lt;span class=&#x27;&quot; + className + tabClass + &quot;&#x27;&gt;&quot; + tabContent + &quot;&lt;/span&gt;&quot;;
                                }
                            };
                        
                            this.updateLines = function(config, firstRow, lastRow) {
                                if (this.config.lastRow != config.lastRow ||
                                    this.config.firstRow != config.firstRow) {
                                    this.scrollLines(config);
                                }
                                this.config = config;
                        
                                var first = Math.max(firstRow, config.firstRow);
                                var last = Math.min(lastRow, config.lastRow);
                        
                                var lineElements = this.element.childNodes;
                                var lineElementsIdx = 0;
                        
                                for (var row = config.firstRow; row &lt; first; row++) {
                                    var foldLine = this.session.getFoldLine(row);
                                    if (foldLine) {
                                        if (foldLine.containsRow(first)) {
                                            first = foldLine.start.row;
                                            break;
                                        } else {
                                            row = foldLine.end.row;
                                        }
                                    }
                                    lineElementsIdx ++;
                                }
                        
                                var row = first;
                                var foldLine = this.session.getNextFoldLine(row);
                                var foldStart = foldLine ? foldLine.start.row : Infinity;
                        
                                while (true) {
                                    if (row &gt; foldStart) {
                                        row = foldLine.end.row+1;
                                        foldLine = this.session.getNextFoldLine(row, foldLine);
                                        foldStart = foldLine ? foldLine.start.row :Infinity;
                                    }
                                    if (row &gt; last)
                                        break;
                        
                                    var lineElement = lineElements[lineElementsIdx++];
                                    if (lineElement) {
                                        var html = [];
                                        this.$renderLine(
                                            html, row, !this.$useLineGroups(), row == foldStart ? foldLine : false
                                        );
                                        lineElement.style.height = config.lineHeight * this.session.getRowLength(row) + &quot;px&quot;;
                                        lineElement.innerHTML = html.join(&quot;&quot;);
                                    }
                                    row++;
                                }
                            };
                        
                            this.scrollLines = function(config) {
                                var oldConfig = this.config;
                                this.config = config;
                        
                                if (!oldConfig || oldConfig.lastRow &lt; config.firstRow)
                                    return this.update(config);
                        
                                if (config.lastRow &lt; oldConfig.firstRow)
                                    return this.update(config);
                        
                                var el = this.element;
                                if (oldConfig.firstRow &lt; config.firstRow)
                                    for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row&gt;0; row--)
                                        el.removeChild(el.firstChild);
                        
                                if (oldConfig.lastRow &gt; config.lastRow)
                                    for (var row=this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row&gt;0; row--)
                                        el.removeChild(el.lastChild);
                        
                                if (config.firstRow &lt; oldConfig.firstRow) {
                                    var fragment = this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1);
                                    if (el.firstChild)
                                        el.insertBefore(fragment, el.firstChild);
                                    else
                                        el.appendChild(fragment);
                                }
                        
                                if (config.lastRow &gt; oldConfig.lastRow) {
                                    var fragment = this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow);
                                    el.appendChild(fragment);
                                }
                            };
                        
                            this.$renderLinesFragment = function(config, firstRow, lastRow) {
                                var fragment = this.element.ownerDocument.createDocumentFragment();
                                var row = firstRow;
                                var foldLine = this.session.getNextFoldLine(row);
                                var foldStart = foldLine ? foldLine.start.row : Infinity;
                        
                                while (true) {
                                    if (row &gt; foldStart) {
                                        row = foldLine.end.row+1;
                                        foldLine = this.session.getNextFoldLine(row, foldLine);
                                        foldStart = foldLine ? foldLine.start.row : Infinity;
                                    }
                                    if (row &gt; lastRow)
                                        break;
                        
                                    var container = dom.createElement(&quot;div&quot;);
                        
                                    var html = [];
                                    this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
                                    container.innerHTML = html.join(&quot;&quot;);
                                    if (this.$useLineGroups()) {
                                        container.className = &#x27;ace_line_group&#x27;;
                                        fragment.appendChild(container);
                                        container.style.height = config.lineHeight * this.session.getRowLength(row) + &quot;px&quot;;
                        
                                    } else {
                                        while(container.firstChild)
                                            fragment.appendChild(container.firstChild);
                                    }
                        
                                    row++;
                                }
                                return fragment;
                            };
                        
                            this.update = function(config) {
                                this.config = config;
                        
                                var html = [];
                                var firstRow = config.firstRow, lastRow = config.lastRow;
                        
                                var row = firstRow;
                                var foldLine = this.session.getNextFoldLine(row);
                                var foldStart = foldLine ? foldLine.start.row : Infinity;
                        
                                while (true) {
                                    if (row &gt; foldStart) {
                                        row = foldLine.end.row+1;
                                        foldLine = this.session.getNextFoldLine(row, foldLine);
                                        foldStart = foldLine ? foldLine.start.row :Infinity;
                                    }
                                    if (row &gt; lastRow)
                                        break;
                        
                                    if (this.$useLineGroups())
                                        html.push(&quot;&lt;div class=&#x27;ace_line_group&#x27; style=&#x27;height:&quot;, config.lineHeight*this.session.getRowLength(row), &quot;px&#x27;&gt;&quot;)
                        
                                    this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
                        
                                    if (this.$useLineGroups())
                                        html.push(&quot;&lt;/div&gt;&quot;); // end the line group
                        
                                    row++;
                                }
                                this.element.innerHTML = html.join(&quot;&quot;);
                            };
                        
                            this.$textToken = {
                                &quot;text&quot;: true,
                                &quot;rparen&quot;: true,
                                &quot;lparen&quot;: true
                            };
                        
                            this.$renderToken = function(stringBuilder, screenColumn, token, value) {
                                var self = this;
                                var replaceReg = /\t|&amp;|&lt;|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\u3000\uFEFF])|[\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3000-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]/g;
                                var replaceFunc = function(c, a, b, tabIdx, idx4) {
                                    if (a) {
                                        return self.showInvisibles
                                            ? &quot;&lt;span class=&#x27;ace_invisible ace_invisible_space&#x27;&gt;&quot; + lang.stringRepeat(self.SPACE_CHAR, c.length) + &quot;&lt;/span&gt;&quot;
                                            : c;
                                    } else if (c == &quot;&amp;&quot;) {
                                        return &quot;&amp;#38;&quot;;
                                    } else if (c == &quot;&lt;&quot;) {
                                        return &quot;&amp;#60;&quot;;
                                    } else if (c == &quot;\t&quot;) {
                                        var tabSize = self.session.getScreenTabSize(screenColumn + tabIdx);
                                        screenColumn += tabSize - 1;
                                        return self.$tabStrings[tabSize];
                                    } else if (c == &quot;\u3000&quot;) {
                                        var classToUse = self.showInvisibles ? &quot;ace_cjk ace_invisible ace_invisible_space&quot; : &quot;ace_cjk&quot;;
                                        var space = self.showInvisibles ? self.SPACE_CHAR : &quot;&quot;;
                                        screenColumn += 1;
                                        return &quot;&lt;span class=&#x27;&quot; + classToUse + &quot;&#x27; style=&#x27;width:&quot; +
                                            (self.config.characterWidth * 2) +
                                            &quot;px&#x27;&gt;&quot; + space + &quot;&lt;/span&gt;&quot;;
                                    } else if (b) {
                                        return &quot;&lt;span class=&#x27;ace_invisible ace_invisible_space ace_invalid&#x27;&gt;&quot; + self.SPACE_CHAR + &quot;&lt;/span&gt;&quot;;
                                    } else {
                                        screenColumn += 1;
                                        return &quot;&lt;span class=&#x27;ace_cjk&#x27; style=&#x27;width:&quot; +
                                            (self.config.characterWidth * 2) +
                                            &quot;px&#x27;&gt;&quot; + c + &quot;&lt;/span&gt;&quot;;
                                    }
                                };
                        
                                var output = value.replace(replaceReg, replaceFunc);
                        
                                if (!this.$textToken[token.type]) {
                                    var classes = &quot;ace_&quot; + token.type.replace(/\./g, &quot; ace_&quot;);
                                    var style = &quot;&quot;;
                                    if (token.type == &quot;fold&quot;)
                                        style = &quot; style=&#x27;width:&quot; + (token.value.length * this.config.characterWidth) + &quot;px;&#x27; &quot;;
                                    stringBuilder.push(&quot;&lt;span class=&#x27;&quot;, classes, &quot;&#x27;&quot;, style, &quot;&gt;&quot;, output, &quot;&lt;/span&gt;&quot;);
                                }
                                else {
                                    stringBuilder.push(output);
                                }
                                return screenColumn + value.length;
                            };
                        
                            this.renderIndentGuide = function(stringBuilder, value, max) {
                                var cols = value.search(this.$indentGuideRe);
                                if (cols &lt;= 0 || cols &gt;= max)
                                    return value;
                                if (value[0] == &quot; &quot;) {
                                    cols -= cols % this.tabSize;
                                    stringBuilder.push(lang.stringRepeat(this.$tabStrings[&quot; &quot;], cols/this.tabSize));
                                    return value.substr(cols);
                                } else if (value[0] == &quot;\t&quot;) {
                                    stringBuilder.push(lang.stringRepeat(this.$tabStrings[&quot;\t&quot;], cols));
                                    return value.substr(cols);
                                }
                                return value;
                            };
                        
                            this.$renderWrappedLine = function(stringBuilder, tokens, splits, onlyContents) {
                                var chars = 0;
                                var split = 0;
                                var splitChars = splits[0];
                                var screenColumn = 0;
                        
                                for (var i = 0; i &lt; tokens.length; i++) {
                                    var token = tokens[i];
                                    var value = token.value;
                                    if (i == 0 &amp;&amp; this.displayIndentGuides) {
                                        chars = value.length;
                                        value = this.renderIndentGuide(stringBuilder, value, splitChars);
                                        if (!value)
                                            continue;
                                        chars -= value.length;
                                    }
                        
                                    if (chars + value.length &lt; splitChars) {
                                        screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                                        chars += value.length;
                                    } else {
                                        while (chars + value.length &gt;= splitChars) {
                                            screenColumn = this.$renderToken(
                                                stringBuilder, screenColumn,
                                                token, value.substring(0, splitChars - chars)
                                            );
                                            value = value.substring(splitChars - chars);
                                            chars = splitChars;
                        
                                            if (!onlyContents) {
                                                stringBuilder.push(&quot;&lt;/div&gt;&quot;,
                                                    &quot;&lt;div class=&#x27;ace_line&#x27; style=&#x27;height:&quot;,
                                                    this.config.lineHeight, &quot;px&#x27;&gt;&quot;
                                                );
                                            }
                        
                                            stringBuilder.push(lang.stringRepeat(&quot;\xa0&quot;, splits.indent));
                        
                                            split ++;
                                            screenColumn = 0;
                                            splitChars = splits[split] || Number.MAX_VALUE;
                                        }
                                        if (value.length != 0) {
                                            chars += value.length;
                                            screenColumn = this.$renderToken(
                                                stringBuilder, screenColumn, token, value
                                            );
                                        }
                                    }
                                }
                            };
                        
                            this.$renderSimpleLine = function(stringBuilder, tokens) {
                                var screenColumn = 0;
                                var token = tokens[0];
                                var value = token.value;
                                if (this.displayIndentGuides)
                                    value = this.renderIndentGuide(stringBuilder, value);
                                if (value)
                                    screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                                for (var i = 1; i &lt; tokens.length; i++) {
                                    token = tokens[i];
                                    value = token.value;
                                    screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                                }
                            };
                            this.$renderLine = function(stringBuilder, row, onlyContents, foldLine) {
                                if (!foldLine &amp;&amp; foldLine != false)
                                    foldLine = this.session.getFoldLine(row);
                        
                                if (foldLine)
                                    var tokens = this.$getFoldLineTokens(row, foldLine);
                                else
                                    var tokens = this.session.getTokens(row);
                        
                        
                                if (!onlyContents) {
                                    stringBuilder.push(
                                        &quot;&lt;div class=&#x27;ace_line&#x27; style=&#x27;height:&quot;, 
                                            this.config.lineHeight * (
                                                this.$useLineGroups() ? 1 :this.session.getRowLength(row)
                                            ), &quot;px&#x27;&gt;&quot;
                                    );
                                }
                        
                                if (tokens.length) {
                                    var splits = this.session.getRowSplitData(row);
                                    if (splits &amp;&amp; splits.length)
                                        this.$renderWrappedLine(stringBuilder, tokens, splits, onlyContents);
                                    else
                                        this.$renderSimpleLine(stringBuilder, tokens);
                                }
                        
                                if (this.showInvisibles) {
                                    if (foldLine)
                                        row = foldLine.end.row
                        
                                    stringBuilder.push(
                                        &quot;&lt;span class=&#x27;ace_invisible ace_invisible_eol&#x27;&gt;&quot;,
                                        row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR,
                                        &quot;&lt;/span&gt;&quot;
                                    );
                                }
                                if (!onlyContents)
                                    stringBuilder.push(&quot;&lt;/div&gt;&quot;);
                            };
                        
                            this.$getFoldLineTokens = function(row, foldLine) {
                                var session = this.session;
                                var renderTokens = [];
                        
                                function addTokens(tokens, from, to) {
                                    var idx = 0, col = 0;
                                    while ((col + tokens[idx].value.length) &lt; from) {
                                        col += tokens[idx].value.length;
                                        idx++;
                        
                                        if (idx == tokens.length)
                                            return;
                                    }
                                    if (col != from) {
                                        var value = tokens[idx].value.substring(from - col);
                                        if (value.length &gt; (to - from))
                                            value = value.substring(0, to - from);
                        
                                        renderTokens.push({
                                            type: tokens[idx].type,
                                            value: value
                                        });
                        
                                        col = from + value.length;
                                        idx += 1;
                                    }
                        
                                    while (col &lt; to &amp;&amp; idx &lt; tokens.length) {
                                        var value = tokens[idx].value;
                                        if (value.length + col &gt; to) {
                                            renderTokens.push({
                                                type: tokens[idx].type,
                                                value: value.substring(0, to - col)
                                            });
                                        } else
                                            renderTokens.push(tokens[idx]);
                                        col += value.length;
                                        idx += 1;
                                    }
                                }
                        
                                var tokens = session.getTokens(row);
                                foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {
                                    if (placeholder != null) {
                                        renderTokens.push({
                                            type: &quot;fold&quot;,
                                            value: placeholder
                                        });
                                    } else {
                                        if (isNewRow)
                                            tokens = session.getTokens(row);
                        
                                        if (tokens.length)
                                            addTokens(tokens, lastColumn, column);
                                    }
                                }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);
                        
                                return renderTokens;
                            };
                        
                            this.$useLineGroups = function() {
                                return this.session.getUseWrapMode();
                            };
                        
                            this.destroy = function() {
                                clearInterval(this.$pollSizeChangesTimer);
                                if (this.$measureNode)
                                    this.$measureNode.parentNode.removeChild(this.$measureNode);
                                delete this.$measureNode;
                            };
                        
                        }).call(Text.prototype);
                        
                        exports.Text = Text;
                        
                        });
                        
                        define(&quot;ace/layer/cursor&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/dom&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var dom = require(&quot;../lib/dom&quot;);
                        var IE8;
                        
                        var Cursor = function(parentEl) {
                            this.element = dom.createElement(&quot;div&quot;);
                            this.element.className = &quot;ace_layer ace_cursor-layer&quot;;
                            parentEl.appendChild(this.element);
                            
                            if (IE8 === undefined)
                                IE8 = &quot;opacity&quot; in this.element;
                        
                            this.isVisible = false;
                            this.isBlinking = true;
                            this.blinkInterval = 1000;
                            this.smoothBlinking = false;
                        
                            this.cursors = [];
                            this.cursor = this.addCursor();
                            dom.addCssClass(this.element, &quot;ace_hidden-cursors&quot;);
                            this.$updateCursors = this.$updateVisibility.bind(this);
                        };
                        
                        (function() {
                            
                            this.$updateVisibility = function(val) {
                                var cursors = this.cursors;
                                for (var i = cursors.length; i--; )
                                    cursors[i].style.visibility = val ? &quot;&quot; : &quot;hidden&quot;;
                            };
                            this.$updateOpacity = function(val) {
                                var cursors = this.cursors;
                                for (var i = cursors.length; i--; )
                                    cursors[i].style.opacity = val ? &quot;&quot; : &quot;0&quot;;
                            };
                            
                        
                            this.$padding = 0;
                            this.setPadding = function(padding) {
                                this.$padding = padding;
                            };
                        
                            this.setSession = function(session) {
                                this.session = session;
                            };
                        
                            this.setBlinking = function(blinking) {
                                if (blinking != this.isBlinking){
                                    this.isBlinking = blinking;
                                    this.restartTimer();
                                }
                            };
                        
                            this.setBlinkInterval = function(blinkInterval) {
                                if (blinkInterval != this.blinkInterval){
                                    this.blinkInterval = blinkInterval;
                                    this.restartTimer();
                                }
                            };
                        
                            this.setSmoothBlinking = function(smoothBlinking) {
                                if (smoothBlinking != this.smoothBlinking &amp;&amp; !IE8) {
                                    this.smoothBlinking = smoothBlinking;
                                    dom.setCssClass(this.element, &quot;ace_smooth-blinking&quot;, smoothBlinking);
                                    this.$updateCursors(true);
                                    this.$updateCursors = (smoothBlinking 
                                        ? this.$updateOpacity
                                        : this.$updateVisibility).bind(this);
                                    this.restartTimer();
                                }
                            };
                        
                            this.addCursor = function() {
                                var el = dom.createElement(&quot;div&quot;);
                                el.className = &quot;ace_cursor&quot;;
                                this.element.appendChild(el);
                                this.cursors.push(el);
                                return el;
                            };
                        
                            this.removeCursor = function() {
                                if (this.cursors.length &gt; 1) {
                                    var el = this.cursors.pop();
                                    el.parentNode.removeChild(el);
                                    return el;
                                }
                            };
                        
                            this.hideCursor = function() {
                                this.isVisible = false;
                                dom.addCssClass(this.element, &quot;ace_hidden-cursors&quot;);
                                this.restartTimer();
                            };
                        
                            this.showCursor = function() {
                                this.isVisible = true;
                                dom.removeCssClass(this.element, &quot;ace_hidden-cursors&quot;);
                                this.restartTimer();
                            };
                        
                            this.restartTimer = function() {
                                var update = this.$updateCursors;
                                clearInterval(this.intervalId);
                                clearTimeout(this.timeoutId);
                                if (this.smoothBlinking) {
                                    dom.removeCssClass(this.element, &quot;ace_smooth-blinking&quot;);
                                }
                                
                                update(true);
                        
                                if (!this.isBlinking || !this.blinkInterval || !this.isVisible)
                                    return;
                        
                                if (this.smoothBlinking) {
                                    setTimeout(function(){
                                        dom.addCssClass(this.element, &quot;ace_smooth-blinking&quot;);
                                    }.bind(this));
                                }
                                
                                var blink = function(){
                                    this.timeoutId = setTimeout(function() {
                                        update(false);
                                    }, 0.6 * this.blinkInterval);
                                }.bind(this);
                        
                                this.intervalId = setInterval(function() {
                                    update(true);
                                    blink();
                                }, this.blinkInterval);
                        
                                blink();
                            };
                        
                            this.getPixelPosition = function(position, onScreen) {
                                if (!this.config || !this.session)
                                    return {left : 0, top : 0};
                        
                                if (!position)
                                    position = this.session.selection.getCursor();
                                var pos = this.session.documentToScreenPosition(position);
                                var cursorLeft = this.$padding + pos.column * this.config.characterWidth;
                                var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *
                                    this.config.lineHeight;
                        
                                return {left : cursorLeft, top : cursorTop};
                            };
                        
                            this.update = function(config) {
                                this.config = config;
                        
                                var selections = this.session.$selectionMarkers;
                                var i = 0, cursorIndex = 0;
                        
                                if (selections === undefined || selections.length === 0){
                                    selections = [{cursor: null}];
                                }
                        
                                for (var i = 0, n = selections.length; i &lt; n; i++) {
                                    var pixelPos = this.getPixelPosition(selections[i].cursor, true);
                                    if ((pixelPos.top &gt; config.height + config.offset ||
                                         pixelPos.top &lt; 0) &amp;&amp; i &gt; 1) {
                                        continue;
                                    }
                        
                                    var style = (this.cursors[cursorIndex++] || this.addCursor()).style;
                                    
                                    if (!this.drawCursor) {
                                        style.left = pixelPos.left + &quot;px&quot;;
                                        style.top = pixelPos.top + &quot;px&quot;;
                                        style.width = config.characterWidth + &quot;px&quot;;
                                        style.height = config.lineHeight + &quot;px&quot;;
                                    } else {
                                        this.drawCursor(style, pixelPos, config, selections[i], this.session);
                                    }
                                }
                                while (this.cursors.length &gt; cursorIndex)
                                    this.removeCursor();
                        
                                var overwrite = this.session.getOverwrite();
                                this.$setOverwrite(overwrite);
                                this.$pixelPos = pixelPos;
                                this.restartTimer();
                            };
                            
                            this.drawCursor = null;
                        
                            this.$setOverwrite = function(overwrite) {
                                if (overwrite != this.overwrite) {
                                    this.overwrite = overwrite;
                                    if (overwrite)
                                        dom.addCssClass(this.element, &quot;ace_overwrite-cursors&quot;);
                                    else
                                        dom.removeCssClass(this.element, &quot;ace_overwrite-cursors&quot;);
                                }
                            };
                        
                            this.destroy = function() {
                                clearInterval(this.intervalId);
                                clearTimeout(this.timeoutId);
                            };
                        
                        }).call(Cursor.prototype);
                        
                        exports.Cursor = Cursor;
                        
                        });
                        
                        define(&quot;ace/scrollbar&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/dom&quot;,&quot;ace/lib/event&quot;,&quot;ace/lib/event_emitter&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var oop = require(&quot;./lib/oop&quot;);
                        var dom = require(&quot;./lib/dom&quot;);
                        var event = require(&quot;./lib/event&quot;);
                        var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
                        var ScrollBar = function(parent) {
                            this.element = dom.createElement(&quot;div&quot;);
                            this.element.className = &quot;ace_scrollbar ace_scrollbar&quot; + this.classSuffix;
                        
                            this.inner = dom.createElement(&quot;div&quot;);
                            this.inner.className = &quot;ace_scrollbar-inner&quot;;
                            this.element.appendChild(this.inner);
                        
                            parent.appendChild(this.element);
                        
                            this.setVisible(false);
                            this.skipEvent = false;
                        
                            event.addListener(this.element, &quot;scroll&quot;, this.onScroll.bind(this));
                            event.addListener(this.element, &quot;mousedown&quot;, event.preventDefault);
                        };
                        
                        (function() {
                            oop.implement(this, EventEmitter);
                        
                            this.setVisible = function(isVisible) {
                                this.element.style.display = isVisible ? &quot;&quot; : &quot;none&quot;;
                                this.isVisible = isVisible;
                            };
                        }).call(ScrollBar.prototype);
                        var VScrollBar = function(parent, renderer) {
                            ScrollBar.call(this, parent);
                            this.scrollTop = 0;
                            renderer.$scrollbarWidth = 
                            this.width = dom.scrollbarWidth(parent.ownerDocument);
                            this.inner.style.width =
                            this.element.style.width = (this.width || 15) + 5 + &quot;px&quot;;
                        };
                        
                        oop.inherits(VScrollBar, ScrollBar);
                        
                        (function() {
                        
                            this.classSuffix = &#x27;-v&#x27;;
                            this.onScroll = function() {
                                if (!this.skipEvent) {
                                    this.scrollTop = this.element.scrollTop;
                                    this._emit(&quot;scroll&quot;, {data: this.scrollTop});
                                }
                                this.skipEvent = false;
                            };
                            this.getWidth = function() {
                                return this.isVisible ? this.width : 0;
                            };
                            this.setHeight = function(height) {
                                this.element.style.height = height + &quot;px&quot;;
                            };
                            this.setInnerHeight = function(height) {
                                this.inner.style.height = height + &quot;px&quot;;
                            };
                            this.setScrollHeight = function(height) {
                                this.inner.style.height = height + &quot;px&quot;;
                            };
                            this.setScrollTop = function(scrollTop) {
                                if (this.scrollTop != scrollTop) {
                                    this.skipEvent = true;
                                    this.scrollTop = this.element.scrollTop = scrollTop;
                                }
                            };
                        
                        }).call(VScrollBar.prototype);
                        var HScrollBar = function(parent, renderer) {
                            ScrollBar.call(this, parent);
                            this.scrollLeft = 0;
                            this.height = renderer.$scrollbarWidth;
                            this.inner.style.height =
                            this.element.style.height = (this.height || 15) + 5 + &quot;px&quot;;
                        };
                        
                        oop.inherits(HScrollBar, ScrollBar);
                        
                        (function() {
                        
                            this.classSuffix = &#x27;-h&#x27;;
                            this.onScroll = function() {
                                if (!this.skipEvent) {
                                    this.scrollLeft = this.element.scrollLeft;
                                    this._emit(&quot;scroll&quot;, {data: this.scrollLeft});
                                }
                                this.skipEvent = false;
                            };
                            this.getHeight = function() {
                                return this.isVisible ? this.height : 0;
                            };
                            this.setWidth = function(width) {
                                this.element.style.width = width + &quot;px&quot;;
                            };
                            this.setInnerWidth = function(width) {
                                this.inner.style.width = width + &quot;px&quot;;
                            };
                            this.setScrollWidth = function(width) {
                                this.inner.style.width = width + &quot;px&quot;;
                            };
                            this.setScrollLeft = function(scrollLeft) {
                                if (this.scrollLeft != scrollLeft) {
                                    this.skipEvent = true;
                                    this.scrollLeft = this.element.scrollLeft = scrollLeft;
                                }
                            };
                        
                        }).call(HScrollBar.prototype);
                        
                        
                        exports.ScrollBar = VScrollBar; // backward compatibility
                        exports.ScrollBarV = VScrollBar; // backward compatibility
                        exports.ScrollBarH = HScrollBar; // backward compatibility
                        
                        exports.VScrollBar = VScrollBar;
                        exports.HScrollBar = HScrollBar;
                        });
                        
                        define(&quot;ace/renderloop&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/event&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var event = require(&quot;./lib/event&quot;);
                        
                        
                        var RenderLoop = function(onRender, win) {
                            this.onRender = onRender;
                            this.pending = false;
                            this.changes = 0;
                            this.window = win || window;
                        };
                        
                        (function() {
                        
                        
                            this.schedule = function(change) {
                                this.changes = this.changes | change;
                                if (!this.pending &amp;&amp; this.changes) {
                                    this.pending = true;
                                    var _self = this;
                                    event.nextFrame(function() {
                                        _self.pending = false;
                                        var changes;
                                        while (changes = _self.changes) {
                                            _self.changes = 0;
                                            _self.onRender(changes);
                                        }
                                    }, this.window);
                                }
                            };
                        
                        }).call(RenderLoop.prototype);
                        
                        exports.RenderLoop = RenderLoop;
                        });
                        
                        define(&quot;ace/layer/font_metrics&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/dom&quot;,&quot;ace/lib/lang&quot;,&quot;ace/lib/useragent&quot;,&quot;ace/lib/event_emitter&quot;], function(require, exports, module) {
                        
                        var oop = require(&quot;../lib/oop&quot;);
                        var dom = require(&quot;../lib/dom&quot;);
                        var lang = require(&quot;../lib/lang&quot;);
                        var useragent = require(&quot;../lib/useragent&quot;);
                        var EventEmitter = require(&quot;../lib/event_emitter&quot;).EventEmitter;
                        
                        var CHAR_COUNT = 0;
                        
                        var FontMetrics = exports.FontMetrics = function(parentEl, interval) {
                            this.el = dom.createElement(&quot;div&quot;);
                            this.$setMeasureNodeStyles(this.el.style, true);
                            
                            this.$main = dom.createElement(&quot;div&quot;);
                            this.$setMeasureNodeStyles(this.$main.style);
                            
                            this.$measureNode = dom.createElement(&quot;div&quot;);
                            this.$setMeasureNodeStyles(this.$measureNode.style);
                            
                            
                            this.el.appendChild(this.$main);
                            this.el.appendChild(this.$measureNode);
                            parentEl.appendChild(this.el);
                            
                            if (!CHAR_COUNT)
                                this.$testFractionalRect();
                            this.$measureNode.innerHTML = lang.stringRepeat(&quot;X&quot;, CHAR_COUNT);
                            
                            this.$characterSize = {width: 0, height: 0};
                            this.checkForSizeChanges();
                        };
                        
                        (function() {
                        
                            oop.implement(this, EventEmitter);
                                
                            this.$characterSize = {width: 0, height: 0};
                            
                            this.$testFractionalRect = function() {
                                var el = dom.createElement(&quot;div&quot;);
                                this.$setMeasureNodeStyles(el.style);
                                el.style.width = &quot;0.2px&quot;;
                                document.documentElement.appendChild(el);
                                var w = el.getBoundingClientRect().width;
                                if (w &gt; 0 &amp;&amp; w &lt; 1)
                                    CHAR_COUNT = 50;
                                else
                                    CHAR_COUNT = 100;
                                el.parentNode.removeChild(el);
                            };
                            
                            this.$setMeasureNodeStyles = function(style, isRoot) {
                                style.width = style.height = &quot;auto&quot;;
                                style.left = style.top = &quot;0px&quot;;
                                style.visibility = &quot;hidden&quot;;
                                style.position = &quot;absolute&quot;;
                                style.whiteSpace = &quot;pre&quot;;
                        
                                if (useragent.isIE &lt; 8) {
                                    style[&quot;font-family&quot;] = &quot;inherit&quot;;
                                } else {
                                    style.font = &quot;inherit&quot;;
                                }
                                style.overflow = isRoot ? &quot;hidden&quot; : &quot;visible&quot;;
                            };
                        
                            this.checkForSizeChanges = function() {
                                var size = this.$measureSizes();
                                if (size &amp;&amp; (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
                                    this.$measureNode.style.fontWeight = &quot;bold&quot;;
                                    var boldSize = this.$measureSizes();
                                    this.$measureNode.style.fontWeight = &quot;&quot;;
                                    this.$characterSize = size;
                                    this.charSizes = Object.create(null);
                                    this.allowBoldFonts = boldSize &amp;&amp; boldSize.width === size.width &amp;&amp; boldSize.height === size.height;
                                    this._emit(&quot;changeCharacterSize&quot;, {data: size});
                                }
                            };
                        
                            this.$pollSizeChanges = function() {
                                if (this.$pollSizeChangesTimer)
                                    return this.$pollSizeChangesTimer;
                                var self = this;
                                return this.$pollSizeChangesTimer = setInterval(function() {
                                    self.checkForSizeChanges();
                                }, 500);
                            };
                            
                            this.setPolling = function(val) {
                                if (val) {
                                    this.$pollSizeChanges();
                                } else if (this.$pollSizeChangesTimer) {
                                    clearInterval(this.$pollSizeChangesTimer);
                                    this.$pollSizeChangesTimer = 0;
                                }
                            };
                        
                            this.$measureSizes = function() {
                                if (CHAR_COUNT === 50) {
                                    var rect = null;
                                    try { 
                                       rect = this.$measureNode.getBoundingClientRect();
                                    } catch(e) {
                                       rect = {width: 0, height:0 };
                                    };
                                    var size = {
                                        height: rect.height,
                                        width: rect.width / CHAR_COUNT
                                    };
                                } else {
                                    var size = {
                                        height: this.$measureNode.clientHeight,
                                        width: this.$measureNode.clientWidth / CHAR_COUNT
                                    };
                                }
                                if (size.width === 0 || size.height === 0)
                                    return null;
                                return size;
                            };
                        
                            this.$measureCharWidth = function(ch) {
                                this.$main.innerHTML = lang.stringRepeat(ch, CHAR_COUNT);
                                var rect = this.$main.getBoundingClientRect();
                                return rect.width / CHAR_COUNT;
                            };
                            
                            this.getCharacterWidth = function(ch) {
                                var w = this.charSizes[ch];
                                if (w === undefined) {
                                    this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
                                }
                                return w;
                            };
                        
                            this.destroy = function() {
                                clearInterval(this.$pollSizeChangesTimer);
                                if (this.el &amp;&amp; this.el.parentNode)
                                    this.el.parentNode.removeChild(this.el);
                            };
                        
                        }).call(FontMetrics.prototype);
                        
                        });
                        
                        define(&quot;ace/virtual_renderer&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/dom&quot;,&quot;ace/config&quot;,&quot;ace/lib/useragent&quot;,&quot;ace/layer/gutter&quot;,&quot;ace/layer/marker&quot;,&quot;ace/layer/text&quot;,&quot;ace/layer/cursor&quot;,&quot;ace/scrollbar&quot;,&quot;ace/scrollbar&quot;,&quot;ace/renderloop&quot;,&quot;ace/layer/font_metrics&quot;,&quot;ace/lib/event_emitter&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var oop = require(&quot;./lib/oop&quot;);
                        var dom = require(&quot;./lib/dom&quot;);
                        var config = require(&quot;./config&quot;);
                        var useragent = require(&quot;./lib/useragent&quot;);
                        var GutterLayer = require(&quot;./layer/gutter&quot;).Gutter;
                        var MarkerLayer = require(&quot;./layer/marker&quot;).Marker;
                        var TextLayer = require(&quot;./layer/text&quot;).Text;
                        var CursorLayer = require(&quot;./layer/cursor&quot;).Cursor;
                        var HScrollBar = require(&quot;./scrollbar&quot;).HScrollBar;
                        var VScrollBar = require(&quot;./scrollbar&quot;).VScrollBar;
                        var RenderLoop = require(&quot;./renderloop&quot;).RenderLoop;
                        var FontMetrics = require(&quot;./layer/font_metrics&quot;).FontMetrics;
                        var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
                        var editorCss = &quot;.ace_editor {\
                        position: relative;\
                        overflow: hidden;\
                        font: 12px/normal &#x27;Monaco&#x27;, &#x27;Menlo&#x27;, &#x27;Ubuntu Mono&#x27;, &#x27;Consolas&#x27;, &#x27;source-code-pro&#x27;, monospace;\
                        direction: ltr;\
                        }\
                        .ace_scroller {\
                        position: absolute;\
                        overflow: hidden;\
                        top: 0;\
                        bottom: 0;\
                        background-color: inherit;\
                        -ms-user-select: none;\
                        -moz-user-select: none;\
                        -webkit-user-select: none;\
                        user-select: none;\
                        cursor: text;\
                        }\
                        .ace_content {\
                        position: absolute;\
                        -moz-box-sizing: border-box;\
                        -webkit-box-sizing: border-box;\
                        box-sizing: border-box;\
                        min-width: 100%;\
                        }\
                        .ace_dragging .ace_scroller:before{\
                        position: absolute;\
                        top: 0;\
                        left: 0;\
                        right: 0;\
                        bottom: 0;\
                        content: &#x27;&#x27;;\
                        background: rgba(250, 250, 250, 0.01);\
                        z-index: 1000;\
                        }\
                        .ace_dragging.ace_dark .ace_scroller:before{\
                        background: rgba(0, 0, 0, 0.01);\
                        }\
                        .ace_selecting, .ace_selecting * {\
                        cursor: text !important;\
                        }\
                        .ace_gutter {\
                        position: absolute;\
                        overflow : hidden;\
                        width: auto;\
                        top: 0;\
                        bottom: 0;\
                        left: 0;\
                        cursor: default;\
                        z-index: 4;\
                        -ms-user-select: none;\
                        -moz-user-select: none;\
                        -webkit-user-select: none;\
                        user-select: none;\
                        }\
                        .ace_gutter-active-line {\
                        position: absolute;\
                        left: 0;\
                        right: 0;\
                        }\
                        .ace_scroller.ace_scroll-left {\
                        box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\
                        }\
                        .ace_gutter-cell {\
                        padding-left: 19px;\
                        padding-right: 6px;\
                        background-repeat: no-repeat;\
                        }\
                        .ace_gutter-cell.ace_error {\
                        background-image: url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\&quot;);\
                        background-repeat: no-repeat;\
                        background-position: 2px center;\
                        }\
                        .ace_gutter-cell.ace_warning {\
                        background-image: url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\&quot;);\
                        background-position: 2px center;\
                        }\
                        .ace_gutter-cell.ace_info {\
                        background-image: url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\&quot;);\
                        background-position: 2px center;\
                        }\
                        .ace_dark .ace_gutter-cell.ace_info {\
                        background-image: url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\&quot;);\
                        }\
                        .ace_scrollbar {\
                        position: absolute;\
                        right: 0;\
                        bottom: 0;\
                        z-index: 6;\
                        }\
                        .ace_scrollbar-inner {\
                        position: absolute;\
                        cursor: text;\
                        left: 0;\
                        top: 0;\
                        }\
                        .ace_scrollbar-v{\
                        overflow-x: hidden;\
                        overflow-y: scroll;\
                        top: 0;\
                        }\
                        .ace_scrollbar-h {\
                        overflow-x: scroll;\
                        overflow-y: hidden;\
                        left: 0;\
                        }\
                        .ace_print-margin {\
                        position: absolute;\
                        height: 100%;\
                        }\
                        .ace_text-input {\
                        position: absolute;\
                        z-index: 0;\
                        width: 0.5em;\
                        height: 1em;\
                        opacity: 0;\
                        background: transparent;\
                        -moz-appearance: none;\
                        appearance: none;\
                        border: none;\
                        resize: none;\
                        outline: none;\
                        overflow: hidden;\
                        font: inherit;\
                        padding: 0 1px;\
                        margin: 0 -1px;\
                        text-indent: -1em;\
                        -ms-user-select: text;\
                        -moz-user-select: text;\
                        -webkit-user-select: text;\
                        user-select: text;\
                        }\
                        .ace_text-input.ace_composition {\
                        background: inherit;\
                        color: inherit;\
                        z-index: 1000;\
                        opacity: 1;\
                        text-indent: 0;\
                        }\
                        .ace_layer {\
                        z-index: 1;\
                        position: absolute;\
                        overflow: hidden;\
                        word-wrap: normal;\
                        white-space: pre;\
                        height: 100%;\
                        width: 100%;\
                        -moz-box-sizing: border-box;\
                        -webkit-box-sizing: border-box;\
                        box-sizing: border-box;\
                        pointer-events: none;\
                        }\
                        .ace_gutter-layer {\
                        position: relative;\
                        width: auto;\
                        text-align: right;\
                        pointer-events: auto;\
                        }\
                        .ace_text-layer {\
                        font: inherit !important;\
                        }\
                        .ace_cjk {\
                        display: inline-block;\
                        text-align: center;\
                        }\
                        .ace_cursor-layer {\
                        z-index: 4;\
                        }\
                        .ace_cursor {\
                        z-index: 4;\
                        position: absolute;\
                        -moz-box-sizing: border-box;\
                        -webkit-box-sizing: border-box;\
                        box-sizing: border-box;\
                        border-left: 2px solid\
                        }\
                        .ace_slim-cursors .ace_cursor {\
                        border-left-width: 1px;\
                        }\
                        .ace_overwrite-cursors .ace_cursor {\
                        border-left-width: 0;\
                        border-bottom: 1px solid;\
                        }\
                        .ace_hidden-cursors .ace_cursor {\
                        opacity: 0.2;\
                        }\
                        .ace_smooth-blinking .ace_cursor {\
                        -webkit-transition: opacity 0.18s;\
                        transition: opacity 0.18s;\
                        }\
                        .ace_editor.ace_multiselect .ace_cursor {\
                        border-left-width: 1px;\
                        }\
                        .ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\
                        position: absolute;\
                        z-index: 3;\
                        }\
                        .ace_marker-layer .ace_selection {\
                        position: absolute;\
                        z-index: 5;\
                        }\
                        .ace_marker-layer .ace_bracket {\
                        position: absolute;\
                        z-index: 6;\
                        }\
                        .ace_marker-layer .ace_active-line {\
                        position: absolute;\
                        z-index: 2;\
                        }\
                        .ace_marker-layer .ace_selected-word {\
                        position: absolute;\
                        z-index: 4;\
                        -moz-box-sizing: border-box;\
                        -webkit-box-sizing: border-box;\
                        box-sizing: border-box;\
                        }\
                        .ace_line .ace_fold {\
                        -moz-box-sizing: border-box;\
                        -webkit-box-sizing: border-box;\
                        box-sizing: border-box;\
                        display: inline-block;\
                        height: 11px;\
                        margin-top: -2px;\
                        vertical-align: middle;\
                        background-image:\
                        url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\&quot;),\
                        url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\&quot;);\
                        background-repeat: no-repeat, repeat-x;\
                        background-position: center center, top left;\
                        color: transparent;\
                        border: 1px solid black;\
                        border-radius: 2px;\
                        cursor: pointer;\
                        pointer-events: auto;\
                        }\
                        .ace_dark .ace_fold {\
                        }\
                        .ace_fold:hover{\
                        background-image:\
                        url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\&quot;),\
                        url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\&quot;);\
                        }\
                        .ace_tooltip {\
                        background-color: #FFF;\
                        background-image: -webkit-linear-gradient(top, transparent, rgba(0, 0, 0, 0.1));\
                        background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\
                        border: 1px solid gray;\
                        border-radius: 1px;\
                        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\
                        color: black;\
                        max-width: 100%;\
                        padding: 3px 4px;\
                        position: fixed;\
                        z-index: 999999;\
                        -moz-box-sizing: border-box;\
                        -webkit-box-sizing: border-box;\
                        box-sizing: border-box;\
                        cursor: default;\
                        white-space: pre;\
                        word-wrap: break-word;\
                        line-height: normal;\
                        font-style: normal;\
                        font-weight: normal;\
                        letter-spacing: normal;\
                        pointer-events: none;\
                        }\
                        .ace_folding-enabled &gt; .ace_gutter-cell {\
                        padding-right: 13px;\
                        }\
                        .ace_fold-widget {\
                        -moz-box-sizing: border-box;\
                        -webkit-box-sizing: border-box;\
                        box-sizing: border-box;\
                        margin: 0 -12px 0 1px;\
                        display: none;\
                        width: 11px;\
                        vertical-align: top;\
                        background-image: url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\&quot;);\
                        background-repeat: no-repeat;\
                        background-position: center;\
                        border-radius: 3px;\
                        border: 1px solid transparent;\
                        cursor: pointer;\
                        }\
                        .ace_folding-enabled .ace_fold-widget {\
                        display: inline-block;   \
                        }\
                        .ace_fold-widget.ace_end {\
                        background-image: url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\&quot;);\
                        }\
                        .ace_fold-widget.ace_closed {\
                        background-image: url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\&quot;);\
                        }\
                        .ace_fold-widget:hover {\
                        border: 1px solid rgba(0, 0, 0, 0.3);\
                        background-color: rgba(255, 255, 255, 0.2);\
                        box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\
                        }\
                        .ace_fold-widget:active {\
                        border: 1px solid rgba(0, 0, 0, 0.4);\
                        background-color: rgba(0, 0, 0, 0.05);\
                        box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\
                        }\
                        .ace_dark .ace_fold-widget {\
                        background-image: url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\&quot;);\
                        }\
                        .ace_dark .ace_fold-widget.ace_end {\
                        background-image: url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\&quot;);\
                        }\
                        .ace_dark .ace_fold-widget.ace_closed {\
                        background-image: url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\&quot;);\
                        }\
                        .ace_dark .ace_fold-widget:hover {\
                        box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
                        background-color: rgba(255, 255, 255, 0.1);\
                        }\
                        .ace_dark .ace_fold-widget:active {\
                        box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
                        }\
                        .ace_fold-widget.ace_invalid {\
                        background-color: #FFB4B4;\
                        border-color: #DE5555;\
                        }\
                        .ace_fade-fold-widgets .ace_fold-widget {\
                        -webkit-transition: opacity 0.4s ease 0.05s;\
                        transition: opacity 0.4s ease 0.05s;\
                        opacity: 0;\
                        }\
                        .ace_fade-fold-widgets:hover .ace_fold-widget {\
                        -webkit-transition: opacity 0.05s ease 0.05s;\
                        transition: opacity 0.05s ease 0.05s;\
                        opacity:1;\
                        }\
                        .ace_underline {\
                        text-decoration: underline;\
                        }\
                        .ace_bold {\
                        font-weight: bold;\
                        }\
                        .ace_nobold .ace_bold {\
                        font-weight: normal;\
                        }\
                        .ace_italic {\
                        font-style: italic;\
                        }\
                        .ace_error-marker {\
                        background-color: rgba(255, 0, 0,0.2);\
                        position: absolute;\
                        z-index: 9;\
                        }\
                        .ace_highlight-marker {\
                        background-color: rgba(255, 255, 0,0.2);\
                        position: absolute;\
                        z-index: 8;\
                        }\
                        &quot;;
                        
                        dom.importCssString(editorCss, &quot;ace_editor.css&quot;);
                        
                        var VirtualRenderer = function(container, theme) {
                            var _self = this;
                        
                            this.container = container || dom.createElement(&quot;div&quot;);
                            this.$keepTextAreaAtCursor = !useragent.isOldIE;
                        
                            dom.addCssClass(this.container, &quot;ace_editor&quot;);
                        
                            this.setTheme(theme);
                        
                            this.$gutter = dom.createElement(&quot;div&quot;);
                            this.$gutter.className = &quot;ace_gutter&quot;;
                            this.container.appendChild(this.$gutter);
                        
                            this.scroller = dom.createElement(&quot;div&quot;);
                            this.scroller.className = &quot;ace_scroller&quot;;
                            this.container.appendChild(this.scroller);
                        
                            this.content = dom.createElement(&quot;div&quot;);
                            this.content.className = &quot;ace_content&quot;;
                            this.scroller.appendChild(this.content);
                        
                            this.$gutterLayer = new GutterLayer(this.$gutter);
                            this.$gutterLayer.on(&quot;changeGutterWidth&quot;, this.onGutterResize.bind(this));
                        
                            this.$markerBack = new MarkerLayer(this.content);
                        
                            var textLayer = this.$textLayer = new TextLayer(this.content);
                            this.canvas = textLayer.element;
                        
                            this.$markerFront = new MarkerLayer(this.content);
                        
                            this.$cursorLayer = new CursorLayer(this.content);
                            this.$horizScroll = false;
                            this.$vScroll = false;
                        
                            this.scrollBar = 
                            this.scrollBarV = new VScrollBar(this.container, this);
                            this.scrollBarH = new HScrollBar(this.container, this);
                            this.scrollBarV.addEventListener(&quot;scroll&quot;, function(e) {
                                if (!_self.$scrollAnimation)
                                    _self.session.setScrollTop(e.data - _self.scrollMargin.top);
                            });
                            this.scrollBarH.addEventListener(&quot;scroll&quot;, function(e) {
                                if (!_self.$scrollAnimation)
                                    _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
                            });
                        
                            this.scrollTop = 0;
                            this.scrollLeft = 0;
                        
                            this.cursorPos = {
                                row : 0,
                                column : 0
                            };
                        
                            this.$fontMetrics = new FontMetrics(this.container, 500);
                            this.$textLayer.$setFontMetrics(this.$fontMetrics);
                            this.$textLayer.addEventListener(&quot;changeCharacterSize&quot;, function(e) {
                                _self.updateCharacterSize();
                                _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
                                _self._signal(&quot;changeCharacterSize&quot;, e);
                            });
                        
                            this.$size = {
                                width: 0,
                                height: 0,
                                scrollerHeight: 0,
                                scrollerWidth: 0,
                                $dirty: true
                            };
                        
                            this.layerConfig = {
                                width : 1,
                                padding : 0,
                                firstRow : 0,
                                firstRowScreen: 0,
                                lastRow : 0,
                                lineHeight : 0,
                                characterWidth : 0,
                                minHeight : 1,
                                maxHeight : 1,
                                offset : 0,
                                height : 1,
                                gutterOffset: 1
                            };
                            
                            this.scrollMargin = {
                                left: 0,
                                right: 0,
                                top: 0,
                                bottom: 0,
                                v: 0,
                                h: 0
                            };
                        
                            this.$loop = new RenderLoop(
                                this.$renderChanges.bind(this),
                                this.container.ownerDocument.defaultView
                            );
                            this.$loop.schedule(this.CHANGE_FULL);
                        
                            this.updateCharacterSize();
                            this.setPadding(4);
                            config.resetOptions(this);
                            config._emit(&quot;renderer&quot;, this);
                        };
                        
                        (function() {
                        
                            this.CHANGE_CURSOR = 1;
                            this.CHANGE_MARKER = 2;
                            this.CHANGE_GUTTER = 4;
                            this.CHANGE_SCROLL = 8;
                            this.CHANGE_LINES = 16;
                            this.CHANGE_TEXT = 32;
                            this.CHANGE_SIZE = 64;
                            this.CHANGE_MARKER_BACK = 128;
                            this.CHANGE_MARKER_FRONT = 256;
                            this.CHANGE_FULL = 512;
                            this.CHANGE_H_SCROLL = 1024;
                        
                            oop.implement(this, EventEmitter);
                        
                            this.updateCharacterSize = function() {
                                if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
                                    this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
                                    this.setStyle(&quot;ace_nobold&quot;, !this.$allowBoldFonts);
                                }
                        
                                this.layerConfig.characterWidth =
                                this.characterWidth = this.$textLayer.getCharacterWidth();
                                this.layerConfig.lineHeight =
                                this.lineHeight = this.$textLayer.getLineHeight();
                                this.$updatePrintMargin();
                            };
                            this.setSession = function(session) {
                                if (this.session)
                                    this.session.doc.off(&quot;changeNewLineMode&quot;, this.onChangeNewLineMode);
                                    
                                this.session = session;
                                if (session &amp;&amp; this.scrollMargin.top &amp;&amp; session.getScrollTop() &lt;= 0)
                                    session.setScrollTop(-this.scrollMargin.top);
                        
                                this.$cursorLayer.setSession(session);
                                this.$markerBack.setSession(session);
                                this.$markerFront.setSession(session);
                                this.$gutterLayer.setSession(session);
                                this.$textLayer.setSession(session);
                                if (!session)
                                    return;
                                
                                this.$loop.schedule(this.CHANGE_FULL);
                                this.session.$setFontMetrics(this.$fontMetrics);
                                
                                this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
                                this.onChangeNewLineMode()
                                this.session.doc.on(&quot;changeNewLineMode&quot;, this.onChangeNewLineMode);
                            };
                            this.updateLines = function(firstRow, lastRow, force) {
                                if (lastRow === undefined)
                                    lastRow = Infinity;
                        
                                if (!this.$changedLines) {
                                    this.$changedLines = {
                                        firstRow: firstRow,
                                        lastRow: lastRow
                                    };
                                }
                                else {
                                    if (this.$changedLines.firstRow &gt; firstRow)
                                        this.$changedLines.firstRow = firstRow;
                        
                                    if (this.$changedLines.lastRow &lt; lastRow)
                                        this.$changedLines.lastRow = lastRow;
                                }
                                if (this.$changedLines.lastRow &lt; this.layerConfig.firstRow) {
                                    if (force)
                                        this.$changedLines.lastRow = this.layerConfig.lastRow;
                                    else
                                        return;
                                }
                                if (this.$changedLines.firstRow &gt; this.layerConfig.lastRow)
                                    return;
                                this.$loop.schedule(this.CHANGE_LINES);
                            };
                        
                            this.onChangeNewLineMode = function() {
                                this.$loop.schedule(this.CHANGE_TEXT);
                                this.$textLayer.$updateEolChar();
                            };
                            
                            this.onChangeTabSize = function() {
                                this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
                                this.$textLayer.onChangeTabSize();
                            };
                            this.updateText = function() {
                                this.$loop.schedule(this.CHANGE_TEXT);
                            };
                            this.updateFull = function(force) {
                                if (force)
                                    this.$renderChanges(this.CHANGE_FULL, true);
                                else
                                    this.$loop.schedule(this.CHANGE_FULL);
                            };
                            this.updateFontSize = function() {
                                this.$textLayer.checkForSizeChanges();
                            };
                        
                            this.$changes = 0;
                            this.$updateSizeAsync = function() {
                                if (this.$loop.pending)
                                    this.$size.$dirty = true;
                                else
                                    this.onResize();
                            };
                            this.onResize = function(force, gutterWidth, width, height) {
                                if (this.resizing &gt; 2)
                                    return;
                                else if (this.resizing &gt; 0)
                                    this.resizing++;
                                else
                                    this.resizing = force ? 1 : 0;
                                var el = this.container;
                                if (!height)
                                    height = el.clientHeight || el.scrollHeight;
                                if (!width)
                                    width = el.clientWidth || el.scrollWidth;
                                var changes = this.$updateCachedSize(force, gutterWidth, width, height);
                        
                                
                                if (!this.$size.scrollerHeight || (!width &amp;&amp; !height))
                                    return this.resizing = 0;
                        
                                if (force)
                                    this.$gutterLayer.$padding = null;
                        
                                if (force)
                                    this.$renderChanges(changes | this.$changes, true);
                                else
                                    this.$loop.schedule(changes | this.$changes);
                        
                                if (this.resizing)
                                    this.resizing = 0;
                                this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;
                            };
                            
                            this.$updateCachedSize = function(force, gutterWidth, width, height) {
                                height -= (this.$extraHeight || 0);
                                var changes = 0;
                                var size = this.$size;
                                var oldSize = {
                                    width: size.width,
                                    height: size.height,
                                    scrollerHeight: size.scrollerHeight,
                                    scrollerWidth: size.scrollerWidth
                                };
                                if (height &amp;&amp; (force || size.height != height)) {
                                    size.height = height;
                                    changes |= this.CHANGE_SIZE;
                        
                                    size.scrollerHeight = size.height;
                                    if (this.$horizScroll)
                                        size.scrollerHeight -= this.scrollBarH.getHeight();
                                    this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + &quot;px&quot;;
                        
                                    changes = changes | this.CHANGE_SCROLL;
                                }
                        
                                if (width &amp;&amp; (force || size.width != width)) {
                                    changes |= this.CHANGE_SIZE;
                                    size.width = width;
                                    
                                    if (gutterWidth == null)
                                        gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
                                    
                                    this.gutterWidth = gutterWidth;
                                    
                                    this.scrollBarH.element.style.left = 
                                    this.scroller.style.left = gutterWidth + &quot;px&quot;;
                                    size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth());           
                                    
                                    this.scrollBarH.element.style.right = 
                                    this.scroller.style.right = this.scrollBarV.getWidth() + &quot;px&quot;;
                                    this.scroller.style.bottom = this.scrollBarH.getHeight() + &quot;px&quot;;
                        
                                    if (this.session &amp;&amp; this.session.getUseWrapMode() &amp;&amp; this.adjustWrapLimit() || force)
                                        changes |= this.CHANGE_FULL;
                                }
                                
                                size.$dirty = !width || !height;
                        
                                if (changes)
                                    this._signal(&quot;resize&quot;, oldSize);
                        
                                return changes;
                            };
                        
                            this.onGutterResize = function() {
                                var gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
                                if (gutterWidth != this.gutterWidth)
                                    this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);
                        
                                if (this.session.getUseWrapMode() &amp;&amp; this.adjustWrapLimit()) {
                                    this.$loop.schedule(this.CHANGE_FULL);
                                } else if (this.$size.$dirty) {
                                    this.$loop.schedule(this.CHANGE_FULL);
                                } else {
                                    this.$computeLayerConfig();
                                    this.$loop.schedule(this.CHANGE_MARKER);
                                }
                            };
                            this.adjustWrapLimit = function() {
                                var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
                                var limit = Math.floor(availableWidth / this.characterWidth);
                                return this.session.adjustWrapLimit(limit, this.$showPrintMargin &amp;&amp; this.$printMarginColumn);
                            };
                            this.setAnimatedScroll = function(shouldAnimate){
                                this.setOption(&quot;animatedScroll&quot;, shouldAnimate);
                            };
                            this.getAnimatedScroll = function() {
                                return this.$animatedScroll;
                            };
                            this.setShowInvisibles = function(showInvisibles) {
                                this.setOption(&quot;showInvisibles&quot;, showInvisibles);
                            };
                            this.getShowInvisibles = function() {
                                return this.getOption(&quot;showInvisibles&quot;);
                            };
                            this.getDisplayIndentGuides = function() {
                                return this.getOption(&quot;displayIndentGuides&quot;);
                            };
                        
                            this.setDisplayIndentGuides = function(display) {
                                this.setOption(&quot;displayIndentGuides&quot;, display);
                            };
                            this.setShowPrintMargin = function(showPrintMargin) {
                                this.setOption(&quot;showPrintMargin&quot;, showPrintMargin);
                            };
                            this.getShowPrintMargin = function() {
                                return this.getOption(&quot;showPrintMargin&quot;);
                            };
                            this.setPrintMarginColumn = function(showPrintMargin) {
                                this.setOption(&quot;printMarginColumn&quot;, showPrintMargin);
                            };
                            this.getPrintMarginColumn = function() {
                                return this.getOption(&quot;printMarginColumn&quot;);
                            };
                            this.getShowGutter = function(){
                                return this.getOption(&quot;showGutter&quot;);
                            };
                            this.setShowGutter = function(show){
                                return this.setOption(&quot;showGutter&quot;, show);
                            };
                        
                            this.getFadeFoldWidgets = function(){
                                return this.getOption(&quot;fadeFoldWidgets&quot;)
                            };
                        
                            this.setFadeFoldWidgets = function(show) {
                                this.setOption(&quot;fadeFoldWidgets&quot;, show);
                            };
                        
                            this.setHighlightGutterLine = function(shouldHighlight) {
                                this.setOption(&quot;highlightGutterLine&quot;, shouldHighlight);
                            };
                        
                            this.getHighlightGutterLine = function() {
                                return this.getOption(&quot;highlightGutterLine&quot;);
                            };
                        
                            this.$updateGutterLineHighlight = function() {
                                var pos = this.$cursorLayer.$pixelPos;
                                var height = this.layerConfig.lineHeight;
                                if (this.session.getUseWrapMode()) {
                                    var cursor = this.session.selection.getCursor();
                                    cursor.column = 0;
                                    pos = this.$cursorLayer.getPixelPosition(cursor, true);
                                    height *= this.session.getRowLength(cursor.row);
                                }
                                this.$gutterLineHighlight.style.top = pos.top - this.layerConfig.offset + &quot;px&quot;;
                                this.$gutterLineHighlight.style.height = height + &quot;px&quot;;
                            };
                        
                            this.$updatePrintMargin = function() {
                                if (!this.$showPrintMargin &amp;&amp; !this.$printMarginEl)
                                    return;
                        
                                if (!this.$printMarginEl) {
                                    var containerEl = dom.createElement(&quot;div&quot;);
                                    containerEl.className = &quot;ace_layer ace_print-margin-layer&quot;;
                                    this.$printMarginEl = dom.createElement(&quot;div&quot;);
                                    this.$printMarginEl.className = &quot;ace_print-margin&quot;;
                                    containerEl.appendChild(this.$printMarginEl);
                                    this.content.insertBefore(containerEl, this.content.firstChild);
                                }
                        
                                var style = this.$printMarginEl.style;
                                style.left = ((this.characterWidth * this.$printMarginColumn) + this.$padding) + &quot;px&quot;;
                                style.visibility = this.$showPrintMargin ? &quot;visible&quot; : &quot;hidden&quot;;
                                
                                if (this.session &amp;&amp; this.session.$wrap == -1)
                                    this.adjustWrapLimit();
                            };
                            this.getContainerElement = function() {
                                return this.container;
                            };
                            this.getMouseEventTarget = function() {
                                return this.content;
                            };
                            this.getTextAreaContainer = function() {
                                return this.container;
                            };
                            this.$moveTextAreaToCursor = function() {
                                if (!this.$keepTextAreaAtCursor)
                                    return;
                                var config = this.layerConfig;
                                var posTop = this.$cursorLayer.$pixelPos.top;
                                var posLeft = this.$cursorLayer.$pixelPos.left;
                                posTop -= config.offset;
                        
                                var style = this.textarea.style;
                                var h = this.lineHeight;
                                if (posTop &lt; 0 || posTop &gt; config.height - h) {
                                    style.top = style.left = &quot;0&quot;;
                                    return;
                                }
                        
                                var w = this.characterWidth;
                                if (this.$composition) {
                                    var val = this.textarea.value.replace(/^\x01+/, &quot;&quot;);
                                    w *= (this.session.$getStringScreenWidth(val)[0]+2);
                                    h += 2;
                                }
                                posLeft -= this.scrollLeft;
                                if (posLeft &gt; this.$size.scrollerWidth - w)
                                    posLeft = this.$size.scrollerWidth - w;
                        
                                posLeft += this.gutterWidth;
                                style.height = h + &quot;px&quot;;
                                style.width = w + &quot;px&quot;;
                                style.left = Math.min(posLeft, this.$size.scrollerWidth - w) + &quot;px&quot;;
                                style.top = Math.min(posTop, this.$size.height - h) + &quot;px&quot;;
                            };
                            this.getFirstVisibleRow = function() {
                                return this.layerConfig.firstRow;
                            };
                            this.getFirstFullyVisibleRow = function() {
                                return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
                            };
                            this.getLastFullyVisibleRow = function() {
                                var flint = Math.floor((this.layerConfig.height + this.layerConfig.offset) / this.layerConfig.lineHeight);
                                return this.layerConfig.firstRow - 1 + flint;
                            };
                            this.getLastVisibleRow = function() {
                                return this.layerConfig.lastRow;
                            };
                        
                            this.$padding = null;
                            this.setPadding = function(padding) {
                                this.$padding = padding;
                                this.$textLayer.setPadding(padding);
                                this.$cursorLayer.setPadding(padding);
                                this.$markerFront.setPadding(padding);
                                this.$markerBack.setPadding(padding);
                                this.$loop.schedule(this.CHANGE_FULL);
                                this.$updatePrintMargin();
                            };
                            
                            this.setScrollMargin = function(top, bottom, left, right) {
                                var sm = this.scrollMargin;
                                sm.top = top|0;
                                sm.bottom = bottom|0;
                                sm.right = right|0;
                                sm.left = left|0;
                                sm.v = sm.top + sm.bottom;
                                sm.h = sm.left + sm.right;
                                if (sm.top &amp;&amp; this.scrollTop &lt;= 0 &amp;&amp; this.session)
                                    this.session.setScrollTop(-sm.top);
                                this.updateFull();
                            };
                            this.getHScrollBarAlwaysVisible = function() {
                                return this.$hScrollBarAlwaysVisible;
                            };
                            this.setHScrollBarAlwaysVisible = function(alwaysVisible) {
                                this.setOption(&quot;hScrollBarAlwaysVisible&quot;, alwaysVisible);
                            };
                            this.getVScrollBarAlwaysVisible = function() {
                                return this.$vScrollBarAlwaysVisible;
                            };
                            this.setVScrollBarAlwaysVisible = function(alwaysVisible) {
                                this.setOption(&quot;vScrollBarAlwaysVisible&quot;, alwaysVisible);
                            };
                        
                            this.$updateScrollBarV = function() {
                                var scrollHeight = this.layerConfig.maxHeight;
                                var scrollerHeight = this.$size.scrollerHeight;
                                if (!this.$maxLines &amp;&amp; this.$scrollPastEnd) {
                                    scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
                                    if (this.scrollTop &gt; scrollHeight - scrollerHeight) {
                                        scrollHeight = this.scrollTop + scrollerHeight;
                                        this.scrollBarV.scrollTop = null;
                                    }
                                }
                                this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
                                this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
                            };
                            this.$updateScrollBarH = function() {
                                this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
                                this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
                            };
                            
                            this.$frozen = false;
                            this.freeze = function() {
                                this.$frozen = true;
                            };
                            
                            this.unfreeze = function() {
                                this.$frozen = false;
                            };
                        
                            this.$renderChanges = function(changes, force) {
                                if (this.$changes) {
                                    changes |= this.$changes;
                                    this.$changes = 0;
                                }
                                if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes &amp;&amp; !force)) {
                                    this.$changes |= changes;
                                    return; 
                                } 
                                if (this.$size.$dirty) {
                                    this.$changes |= changes;
                                    return this.onResize(true);
                                }
                                if (!this.lineHeight) {
                                    this.$textLayer.checkForSizeChanges();
                                }
                                
                                this._signal(&quot;beforeRender&quot;);
                                var config = this.layerConfig;
                                if (changes &amp; this.CHANGE_FULL ||
                                    changes &amp; this.CHANGE_SIZE ||
                                    changes &amp; this.CHANGE_TEXT ||
                                    changes &amp; this.CHANGE_LINES ||
                                    changes &amp; this.CHANGE_SCROLL ||
                                    changes &amp; this.CHANGE_H_SCROLL
                                ) {
                                    changes |= this.$computeLayerConfig();
                                    if (config.firstRow != this.layerConfig.firstRow &amp;&amp; config.firstRowScreen == this.layerConfig.firstRowScreen) {
                                        var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;
                                        if (st &gt; 0) {
                                            this.scrollTop = st;
                                            changes = changes | this.CHANGE_SCROLL;
                                            changes |= this.$computeLayerConfig();
                                        }
                                    }
                                    config = this.layerConfig;
                                    this.$updateScrollBarV();
                                    if (changes &amp; this.CHANGE_H_SCROLL)
                                        this.$updateScrollBarH();
                                    this.$gutterLayer.element.style.marginTop = (-config.offset) + &quot;px&quot;;
                                    this.content.style.marginTop = (-config.offset) + &quot;px&quot;;
                                    this.content.style.width = config.width + 2 * this.$padding + &quot;px&quot;;
                                    this.content.style.height = config.minHeight + &quot;px&quot;;
                                }
                                if (changes &amp; this.CHANGE_H_SCROLL) {
                                    this.content.style.marginLeft = -this.scrollLeft + &quot;px&quot;;
                                    this.scroller.className = this.scrollLeft &lt;= 0 ? &quot;ace_scroller&quot; : &quot;ace_scroller ace_scroll-left&quot;;
                                }
                                if (changes &amp; this.CHANGE_FULL) {
                                    this.$textLayer.update(config);
                                    if (this.$showGutter)
                                        this.$gutterLayer.update(config);
                                    this.$markerBack.update(config);
                                    this.$markerFront.update(config);
                                    this.$cursorLayer.update(config);
                                    this.$moveTextAreaToCursor();
                                    this.$highlightGutterLine &amp;&amp; this.$updateGutterLineHighlight();
                                    this._signal(&quot;afterRender&quot;);
                                    return;
                                }
                                if (changes &amp; this.CHANGE_SCROLL) {
                                    if (changes &amp; this.CHANGE_TEXT || changes &amp; this.CHANGE_LINES)
                                        this.$textLayer.update(config);
                                    else
                                        this.$textLayer.scrollLines(config);
                        
                                    if (this.$showGutter)
                                        this.$gutterLayer.update(config);
                                    this.$markerBack.update(config);
                                    this.$markerFront.update(config);
                                    this.$cursorLayer.update(config);
                                    this.$highlightGutterLine &amp;&amp; this.$updateGutterLineHighlight();
                                    this.$moveTextAreaToCursor();
                                    this._signal(&quot;afterRender&quot;);
                                    return;
                                }
                        
                                if (changes &amp; this.CHANGE_TEXT) {
                                    this.$textLayer.update(config);
                                    if (this.$showGutter)
                                        this.$gutterLayer.update(config);
                                }
                                else if (changes &amp; this.CHANGE_LINES) {
                                    if (this.$updateLines() || (changes &amp; this.CHANGE_GUTTER) &amp;&amp; this.$showGutter)
                                        this.$gutterLayer.update(config);
                                }
                                else if (changes &amp; this.CHANGE_TEXT || changes &amp; this.CHANGE_GUTTER) {
                                    if (this.$showGutter)
                                        this.$gutterLayer.update(config);
                                }
                        
                                if (changes &amp; this.CHANGE_CURSOR) {
                                    this.$cursorLayer.update(config);
                                    this.$moveTextAreaToCursor();
                                    this.$highlightGutterLine &amp;&amp; this.$updateGutterLineHighlight();
                                }
                        
                                if (changes &amp; (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
                                    this.$markerFront.update(config);
                                }
                        
                                if (changes &amp; (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
                                    this.$markerBack.update(config);
                                }
                        
                                this._signal(&quot;afterRender&quot;);
                            };
                        
                            
                            this.$autosize = function() {
                                var height = this.session.getScreenLength() * this.lineHeight;
                                var maxHeight = this.$maxLines * this.lineHeight;
                                var desiredHeight = Math.max(
                                    (this.$minLines||1) * this.lineHeight,
                                    Math.min(maxHeight, height)
                                ) + this.scrollMargin.v + (this.$extraHeight || 0);
                                var vScroll = height &gt; maxHeight;
                                
                                if (desiredHeight != this.desiredHeight ||
                                    this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
                                    if (vScroll != this.$vScroll) {
                                        this.$vScroll = vScroll;
                                        this.scrollBarV.setVisible(vScroll);
                                    }
                                    
                                    var w = this.container.clientWidth;
                                    this.container.style.height = desiredHeight + &quot;px&quot;;
                                    this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
                                    this.desiredHeight = desiredHeight;
                                    
                                    this._signal(&quot;autosize&quot;);
                                }
                            };
                            
                            this.$computeLayerConfig = function() {
                                if (this.$maxLines &amp;&amp; this.lineHeight &gt; 1)
                                    this.$autosize();
                        
                                var session = this.session;
                                var size = this.$size;
                                
                                var hideScrollbars = size.height &lt;= 2 * this.lineHeight;
                                var screenLines = this.session.getScreenLength();
                                var maxHeight = screenLines * this.lineHeight;
                        
                                var offset = this.scrollTop % this.lineHeight;
                                var minHeight = size.scrollerHeight + this.lineHeight;
                        
                                var longestLine = this.$getLongestLine();
                                
                                var horizScroll = !hideScrollbars &amp;&amp; (this.$hScrollBarAlwaysVisible ||
                                    size.scrollerWidth - longestLine - 2 * this.$padding &lt; 0);
                        
                                var hScrollChanged = this.$horizScroll !== horizScroll;
                                if (hScrollChanged) {
                                    this.$horizScroll = horizScroll;
                                    this.scrollBarH.setVisible(horizScroll);
                                }
                                
                                var scrollPastEnd = !this.$maxLines &amp;&amp; this.$scrollPastEnd
                                    ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd
                                    : 0;
                                maxHeight += scrollPastEnd;
                                
                                this.session.setScrollTop(Math.max(-this.scrollMargin.top,
                                    Math.min(this.scrollTop, maxHeight - size.scrollerHeight + this.scrollMargin.bottom)));
                        
                                this.session.setScrollLeft(Math.max(-this.scrollMargin.left, Math.min(this.scrollLeft, 
                                    longestLine + 2 * this.$padding - size.scrollerWidth + this.scrollMargin.right)));
                                
                                var vScroll = !hideScrollbars &amp;&amp; (this.$vScrollBarAlwaysVisible ||
                                    size.scrollerHeight - maxHeight + scrollPastEnd &lt; 0 || this.scrollTop);
                                var vScrollChanged = this.$vScroll !== vScroll;
                                if (vScrollChanged) {
                                    this.$vScroll = vScroll;
                                    this.scrollBarV.setVisible(vScroll);
                                }
                        
                                var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
                                var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
                                var lastRow = firstRow + lineCount;
                                var firstRowScreen, firstRowHeight;
                                var lineHeight = this.lineHeight;
                                firstRow = session.screenToDocumentRow(firstRow, 0);
                                var foldLine = session.getFoldLine(firstRow);
                                if (foldLine) {
                                    firstRow = foldLine.start.row;
                                }
                        
                                firstRowScreen = session.documentToScreenRow(firstRow, 0);
                                firstRowHeight = session.getRowLength(firstRow) * lineHeight;
                        
                                lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
                                minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +
                                                                        firstRowHeight;
                        
                                offset = this.scrollTop - firstRowScreen * lineHeight;
                        
                                var changes = 0;
                                if (this.layerConfig.width != longestLine) 
                                    changes = this.CHANGE_H_SCROLL;
                                if (hScrollChanged || vScrollChanged) {
                                    changes = this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
                                    this._signal(&quot;scrollbarVisibilityChanged&quot;);
                                    if (vScrollChanged)
                                        longestLine = this.$getLongestLine();
                                }
                                
                                this.layerConfig = {
                                    width : longestLine,
                                    padding : this.$padding,
                                    firstRow : firstRow,
                                    firstRowScreen: firstRowScreen,
                                    lastRow : lastRow,
                                    lineHeight : lineHeight,
                                    characterWidth : this.characterWidth,
                                    minHeight : minHeight,
                                    maxHeight : maxHeight,
                                    offset : offset,
                                    gutterOffset : Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)),
                                    height : this.$size.scrollerHeight
                                };
                        
                                return changes;
                            };
                        
                            this.$updateLines = function() {
                                var firstRow = this.$changedLines.firstRow;
                                var lastRow = this.$changedLines.lastRow;
                                this.$changedLines = null;
                        
                                var layerConfig = this.layerConfig;
                        
                                if (firstRow &gt; layerConfig.lastRow + 1) { return; }
                                if (lastRow &lt; layerConfig.firstRow) { return; }
                                if (lastRow === Infinity) {
                                    if (this.$showGutter)
                                        this.$gutterLayer.update(layerConfig);
                                    this.$textLayer.update(layerConfig);
                                    return;
                                }
                                this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
                                return true;
                            };
                        
                            this.$getLongestLine = function() {
                                var charCount = this.session.getScreenWidth();
                                if (this.showInvisibles &amp;&amp; !this.session.$useWrapMode)
                                    charCount += 1;
                        
                                return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
                            };
                            this.updateFrontMarkers = function() {
                                this.$markerFront.setMarkers(this.session.getMarkers(true));
                                this.$loop.schedule(this.CHANGE_MARKER_FRONT);
                            };
                            this.updateBackMarkers = function() {
                                this.$markerBack.setMarkers(this.session.getMarkers());
                                this.$loop.schedule(this.CHANGE_MARKER_BACK);
                            };
                            this.addGutterDecoration = function(row, className){
                                this.$gutterLayer.addGutterDecoration(row, className);
                            };
                            this.removeGutterDecoration = function(row, className){
                                this.$gutterLayer.removeGutterDecoration(row, className);
                            };
                            this.updateBreakpoints = function(rows) {
                                this.$loop.schedule(this.CHANGE_GUTTER);
                            };
                            this.setAnnotations = function(annotations) {
                                this.$gutterLayer.setAnnotations(annotations);
                                this.$loop.schedule(this.CHANGE_GUTTER);
                            };
                            this.updateCursor = function() {
                                this.$loop.schedule(this.CHANGE_CURSOR);
                            };
                            this.hideCursor = function() {
                                this.$cursorLayer.hideCursor();
                            };
                            this.showCursor = function() {
                                this.$cursorLayer.showCursor();
                            };
                        
                            this.scrollSelectionIntoView = function(anchor, lead, offset) {
                                this.scrollCursorIntoView(anchor, offset);
                                this.scrollCursorIntoView(lead, offset);
                            };
                            this.scrollCursorIntoView = function(cursor, offset, $viewMargin) {
                                if (this.$size.scrollerHeight === 0)
                                    return;
                        
                                var pos = this.$cursorLayer.getPixelPosition(cursor);
                        
                                var left = pos.left;
                                var top = pos.top;
                                
                                var topMargin = $viewMargin &amp;&amp; $viewMargin.top || 0;
                                var bottomMargin = $viewMargin &amp;&amp; $viewMargin.bottom || 0;
                                
                                var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
                                
                                if (scrollTop + topMargin &gt; top) {
                                    if (offset)
                                        top -= offset * this.$size.scrollerHeight;
                                    if (top === 0)
                                        top = -this.scrollMargin.top;
                                    this.session.setScrollTop(top);
                                } else if (scrollTop + this.$size.scrollerHeight - bottomMargin &lt; top + this.lineHeight) {
                                    if (offset)
                                        top += offset * this.$size.scrollerHeight;
                                    this.session.setScrollTop(top + this.lineHeight - this.$size.scrollerHeight);
                                }
                        
                                var scrollLeft = this.scrollLeft;
                        
                                if (scrollLeft &gt; left) {
                                    if (left &lt; this.$padding + 2 * this.layerConfig.characterWidth)
                                        left = -this.scrollMargin.left;
                                    this.session.setScrollLeft(left);
                                } else if (scrollLeft + this.$size.scrollerWidth &lt; left + this.characterWidth) {
                                    this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
                                } else if (scrollLeft &lt;= this.$padding &amp;&amp; left - scrollLeft &lt; this.characterWidth) {
                                    this.session.setScrollLeft(0);
                                }
                            };
                            this.getScrollTop = function() {
                                return this.session.getScrollTop();
                            };
                            this.getScrollLeft = function() {
                                return this.session.getScrollLeft();
                            };
                            this.getScrollTopRow = function() {
                                return this.scrollTop / this.lineHeight;
                            };
                            this.getScrollBottomRow = function() {
                                return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
                            };
                            this.scrollToRow = function(row) {
                                this.session.setScrollTop(row * this.lineHeight);
                            };
                        
                            this.alignCursor = function(cursor, alignment) {
                                if (typeof cursor == &quot;number&quot;)
                                    cursor = {row: cursor, column: 0};
                        
                                var pos = this.$cursorLayer.getPixelPosition(cursor);
                                var h = this.$size.scrollerHeight - this.lineHeight;
                                var offset = pos.top - h * (alignment || 0);
                        
                                this.session.setScrollTop(offset);
                                return offset;
                            };
                        
                            this.STEPS = 8;
                            this.$calcSteps = function(fromValue, toValue){
                                var i = 0;
                                var l = this.STEPS;
                                var steps = [];
                        
                                var func  = function(t, x_min, dx) {
                                    return dx * (Math.pow(t - 1, 3) + 1) + x_min;
                                };
                        
                                for (i = 0; i &lt; l; ++i)
                                    steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));
                        
                                return steps;
                            };
                            this.scrollToLine = function(line, center, animate, callback) {
                                var pos = this.$cursorLayer.getPixelPosition({row: line, column: 0});
                                var offset = pos.top;
                                if (center)
                                    offset -= this.$size.scrollerHeight / 2;
                        
                                var initialScroll = this.scrollTop;
                                this.session.setScrollTop(offset);
                                if (animate !== false)
                                    this.animateScrolling(initialScroll, callback);
                            };
                        
                            this.animateScrolling = function(fromValue, callback) {
                                var toValue = this.scrollTop;
                                if (!this.$animatedScroll)
                                    return;
                                var _self = this;
                                
                                if (fromValue == toValue)
                                    return;
                                
                                if (this.$scrollAnimation) {
                                    var oldSteps = this.$scrollAnimation.steps;
                                    if (oldSteps.length) {
                                        fromValue = oldSteps[0];
                                        if (fromValue == toValue)
                                            return;
                                    }
                                }
                                
                                var steps = _self.$calcSteps(fromValue, toValue);
                                this.$scrollAnimation = {from: fromValue, to: toValue, steps: steps};
                        
                                clearInterval(this.$timer);
                        
                                _self.session.setScrollTop(steps.shift());
                                _self.session.$scrollTop = toValue;
                                this.$timer = setInterval(function() {
                                    if (steps.length) {
                                        _self.session.setScrollTop(steps.shift());
                                        _self.session.$scrollTop = toValue;
                                    } else if (toValue != null) {
                                        _self.session.$scrollTop = -1;
                                        _self.session.setScrollTop(toValue);
                                        toValue = null;
                                    } else {
                                        _self.$timer = clearInterval(_self.$timer);
                                        _self.$scrollAnimation = null;
                                        callback &amp;&amp; callback();
                                    }
                                }, 10);
                            };
                            this.scrollToY = function(scrollTop) {
                                if (this.scrollTop !== scrollTop) {
                                    this.$loop.schedule(this.CHANGE_SCROLL);
                                    this.scrollTop = scrollTop;
                                }
                            };
                            this.scrollToX = function(scrollLeft) {
                                if (this.scrollLeft !== scrollLeft)
                                    this.scrollLeft = scrollLeft;
                                this.$loop.schedule(this.CHANGE_H_SCROLL);
                            };
                            this.scrollTo = function(x, y) {
                                this.session.setScrollTop(y);
                                this.session.setScrollLeft(y);
                            };
                            this.scrollBy = function(deltaX, deltaY) {
                                deltaY &amp;&amp; this.session.setScrollTop(this.session.getScrollTop() + deltaY);
                                deltaX &amp;&amp; this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
                            };
                            this.isScrollableBy = function(deltaX, deltaY) {
                                if (deltaY &lt; 0 &amp;&amp; this.session.getScrollTop() &gt;= 1 - this.scrollMargin.top)
                                   return true;
                                if (deltaY &gt; 0 &amp;&amp; this.session.getScrollTop() + this.$size.scrollerHeight
                                    - this.layerConfig.maxHeight &lt; -1 + this.scrollMargin.bottom)
                                   return true;
                                if (deltaX &lt; 0 &amp;&amp; this.session.getScrollLeft() &gt;= 1 - this.scrollMargin.left)
                                    return true;
                                if (deltaX &gt; 0 &amp;&amp; this.session.getScrollLeft() + this.$size.scrollerWidth
                                    - this.layerConfig.width &lt; -1 + this.scrollMargin.right)
                                   return true;
                            };
                        
                            this.pixelToScreenCoordinates = function(x, y) {
                                var canvasPos = this.scroller.getBoundingClientRect();
                        
                                var offset = (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth;
                                var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
                                var col = Math.round(offset);
                        
                                return {row: row, column: col, side: offset - col &gt; 0 ? 1 : -1};
                            };
                        
                            this.screenToTextCoordinates = function(x, y) {
                                var canvasPos = this.scroller.getBoundingClientRect();
                        
                                var col = Math.round(
                                    (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth
                                );
                        
                                var row = (y + this.scrollTop - canvasPos.top) / this.lineHeight;
                        
                                return this.session.screenToDocumentPosition(row, Math.max(col, 0));
                            };
                            this.textToScreenCoordinates = function(row, column) {
                                var canvasPos = this.scroller.getBoundingClientRect();
                                var pos = this.session.documentToScreenPosition(row, column);
                        
                                var x = this.$padding + Math.round(pos.column * this.characterWidth);
                                var y = pos.row * this.lineHeight;
                        
                                return {
                                    pageX: canvasPos.left + x - this.scrollLeft,
                                    pageY: canvasPos.top + y - this.scrollTop
                                };
                            };
                            this.visualizeFocus = function() {
                                dom.addCssClass(this.container, &quot;ace_focus&quot;);
                            };
                            this.visualizeBlur = function() {
                                dom.removeCssClass(this.container, &quot;ace_focus&quot;);
                            };
                            this.showComposition = function(position) {
                                if (!this.$composition)
                                    this.$composition = {
                                        keepTextAreaAtCursor: this.$keepTextAreaAtCursor,
                                        cssText: this.textarea.style.cssText
                                    };
                        
                                this.$keepTextAreaAtCursor = true;
                                dom.addCssClass(this.textarea, &quot;ace_composition&quot;);
                                this.textarea.style.cssText = &quot;&quot;;
                                this.$moveTextAreaToCursor();
                            };
                            this.setCompositionText = function(text) {
                                this.$moveTextAreaToCursor();
                            };
                            this.hideComposition = function() {
                                if (!this.$composition)
                                    return;
                        
                                dom.removeCssClass(this.textarea, &quot;ace_composition&quot;);
                                this.$keepTextAreaAtCursor = this.$composition.keepTextAreaAtCursor;
                                this.textarea.style.cssText = this.$composition.cssText;
                                this.$composition = null;
                            };
                            this.setTheme = function(theme, cb) {
                                var _self = this;
                                this.$themeId = theme;
                                _self._dispatchEvent(&#x27;themeChange&#x27;,{theme:theme});
                        
                                if (!theme || typeof theme == &quot;string&quot;) {
                                    var moduleName = theme || this.$options.theme.initialValue;
                                    config.loadModule([&quot;theme&quot;, moduleName], afterLoad);
                                } else {
                                    afterLoad(theme);
                                }
                        
                                function afterLoad(module) {
                                    if (_self.$themeId != theme)
                                        return cb &amp;&amp; cb();
                                    if (!module.cssClass)
                                        return;
                                    dom.importCssString(
                                        module.cssText,
                                        module.cssClass,
                                        _self.container.ownerDocument
                                    );
                        
                                    if (_self.theme)
                                        dom.removeCssClass(_self.container, _self.theme.cssClass);
                        
                                    var padding = &quot;padding&quot; in module ? module.padding 
                                        : &quot;padding&quot; in (_self.theme || {}) ? 4 : _self.$padding;
                                    if (_self.$padding &amp;&amp; padding != _self.$padding)
                                        _self.setPadding(padding);
                                    _self.$theme = module.cssClass;
                        
                                    _self.theme = module;
                                    dom.addCssClass(_self.container, module.cssClass);
                                    dom.setCssClass(_self.container, &quot;ace_dark&quot;, module.isDark);
                                    if (_self.$size) {
                                        _self.$size.width = 0;
                                        _self.$updateSizeAsync();
                                    }
                        
                                    _self._dispatchEvent(&#x27;themeLoaded&#x27;, {theme:module});
                                    cb &amp;&amp; cb();
                                }
                            };
                            this.getTheme = function() {
                                return this.$themeId;
                            };
                            this.setStyle = function(style, include) {
                                dom.setCssClass(this.container, style, include !== false);
                            };
                            this.unsetStyle = function(style) {
                                dom.removeCssClass(this.container, style);
                            };
                            
                            this.setCursorStyle = function(style) {
                                if (this.scroller.style.cursor != style)
                                    this.scroller.style.cursor = style;
                            };
                            this.setMouseCursor = function(cursorStyle) {
                                this.scroller.style.cursor = cursorStyle;
                            };
                            this.destroy = function() {
                                this.$textLayer.destroy();
                                this.$cursorLayer.destroy();
                            };
                        
                        }).call(VirtualRenderer.prototype);
                        
                        
                        config.defineOptions(VirtualRenderer.prototype, &quot;renderer&quot;, {
                            animatedScroll: {initialValue: false},
                            showInvisibles: {
                                set: function(value) {
                                    if (this.$textLayer.setShowInvisibles(value))
                                        this.$loop.schedule(this.CHANGE_TEXT);
                                },
                                initialValue: false
                            },
                            showPrintMargin: {
                                set: function() { this.$updatePrintMargin(); },
                                initialValue: true
                            },
                            printMarginColumn: {
                                set: function() { this.$updatePrintMargin(); },
                                initialValue: 80
                            },
                            printMargin: {
                                set: function(val) {
                                    if (typeof val == &quot;number&quot;)
                                        this.$printMarginColumn = val;
                                    this.$showPrintMargin = !!val;
                                    this.$updatePrintMargin();
                                },
                                get: function() {
                                    return this.$showPrintMargin &amp;&amp; this.$printMarginColumn; 
                                }
                            },
                            showGutter: {
                                set: function(show){
                                    this.$gutter.style.display = show ? &quot;block&quot; : &quot;none&quot;;
                                    this.$loop.schedule(this.CHANGE_FULL);
                                    this.onGutterResize();
                                },
                                initialValue: true
                            },
                            fadeFoldWidgets: {
                                set: function(show) {
                                    dom.setCssClass(this.$gutter, &quot;ace_fade-fold-widgets&quot;, show);
                                },
                                initialValue: false
                            },
                            showFoldWidgets: {
                                set: function(show) {this.$gutterLayer.setShowFoldWidgets(show)},
                                initialValue: true
                            },
                            showLineNumbers: {
                                set: function(show) {
                                    this.$gutterLayer.setShowLineNumbers(show);
                                    this.$loop.schedule(this.CHANGE_GUTTER);
                                },
                                initialValue: true
                            },
                            displayIndentGuides: {
                                set: function(show) {
                                    if (this.$textLayer.setDisplayIndentGuides(show))
                                        this.$loop.schedule(this.CHANGE_TEXT);
                                },
                                initialValue: true
                            },
                            highlightGutterLine: {
                                set: function(shouldHighlight) {
                                    if (!this.$gutterLineHighlight) {
                                        this.$gutterLineHighlight = dom.createElement(&quot;div&quot;);
                                        this.$gutterLineHighlight.className = &quot;ace_gutter-active-line&quot;;
                                        this.$gutter.appendChild(this.$gutterLineHighlight);
                                        return;
                                    }
                        
                                    this.$gutterLineHighlight.style.display = shouldHighlight ? &quot;&quot; : &quot;none&quot;;
                                    if (this.$cursorLayer.$pixelPos)
                                        this.$updateGutterLineHighlight();
                                },
                                initialValue: false,
                                value: true
                            },
                            hScrollBarAlwaysVisible: {
                                set: function(val) {
                                    if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
                                        this.$loop.schedule(this.CHANGE_SCROLL);
                                },
                                initialValue: false
                            },
                            vScrollBarAlwaysVisible: {
                                set: function(val) {
                                    if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
                                        this.$loop.schedule(this.CHANGE_SCROLL);
                                },
                                initialValue: false
                            },
                            fontSize:  {
                                set: function(size) {
                                    if (typeof size == &quot;number&quot;)
                                        size = size + &quot;px&quot;;
                                    this.container.style.fontSize = size;
                                    this.updateFontSize();
                                },
                                initialValue: 12
                            },
                            fontFamily: {
                                set: function(name) {
                                    this.container.style.fontFamily = name;
                                    this.updateFontSize();
                                }
                            },
                            maxLines: {
                                set: function(val) {
                                    this.updateFull();
                                }
                            },
                            minLines: {
                                set: function(val) {
                                    this.updateFull();
                                }
                            },
                            scrollPastEnd: {
                                set: function(val) {
                                    val = +val || 0;
                                    if (this.$scrollPastEnd == val)
                                        return;
                                    this.$scrollPastEnd = val;
                                    this.$loop.schedule(this.CHANGE_SCROLL);
                                },
                                initialValue: 0,
                                handlesSet: true
                            },
                            fixedWidthGutter: {
                                set: function(val) {
                                    this.$gutterLayer.$fixedWidth = !!val;
                                    this.$loop.schedule(this.CHANGE_GUTTER);
                                }
                            },
                            theme: {
                                set: function(val) { this.setTheme(val) },
                                get: function() { return this.$themeId || this.theme; },
                                initialValue: &quot;./theme/textmate&quot;,
                                handlesSet: true
                            }
                        });
                        
                        exports.VirtualRenderer = VirtualRenderer;
                        });
                        
                        define(&quot;ace/worker/worker_client&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/net&quot;,&quot;ace/lib/event_emitter&quot;,&quot;ace/config&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var oop = require(&quot;../lib/oop&quot;);
                        var net = require(&quot;../lib/net&quot;);
                        var EventEmitter = require(&quot;../lib/event_emitter&quot;).EventEmitter;
                        var config = require(&quot;../config&quot;);
                        
                        var WorkerClient = function(topLevelNamespaces, mod, classname, workerUrl) {
                            this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
                            this.changeListener = this.changeListener.bind(this);
                            this.onMessage = this.onMessage.bind(this);
                            if (require.nameToUrl &amp;&amp; !require.toUrl)
                                require.toUrl = require.nameToUrl;
                            
                            if (config.get(&quot;packaged&quot;) || !require.toUrl) {
                                workerUrl = workerUrl || config.moduleUrl(mod, &quot;worker&quot;);
                            } else {
                                var normalizePath = this.$normalizePath;
                                workerUrl = workerUrl || normalizePath(require.toUrl(&quot;ace/worker/worker.js&quot;, null, &quot;_&quot;));
                        
                                var tlns = {};
                                topLevelNamespaces.forEach(function(ns) {
                                    tlns[ns] = normalizePath(require.toUrl(ns, null, &quot;_&quot;).replace(/(\.js)?(\?.*)?$/, &quot;&quot;));
                                });
                            }
                        
                            try {
                                this.$worker = new Worker(workerUrl);
                            } catch(e) {
                                if (e instanceof window.DOMException) {
                                    var blob = this.$workerBlob(workerUrl);
                                    var URL = window.URL || window.webkitURL;
                                    var blobURL = URL.createObjectURL(blob);
                        
                                    this.$worker = new Worker(blobURL);
                                    URL.revokeObjectURL(blobURL);
                                } else {
                                    throw e;
                                }
                            }
                            this.$worker.postMessage({
                                init : true,
                                tlns : tlns,
                                module : mod,
                                classname : classname
                            });
                        
                            this.callbackId = 1;
                            this.callbacks = {};
                        
                            this.$worker.onmessage = this.onMessage;
                        };
                        
                        (function(){
                        
                            oop.implement(this, EventEmitter);
                        
                            this.onMessage = function(e) {
                                var msg = e.data;
                                switch(msg.type) {
                                    case &quot;event&quot;:
                                        this._signal(msg.name, {data: msg.data});
                                        break;
                                    case &quot;call&quot;:
                                        var callback = this.callbacks[msg.id];
                                        if (callback) {
                                            callback(msg.data);
                                            delete this.callbacks[msg.id];
                                        }
                                        break;
                                    case &quot;error&quot;:
                                        this.reportError(msg.data);
                                        break;
                                    case &quot;log&quot;:
                                        window.console &amp;&amp; console.log &amp;&amp; console.log.apply(console, msg.data);
                                        break;
                                }
                            };
                            
                            this.reportError = function(err) {
                                window.console &amp;&amp; console.error &amp;&amp; console.error(err);
                            };
                        
                            this.$normalizePath = function(path) {
                                return net.qualifyURL(path);
                            };
                        
                            this.terminate = function() {
                                this._signal(&quot;terminate&quot;, {});
                                this.deltaQueue = null;
                                this.$worker.terminate();
                                this.$worker = null;
                                if (this.$doc)
                                    this.$doc.off(&quot;change&quot;, this.changeListener);
                                this.$doc = null;
                            };
                        
                            this.send = function(cmd, args) {
                                this.$worker.postMessage({command: cmd, args: args});
                            };
                        
                            this.call = function(cmd, args, callback) {
                                if (callback) {
                                    var id = this.callbackId++;
                                    this.callbacks[id] = callback;
                                    args.push(id);
                                }
                                this.send(cmd, args);
                            };
                        
                            this.emit = function(event, data) {
                                try {
                                    this.$worker.postMessage({event: event, data: {data: data.data}});
                                }
                                catch(ex) {
                                    console.error(ex.stack);
                                }
                            };
                        
                            this.attachToDocument = function(doc) {
                                if(this.$doc)
                                    this.terminate();
                        
                                this.$doc = doc;
                                this.call(&quot;setValue&quot;, [doc.getValue()]);
                                doc.on(&quot;change&quot;, this.changeListener);
                            };
                        
                            this.changeListener = function(e) {
                                if (!this.deltaQueue) {
                                    this.deltaQueue = [e.data];
                                    setTimeout(this.$sendDeltaQueue, 0);
                                } else
                                    this.deltaQueue.push(e.data);
                            };
                        
                            this.$sendDeltaQueue = function() {
                                var q = this.deltaQueue;
                                if (!q) return;
                                this.deltaQueue = null;
                                if (q.length &gt; 20 &amp;&amp; q.length &gt; this.$doc.getLength() &gt;&gt; 1) {
                                    this.call(&quot;setValue&quot;, [this.$doc.getValue()]);
                                } else
                                    this.emit(&quot;change&quot;, {data: q});
                            };
                        
                            this.$workerBlob = function(workerUrl) {
                                var script = &quot;importScripts(&#x27;&quot; + net.qualifyURL(workerUrl) + &quot;&#x27;);&quot;;
                                try {
                                    return new Blob([script], {&quot;type&quot;: &quot;application/javascript&quot;});
                                } catch (e) { // Backwards-compatibility
                                    var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
                                    var blobBuilder = new BlobBuilder();
                                    blobBuilder.append(script);
                                    return blobBuilder.getBlob(&quot;application/javascript&quot;);
                                }
                            };
                        
                        }).call(WorkerClient.prototype);
                        
                        
                        var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
                            this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
                            this.changeListener = this.changeListener.bind(this);
                            this.callbackId = 1;
                            this.callbacks = {};
                            this.messageBuffer = [];
                        
                            var main = null;
                            var emitSync = false;
                            var sender = Object.create(EventEmitter);
                            var _self = this;
                        
                            this.$worker = {};
                            this.$worker.terminate = function() {};
                            this.$worker.postMessage = function(e) {
                                _self.messageBuffer.push(e);
                                if (main) {
                                    if (emitSync)
                                        setTimeout(processNext);
                                    else
                                        processNext();
                                }
                            };
                            this.setEmitSync = function(val) { emitSync = val };
                        
                            var processNext = function() {
                                var msg = _self.messageBuffer.shift();
                                if (msg.command)
                                    main[msg.command].apply(main, msg.args);
                                else if (msg.event)
                                    sender._signal(msg.event, msg.data);
                            };
                        
                            sender.postMessage = function(msg) {
                                _self.onMessage({data: msg});
                            };
                            sender.callback = function(data, callbackId) {
                                this.postMessage({type: &quot;call&quot;, id: callbackId, data: data});
                            };
                            sender.emit = function(name, data) {
                                this.postMessage({type: &quot;event&quot;, name: name, data: data});
                            };
                        
                            config.loadModule([&quot;worker&quot;, mod], function(Main) {
                                main = new Main[classname](sender);
                                while (_self.messageBuffer.length)
                                    processNext();
                            });
                        };
                        
                        UIWorkerClient.prototype = WorkerClient.prototype;
                        
                        exports.UIWorkerClient = UIWorkerClient;
                        exports.WorkerClient = WorkerClient;
                        
                        });
                        
                        define(&quot;ace/placeholder&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/range&quot;,&quot;ace/lib/event_emitter&quot;,&quot;ace/lib/oop&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var Range = require(&quot;./range&quot;).Range;
                        var EventEmitter = require(&quot;./lib/event_emitter&quot;).EventEmitter;
                        var oop = require(&quot;./lib/oop&quot;);
                        
                        var PlaceHolder = function(session, length, pos, others, mainClass, othersClass) {
                            var _self = this;
                            this.length = length;
                            this.session = session;
                            this.doc = session.getDocument();
                            this.mainClass = mainClass;
                            this.othersClass = othersClass;
                            this.$onUpdate = this.onUpdate.bind(this);
                            this.doc.on(&quot;change&quot;, this.$onUpdate);
                            this.$others = others;
                            
                            this.$onCursorChange = function() {
                                setTimeout(function() {
                                    _self.onCursorChange();
                                });
                            };
                            
                            this.$pos = pos;
                            var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || {length: -1};
                            this.$undoStackDepth =  undoStack.length;
                            this.setup();
                        
                            session.selection.on(&quot;changeCursor&quot;, this.$onCursorChange);
                        };
                        
                        (function() {
                        
                            oop.implement(this, EventEmitter);
                            this.setup = function() {
                                var _self = this;
                                var doc = this.doc;
                                var session = this.session;
                                var pos = this.$pos;
                                
                                this.selectionBefore = session.selection.toJSON();
                                if (session.selection.inMultiSelectMode)
                                    session.selection.toSingleRange();
                        
                                this.pos = doc.createAnchor(pos.row, pos.column);
                                this.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
                                this.pos.on(&quot;change&quot;, function(event) {
                                    session.removeMarker(_self.markerId);
                                    _self.markerId = session.addMarker(new Range(event.value.row, event.value.column, event.value.row, event.value.column+_self.length), _self.mainClass, null, false);
                                });
                                this.others = [];
                                this.$others.forEach(function(other) {
                                    var anchor = doc.createAnchor(other.row, other.column);
                                    _self.others.push(anchor);
                                });
                                session.setUndoSelect(false);
                            };
                            this.showOtherMarkers = function() {
                                if(this.othersActive) return;
                                var session = this.session;
                                var _self = this;
                                this.othersActive = true;
                                this.others.forEach(function(anchor) {
                                    anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column+_self.length), _self.othersClass, null, false);
                                    anchor.on(&quot;change&quot;, function(event) {
                                        session.removeMarker(anchor.markerId);
                                        anchor.markerId = session.addMarker(new Range(event.value.row, event.value.column, event.value.row, event.value.column+_self.length), _self.othersClass, null, false);
                                    });
                                });
                            };
                            this.hideOtherMarkers = function() {
                                if(!this.othersActive) return;
                                this.othersActive = false;
                                for (var i = 0; i &lt; this.others.length; i++) {
                                    this.session.removeMarker(this.others[i].markerId);
                                }
                            };
                            this.onUpdate = function(event) {
                                var delta = event.data;
                                var range = delta.range;
                                if(range.start.row !== range.end.row) return;
                                if(range.start.row !== this.pos.row) return;
                                if (this.$updating) return;
                                this.$updating = true;
                                var lengthDiff = delta.action === &quot;insertText&quot; ? range.end.column - range.start.column : range.start.column - range.end.column;
                                
                                if(range.start.column &gt;= this.pos.column &amp;&amp; range.start.column &lt;= this.pos.column + this.length + 1) {
                                    var distanceFromStart = range.start.column - this.pos.column;
                                    this.length += lengthDiff;
                                    if(!this.session.$fromUndo) {
                                        if(delta.action === &quot;insertText&quot;) {
                                            for (var i = this.others.length - 1; i &gt;= 0; i--) {
                                                var otherPos = this.others[i];
                                                var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
                                                if(otherPos.row === range.start.row &amp;&amp; range.start.column &lt; otherPos.column)
                                                    newPos.column += lengthDiff;
                                                this.doc.insert(newPos, delta.text);
                                            }
                                        } else if(delta.action === &quot;removeText&quot;) {
                                            for (var i = this.others.length - 1; i &gt;= 0; i--) {
                                                var otherPos = this.others[i];
                                                var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
                                                if(otherPos.row === range.start.row &amp;&amp; range.start.column &lt; otherPos.column)
                                                    newPos.column += lengthDiff;
                                                this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                                            }
                                        }
                                        if(range.start.column === this.pos.column &amp;&amp; delta.action === &quot;insertText&quot;) {
                                            setTimeout(function() {
                                                this.pos.setPosition(this.pos.row, this.pos.column - lengthDiff);
                                                for (var i = 0; i &lt; this.others.length; i++) {
                                                    var other = this.others[i];
                                                    var newPos = {row: other.row, column: other.column - lengthDiff};
                                                    if(other.row === range.start.row &amp;&amp; range.start.column &lt; other.column)
                                                        newPos.column += lengthDiff;
                                                    other.setPosition(newPos.row, newPos.column);
                                                }
                                            }.bind(this), 0);
                                        }
                                        else if(range.start.column === this.pos.column &amp;&amp; delta.action === &quot;removeText&quot;) {
                                            setTimeout(function() {
                                                for (var i = 0; i &lt; this.others.length; i++) {
                                                    var other = this.others[i];
                                                    if(other.row === range.start.row &amp;&amp; range.start.column &lt; other.column) {
                                                        other.setPosition(other.row, other.column - lengthDiff);
                                                    }
                                                }
                                            }.bind(this), 0);
                                        }
                                    }
                                    this.pos._emit(&quot;change&quot;, {value: this.pos});
                                    for (var i = 0; i &lt; this.others.length; i++) {
                                        this.others[i]._emit(&quot;change&quot;, {value: this.others[i]});
                                    }
                                }
                                this.$updating = false;
                            };
                        
                            this.onCursorChange = function(event) {
                                if (this.$updating || !this.session) return;
                                var pos = this.session.selection.getCursor();
                                if (pos.row === this.pos.row &amp;&amp; pos.column &gt;= this.pos.column &amp;&amp; pos.column &lt;= this.pos.column + this.length) {
                                    this.showOtherMarkers();
                                    this._emit(&quot;cursorEnter&quot;, event);
                                } else {
                                    this.hideOtherMarkers();
                                    this._emit(&quot;cursorLeave&quot;, event);
                                }
                            };    
                            this.detach = function() {
                                this.session.removeMarker(this.markerId);
                                this.hideOtherMarkers();
                                this.doc.removeEventListener(&quot;change&quot;, this.$onUpdate);
                                this.session.selection.removeEventListener(&quot;changeCursor&quot;, this.$onCursorChange);
                                this.pos.detach();
                                for (var i = 0; i &lt; this.others.length; i++) {
                                    this.others[i].detach();
                                }
                                this.session.setUndoSelect(true);
                                this.session = null;
                            };
                            this.cancel = function() {
                                if(this.$undoStackDepth === -1)
                                    throw Error(&quot;Canceling placeholders only supported with undo manager attached to session.&quot;);
                                var undoManager = this.session.getUndoManager();
                                var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
                                for (var i = 0; i &lt; undosRequired; i++) {
                                    undoManager.undo(true);
                                }
                                if (this.selectionBefore)
                                    this.session.selection.fromJSON(this.selectionBefore);
                            };
                        }).call(PlaceHolder.prototype);
                        
                        
                        exports.PlaceHolder = PlaceHolder;
                        });
                        
                        define(&quot;ace/mouse/multi_select_handler&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/event&quot;,&quot;ace/lib/useragent&quot;], function(require, exports, module) {
                        
                        var event = require(&quot;../lib/event&quot;);
                        var useragent = require(&quot;../lib/useragent&quot;);
                        function isSamePoint(p1, p2) {
                            return p1.row == p2.row &amp;&amp; p1.column == p2.column;
                        }
                        
                        function onMouseDown(e) {
                            var ev = e.domEvent;
                            var alt = ev.altKey;
                            var shift = ev.shiftKey;
                            var ctrl = ev.ctrlKey;
                            var accel = e.getAccelKey();
                            var button = e.getButton();
                            
                            if (ctrl &amp;&amp; useragent.isMac)
                                button = ev.button;
                        
                            if (e.editor.inMultiSelectMode &amp;&amp; button == 2) {
                                e.editor.textInput.onContextMenu(e.domEvent);
                                return;
                            }
                            
                            if (!ctrl &amp;&amp; !alt &amp;&amp; !accel) {
                                if (button === 0 &amp;&amp; e.editor.inMultiSelectMode)
                                    e.editor.exitMultiSelectMode();
                                return;
                            }
                            
                            if (button !== 0)
                                return;
                        
                            var editor = e.editor;
                            var selection = editor.selection;
                            var isMultiSelect = editor.inMultiSelectMode;
                            var pos = e.getDocumentPosition();
                            var cursor = selection.getCursor();
                            var inSelection = e.inSelection() || (selection.isEmpty() &amp;&amp; isSamePoint(pos, cursor));
                        
                            var mouseX = e.x, mouseY = e.y;
                            var onMouseSelection = function(e) {
                                mouseX = e.clientX;
                                mouseY = e.clientY;
                            };
                            
                            var session = editor.session;
                            var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
                            var screenCursor = screenAnchor;
                            
                            var selectionMode;
                            if (editor.$mouseHandler.$enableJumpToDef) {
                                if (ctrl &amp;&amp; alt || accel &amp;&amp; alt)
                                    selectionMode = &quot;add&quot;;
                                else if (alt &amp;&amp; editor.$blockSelectEnabled)
                                    selectionMode = &quot;block&quot;;
                            } else {
                                if (accel &amp;&amp; !alt) {
                                    selectionMode = &quot;add&quot;;
                                    if (!isMultiSelect &amp;&amp; shift)
                                        return;
                                } else if (alt &amp;&amp; editor.$blockSelectEnabled) {
                                    selectionMode = &quot;block&quot;;
                                }
                            }
                            
                            if (selectionMode &amp;&amp; useragent.isMac &amp;&amp; ev.ctrlKey) {
                                editor.$mouseHandler.cancelContextMenu();
                            }
                        
                            if (selectionMode == &quot;add&quot;) {
                                if (!isMultiSelect &amp;&amp; inSelection)
                                    return; // dragging
                        
                                if (!isMultiSelect) {
                                    var range = selection.toOrientedRange();
                                    editor.addSelectionMarker(range);
                                }
                        
                                var oldRange = selection.rangeList.rangeAtPoint(pos);
                                
                                
                                editor.$blockScrolling++;
                                editor.inVirtualSelectionMode = true;
                                
                                if (shift) {
                                    oldRange = null;
                                    range = selection.ranges[0];
                                    editor.removeSelectionMarker(range);
                                }
                                editor.once(&quot;mouseup&quot;, function() {
                                    var tmpSel = selection.toOrientedRange();
                        
                                    if (oldRange &amp;&amp; tmpSel.isEmpty() &amp;&amp; isSamePoint(oldRange.cursor, tmpSel.cursor))
                                        selection.substractPoint(tmpSel.cursor);
                                    else {
                                        if (shift) {
                                            selection.substractPoint(range.cursor);
                                        } else if (range) {
                                            editor.removeSelectionMarker(range);
                                            selection.addRange(range);
                                        }
                                        selection.addRange(tmpSel);
                                    }
                                    editor.$blockScrolling--;
                                    editor.inVirtualSelectionMode = false;
                                });
                        
                            } else if (selectionMode == &quot;block&quot;) {
                                e.stop();
                                editor.inVirtualSelectionMode = true;        
                                var initialRange;
                                var rectSel = [];
                                var blockSelect = function() {
                                    var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
                                    var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column);
                        
                                    if (isSamePoint(screenCursor, newCursor) &amp;&amp; isSamePoint(cursor, selection.lead))
                                        return;
                                    screenCursor = newCursor;
                                    
                                    editor.$blockScrolling++;
                                    editor.selection.moveToPosition(cursor);
                                    editor.renderer.scrollCursorIntoView();
                        
                                    editor.removeSelectionMarkers(rectSel);
                                    rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
                                    if (editor.$mouseHandler.$clickSelection &amp;&amp; rectSel.length == 1 &amp;&amp; rectSel[0].isEmpty())
                                        rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
                                    rectSel.forEach(editor.addSelectionMarker, editor);
                                    editor.updateSelectionMarkers();
                                    editor.$blockScrolling--;
                                };
                                editor.$blockScrolling++;
                                if (isMultiSelect &amp;&amp; !accel) {
                                    selection.toSingleRange();
                                } else if (!isMultiSelect &amp;&amp; accel) {
                                    initialRange = selection.toOrientedRange();
                                    editor.addSelectionMarker(initialRange);
                                }
                                
                                if (shift)
                                    screenAnchor = session.documentToScreenPosition(selection.lead);            
                                else
                                    selection.moveToPosition(pos);
                                editor.$blockScrolling--;
                                
                                screenCursor = {row: -1, column: -1};
                        
                                var onMouseSelectionEnd = function(e) {
                                    clearInterval(timerId);
                                    editor.removeSelectionMarkers(rectSel);
                                    if (!rectSel.length)
                                        rectSel = [selection.toOrientedRange()];
                                    editor.$blockScrolling++;
                                    if (initialRange) {
                                        editor.removeSelectionMarker(initialRange);
                                        selection.toSingleRange(initialRange);
                                    }
                                    for (var i = 0; i &lt; rectSel.length; i++)
                                        selection.addRange(rectSel[i]);
                                    editor.inVirtualSelectionMode = false;
                                    editor.$mouseHandler.$clickSelection = null;
                                    editor.$blockScrolling--;
                                };
                        
                                var onSelectionInterval = blockSelect;
                        
                                event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
                                var timerId = setInterval(function() {onSelectionInterval();}, 20);
                        
                                return e.preventDefault();
                            }
                        }
                        
                        
                        exports.onMouseDown = onMouseDown;
                        
                        });
                        
                        define(&quot;ace/commands/multi_select_commands&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/keyboard/hash_handler&quot;], function(require, exports, module) {
                        exports.defaultCommands = [{
                            name: &quot;addCursorAbove&quot;,
                            exec: function(editor) { editor.selectMoreLines(-1); },
                            bindKey: {win: &quot;Ctrl-Alt-Up&quot;, mac: &quot;Ctrl-Alt-Up&quot;},
                            scrollIntoView: &quot;cursor&quot;,
                            readonly: true
                        }, {
                            name: &quot;addCursorBelow&quot;,
                            exec: function(editor) { editor.selectMoreLines(1); },
                            bindKey: {win: &quot;Ctrl-Alt-Down&quot;, mac: &quot;Ctrl-Alt-Down&quot;},
                            scrollIntoView: &quot;cursor&quot;,
                            readonly: true
                        }, {
                            name: &quot;addCursorAboveSkipCurrent&quot;,
                            exec: function(editor) { editor.selectMoreLines(-1, true); },
                            bindKey: {win: &quot;Ctrl-Alt-Shift-Up&quot;, mac: &quot;Ctrl-Alt-Shift-Up&quot;},
                            scrollIntoView: &quot;cursor&quot;,
                            readonly: true
                        }, {
                            name: &quot;addCursorBelowSkipCurrent&quot;,
                            exec: function(editor) { editor.selectMoreLines(1, true); },
                            bindKey: {win: &quot;Ctrl-Alt-Shift-Down&quot;, mac: &quot;Ctrl-Alt-Shift-Down&quot;},
                            scrollIntoView: &quot;cursor&quot;,
                            readonly: true
                        }, {
                            name: &quot;selectMoreBefore&quot;,
                            exec: function(editor) { editor.selectMore(-1); },
                            bindKey: {win: &quot;Ctrl-Alt-Left&quot;, mac: &quot;Ctrl-Alt-Left&quot;},
                            scrollIntoView: &quot;cursor&quot;,
                            readonly: true
                        }, {
                            name: &quot;selectMoreAfter&quot;,
                            exec: function(editor) { editor.selectMore(1); },
                            bindKey: {win: &quot;Ctrl-Alt-Right&quot;, mac: &quot;Ctrl-Alt-Right&quot;},
                            scrollIntoView: &quot;cursor&quot;,
                            readonly: true
                        }, {
                            name: &quot;selectNextBefore&quot;,
                            exec: function(editor) { editor.selectMore(-1, true); },
                            bindKey: {win: &quot;Ctrl-Alt-Shift-Left&quot;, mac: &quot;Ctrl-Alt-Shift-Left&quot;},
                            scrollIntoView: &quot;cursor&quot;,
                            readonly: true
                        }, {
                            name: &quot;selectNextAfter&quot;,
                            exec: function(editor) { editor.selectMore(1, true); },
                            bindKey: {win: &quot;Ctrl-Alt-Shift-Right&quot;, mac: &quot;Ctrl-Alt-Shift-Right&quot;},
                            scrollIntoView: &quot;cursor&quot;,
                            readonly: true
                        }, {
                            name: &quot;splitIntoLines&quot;,
                            exec: function(editor) { editor.multiSelect.splitIntoLines(); },
                            bindKey: {win: &quot;Ctrl-Alt-L&quot;, mac: &quot;Ctrl-Alt-L&quot;},
                            readonly: true
                        }, {
                            name: &quot;alignCursors&quot;,
                            exec: function(editor) { editor.alignCursors(); },
                            bindKey: {win: &quot;Ctrl-Alt-A&quot;, mac: &quot;Ctrl-Alt-A&quot;},
                            scrollIntoView: &quot;cursor&quot;
                        }, {
                            name: &quot;findAll&quot;,
                            exec: function(editor) { editor.findAll(); },
                            bindKey: {win: &quot;Ctrl-Alt-K&quot;, mac: &quot;Ctrl-Alt-G&quot;},
                            scrollIntoView: &quot;cursor&quot;,
                            readonly: true
                        }];
                        exports.multiSelectCommands = [{
                            name: &quot;singleSelection&quot;,
                            bindKey: &quot;esc&quot;,
                            exec: function(editor) { editor.exitMultiSelectMode(); },
                            scrollIntoView: &quot;cursor&quot;,
                            readonly: true,
                            isAvailable: function(editor) {return editor &amp;&amp; editor.inMultiSelectMode}
                        }];
                        
                        var HashHandler = require(&quot;../keyboard/hash_handler&quot;).HashHandler;
                        exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);
                        
                        });
                        
                        define(&quot;ace/multi_select&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/range_list&quot;,&quot;ace/range&quot;,&quot;ace/selection&quot;,&quot;ace/mouse/multi_select_handler&quot;,&quot;ace/lib/event&quot;,&quot;ace/lib/lang&quot;,&quot;ace/commands/multi_select_commands&quot;,&quot;ace/search&quot;,&quot;ace/edit_session&quot;,&quot;ace/editor&quot;,&quot;ace/config&quot;], function(require, exports, module) {
                        
                        var RangeList = require(&quot;./range_list&quot;).RangeList;
                        var Range = require(&quot;./range&quot;).Range;
                        var Selection = require(&quot;./selection&quot;).Selection;
                        var onMouseDown = require(&quot;./mouse/multi_select_handler&quot;).onMouseDown;
                        var event = require(&quot;./lib/event&quot;);
                        var lang = require(&quot;./lib/lang&quot;);
                        var commands = require(&quot;./commands/multi_select_commands&quot;);
                        exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
                        var Search = require(&quot;./search&quot;).Search;
                        var search = new Search();
                        
                        function find(session, needle, dir) {
                            search.$options.wrap = true;
                            search.$options.needle = needle;
                            search.$options.backwards = dir == -1;
                            return search.find(session);
                        }
                        var EditSession = require(&quot;./edit_session&quot;).EditSession;
                        (function() {
                            this.getSelectionMarkers = function() {
                                return this.$selectionMarkers;
                            };
                        }).call(EditSession.prototype);
                        (function() {
                            this.ranges = null;
                            this.rangeList = null;
                            this.addRange = function(range, $blockChangeEvents) {
                                if (!range)
                                    return;
                        
                                if (!this.inMultiSelectMode &amp;&amp; this.rangeCount === 0) {
                                    var oldRange = this.toOrientedRange();
                                    this.rangeList.add(oldRange);
                                    this.rangeList.add(range);
                                    if (this.rangeList.ranges.length != 2) {
                                        this.rangeList.removeAll();
                                        return $blockChangeEvents || this.fromOrientedRange(range);
                                    }
                                    this.rangeList.removeAll();
                                    this.rangeList.add(oldRange);
                                    this.$onAddRange(oldRange);
                                }
                        
                                if (!range.cursor)
                                    range.cursor = range.end;
                        
                                var removed = this.rangeList.add(range);
                        
                                this.$onAddRange(range);
                        
                                if (removed.length)
                                    this.$onRemoveRange(removed);
                        
                                if (this.rangeCount &gt; 1 &amp;&amp; !this.inMultiSelectMode) {
                                    this._signal(&quot;multiSelect&quot;);
                                    this.inMultiSelectMode = true;
                                    this.session.$undoSelect = false;
                                    this.rangeList.attach(this.session);
                                }
                        
                                return $blockChangeEvents || this.fromOrientedRange(range);
                            };
                        
                            this.toSingleRange = function(range) {
                                range = range || this.ranges[0];
                                var removed = this.rangeList.removeAll();
                                if (removed.length)
                                    this.$onRemoveRange(removed);
                        
                                range &amp;&amp; this.fromOrientedRange(range);
                            };
                            this.substractPoint = function(pos) {
                                var removed = this.rangeList.substractPoint(pos);
                                if (removed) {
                                    this.$onRemoveRange(removed);
                                    return removed[0];
                                }
                            };
                            this.mergeOverlappingRanges = function() {
                                var removed = this.rangeList.merge();
                                if (removed.length)
                                    this.$onRemoveRange(removed);
                                else if(this.ranges[0])
                                    this.fromOrientedRange(this.ranges[0]);
                            };
                        
                            this.$onAddRange = function(range) {
                                this.rangeCount = this.rangeList.ranges.length;
                                this.ranges.unshift(range);
                                this._signal(&quot;addRange&quot;, {range: range});
                            };
                        
                            this.$onRemoveRange = function(removed) {
                                this.rangeCount = this.rangeList.ranges.length;
                                if (this.rangeCount == 1 &amp;&amp; this.inMultiSelectMode) {
                                    var lastRange = this.rangeList.ranges.pop();
                                    removed.push(lastRange);
                                    this.rangeCount = 0;
                                }
                        
                                for (var i = removed.length; i--; ) {
                                    var index = this.ranges.indexOf(removed[i]);
                                    this.ranges.splice(index, 1);
                                }
                        
                                this._signal(&quot;removeRange&quot;, {ranges: removed});
                        
                                if (this.rangeCount === 0 &amp;&amp; this.inMultiSelectMode) {
                                    this.inMultiSelectMode = false;
                                    this._signal(&quot;singleSelect&quot;);
                                    this.session.$undoSelect = true;
                                    this.rangeList.detach(this.session);
                                }
                        
                                lastRange = lastRange || this.ranges[0];
                                if (lastRange &amp;&amp; !lastRange.isEqual(this.getRange()))
                                    this.fromOrientedRange(lastRange);
                            };
                            this.$initRangeList = function() {
                                if (this.rangeList)
                                    return;
                        
                                this.rangeList = new RangeList();
                                this.ranges = [];
                                this.rangeCount = 0;
                            };
                            this.getAllRanges = function() {
                                return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
                            };
                        
                            this.splitIntoLines = function () {
                                if (this.rangeCount &gt; 1) {
                                    var ranges = this.rangeList.ranges;
                                    var lastRange = ranges[ranges.length - 1];
                                    var range = Range.fromPoints(ranges[0].start, lastRange.end);
                        
                                    this.toSingleRange();
                                    this.setSelectionRange(range, lastRange.cursor == lastRange.start);
                                } else {
                                    var range = this.getRange();
                                    var isBackwards = this.isBackwards();
                                    var startRow = range.start.row;
                                    var endRow = range.end.row;
                                    if (startRow == endRow) {
                                        if (isBackwards)
                                            var start = range.end, end = range.start;
                                        else
                                            var start = range.start, end = range.end;
                                        
                                        this.addRange(Range.fromPoints(end, end));
                                        this.addRange(Range.fromPoints(start, start));
                                        return;
                                    }
                        
                                    var rectSel = [];
                                    var r = this.getLineRange(startRow, true);
                                    r.start.column = range.start.column;
                                    rectSel.push(r);
                        
                                    for (var i = startRow + 1; i &lt; endRow; i++)
                                        rectSel.push(this.getLineRange(i, true));
                        
                                    r = this.getLineRange(endRow, true);
                                    r.end.column = range.end.column;
                                    rectSel.push(r);
                        
                                    rectSel.forEach(this.addRange, this);
                                }
                            };
                            this.toggleBlockSelection = function () {
                                if (this.rangeCount &gt; 1) {
                                    var ranges = this.rangeList.ranges;
                                    var lastRange = ranges[ranges.length - 1];
                                    var range = Range.fromPoints(ranges[0].start, lastRange.end);
                        
                                    this.toSingleRange();
                                    this.setSelectionRange(range, lastRange.cursor == lastRange.start);
                                } else {
                                    var cursor = this.session.documentToScreenPosition(this.selectionLead);
                                    var anchor = this.session.documentToScreenPosition(this.selectionAnchor);
                        
                                    var rectSel = this.rectangularRangeBlock(cursor, anchor);
                                    rectSel.forEach(this.addRange, this);
                                }
                            };
                            this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
                                var rectSel = [];
                        
                                var xBackwards = screenCursor.column &lt; screenAnchor.column;
                                if (xBackwards) {
                                    var startColumn = screenCursor.column;
                                    var endColumn = screenAnchor.column;
                                } else {
                                    var startColumn = screenAnchor.column;
                                    var endColumn = screenCursor.column;
                                }
                        
                                var yBackwards = screenCursor.row &lt; screenAnchor.row;
                                if (yBackwards) {
                                    var startRow = screenCursor.row;
                                    var endRow = screenAnchor.row;
                                } else {
                                    var startRow = screenAnchor.row;
                                    var endRow = screenCursor.row;
                                }
                        
                                if (startColumn &lt; 0)
                                    startColumn = 0;
                                if (startRow &lt; 0)
                                    startRow = 0;
                        
                                if (startRow == endRow)
                                    includeEmptyLines = true;
                        
                                for (var row = startRow; row &lt;= endRow; row++) {
                                    var range = Range.fromPoints(
                                        this.session.screenToDocumentPosition(row, startColumn),
                                        this.session.screenToDocumentPosition(row, endColumn)
                                    );
                                    if (range.isEmpty()) {
                                        if (docEnd &amp;&amp; isSamePoint(range.end, docEnd))
                                            break;
                                        var docEnd = range.end;
                                    }
                                    range.cursor = xBackwards ? range.start : range.end;
                                    rectSel.push(range);
                                }
                        
                                if (yBackwards)
                                    rectSel.reverse();
                        
                                if (!includeEmptyLines) {
                                    var end = rectSel.length - 1;
                                    while (rectSel[end].isEmpty() &amp;&amp; end &gt; 0)
                                        end--;
                                    if (end &gt; 0) {
                                        var start = 0;
                                        while (rectSel[start].isEmpty())
                                            start++;
                                    }
                                    for (var i = end; i &gt;= start; i--) {
                                        if (rectSel[i].isEmpty())
                                            rectSel.splice(i, 1);
                                    }
                                }
                        
                                return rectSel;
                            };
                        }).call(Selection.prototype);
                        var Editor = require(&quot;./editor&quot;).Editor;
                        (function() {
                            this.updateSelectionMarkers = function() {
                                this.renderer.updateCursor();
                                this.renderer.updateBackMarkers();
                            };
                            this.addSelectionMarker = function(orientedRange) {
                                if (!orientedRange.cursor)
                                    orientedRange.cursor = orientedRange.end;
                        
                                var style = this.getSelectionStyle();
                                orientedRange.marker = this.session.addMarker(orientedRange, &quot;ace_selection&quot;, style);
                        
                                this.session.$selectionMarkers.push(orientedRange);
                                this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
                                return orientedRange;
                            };
                            this.removeSelectionMarker = function(range) {
                                if (!range.marker)
                                    return;
                                this.session.removeMarker(range.marker);
                                var index = this.session.$selectionMarkers.indexOf(range);
                                if (index != -1)
                                    this.session.$selectionMarkers.splice(index, 1);
                                this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
                            };
                        
                            this.removeSelectionMarkers = function(ranges) {
                                var markerList = this.session.$selectionMarkers;
                                for (var i = ranges.length; i--; ) {
                                    var range = ranges[i];
                                    if (!range.marker)
                                        continue;
                                    this.session.removeMarker(range.marker);
                                    var index = markerList.indexOf(range);
                                    if (index != -1)
                                        markerList.splice(index, 1);
                                }
                                this.session.selectionMarkerCount = markerList.length;
                            };
                        
                            this.$onAddRange = function(e) {
                                this.addSelectionMarker(e.range);
                                this.renderer.updateCursor();
                                this.renderer.updateBackMarkers();
                            };
                        
                            this.$onRemoveRange = function(e) {
                                this.removeSelectionMarkers(e.ranges);
                                this.renderer.updateCursor();
                                this.renderer.updateBackMarkers();
                            };
                        
                            this.$onMultiSelect = function(e) {
                                if (this.inMultiSelectMode)
                                    return;
                                this.inMultiSelectMode = true;
                        
                                this.setStyle(&quot;ace_multiselect&quot;);
                                this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
                                this.commands.setDefaultHandler(&quot;exec&quot;, this.$onMultiSelectExec);
                        
                                this.renderer.updateCursor();
                                this.renderer.updateBackMarkers();
                            };
                        
                            this.$onSingleSelect = function(e) {
                                if (this.session.multiSelect.inVirtualMode)
                                    return;
                                this.inMultiSelectMode = false;
                        
                                this.unsetStyle(&quot;ace_multiselect&quot;);
                                this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);
                        
                                this.commands.removeDefaultHandler(&quot;exec&quot;, this.$onMultiSelectExec);
                                this.renderer.updateCursor();
                                this.renderer.updateBackMarkers();
                                this._emit(&quot;changeSelection&quot;);
                            };
                        
                            this.$onMultiSelectExec = function(e) {
                                var command = e.command;
                                var editor = e.editor;
                                if (!editor.multiSelect)
                                    return;
                                if (!command.multiSelectAction) {
                                    var result = command.exec(editor, e.args || {});
                                    editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
                                    editor.multiSelect.mergeOverlappingRanges();
                                } else if (command.multiSelectAction == &quot;forEach&quot;) {
                                    result = editor.forEachSelection(command, e.args);
                                } else if (command.multiSelectAction == &quot;forEachLine&quot;) {
                                    result = editor.forEachSelection(command, e.args, true);
                                } else if (command.multiSelectAction == &quot;single&quot;) {
                                    editor.exitMultiSelectMode();
                                    result = command.exec(editor, e.args || {});
                                } else {
                                    result = command.multiSelectAction(editor, e.args || {});
                                }
                                return result;
                            }; 
                            this.forEachSelection = function(cmd, args, options) {
                                if (this.inVirtualSelectionMode)
                                    return;
                                var keepOrder = options &amp;&amp; options.keepOrder;
                                var $byLines = options == true || options &amp;&amp; options.$byLines
                                var session = this.session;
                                var selection = this.selection;
                                var rangeList = selection.rangeList;
                                var ranges = (keepOrder ? selection : rangeList).ranges;
                                var result;
                                
                                if (!ranges.length)
                                    return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
                                
                                var reg = selection._eventRegistry;
                                selection._eventRegistry = {};
                        
                                var tmpSel = new Selection(session);
                                this.inVirtualSelectionMode = true;
                                for (var i = ranges.length; i--;) {
                                    if ($byLines) {
                                        while (i &gt; 0 &amp;&amp; ranges[i].start.row == ranges[i - 1].end.row)
                                            i--;
                                    }
                                    tmpSel.fromOrientedRange(ranges[i]);
                                    tmpSel.index = i;
                                    this.selection = session.selection = tmpSel;
                                    var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
                                    if (!result &amp;&amp; cmdResult !== undefined)
                                        result = cmdResult;
                                    tmpSel.toOrientedRange(ranges[i]);
                                }
                                tmpSel.detach();
                        
                                this.selection = session.selection = selection;
                                this.inVirtualSelectionMode = false;
                                selection._eventRegistry = reg;
                                selection.mergeOverlappingRanges();
                                
                                var anim = this.renderer.$scrollAnimation;
                                this.onCursorChange();
                                this.onSelectionChange();
                                if (anim &amp;&amp; anim.from == anim.to)
                                    this.renderer.animateScrolling(anim.from);
                                
                                return result;
                            };
                            this.exitMultiSelectMode = function() {
                                if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
                                    return;
                                this.multiSelect.toSingleRange();
                            };
                        
                            this.getSelectedText = function() {
                                var text = &quot;&quot;;
                                if (this.inMultiSelectMode &amp;&amp; !this.inVirtualSelectionMode) {
                                    var ranges = this.multiSelect.rangeList.ranges;
                                    var buf = [];
                                    for (var i = 0; i &lt; ranges.length; i++) {
                                        buf.push(this.session.getTextRange(ranges[i]));
                                    }
                                    var nl = this.session.getDocument().getNewLineCharacter();
                                    text = buf.join(nl);
                                    if (text.length == (buf.length - 1) * nl.length)
                                        text = &quot;&quot;;
                                } else if (!this.selection.isEmpty()) {
                                    text = this.session.getTextRange(this.getSelectionRange());
                                }
                                return text;
                            };
                            
                            this.$checkMultiselectChange = function(e, anchor) {
                                if (this.inMultiSelectMode &amp;&amp; !this.inVirtualSelectionMode) {
                                    var range = this.multiSelect.ranges[0];
                                    if (this.multiSelect.isEmpty() &amp;&amp; anchor == this.multiSelect.anchor)
                                        return;
                                    var pos = anchor == this.multiSelect.anchor
                                        ? range.cursor == range.start ? range.end : range.start
                                        : range.cursor;
                                    if (pos.row != anchor.row 
                                        || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
                                        this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
                                }
                            };
                            this.findAll = function(needle, options, additive) {
                                options = options || {};
                                options.needle = needle || options.needle;
                                if (options.needle == undefined) {
                                    var range = this.selection.isEmpty()
                                        ? this.selection.getWordRange()
                                        : this.selection.getRange();
                                    options.needle = this.session.getTextRange(range);
                                }    
                                this.$search.set(options);
                                
                                var ranges = this.$search.findAll(this.session);
                                if (!ranges.length)
                                    return 0;
                        
                                this.$blockScrolling += 1;
                                var selection = this.multiSelect;
                        
                                if (!additive)
                                    selection.toSingleRange(ranges[0]);
                        
                                for (var i = ranges.length; i--; )
                                    selection.addRange(ranges[i], true);
                                if (range &amp;&amp; selection.rangeList.rangeAtPoint(range.start))
                                    selection.addRange(range, true);
                                
                                this.$blockScrolling -= 1;
                        
                                return ranges.length;
                            };
                            this.selectMoreLines = function(dir, skip) {
                                var range = this.selection.toOrientedRange();
                                var isBackwards = range.cursor == range.end;
                        
                                var screenLead = this.session.documentToScreenPosition(range.cursor);
                                if (this.selection.$desiredColumn)
                                    screenLead.column = this.selection.$desiredColumn;
                        
                                var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);
                        
                                if (!range.isEmpty()) {
                                    var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
                                    var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
                                } else {
                                    var anchor = lead;
                                }
                        
                                if (isBackwards) {
                                    var newRange = Range.fromPoints(lead, anchor);
                                    newRange.cursor = newRange.start;
                                } else {
                                    var newRange = Range.fromPoints(anchor, lead);
                                    newRange.cursor = newRange.end;
                                }
                        
                                newRange.desiredColumn = screenLead.column;
                                if (!this.selection.inMultiSelectMode) {
                                    this.selection.addRange(range);
                                } else {
                                    if (skip)
                                        var toRemove = range.cursor;
                                }
                        
                                this.selection.addRange(newRange);
                                if (toRemove)
                                    this.selection.substractPoint(toRemove);
                            };
                            this.transposeSelections = function(dir) {
                                var session = this.session;
                                var sel = session.multiSelect;
                                var all = sel.ranges;
                        
                                for (var i = all.length; i--; ) {
                                    var range = all[i];
                                    if (range.isEmpty()) {
                                        var tmp = session.getWordRange(range.start.row, range.start.column);
                                        range.start.row = tmp.start.row;
                                        range.start.column = tmp.start.column;
                                        range.end.row = tmp.end.row;
                                        range.end.column = tmp.end.column;
                                    }
                                }
                                sel.mergeOverlappingRanges();
                        
                                var words = [];
                                for (var i = all.length; i--; ) {
                                    var range = all[i];
                                    words.unshift(session.getTextRange(range));
                                }
                        
                                if (dir &lt; 0)
                                    words.unshift(words.pop());
                                else
                                    words.push(words.shift());
                        
                                for (var i = all.length; i--; ) {
                                    var range = all[i];
                                    var tmp = range.clone();
                                    session.replace(range, words[i]);
                                    range.start.row = tmp.start.row;
                                    range.start.column = tmp.start.column;
                                }
                            };
                            this.selectMore = function(dir, skip, stopAtFirst) {
                                var session = this.session;
                                var sel = session.multiSelect;
                        
                                var range = sel.toOrientedRange();
                                if (range.isEmpty()) {
                                    range = session.getWordRange(range.start.row, range.start.column);
                                    range.cursor = dir == -1 ? range.start : range.end;
                                    this.multiSelect.addRange(range);
                                    if (stopAtFirst)
                                        return;
                                }
                                var needle = session.getTextRange(range);
                        
                                var newRange = find(session, needle, dir);
                                if (newRange) {
                                    newRange.cursor = dir == -1 ? newRange.start : newRange.end;
                                    this.$blockScrolling += 1;
                                    this.session.unfold(newRange);
                                    this.multiSelect.addRange(newRange);
                                    this.$blockScrolling -= 1;
                                    this.renderer.scrollCursorIntoView(null, 0.5);
                                }
                                if (skip)
                                    this.multiSelect.substractPoint(range.cursor);
                            };
                            this.alignCursors = function() {
                                var session = this.session;
                                var sel = session.multiSelect;
                                var ranges = sel.ranges;
                                var row = -1;
                                var sameRowRanges = ranges.filter(function(r) {
                                    if (r.cursor.row == row)
                                        return true;
                                    row = r.cursor.row;
                                });
                                
                                if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
                                    var range = this.selection.getRange();
                                    var fr = range.start.row, lr = range.end.row;
                                    var guessRange = fr == lr;
                                    if (guessRange) {
                                        var max = this.session.getLength();
                                        var line;
                                        do {
                                            line = this.session.getLine(lr);
                                        } while (/[=:]/.test(line) &amp;&amp; ++lr &lt; max);
                                        do {
                                            line = this.session.getLine(fr);
                                        } while (/[=:]/.test(line) &amp;&amp; --fr &gt; 0);
                                        
                                        if (fr &lt; 0) fr = 0;
                                        if (lr &gt;= max) lr = max - 1;
                                    }
                                    var lines = this.session.doc.removeLines(fr, lr);
                                    lines = this.$reAlignText(lines, guessRange);
                                    this.session.doc.insert({row: fr, column: 0}, lines.join(&quot;\n&quot;) + &quot;\n&quot;);
                                    if (!guessRange) {
                                        range.start.column = 0;
                                        range.end.column = lines[lines.length - 1].length;
                                    }
                                    this.selection.setRange(range);
                                } else {
                                    sameRowRanges.forEach(function(r) {
                                        sel.substractPoint(r.cursor);
                                    });
                        
                                    var maxCol = 0;
                                    var minSpace = Infinity;
                                    var spaceOffsets = ranges.map(function(r) {
                                        var p = r.cursor;
                                        var line = session.getLine(p.row);
                                        var spaceOffset = line.substr(p.column).search(/\S/g);
                                        if (spaceOffset == -1)
                                            spaceOffset = 0;
                        
                                        if (p.column &gt; maxCol)
                                            maxCol = p.column;
                                        if (spaceOffset &lt; minSpace)
                                            minSpace = spaceOffset;
                                        return spaceOffset;
                                    });
                                    ranges.forEach(function(r, i) {
                                        var p = r.cursor;
                                        var l = maxCol - p.column;
                                        var d = spaceOffsets[i] - minSpace;
                                        if (l &gt; d)
                                            session.insert(p, lang.stringRepeat(&quot; &quot;, l - d));
                                        else
                                            session.remove(new Range(p.row, p.column, p.row, p.column - l + d));
                        
                                        r.start.column = r.end.column = maxCol;
                                        r.start.row = r.end.row = p.row;
                                        r.cursor = r.end;
                                    });
                                    sel.fromOrientedRange(ranges[0]);
                                    this.renderer.updateCursor();
                                    this.renderer.updateBackMarkers();
                                }
                            };
                        
                            this.$reAlignText = function(lines, forceLeft) {
                                var isLeftAligned = true, isRightAligned = true;
                                var startW, textW, endW;
                        
                                return lines.map(function(line) {
                                    var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
                                    if (!m)
                                        return [line];
                        
                                    if (startW == null) {
                                        startW = m[1].length;
                                        textW = m[2].length;
                                        endW = m[3].length;
                                        return m;
                                    }
                        
                                    if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
                                        isRightAligned = false;
                                    if (startW != m[1].length)
                                        isLeftAligned = false;
                        
                                    if (startW &gt; m[1].length)
                                        startW = m[1].length;
                                    if (textW &lt; m[2].length)
                                        textW = m[2].length;
                                    if (endW &gt; m[3].length)
                                        endW = m[3].length;
                        
                                    return m;
                                }).map(forceLeft ? alignLeft :
                                    isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);
                        
                                function spaces(n) {
                                    return lang.stringRepeat(&quot; &quot;, n);
                                }
                        
                                function alignLeft(m) {
                                    return !m[2] ? m[0] : spaces(startW) + m[2]
                                        + spaces(textW - m[2].length + endW)
                                        + m[4].replace(/^([=:])\s+/, &quot;$1 &quot;);
                                }
                                function alignRight(m) {
                                    return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]
                                        + spaces(endW, &quot; &quot;)
                                        + m[4].replace(/^([=:])\s+/, &quot;$1 &quot;);
                                }
                                function unAlign(m) {
                                    return !m[2] ? m[0] : spaces(startW) + m[2]
                                        + spaces(endW)
                                        + m[4].replace(/^([=:])\s+/, &quot;$1 &quot;);
                                }
                            };
                        }).call(Editor.prototype);
                        
                        
                        function isSamePoint(p1, p2) {
                            return p1.row == p2.row &amp;&amp; p1.column == p2.column;
                        }
                        exports.onSessionChange = function(e) {
                            var session = e.session;
                            if (session &amp;&amp; !session.multiSelect) {
                                session.$selectionMarkers = [];
                                session.selection.$initRangeList();
                                session.multiSelect = session.selection;
                            }
                            this.multiSelect = session &amp;&amp; session.multiSelect;
                        
                            var oldSession = e.oldSession;
                            if (oldSession) {
                                oldSession.multiSelect.off(&quot;addRange&quot;, this.$onAddRange);
                                oldSession.multiSelect.off(&quot;removeRange&quot;, this.$onRemoveRange);
                                oldSession.multiSelect.off(&quot;multiSelect&quot;, this.$onMultiSelect);
                                oldSession.multiSelect.off(&quot;singleSelect&quot;, this.$onSingleSelect);
                                oldSession.multiSelect.lead.off(&quot;change&quot;,  this.$checkMultiselectChange);
                                oldSession.multiSelect.anchor.off(&quot;change&quot;,  this.$checkMultiselectChange);
                            }
                        
                            if (session) {
                                session.multiSelect.on(&quot;addRange&quot;, this.$onAddRange);
                                session.multiSelect.on(&quot;removeRange&quot;, this.$onRemoveRange);
                                session.multiSelect.on(&quot;multiSelect&quot;, this.$onMultiSelect);
                                session.multiSelect.on(&quot;singleSelect&quot;, this.$onSingleSelect);
                                session.multiSelect.lead.on(&quot;change&quot;,  this.$checkMultiselectChange);
                                session.multiSelect.anchor.on(&quot;change&quot;,  this.$checkMultiselectChange);
                            }
                        
                            if (session &amp;&amp; this.inMultiSelectMode != session.selection.inMultiSelectMode) {
                                if (session.selection.inMultiSelectMode)
                                    this.$onMultiSelect();
                                else
                                    this.$onSingleSelect();
                            }
                        };
                        function MultiSelect(editor) {
                            if (editor.$multiselectOnSessionChange)
                                return;
                            editor.$onAddRange = editor.$onAddRange.bind(editor);
                            editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
                            editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
                            editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
                            editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
                            editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);
                        
                            editor.$multiselectOnSessionChange(editor);
                            editor.on(&quot;changeSession&quot;, editor.$multiselectOnSessionChange);
                        
                            editor.on(&quot;mousedown&quot;, onMouseDown);
                            editor.commands.addCommands(commands.defaultCommands);
                        
                            addAltCursorListeners(editor);
                        }
                        
                        function addAltCursorListeners(editor){
                            var el = editor.textInput.getElement();
                            var altCursor = false;
                            event.addListener(el, &quot;keydown&quot;, function(e) {
                                var altDown = e.keyCode == 18 &amp;&amp; !(e.ctrlKey || e.shiftKey || e.metaKey);
                                if (editor.$blockSelectEnabled &amp;&amp; altDown) {
                                    if (!altCursor) {
                                        editor.renderer.setMouseCursor(&quot;crosshair&quot;);
                                        altCursor = true;
                                    }
                                } else if (altCursor) {
                                    reset();
                                }
                            });
                        
                            event.addListener(el, &quot;keyup&quot;, reset);
                            event.addListener(el, &quot;blur&quot;, reset);
                            function reset(e) {
                                if (altCursor) {
                                    editor.renderer.setMouseCursor(&quot;&quot;);
                                    altCursor = false;
                                }
                            }
                        }
                        
                        exports.MultiSelect = MultiSelect;
                        
                        
                        require(&quot;./config&quot;).defineOptions(Editor.prototype, &quot;editor&quot;, {
                            enableMultiselect: {
                                set: function(val) {
                                    MultiSelect(this);
                                    if (val) {
                                        this.on(&quot;changeSession&quot;, this.$multiselectOnSessionChange);
                                        this.on(&quot;mousedown&quot;, onMouseDown);
                                    } else {
                                        this.off(&quot;changeSession&quot;, this.$multiselectOnSessionChange);
                                        this.off(&quot;mousedown&quot;, onMouseDown);
                                    }
                                },
                                value: true
                            },
                            enableBlockSelect: {
                                set: function(val) {
                                    this.$blockSelectEnabled = val;
                                },
                                value: true
                            }
                        });
                        
                        
                        
                        });
                        
                        define(&quot;ace/mode/folding/fold_mode&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/range&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var Range = require(&quot;../../range&quot;).Range;
                        
                        var FoldMode = exports.FoldMode = function() {};
                        
                        (function() {
                        
                            this.foldingStartMarker = null;
                            this.foldingStopMarker = null;
                            this.getFoldWidget = function(session, foldStyle, row) {
                                var line = session.getLine(row);
                                if (this.foldingStartMarker.test(line))
                                    return &quot;start&quot;;
                                if (foldStyle == &quot;markbeginend&quot;
                                        &amp;&amp; this.foldingStopMarker
                                        &amp;&amp; this.foldingStopMarker.test(line))
                                    return &quot;end&quot;;
                                return &quot;&quot;;
                            };
                        
                            this.getFoldWidgetRange = function(session, foldStyle, row) {
                                return null;
                            };
                        
                            this.indentationBlock = function(session, row, column) {
                                var re = /\S/;
                                var line = session.getLine(row);
                                var startLevel = line.search(re);
                                if (startLevel == -1)
                                    return;
                        
                                var startColumn = column || line.length;
                                var maxRow = session.getLength();
                                var startRow = row;
                                var endRow = row;
                        
                                while (++row &lt; maxRow) {
                                    var level = session.getLine(row).search(re);
                        
                                    if (level == -1)
                                        continue;
                        
                                    if (level &lt;= startLevel)
                                        break;
                        
                                    endRow = row;
                                }
                        
                                if (endRow &gt; startRow) {
                                    var endColumn = session.getLine(endRow).length;
                                    return new Range(startRow, startColumn, endRow, endColumn);
                                }
                            };
                        
                            this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
                                var start = {row: row, column: column + 1};
                                var end = session.$findClosingBracket(bracket, start, typeRe);
                                if (!end)
                                    return;
                        
                                var fw = session.foldWidgets[end.row];
                                if (fw == null)
                                    fw = session.getFoldWidget(end.row);
                        
                                if (fw == &quot;start&quot; &amp;&amp; end.row &gt; start.row) {
                                    end.row --;
                                    end.column = session.getLine(end.row).length;
                                }
                                return Range.fromPoints(start, end);
                            };
                        
                            this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
                                var end = {row: row, column: column};
                                var start = session.$findOpeningBracket(bracket, end);
                        
                                if (!start)
                                    return;
                        
                                start.column++;
                                end.column--;
                        
                                return  Range.fromPoints(start, end);
                            };
                        }).call(FoldMode.prototype);
                        
                        });
                        
                        define(&quot;ace/theme/textmate&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/dom&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        exports.isDark = false;
                        exports.cssClass = &quot;ace-tm&quot;;
                        exports.cssText = &quot;.ace-tm .ace_gutter {\
                        background: #f0f0f0;\
                        color: #333;\
                        }\
                        .ace-tm .ace_print-margin {\
                        width: 1px;\
                        background: #e8e8e8;\
                        }\
                        .ace-tm .ace_fold {\
                        background-color: #6B72E6;\
                        }\
                        .ace-tm {\
                        background-color: #FFFFFF;\
                        color: black;\
                        }\
                        .ace-tm .ace_cursor {\
                        color: black;\
                        }\
                        .ace-tm .ace_invisible {\
                        color: rgb(191, 191, 191);\
                        }\
                        .ace-tm .ace_storage,\
                        .ace-tm .ace_keyword {\
                        color: blue;\
                        }\
                        .ace-tm .ace_constant {\
                        color: rgb(197, 6, 11);\
                        }\
                        .ace-tm .ace_constant.ace_buildin {\
                        color: rgb(88, 72, 246);\
                        }\
                        .ace-tm .ace_constant.ace_language {\
                        color: rgb(88, 92, 246);\
                        }\
                        .ace-tm .ace_constant.ace_library {\
                        color: rgb(6, 150, 14);\
                        }\
                        .ace-tm .ace_invalid {\
                        background-color: rgba(255, 0, 0, 0.1);\
                        color: red;\
                        }\
                        .ace-tm .ace_support.ace_function {\
                        color: rgb(60, 76, 114);\
                        }\
                        .ace-tm .ace_support.ace_constant {\
                        color: rgb(6, 150, 14);\
                        }\
                        .ace-tm .ace_support.ace_type,\
                        .ace-tm .ace_support.ace_class {\
                        color: rgb(109, 121, 222);\
                        }\
                        .ace-tm .ace_keyword.ace_operator {\
                        color: rgb(104, 118, 135);\
                        }\
                        .ace-tm .ace_string {\
                        color: rgb(3, 106, 7);\
                        }\
                        .ace-tm .ace_comment {\
                        color: rgb(76, 136, 107);\
                        }\
                        .ace-tm .ace_comment.ace_doc {\
                        color: rgb(0, 102, 255);\
                        }\
                        .ace-tm .ace_comment.ace_doc.ace_tag {\
                        color: rgb(128, 159, 191);\
                        }\
                        .ace-tm .ace_constant.ace_numeric {\
                        color: rgb(0, 0, 205);\
                        }\
                        .ace-tm .ace_variable {\
                        color: rgb(49, 132, 149);\
                        }\
                        .ace-tm .ace_xml-pe {\
                        color: rgb(104, 104, 91);\
                        }\
                        .ace-tm .ace_entity.ace_name.ace_function {\
                        color: #0000A2;\
                        }\
                        .ace-tm .ace_heading {\
                        color: rgb(12, 7, 255);\
                        }\
                        .ace-tm .ace_list {\
                        color:rgb(185, 6, 144);\
                        }\
                        .ace-tm .ace_meta.ace_tag {\
                        color:rgb(0, 22, 142);\
                        }\
                        .ace-tm .ace_string.ace_regex {\
                        color: rgb(255, 0, 0)\
                        }\
                        .ace-tm .ace_marker-layer .ace_selection {\
                        background: rgb(181, 213, 255);\
                        }\
                        .ace-tm.ace_multiselect .ace_selection.ace_start {\
                        box-shadow: 0 0 3px 0px white;\
                        border-radius: 2px;\
                        }\
                        .ace-tm .ace_marker-layer .ace_step {\
                        background: rgb(252, 255, 0);\
                        }\
                        .ace-tm .ace_marker-layer .ace_stack {\
                        background: rgb(164, 229, 101);\
                        }\
                        .ace-tm .ace_marker-layer .ace_bracket {\
                        margin: -1px 0 0 -1px;\
                        border: 1px solid rgb(192, 192, 192);\
                        }\
                        .ace-tm .ace_marker-layer .ace_active-line {\
                        background: rgba(0, 0, 0, 0.07);\
                        }\
                        .ace-tm .ace_gutter-active-line {\
                        background-color : #dcdcdc;\
                        }\
                        .ace-tm .ace_marker-layer .ace_selected-word {\
                        background: rgb(250, 250, 255);\
                        border: 1px solid rgb(200, 200, 250);\
                        }\
                        .ace-tm .ace_indent-guide {\
                        background: url(\&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\&quot;) right repeat-y;\
                        }\
                        &quot;;
                        
                        var dom = require(&quot;../lib/dom&quot;);
                        dom.importCssString(exports.cssText, exports.cssClass);
                        });
                        
                        define(&quot;ace/line_widgets&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/oop&quot;,&quot;ace/lib/dom&quot;,&quot;ace/range&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        var oop = require(&quot;./lib/oop&quot;);
                        var dom = require(&quot;./lib/dom&quot;);
                        var Range = require(&quot;./range&quot;).Range;
                        
                        
                        function LineWidgets(session) {
                            this.session = session;
                            this.session.widgetManager = this;
                            this.session.getRowLength = this.getRowLength;
                            this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
                            this.updateOnChange = this.updateOnChange.bind(this);
                            this.renderWidgets = this.renderWidgets.bind(this);
                            this.measureWidgets = this.measureWidgets.bind(this);
                            this.session._changedWidgets = [];
                            this.$onChangeEditor = this.$onChangeEditor.bind(this);
                            
                            this.session.on(&quot;change&quot;, this.updateOnChange);
                            this.session.on(&quot;changeEditor&quot;, this.$onChangeEditor);
                        }
                        
                        (function() {
                            this.getRowLength = function(row) {
                                var h;
                                if (this.lineWidgets)
                                    h = this.lineWidgets[row] &amp;&amp; this.lineWidgets[row].rowCount || 0;
                                else 
                                    h = 0;
                                if (!this.$useWrapMode || !this.$wrapData[row]) {
                                    return 1 + h;
                                } else {
                                    return this.$wrapData[row].length + 1 + h;
                                }
                            };
                        
                            this.$getWidgetScreenLength = function() {
                                var screenRows = 0;
                                this.lineWidgets.forEach(function(w){
                                    if (w &amp;&amp; w.rowCount)
                                        screenRows +=w.rowCount;
                                });
                                return screenRows;
                            };    
                            
                            this.$onChangeEditor = function(e) {
                                this.attach(e.editor);
                            };
                            
                            this.attach = function(editor) {
                                if (editor  &amp;&amp; editor.widgetManager &amp;&amp; editor.widgetManager != this)
                                    editor.widgetManager.detach();
                        
                                if (this.editor == editor)
                                    return;
                        
                                this.detach();
                                this.editor = editor;
                                
                                if (editor) {
                                    editor.widgetManager = this;
                                    editor.renderer.on(&quot;beforeRender&quot;, this.measureWidgets);
                                    editor.renderer.on(&quot;afterRender&quot;, this.renderWidgets);
                                }
                            };
                            this.detach = function(e) {
                                var editor = this.editor;
                                if (!editor)
                                    return;
                                
                                this.editor = null;
                                editor.widgetManager = null;
                                
                                editor.renderer.off(&quot;beforeRender&quot;, this.measureWidgets);
                                editor.renderer.off(&quot;afterRender&quot;, this.renderWidgets);
                                var lineWidgets = this.session.lineWidgets;
                                lineWidgets &amp;&amp; lineWidgets.forEach(function(w) {
                                    if (w &amp;&amp; w.el &amp;&amp; w.el.parentNode) {
                                        w._inDocument = false;
                                        w.el.parentNode.removeChild(w.el);
                                    }
                                });
                            };
                        
                            this.updateOnChange = function(e) {
                                var lineWidgets = this.session.lineWidgets;
                                if (!lineWidgets) return;
                                    
                                var delta = e.data;
                                var range = delta.range;
                                var startRow = range.start.row;
                                var len = range.end.row - startRow;
                        
                                if (len === 0) {
                                } else if (delta.action == &quot;removeText&quot; || delta.action == &quot;removeLines&quot;) {
                                    var removed = lineWidgets.splice(startRow + 1, len);
                                    removed.forEach(function(w) {
                                        w &amp;&amp; this.removeLineWidget(w);
                                    }, this);
                                    this.$updateRows();
                                } else {
                                    var args = new Array(len);
                                    args.unshift(startRow, 0);
                                    lineWidgets.splice.apply(lineWidgets, args);
                                    this.$updateRows();
                                }
                            };
                            
                            this.$updateRows = function() {
                                var lineWidgets = this.session.lineWidgets;
                                if (!lineWidgets) return;
                                var noWidgets = true;
                                lineWidgets.forEach(function(w, i) {
                                    if (w) {
                                        noWidgets = false;
                                        w.row = i;
                                    }
                                });
                                if (noWidgets)
                                    this.session.lineWidgets = null;
                            };
                        
                            this.addLineWidget = function(w) {
                                if (!this.session.lineWidgets)
                                    this.session.lineWidgets = new Array(this.session.getLength());
                                
                                this.session.lineWidgets[w.row] = w;
                                
                                var renderer = this.editor.renderer;
                                if (w.html &amp;&amp; !w.el) {
                                    w.el = dom.createElement(&quot;div&quot;);
                                    w.el.innerHTML = w.html;
                                }
                                if (w.el) {
                                    dom.addCssClass(w.el, &quot;ace_lineWidgetContainer&quot;);
                                    w.el.style.position = &quot;absolute&quot;;
                                    w.el.style.zIndex = 5;
                                    renderer.container.appendChild(w.el);
                                    w._inDocument = true;
                                }
                                
                                if (!w.coverGutter) {
                                    w.el.style.zIndex = 3;
                                }
                                if (!w.pixelHeight) {
                                    w.pixelHeight = w.el.offsetHeight;
                                }
                                if (w.rowCount == null)
                                    w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
                                
                                this.session._emit(&quot;changeFold&quot;, {data:{start:{row: w.row}}});
                                
                                this.$updateRows();
                                this.renderWidgets(null, renderer);
                                return w;
                            };
                            
                            this.removeLineWidget = function(w) {
                                w._inDocument = false;
                                if (w.el &amp;&amp; w.el.parentNode)
                                    w.el.parentNode.removeChild(w.el);
                                if (w.editor &amp;&amp; w.editor.destroy) try {
                                    w.editor.destroy();
                                } catch(e){}
                                if (this.session.lineWidgets)
                                    this.session.lineWidgets[w.row] = undefined;
                                this.session._emit(&quot;changeFold&quot;, {data:{start:{row: w.row}}});
                                this.$updateRows();
                            };
                            
                            this.onWidgetChanged = function(w) {
                                this.session._changedWidgets.push(w);
                                this.editor &amp;&amp; this.editor.renderer.updateFull();
                            };
                            
                            this.measureWidgets = function(e, renderer) {
                                var changedWidgets = this.session._changedWidgets;
                                var config = renderer.layerConfig;
                                
                                if (!changedWidgets || !changedWidgets.length) return;
                                var min = Infinity;
                                for (var i = 0; i &lt; changedWidgets.length; i++) {
                                    var w = changedWidgets[i];
                                    if (!w._inDocument) {
                                        w._inDocument = true;
                                        renderer.container.appendChild(w.el);
                                    }
                                    
                                    w.h = w.el.offsetHeight;
                                    
                                    if (!w.fixedWidth) {
                                        w.w = w.el.offsetWidth;
                                        w.screenWidth = Math.ceil(w.w / config.characterWidth);
                                    }
                                    
                                    var rowCount = w.h / config.lineHeight;
                                    if (w.coverLine) {
                                        rowCount -= this.session.getRowLineCount(w.row);
                                        if (rowCount &lt; 0)
                                            rowCount = 0;
                                    }
                                    if (w.rowCount != rowCount) {
                                        w.rowCount = rowCount;
                                        if (w.row &lt; min)
                                            min = w.row;
                                    }
                                }
                                if (min != Infinity) {
                                    this.session._emit(&quot;changeFold&quot;, {data:{start:{row: min}}});
                                    this.session.lineWidgetWidth = null;
                                }
                                this.session._changedWidgets = [];
                            };
                            
                            this.renderWidgets = function(e, renderer) {
                                var config = renderer.layerConfig;
                                var lineWidgets = this.session.lineWidgets;
                                if (!lineWidgets)
                                    return;
                                var first = Math.min(this.firstRow, config.firstRow);
                                var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
                                
                                while (first &gt; 0 &amp;&amp; !lineWidgets[first])
                                    first--;
                                
                                this.firstRow = config.firstRow;
                                this.lastRow = config.lastRow;
                        
                                renderer.$cursorLayer.config = config;
                                for (var i = first; i &lt;= last; i++) {
                                    var w = lineWidgets[i];
                                    if (!w || !w.el) continue;
                        
                                    if (!w._inDocument) {
                                        w._inDocument = true;
                                        renderer.container.appendChild(w.el);
                                    }
                                    var top = renderer.$cursorLayer.getPixelPosition({row: i, column:0}, true).top;
                                    if (!w.coverLine)
                                        top += config.lineHeight * this.session.getRowLineCount(w.row);
                                    w.el.style.top = top - config.offset + &quot;px&quot;;
                                    
                                    var left = w.coverGutter ? 0 : renderer.gutterWidth;
                                    if (!w.fixedWidth)
                                        left -= renderer.scrollLeft;
                                    w.el.style.left = left + &quot;px&quot;;
                        
                                    if (w.fixedWidth) {
                                        w.el.style.right = renderer.scrollBar.getWidth() + &quot;px&quot;;
                                    } else {
                                        w.el.style.right = &quot;&quot;;
                                    }
                                }
                            };
                            
                        }).call(LineWidgets.prototype);
                        
                        
                        exports.LineWidgets = LineWidgets;
                        
                        });
                        
                        define(&quot;ace/ext/error_marker&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/line_widgets&quot;,&quot;ace/lib/dom&quot;,&quot;ace/range&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        var LineWidgets = require(&quot;../line_widgets&quot;).LineWidgets;
                        var dom = require(&quot;../lib/dom&quot;);
                        var Range = require(&quot;../range&quot;).Range;
                        
                        function binarySearch(array, needle, comparator) {
                            var first = 0;
                            var last = array.length - 1;
                        
                            while (first &lt;= last) {
                                var mid = (first + last) &gt;&gt; 1;
                                var c = comparator(needle, array[mid]);
                                if (c &gt; 0)
                                    first = mid + 1;
                                else if (c &lt; 0)
                                    last = mid - 1;
                                else
                                    return mid;
                            }
                            return -(first + 1);
                        }
                        
                        function findAnnotations(session, row, dir) {
                            var annotations = session.getAnnotations().sort(Range.comparePoints);
                            if (!annotations.length)
                                return;
                            
                            var i = binarySearch(annotations, {row: row, column: -1}, Range.comparePoints);
                            if (i &lt; 0)
                                i = -i - 1;
                            
                            if (i &gt;= annotations.length)
                                i = dir &gt; 0 ? 0 : annotations.length - 1;
                            else if (i === 0 &amp;&amp; dir &lt; 0)
                                i = annotations.length - 1;
                            
                            var annotation = annotations[i];
                            if (!annotation || !dir)
                                return;
                        
                            if (annotation.row === row) {
                                do {
                                    annotation = annotations[i += dir];
                                } while (annotation &amp;&amp; annotation.row === row);
                                if (!annotation)
                                    return annotations.slice();
                            }
                            
                            
                            var matched = [];
                            row = annotation.row;
                            do {
                                matched[dir &lt; 0 ? &quot;unshift&quot; : &quot;push&quot;](annotation);
                                annotation = annotations[i += dir];
                            } while (annotation &amp;&amp; annotation.row == row);
                            return matched.length &amp;&amp; matched;
                        }
                        
                        exports.showErrorMarker = function(editor, dir) {
                            var session = editor.session;
                            if (!session.widgetManager) {
                                session.widgetManager = new LineWidgets(session);
                                session.widgetManager.attach(editor);
                            }
                            
                            var pos = editor.getCursorPosition();
                            var row = pos.row;
                            var oldWidget = session.lineWidgets &amp;&amp; session.lineWidgets[row];
                            if (oldWidget) {
                                oldWidget.destroy();
                            } else {
                                row -= dir;
                            }
                            var annotations = findAnnotations(session, row, dir);
                            var gutterAnno;
                            if (annotations) {
                                var annotation = annotations[0];
                                pos.column = (annotation.pos &amp;&amp; typeof annotation.column != &quot;number&quot;
                                    ? annotation.pos.sc
                                    : annotation.column) || 0;
                                pos.row = annotation.row;
                                gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
                            } else if (oldWidget) {
                                return;
                            } else {
                                gutterAnno = {
                                    text: [&quot;Looks good!&quot;],
                                    className: &quot;ace_ok&quot;
                                };
                            }
                            editor.session.unfold(pos.row);
                            editor.selection.moveToPosition(pos);
                            
                            var w = {
                                row: pos.row, 
                                fixedWidth: true,
                                coverGutter: true,
                                el: dom.createElement(&quot;div&quot;)
                            };
                            var el = w.el.appendChild(dom.createElement(&quot;div&quot;));
                            var arrow = w.el.appendChild(dom.createElement(&quot;div&quot;));
                            arrow.className = &quot;error_widget_arrow &quot; + gutterAnno.className;
                            
                            var left = editor.renderer.$cursorLayer
                                .getPixelPosition(pos).left;
                            arrow.style.left = left + editor.renderer.gutterWidth - 5 + &quot;px&quot;;
                            
                            w.el.className = &quot;error_widget_wrapper&quot;;
                            el.className = &quot;error_widget &quot; + gutterAnno.className;
                            el.innerHTML = gutterAnno.text.join(&quot;&lt;br&gt;&quot;);
                            
                            el.appendChild(dom.createElement(&quot;div&quot;));
                            
                            var kb = function(_, hashId, keyString) {
                                if (hashId === 0 &amp;&amp; (keyString === &quot;esc&quot; || keyString === &quot;return&quot;)) {
                                    w.destroy();
                                    return {command: &quot;null&quot;};
                                }
                            };
                            
                            w.destroy = function() {
                                if (editor.$mouseHandler.isMousePressed)
                                    return;
                                editor.keyBinding.removeKeyboardHandler(kb);
                                session.widgetManager.removeLineWidget(w);
                                editor.off(&quot;changeSelection&quot;, w.destroy);
                                editor.off(&quot;changeSession&quot;, w.destroy);
                                editor.off(&quot;mouseup&quot;, w.destroy);
                                editor.off(&quot;change&quot;, w.destroy);
                            };
                            
                            editor.keyBinding.addKeyboardHandler(kb);
                            editor.on(&quot;changeSelection&quot;, w.destroy);
                            editor.on(&quot;changeSession&quot;, w.destroy);
                            editor.on(&quot;mouseup&quot;, w.destroy);
                            editor.on(&quot;change&quot;, w.destroy);
                            
                            editor.session.widgetManager.addLineWidget(w);
                            
                            w.el.onmousedown = editor.focus.bind(editor);
                            
                            editor.renderer.scrollCursorIntoView(null, 0.5, {bottom: w.el.offsetHeight});
                        };
                        
                        
                        dom.importCssString(&quot;\
                            .error_widget_wrapper {\
                                background: inherit;\
                                color: inherit;\
                                border:none\
                            }\
                            .error_widget {\
                                border-top: solid 2px;\
                                border-bottom: solid 2px;\
                                margin: 5px 0;\
                                padding: 10px 40px;\
                                white-space: pre-wrap;\
                            }\
                            .error_widget.ace_error, .error_widget_arrow.ace_error{\
                                border-color: #ff5a5a\
                            }\
                            .error_widget.ace_warning, .error_widget_arrow.ace_warning{\
                                border-color: #F1D817\
                            }\
                            .error_widget.ace_info, .error_widget_arrow.ace_info{\
                                border-color: #5a5a5a\
                            }\
                            .error_widget.ace_ok, .error_widget_arrow.ace_ok{\
                                border-color: #5aaa5a\
                            }\
                            .error_widget_arrow {\
                                position: absolute;\
                                border: solid 5px;\
                                border-top-color: transparent!important;\
                                border-right-color: transparent!important;\
                                border-left-color: transparent!important;\
                                top: -5px;\
                            }\
                        &quot;, &quot;&quot;);
                        
                        });
                        
                        define(&quot;ace/ace&quot;,[&quot;require&quot;,&quot;exports&quot;,&quot;module&quot;,&quot;ace/lib/fixoldbrowsers&quot;,&quot;ace/lib/dom&quot;,&quot;ace/lib/event&quot;,&quot;ace/editor&quot;,&quot;ace/edit_session&quot;,&quot;ace/undomanager&quot;,&quot;ace/virtual_renderer&quot;,&quot;ace/worker/worker_client&quot;,&quot;ace/keyboard/hash_handler&quot;,&quot;ace/placeholder&quot;,&quot;ace/multi_select&quot;,&quot;ace/mode/folding/fold_mode&quot;,&quot;ace/theme/textmate&quot;,&quot;ace/ext/error_marker&quot;,&quot;ace/config&quot;], function(require, exports, module) {
                        &quot;use strict&quot;;
                        
                        require(&quot;./lib/fixoldbrowsers&quot;);
                        
                        var dom = require(&quot;./lib/dom&quot;);
                        var event = require(&quot;./lib/event&quot;);
                        
                        var Editor = require(&quot;./editor&quot;).Editor;
                        var EditSession = require(&quot;./edit_session&quot;).EditSession;
                        var UndoManager = require(&quot;./undomanager&quot;).UndoManager;
                        var Renderer = require(&quot;./virtual_renderer&quot;).VirtualRenderer;
                        require(&quot;./worker/worker_client&quot;);
                        require(&quot;./keyboard/hash_handler&quot;);
                        require(&quot;./placeholder&quot;);
                        require(&quot;./multi_select&quot;);
                        require(&quot;./mode/folding/fold_mode&quot;);
                        require(&quot;./theme/textmate&quot;);
                        require(&quot;./ext/error_marker&quot;);
                        
                        exports.config = require(&quot;./config&quot;);
                        exports.require = require;
                        exports.edit = function(el) {
                            if (typeof(el) == &quot;string&quot;) {
                                var _id = el;
                                el = document.getElementById(_id);
                                if (!el)
                                    throw new Error(&quot;ace.edit can&#x27;t find div #&quot; + _id);
                            }
                        
                            if (el &amp;&amp; el.env &amp;&amp; el.env.editor instanceof Editor)
                                return el.env.editor;
                        
                            var value = &quot;&quot;;
                            if (el &amp;&amp; /input|textarea/i.test(el.tagName)) {
                                var oldNode = el;
                                value = oldNode.value;
                                el = dom.createElement(&quot;pre&quot;);
                                oldNode.parentNode.replaceChild(el, oldNode);
                            } else {
                                value = dom.getInnerText(el);
                                el.innerHTML = &#x27;&#x27;;
                            }
                        
                            var doc = exports.createEditSession(value);
                        
                            var editor = new Editor(new Renderer(el));
                            editor.setSession(doc);
                        
                            var env = {
                                document: doc,
                                editor: editor,
                                onResize: editor.resize.bind(editor, null)
                            };
                            if (oldNode) env.textarea = oldNode;
                            event.addListener(window, &quot;resize&quot;, env.onResize);
                            editor.on(&quot;destroy&quot;, function() {
                                event.removeListener(window, &quot;resize&quot;, env.onResize);
                                env.editor.container.env = null; // prevent memory leak on old ie
                            });
                            editor.container.env = editor.env = env;
                            return editor;
                        };
                        exports.createEditSession = function(text, mode) {
                            var doc = new EditSession(text, mode);
                            doc.setUndoManager(new UndoManager());
                            return doc;
                        }
                        exports.EditSession = EditSession;
                        exports.UndoManager = UndoManager;
                        });
                                    (function() {
                                        window.require([&quot;ace/ace&quot;], function(a) {
                                            a &amp;&amp; a.config.init(true);
                                            if (!window.ace)
                                                window.ace = a;
                                            for (var key in a) if (a.hasOwnProperty(key))
                                                window.ace[key] = a[key];
                                        });
                                    })();
                                
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
